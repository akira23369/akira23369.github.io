---
title: 数字三角形
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 动态规划

tags:
  - 算法
  - Acwing
  - 基础
  - 动态规划
  - 模板题
---

[898. 数字三角形 - AcWing题库](https://www.acwing.com/problem/content/900/)

[E02 线性DP 数字三角形_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Rk4y1173p/?spm_id_from=333.1387.search.video_card.click&vd_source=2f348893e98a838d97300d2bf728b18b)

### 题目描述
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数 n$n$，表示数字三角形的层数。

接下来 n$n$ 行，每行包含若干整数，其中第 i$i$ 行表示数字三角形第 i$i$ 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

1≤n≤500$1 \le n \le 500$,  
−10000≤三角形中的整数≤10000$-10000 \le 三角形中的整数 \le 10000$

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```

---
### 算法

```cpp
#include<iostream>
using namespace std;
const int N = 510, INF = 0x3f3f3f3f;
int a[N][N];
int f[N][N];
int n;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= i; j++) 
            cin >> a[i][j];
    // 防止全是负数
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i + 1; j++)
            f[i][j] = -INF;
    f[1][1] = a[1][1];
    for (int i = 2; i <= n; i++)
        for (int j = 1; j <= i; j++)
            f[i][j] = max(f[i - 1][j] + a[i][j], f[i - 1][j - 1] + a[i][j]);
    int res = -INF;
    for (int i = 1; i <= n; i++) res = max(res, f[n][i]);
    cout << res << endl;
    return 0;
}

作者：爱不被爱的爱酱
链接：https://www.acwing.com/activity/content/code/content/4846218/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


#### 倒着来

```cpp
#include<iostream>
const int N = 510, INF = 0x3f3f3f3f;
int f[N][N];
int a[N][N];
int n;
int main()
{
    std::cin >> n;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= i; j++)
            std::cin >> a[i][j];
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i + 1; j++)
            if (i == n) f[i][j] = a[i][j];
            else f[i][j] = -INF;

    for (int i = n - 1; i >= 1; i--)
        for (int j = 1; j <= i; j++)
            f[i][j] = std::max(f[i + 1][j + 1] + a[i][j], f[i + 1][j] + a[i][j]);
    std::cout << f[1][1] << std::endl;
    return 0;
}

作者：爱不被爱的爱酱
链接：https://www.acwing.com/activity/content/code/content/4846218/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### 倒着来空间复杂度优化
```cpp
#include<iostream>
const int N = 510, INF = 0x3f3f3f3f;
int f[N];
int a[N][N];
int n;
int main()
{
    std::cin >> n;
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= i; j++)
            std::cin >> a[i][j];
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i + 1; j++)
            if (i == n) f[j] = a[i][j];
            else f[j] = -INF;

    for (int i = n - 1; i >= 1; i--)
        for (int j = 1; j <= i; j++)        // 要被用到的会先更新所以要正着来遍历
            f[j] = std::max(f[j + 1] + a[i][j], f[j] + a[i][j]);
    std::cout << f[1] << std::endl;
    return 0;
}

作者：爱不被爱的爱酱
链接：https://www.acwing.com/activity/content/code/content/4846218/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```