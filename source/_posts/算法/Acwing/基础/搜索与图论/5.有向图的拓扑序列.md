---
title: 5.有向图的拓扑序列
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 搜索与图论

tags:
  - 算法
  - Acwing
  - 基础
  - 搜索与图论
  - 模板题
  - 拓扑排序
---

[848. 有向图的拓扑序列 - AcWing题库](https://www.acwing.com/problem/content/850/)

### 题目描述
给定一个 $n$ 个点 $m$ 条边的有向图，点的编号是 $1$ 到 $n$，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 $-1$。

若一个由图中所有点构成的序列 $A$ 满足：对于图中的每条边 $(x, y)$，$x$ 在 $A$ 中都出现在 $y$ 之前，则称 $A$ 是该图的一个拓扑序列。

#### 输入格式

第一行包含两个整数 $n$ 和 $m$。

接下来 $m$ 行，每行包含两个整数 $x$ 和 $y$，表示存在一条从点 $x$ 到点 $y$ 的有向边 $(x, y)$。

#### 输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 $-1$。

#### 数据范围

$1 \le n,m \le 10^5$

#### 输入样例：

```
3 3
1 2
2 3
1 3
```

#### 输出样例：

```
1 2 3
```

---
### 算法

```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;

const int N = 1e5 + 10;
int h[N], e[N], ne[N], d[N], idx;
int n, m;
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
    d[b]++;
}

int k, path[N];

bool bfs()
{
    queue<int> q;
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        if (d[i] == 0) q.push(i), st[i] = true, cnt++;
    }
    while (q.size())
    {
        int t = q.front(); q.pop();
        path[k++] = t;
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            d[j]--;
            if (!d[j]) q.push(j), cnt++;
        }
    }
    return cnt == n ? true : false;
}

int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while (m--)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    bool flag = bfs();
    if (flag) for (int i = 0; i < k; i++) cout << path[i] << " ";
    else cout << -1 << endl;
    return 0;
}
```