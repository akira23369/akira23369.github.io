---
title: 13.二分图的最大匹配
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 搜索与图论

tags:
  - 算法
  - Acwing
  - 基础
  - 搜索与图论
  - 模板题
  - 匈牙利算法
---

[861. 二分图的最大匹配 - AcWing题库](https://www.acwing.com/problem/content/863/)
### 题目描述
给定一个二分图，其中左半部包含 $n_1$ 个点（编号 $1 \sim n_1$），右半部包含 $n_2$ 个点（编号 $1 \sim n_2$），二分图共包含 $m$ 条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 $\{E\}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。
> 
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

#### 输入格式

第一行包含三个整数 $n_1$、 $n_2$ 和 $m$。

接下来 $m$ 行，每行包含两个整数 $u$ 和 $v$，表示左半部点集中的点 $u$ 和右半部点集中的点 $v$ 之间存在一条边。

#### 输出格式

输出一个整数，表示二分图的最大匹配数。

#### 数据范围

$1 \le n_1,n_2 \le 500$,  
$1 \le u \le n_1$,  
$1 \le v \le n_2$,  
$1 \le m \le 10^5$

#### 输入样例：

```
2 2 4
1 1
1 2
2 1
2 2
```

#### 输出样例：

```
2
```

---
### 算法


```cpp
// 匈牙利算法

// 匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。
// 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。
// 二分图的最大匹配：就是一边从另一边找对象的过程

// 如果你想找的妹子已经有了男朋友，
// 你就去问问她男朋友，
// 你有没有备胎，
// 把这个让给我好吗？
// 他能让就让，
// 要是让不了，他们就是真爱。
// 你就找你的下一个备胎。

#include<iostream>
#include<cstring>
using namespace std;
const int N = 100010;

int e[N], ne[N], h[N], idx;
int match[N];       //match[j]=a,表示女孩j的现有配对男友是a
bool state[N];       //当前 “这一轮匹配” st[j]=a表示，女孩j被男孩a预定了。
int n1, n2, m;      //n1，n2分别表示男，女集合 m边
int cnt;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

//一轮男女配对过程
bool find(int x)
{
    //遍历自己喜欢的女孩
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        //如果这个女孩之前没被自己找过
        if (!state[j])
        {
            state[j] = true;      
            if (!match[j] || find(match[j]))        //如果找的女孩没有男友，或者男友有备选
            {
                match[j] = x;
                return true;
            }    

        }
    }
    return false;       //如果自己中意的都有男友
}


int main()
{
    cin >> n1 >> n2 >> m;
    memset(h, -1, sizeof(h));
    while (m--)
    {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    int cnt = 0;
    for (int i = 1; i <= n1; i++)
    {
        memset(state, 0, sizeof(state));        //每次找女友时都要重置一下
        if (find(i)) cnt ++;
    }
    cout << cnt;
    return 0;
}
```