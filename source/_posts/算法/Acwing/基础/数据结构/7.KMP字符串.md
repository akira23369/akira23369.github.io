---
title: 7.KMP字符串
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 数据结构

tags:
  - 算法
  - Acwing
  - 基础
  - 数据结构
  - 模板题
  - KMP
---

[831. KMP字符串 - AcWing题库](https://www.acwing.com/problem/content/833/)

[F03【模板】KMP 算法——信息学竞赛算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ag411o7US/?spm_id_from=333.1387.search.video_card.click&vd_source=2f348893e98a838d97300d2bf728b18b)

### 题目描述
给定一个字符串 $S$，以及一个模式串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 $P$ 在字符串 $S$ 中多次作为子串出现。

求出模式串 $P$ 在字符串 $S$ 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 $N$，表示字符串 $P$ 的长度。

第二行输入字符串 $P$。

第三行输入整数 $M$，表示字符串 $S$ 的长度。

第四行输入字符串 $S$。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。

#### 数据范围

$1 \le N \le 10^5$  
$1 \le M \le 10^6$

#### 输入样例：

```
3
aba
5
ababa
```

#### 输出样例：

```
0 2
```

---
### 算法


![](7.KMP字符串/Pasted%20image%2020240509185309.png)


最大前后缀
每次匹配只要移动到最大后缀那里

![](7.KMP字符串/Pasted%20image%2020240509185325.png)

将模式串中的每一个不匹配的字符所需要回退的下标保存起来就是next数组

![](7.KMP字符串/Pasted%20image%2020240509185351.png)

```cpp
#include<stdio.h>
#include<malloc.h>
#include<iostream>
#include<stdlib.h>
using namespace std;

void get_next(string T, int next[])
{
    int i = 1, j = 0;
    next[1] = 0;
    while (i < T.size())
    {
        //如果j回溯到底 或者匹配成功
        if (j == 0 || T[i] == T[j])
        {
            i++, j++;
            next[i] = j;        //即next[j+1] == k + 1 == next[j] + 1。
        }
        else
            j = next[j];        //回溯前一重合部分子串的公共部分
    }
}


int KMP(string S, string T)
{
    int i = 1, j = 1;
    int* next = new int[T.size()]();
    while (i <= S.length() && j <= T.length())
    {
        if (j == 0 || T[j] == S[i])
        {
            i++, j++;
        }
        else j = next[j];
    }
    if (j > T.length()) return i - T.length();  //匹配成功
    else return 0;
}


int main() {

    return 0;
}
```


![](7.KMP字符串/Pasted%20image%2020240509185448.png)

```cpp
#include<iostream>
using namespace std;

const int N = 1000010;
char s[N], p[N];
int n, m, ne[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    //处理next数组
    for (int i = 2, j = 0; i <= n; i++)
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j++;
        ne[i] = j;
    }
    for (int i = 1, j = 0; i <= m; i++) 
    {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (p[j + 1] == s[i]) j++;
        if (j == n)
        {
            //匹配成功后相关操作
            cout << i - n << " ";
            //成功后还要回溯
            j = ne[j];
        }
    }

    return 0;
}
```
