---
title: 10.1模拟堆
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 数据结构

tags:
  - 算法
  - Acwing
  - 基础
  - 数据结构
  - 模板题
  - 堆
---

[839. 模拟堆 - AcWing题库](https://www.acwing.com/problem/content/841/)

### 题目描述
维护一个集合，初始时集合为空，支持如下几种操作：

1.  `I x`，插入一个数 $x$；
2.  `PM`，输出当前集合中的最小值；
3.  `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4.  `D k`，删除第 $k$ 个插入的数；
5.  `C k x`，修改第 $k$ 个插入的数，将其变为 $x$；

现在要进行 $N$ 次操作，对于所有第 $2$ 个操作，输出当前集合的最小值。

#### 输入格式

第一行包含整数 $N$。

接下来 $N$ 行，每行包含一个操作指令，操作指令为 `I x`，`PM`，`DM`，`D k` 或 `C k x` 中的一种。

#### 输出格式

对于每个输出指令 `PM`，输出一个结果，表示当前集合中的最小值。

每个结果占一行。

#### 数据范围

$1 \le N \le 10^5$  
$-10^9 \le x \le 10^9$  
数据保证合法。

#### 输入样例：

```
8
I -10
PM
I -10
D 1
C 2 8
I 6
PM
DM
```

#### 输出样例：

```
-10
6
```

---
### 算法

```cpp
//如何手写一个堆
// 插入                 heap[++size] = x;up(size)
// 求最小               heap[1]
// 删除最小             heap[1] = heap[size--], down(1);
// 删除第k个插入的数    heap[k] = heap[size--], up(k),down(k)
// 修改第k个插入的数    heap[k] = x;up(k),down(k)

// 所有的堆操作都可以用up 和 down来拼凑出来

#include<iostream>
using namespace std;

const int N = 100010;
int h[N], curSize;
int hp[N], ph[N];       //想要根据下标快速知道这是第几个插入的节点，和快速找到第几个节点对应的下标

//全新的交换，主要是维护映射关系        x,y是下标
void heapSwap(int x, int y)
{
    swap(ph[hp[x]], ph[hp[y]]);
    swap(hp[x], hp[y]);
    swap(h[x], h[y]);
}

void down(int x)
{
    int min = x;
    if (2 * x <= curSize && h[2 * x] < h[min]) min = 2 * x;
    if (2 * x + 1 <= curSize && h[2 * x + 1] < h[min]) min = 2 * x + 1;
    if (min != x)
    {
        heapSwap(min, x);
        down(min);
    }
}

void up(int x)
{
    while (x / 2 && h[x / 2] > h[x])
    {
        heapSwap(x / 2, x);
        x /= 2;
    }
}

int main()
{
    int n, k, x;
    int m = 0;      //用来表示第几个
    cin >> n;
    while (n--)
    {
        string op;
        cin >> op;
        if(op == "I")   
        {
            cin >> x;
            m++;
            h[++curSize] = x;
            hp[curSize] = m, ph[m] = curSize;
            up(curSize);    //down(curSize);

        }
        else if(op=="PM")    cout<<h[1]<<endl;
        else if(op=="DM")
        {
            heapSwap(1, curSize--);
            down(1);
        }
        else if(op=="D")
        {
            cin >> k;
            k = ph[k];           //这里非常要注意， ph[k]当参数传递时会改变值必须先保存
            heapSwap(k, curSize);
            curSize--;
            up(k), down(k);
        }
        else if(op=="C")
        {
            cin >> k >> x;
            k = ph[k];
            h[k] = x;
            up(k), down(k);
        }
    }
    return 0;
}
```
