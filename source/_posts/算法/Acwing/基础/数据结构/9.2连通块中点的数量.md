---
title: 9.2连通块中点的数量
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 数据结构

tags:
  - 算法
  - Acwing
  - 基础
  - 数据结构
  - 模板题
  - 并查集
---

[837. 连通块中点的数量 - AcWing题库](https://www.acwing.com/problem/content/839/)

### 题目描述
给定一个包含 n$n$ 个点（编号为 1∼n$1 \sim n$）的无向图，初始时图中没有边。

现在要进行 m$m$ 个操作，操作共有三种：

1.  `C a b`，在点 a$a$ 和点 b$b$ 之间连一条边，a$a$ 和 b$b$ 可能相等；
2.  `Q1 a b`，询问点 a$a$ 和点 b$b$ 是否在同一个连通块中，a$a$ 和 b$b$ 可能相等；
3.  `Q2 a`，询问点 a$a$ 所在连通块中点的数量；

#### 输入格式

第一行输入整数 n$n$ 和 m$m$。

接下来 m$m$ 行，每行包含一个操作指令，指令为 `C a b`，`Q1 a b` 或 `Q2 a` 中的一种。

#### 输出格式

对于每个询问指令 `Q1 a b`，如果 a$a$ 和 b$b$ 在同一个连通块中，则输出 `Yes`，否则输出 `No`。

对于每个询问指令 `Q2 a`，输出一个整数表示点 a$a$ 所在连通块中点的数量

每个结果占一行。

#### 数据范围

1≤n,m≤105$1 \le n,m \le 10^5$

#### 输入样例：

```
5 5
C 1 2
Q1 1 2
Q2 1
C 2 5
Q2 5
```

#### 输出样例：

```
Yes
2
3
```

---
### 算法

```cpp
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
int n, m;
int p[N], cnt[N];


int find(int x)
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}


int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        p[i] = i;
        cnt[i] = 1;
    }
    while (m--)
    {
        string s;
        int a, b;
        cin >> s;
        if (s == "C")
        {
            cin  >> a >> b;
            if (find(a) != find(b)) cnt[find(b)] += cnt[find(a)];
            p[find(a)] = find(p[b]);
        }
        else if (s == "Q1")
        {
            cin >> a >> b;
            if (find(a) == find(b)) cout << "Yes" << endl;
            else cout << "No" << endl;
        }
        else if (s == "Q2")
        {
            cin >> a;
            cout << cnt[find(a)] << endl;
        }
    }
    return 0;
}
```
