---
title: 11.2字符串哈希
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 数据结构

tags:
  - 算法
  - Acwing
  - 基础
  - 数据结构
  - 模板题
  - 哈希表
---

[841. 字符串哈希 - AcWing题库](https://www.acwing.com/problem/content/843/)

### 题目描述
给定一个长度为 $n$ 的字符串，再给定 $m$ 个询问，每个询问包含四个整数 $l_1, r_1, l_2, r_2$，请你判断 $[l_1, r_1]$ 和 $[l_2, r_2]$ 这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

#### 输入格式

第一行包含整数 $n$ 和 $m$，表示字符串长度和询问次数。

第二行包含一个长度为 $n$ 的字符串，字符串中只包含大小写英文字母和数字。

接下来 $m$ 行，每行包含四个整数 $l_1, r_1, l_2, r_2$，表示一次询问所涉及的两个区间。

注意，字符串的位置从 $1$ 开始编号。

#### 输出格式

对于每个询问输出一个结果，如果两个字符串子串完全相同则输出 `Yes`，否则输出 `No`。

每个结果占一行。

#### 数据范围

$1 \le n, m \le 10^5$

#### 输入样例：

```
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
```

#### 输出样例：

```
Yes
No
Yes
```

---
### 算法

```cpp
// 字符串哈希
// 判断数字间是否有相同的子串？
// string 1 = 99912366000
// string 2 = 66612345
// s1[6] - s1[3] = s2[6] - s2[3];      s1, s2是，的前缀和数组

// 所谓字符串哈希就是把每个子串映射成一个 p进制 哈希值，通过上面类似的式子判断相同子串
// ps:人品足够好，不会发生冲突，字符串哈希时只放在一个数组，故有如下公式
//预处理前缀哈希值 ： h[i] = h[i - 1] * p + str[i]  
//判断子串是否相等 ： h[r1] - h[l1 - 1] * p[r1 - l1 + 1] = h[r2] - h[l2 - 1] * p[r2 - l2 + 1]

#include<iostream>
using namespace std;
typedef unsigned long long ULL;

const int N = 100010, P = 131;      //一般来说进制数p可以去经验值131 ，13331
ULL h[N], p[N];     //p用来存p的多少次方
char str[N];

//返回子串的哈希值1
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}


int main()
{
    int n, m;
    cin >> n >> m;
    scanf("%s", str + 1);       //题目是从1开始
    p[0] = 1;
    for (int i = 1; i <= n; i++)    //处理p， 和 前缀和哈希数组
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m--)
    {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if (get(l1, r1) == get(l2, r2)) cout << "Yes" << endl;
        else cout << "No" << endl;

    }
    return 0;
}
```
