---
title: 3.2表达式求值
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 数据结构

tags:
  - 算法
  - Acwing
  - 基础
  - 数据结构
  - 模板题
  - 栈
---

[3302. 表达式求值 - AcWing题库](https://www.acwing.com/problem/content/3305/)

### 题目描述
给定一个表达式，其中运算符仅包含 `+,-,*,/`（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

**注意：**

*   数据保证给定的表达式合法。
*   题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式均不会出现。
*   题目保证表达式中所有数字均为正整数。
*   题目保证表达式在中间计算过程以及结果中，均不超过 $2^{31}-1$。
*   题目中的整除是指向 $0$ 取整，也就是说对于大于 $0$ 的结果向下取整，例如 $5/3=1$，对于小于 $0$ 的结果向上取整，例如 $5/(1-4) = -1$。
*   C++和Java中的整除默认是向零取整；Python中的整除`//`默认向下取整，因此Python的`eval()`函数中的整除也是向下取整，在本题中不能直接使用。

#### 输入格式

共一行，为给定表达式。

#### 输出格式

共一行，为表达式的结果。

#### 数据范围

表达式的长度不超过 $10^5$。

#### 输入样例：

```
(2+2)*(1+1)
```

#### 输出样例：

```
8
```

---
### 算法

```cpp
#include <iostream>
#include <cstring>
#include <stack>

using namespace std;


inline bool isOperator(char c)
{
    return c == '+' || c == '-' || c == '*' || c == '/';
}

inline int precedence(char c)
{
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

inline int calc(char op, int a, int b)
{
    if (op == '+') return a + b;
    if (op == '-') return a - b;
    if (op == '*') return a * b;
    if (op == '/') return a / b;
    return 0;
}

bool isDigit(char c)
{
    return c >= '0' && c <= '9';
}

const int N = 1e5 + 10;
char str[N];


int main()
{
    cin >> str;
    stack<char> ops;
    stack<int> nums;
    int i = 0, n = strlen(str);
    while (i < n)
    {
        char ch = str[i];
        if (isDigit(ch))
        {
            int num = 0;
            while (i < n && isDigit(str[i]))
            {
                num = num * 10 + (str[i] - '0');
                i++;
            }
            nums.push(num);
            continue;
        }
        else if (isOperator(ch)) 
        {
            while (!ops.empty() && precedence(ops.top()) >= precedence(ch))
            {
                char op = ops.top(); ops.pop();
                int b = nums.top(); nums.pop();
                int a = nums.top(); nums.pop();
                nums.push(calc(op, a, b));
            }
            ops.push(ch);
            
        }
        else if (ch == '(') ops.push(ch);
        else if (ch == ')')
        {
            while (ops.top() != '(')
            {
                char op = ops.top(); ops.pop();
                int b = nums.top(); nums.pop();
                int a = nums.top(); nums.pop();
                nums.push(calc(op, a, b));
            }
            ops.pop();
        }
        i++;
    }
    while (!ops.empty())
    {
        char op = ops.top(); ops.pop();
        int b = nums.top(); nums.pop();
        int a = nums.top(); nums.pop();
        nums.push(calc(op, a, b));
    }

  cout << nums.top() << endl;
}
```


```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int Calculate(string s) {
        Stack<int> nums = new Stack<int>(); // 存储操作数
        Stack<char> ops = new Stack<char>(); // 存储操作符
        int n = s.Length;
        int i = 0;
        
        while (i < n) {
            char c = s[i];
            
            if (Char.IsDigit(c)) {
                int num = 0;
                while (i < n && Char.IsDigit(s[i])) {
                    num = num * 10 + (s[i] - '0');
                    i++;
                }
                nums.Push(num);
                continue; // 此时 i 已经在下一个字符，不用再自增
            }
            
            if (c == '(') {
                ops.Push(c);
            } else if (c == ')') {
                while (ops.Peek() != '(') {
                    nums.Push(ApplyOp(ops.Pop(), nums.Pop(), nums.Pop()));
                }
                ops.Pop(); // 弹出左括号 '('
            } else if (IsOperator(c)) {
                while (ops.Count > 0 && Precedence(ops.Peek()) >= Precedence(c)) {
                    nums.Push(ApplyOp(ops.Pop(), nums.Pop(), nums.Pop()));
                }
                ops.Push(c);
            }
            i++;
        }
        
        // 处理栈中剩余的操作符
        while (ops.Count > 0) {
            nums.Push(ApplyOp(ops.Pop(), nums.Pop(), nums.Pop()));
        }
        
        return nums.Pop();
    }
    
    // 检查是否是操作符
    private bool IsOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }

    // 定义操作符优先级
    private int Precedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        return 0;
    }

    // 应用操作符计算两个数
    private int ApplyOp(char op, int b, int a) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        return 0;
    }
}

```