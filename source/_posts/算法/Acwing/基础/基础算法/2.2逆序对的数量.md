---
title: 2.2逆序对的数量
date: 2000-01-01 00:00:00
toc: false
categories:
  - 算法
  - Acwing
  - 基础
  - 基础算法

tags:
  - 算法
  - Acwing
  - 基础
  - 基础算法
  - 模板题
  - 归并排序
---

[788. 逆序对的数量 - AcWing题库](https://www.acwing.com/problem/content/790/)

### 题目描述
给定一个长度为 $n$ 的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i < j$ 且 $a[i] > a[j]$，则其为一个逆序对；否则不是。

#### 输入格式

第一行包含整数 $n$，表示数列的长度。

第二行包含 $n$ 个整数，表示整个数列。

#### 输出格式

输出一个整数，表示逆序对的个数。

#### 数据范围

$1 \le n \le 100000$，  
数列中的元素的取值范围 $[1,10^9]$。

#### 输入样例：

```
6
2 3 4 5 6 1
```

#### 输出样例：

```
5
```

---
### 算法
```cpp
#include<iostream>
const int N = 100010;

int a[N];
int n;
long long res;

int merge(int a[], int l, int r)
{
    if (l >= r) return 0;
    int mid = (l + r) >> 1;
    merge(a, l, mid);
    merge(a, mid + 1, r);
    int i = l, j = mid + 1, tem[r - l + 1], k = 0;
    while (i <= mid && j <= r)
    {
        if (a[i] <= a[j]) tem[k++] = a[i++];
        else 
        {
            tem[k++] = a[j++];
            res += mid - i + 1;
        }
    }
    while (i <= mid) tem[k++] = a[i++];
    while (j <= r) tem[k++] = a[j++];
    for (int i = 0, j = l; j <= r; j++, i++) a[j] = tem[i];
    return res;
}


int main()
{
    std::cin >> n;
    for (int i = 0; i < n; i++) std::cin >> a[i];
    merge(a, 0, n - 1);
    std::cout << res;
}
```
