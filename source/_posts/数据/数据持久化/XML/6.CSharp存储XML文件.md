---
title: 6.CSharp存储XML文件
date: 2025-03-06 15:35:19
toc: true
categories:
  - 数据
  - 数据持久化
  - XML

tags:
  - 数据
  - 数据持久化
  - XML
---

# Xml决定存储在哪个文件夹下
注意：存储xml文件 在Unity中**一定是使用各平台都可读可写可找到的{% post_link 11.特殊文件夹 路径%}**
- Resources 可读 不可写 打包加密后通过路径找不到 ×
- Application.streamingAssetsPath 可读 PC端可写 但是其他平台不可写 打包加密后通过路径找得到 可以存些不会改的xml文件 ×
- Application.dataPath 编辑器上操作看起来没什么问题 但是打包后找不到 ×
- `Application.persistentDataPath` 可读可写 各个平台找得到 √

```cs
string path = Application.persistentDataPath + "/player_data.xml";
print(Application.persistentDataPath);
```

# 存储XML文件
## 手动构建XML文档
**具体的五个步骤**：
1. 创建XmlDocument文档对象
2. 添加固定版本信息
3. 添加根节点
4. 为根节点添加子节点
5. 保存
**适用场景**：简单配置、快速原型开发
```cs
// 创建XML文档对象
XmlDocument doc = new XmlDocument();

// 这一句代码 相当于就是创建<?xmlDocument version="1.0" encoding="UTF-8"?>这句内容
XmlDeclaration xmlDec = xmlDocument.CreateXmlDeclaration("1.0", "UTF-8", "");

// 创建根节点
XmlElement root = doc.CreateElement("PlayerData");
doc.AppendChild(root);

// 添加基础属性
XmlElement player = doc.CreateElement("Player");
player.SetAttribute("id", "1001");
player.SetAttribute("class", "Warrior");

// 添加子节点
// HP
XmlElement hpNode = doc.CreateElement("HP");
hpNode.InnerText = "500";
// Atk
XmlElement atkElement = xmlDoc.CreateElement("Atk");
atkElement.InnerText = "200";

player.AppendChild(hpNode);
player.AppendChild(atkElement);

// 保存到文件
doc.Save(path); // player_data.xml
```

生成的结果
```xml
<PlayerData>
  <Player id="1001" class="Warrior">
    <HP>500</HP>
    <Atk>200</Atk>
  </Player>
</PlayerData>
```

# 修改XML文件
判断文件是否存在
```cs
//File类中的Exists方法 判断路径是否存在
if (File.Exists(path))
{
}
```

**加载后利用学过的方法修改xml文件**
```cs
// 创建 XmlDocument 对象
XmlDocument xmlDoc = new XmlDocument();
// 加载 XML 文件
xmlDoc.Load("player_data.xml");
```

**添加节点**
```cs
// 假设已经加载了 XML 文件到 xmlDoc 中
// 获取根节点
XmlElement root = xmlDoc.DocumentElement;

// 创建新的元素节点
XmlElement newElement = xmlDoc.CreateElement("newNode");
// 设置元素节点的文本内容
newElement.InnerText = "New Node Content";

// 将新节点添加到根节点下
root.AppendChild(newElement);
```

**删除节点**
```cs
// 假设已经加载了 XML 文件到 xmlDoc 中
// 使用 XPath 选择要删除的节点
XmlNode nodeToDelete = xmlDoc.SelectSingleNode("//Atk");

if (nodeToDelete != null)
{
    // 获取父节点
    XmlNode parentNode = nodeToDelete.ParentNode;
    // 从父节点中移除该节点
    parentNode.RemoveChild(nodeToDelete);
}
```


# 练习
定义一个名为 SaveData 的公共方法，参数为文件名字符串 fileName
```cs
//定义一个名为 SaveData 的公共方法，参数为文件名字符串 fileName
public void SaveData(string fileName)
{
    //决定存储路径
    string path = Application.persistentDataPath + "/" + fileName + ".xml";

    //输出该XML文档将保存在何处。
    Debug.Log(Application.persistentDataPath);

    //初始化5步操作。

    //1.创建XmlDocument对象。稍后它将包含所需的Xml数据。
    XmlDocument xml = new XmlDocument();

    //2.使用CreateXmlDeclaration()方法创建XmlDeclaration对象声明文档类型和版本。
    XmlDeclaration xmlDec = xml.CreateXmlDeclaration("1.0", "UTF-8", "");
    //将XmlDeclaration对象添加到XmlDocument对象中。
    //这将把该声明作为XML文件的第一行。
    xml.AppendChild(xmlDec);

    //3.添加根节点
    //使用CreateElement()方法，创建一个根节点XmlElement对象并命名为“PlayerInfo”。
    XmlElement playerInfo = xml.CreateElement("PlayerInfo");
    //向XmlDocument对象添加根节点XmlElement对象“playerInfo”
    xml.AppendChild(playerInfo);

    //4.添加子节点 或者 属性相关

    //使用CreateElement方法创建Xml子项XmlElement对象并设置它们的InnerText值。
    //XmlElement对象表示不带数据的标记或元素。
    XmlElement name = xml.CreateElement("name");
    name.InnerText = this.name;
    playerInfo.AppendChild(name);

    XmlElement atk = xml.CreateElement("atk");
    atk.InnerText = this.atk.ToString();
    playerInfo.AppendChild(atk);

    XmlElement def = xml.CreateElement("def");
    def.InnerText = this.def.ToString();
    playerInfo.AppendChild(def);

    XmlElement moveSpeed = xml.CreateElement("moveSpeed");
    moveSpeed.InnerText = this.moveSpeed.ToString();
    playerInfo.AppendChild(moveSpeed);

    XmlElement roundSpeed = xml.CreateElement("roundSpeed");
    roundSpeed.InnerText = this.roundSpeed.ToString();
    playerInfo.AppendChild(roundSpeed);

    //创建XmlElement对象表示装备与其属性
    XmlElement weapon = xml.CreateElement("weapon");

    XmlElement id = xml.CreateElement("id");
    id.InnerText = this.weapon.id.ToString();
    weapon.AppendChild(id);

    XmlElement num = xml.CreateElement("num");
    num.InnerText = this.weapon.num.ToString();
    weapon.AppendChild(num);

    playerInfo.AppendChild(weapon);

    //创建XmlAttribute对象表示一个整数列表（listInt）
    XmlElement listInt = xml.CreateElement("listInt");
    for (int i = 0; i < this.listInt.Count; i++)
    {
        //使用CreateElement方法创建名为“int”的子节点，设置InnerText值并添加到根节点中的列表项。
        XmlElement intNode = xml.CreateElement("int");
        intNode.InnerText = this.listInt[i].ToString();
        listInt.AppendChild(intNode);
    }

    playerInfo.AppendChild(listInt);

    //构建名为$itemList的XmlElement对象，该对象将保存所有的Item项目 .
    XmlElement itemList = xml.CreateElement("itemList");

    for (int i = 0; i < this.itemList.Count; i++)
    {
        //使用CreateElement方法分别在itemList根节点下创建三个Xml子项<Element>对象。
        XmlElement itemNode = xml.CreateElement("Item");

        //谁每个XmlElement对象的ID和Num属性各自包含了itemList中的Item对象的ID属性和Num属性。
        itemNode.SetAttribute("id", this.itemList[i].id.ToString());
        itemNode.SetAttribute("num", this.itemList[i].num.ToString());

        //将三个XmlElement对象都添加到itemList节点之下。
        itemList.AppendChild(itemNode);
    }

    playerInfo.AppendChild(itemList);

    //创建一个名为itemDict的XmlElement对象，该对象将保存所有Item相关数据
    XmlElement itemDic = xml.CreateElement("itemDic");

    foreach (int key in this.itemDic.Keys)
    {
        //分别实例化intNode和itemNode对象来存储Dictionary<int,Item>对象的键值对数据。
        XmlElement intNode = xml.CreateElement("int");
        intNode.InnerText = key.ToString();   //key作为标记内部的InnerText值

        //itemNode的ID属性和Num属性包含字典项的Id属性和Num属性。
        XmlElement itemNode = xml.CreateElement("Item");
        itemNode.SetAttribute("id", this.itemDic[key].id.ToString());
        itemNode.SetAttribute("num", this.itemDic[key].num.ToString());

        //添加这两个XmlElement对象到XmlDocument对象中。
        itemDic.AppendChild(intNode);
        itemDic.AppendChild(itemNode);
    }

    //将此XmlElement对象添加到根XmlElement对象之下
    playerInfo.AppendChild(itemDic);

    //5.使用XmlDocument类的Save()方法将生成的XML文本与指定路径path的文件进行存储。
    xml.Save(path);
}

```