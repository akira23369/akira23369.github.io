---
title: 7.各Json库对比
date: 2025-03-27 20:10:06
toc: true
categories:
  - 数据
  - 数据持久化
  - Json

tags:
  - 数据
  - 数据持久化
  - Json
---
在 Unity 开发中，处理 JSON 数据时常用的三种库是 Newtonsoft.Json、LitJson 和 Unity 内置的 JsonUtility。以下是它们的详细对比，涵盖功能、性能、兼容性、优缺点及适用场景。

# **核心对比表**
| **特性**             | **Newtonsoft.Json**            | **LitJson**              | **Unity JsonUtility**           |
| ------------------ | ------------------------------ | ------------------------ | ------------------------------- |
| **类型支持**           | ✔️ 支持复杂类型（字典、多态、接口、私有字段等）      | ✔️ 基础类型、简单对象，有限支持多态（字典）  | ❌ 仅支持标记为 `[Serializable]` 的公共字段 |
| **性能**             | ❌ 最慢（反射开销大）                    | ✔️ 较快（轻量级实现）             | ✔️ 最快（底层 C++ 实现）                |
| **Unity 类型支持**     | ❌ 需自定义转换器（如 `Vector3`）         | ❌ 需自定义转换器                | ✔️ 原生支持 `Vector3`、`Color` 等     |
| **多态/继承支持**        | ✔️ 完整支持（通过 `TypeNameHandling`） | ✔️ 有限支持（需额外配置）           | ❌ 不支持                           |
| **自定义序列化**         | ✔️ 支持（`JsonConverter`、属性标记）    | ✔️ 有限支持（通过 `JsonMapper`） | ❌ 不支持                           |
| **空值和默认值处理**       | ✔️ 灵活配置（`NullValueHandling`）   | ✔️ 基础支持                  | ❌ 仅忽略 `null`                    |
| **文档和社区**          | ✔️ 完善（官方文档 + Stack Overflow）   | ❌ 文档较少，社区支持一般            | ✔️ 官方文档（但功能有限）                  |
| **安装方式**           | ✔️ NuGet 包或手动导入                | ✔️ 手动导入 DLL 或源码          | ✔️ Unity 内置                     |
| **AOT/IL2CPP 兼容性** | ❌ 需要额外处理（`link.xml`）           | ✔️ 较好                    | ✔️ 完美兼容                         |
| **体积**             | ❌ 较大（DLL 约 500KB）              | ✔️ 较小（DLL 约 100KB）       | ✔️ 零额外体积                        |
| **数据反序列化为数据集合**    | ✔️                             | ✔️                       | ❌不能直接将数据反序列化为数据集合(数组字典),要包裹一层   |

# 详细对比分析
## **功能丰富性**
**Newtonsoft.Json**：
    **最强功能**：支持多态类型、字典、私有字段、接口、循环引用处理、自定义转换器等。
    适合复杂数据结构（如 RPG 游戏的存档、网络协议数据）。
**LitJson**：
    **中等功能**：支持基础类型和简单对象，多态需要手动注册类型。
    适合轻量级需求（如配置表解析）。
**JsonUtility**：
    **功能最弱**：仅支持标记为 `[Serializable]` 的公共字段，不支持字典、多态、私有字段。
    适合简单数据（如玩家位置、基础配置）。

## **性能**
**JsonUtility**：
    **最快**：底层是 C++ 实现，无反射开销，适合高频调用（如每帧序列化）。
    测试数据：序列化 10,000 个简单对象约 **5ms**。
**LitJson**：
    **次快**：基于轻量级代码生成，反射开销较小。
    测试数据：序列化 10,000 个简单对象约 **20ms**。
**Newtonsoft.Json**：
    **最慢**：依赖反射和动态类型，性能较差。
    测试数据：序列化 10,000 个简单对象约 **100ms**。
## **Unity 类型支持**
**JsonUtility**：原生支持 `Vector3`、`Color`、`Quaternion` 等 Unity 特有类型。
**Newtonsoft.Json** 和 **LitJson**：需要自定义转换器才能序列化 Unity 类型（如 `Vector3`）。
```cs
// Newtonsoft.Json 自定义 Vector3 转换器
public class Vector3Converter : JsonConverter<Vector3> {
    public override void WriteJson(JsonWriter writer, Vector3 value, JsonSerializer serializer) {
        writer.WriteValue($"{value.x},{value.y},{value.z}");
    }
    public override Vector3 ReadJson(JsonReader reader, Type objectType, Vector3 existingValue, bool hasExistingValue, JsonSerializer serializer) {
        string[] parts = ((string)reader.Value).Split(',');
        return new Vector3(float.Parse(parts[0]), float.Parse(parts[1]), float.Parse(parts[2]));
    }
}
```
## **多态支持（继承类/接口）**
**Newtonsoft.Json**：通过 `TypeNameHandling.Auto` 自动添加类型信息。
```cs
[JsonObject(ItemTypeNameHandling = TypeNameHandling.Auto)]
public List<Character> Characters; // 支持 Enemy/NPC 派生类
```
**LitJson**：需手动注册子类型
```cs
JsonMapper.RegisterExporter<Enemy>((obj, writer) => { /* 自定义导出逻辑 */ });
```
**JsonUtility**：不支持多态，反序列化时无法还原派生类。


## **移动端兼容性**
**JsonUtility**：完美支持 IL2CPP，无 AOT 问题。
**LitJson**：兼容性较好，但部分复杂类型可能需额外处理。
**Newtonsoft.Json**：在 IL2CPP 下可能因反射导致 AOT 错误，需通过 `link.xml` 保留类型：
```xml
<!-- link.xml -->
<linker>
  <assembly fullname="Newtonsoft.Json" preserve="all"/>
</linker>
```

# **场景推荐**
**Newtonsoft.Json：**
需要处理复杂数据结构（如包含字典、多态类型的存档）。
需要高度定制序列化行为（如忽略空值、自定义字段名）。

典型场景：**网络协议、复杂游戏存档、编辑器工具**。

**LitJson：**
对性能有一定要求，但数据结构简单。
不想依赖 Unity 以外的库。

典型场景：**配置表解析、轻量级网络通信。**

**JsonUtility：**
数据结构简单，且需要极致性能（如频繁序列化）。
项目要求零额外依赖。

典型场景：**玩家位置同步、简单配置存储。**


```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Lesson06_JsonUtility和LitJson对比 : MonoBehaviour
{
    void Start()
    {
        #region 知识点一 JsonUtlity和LitJson相同点
        //1.他们都是用于Json的序列化反序列化
        //2.Json文档编码格式必须是UTF-8
        //3.都是通过静态类进行方法调用
        #endregion

        #region 知识点二 JsonUtlity和LitJson不同点
        //1.JsonUtlity是Unity自带，LitJson是第三方需要引用命名空间
        //2.JsonUtlity使用时自定义类需要加特性,LitJson不需要
        //3.JsonUtlity支持私有变量(加特性),LitJson不支持
        //4.JsonUtlity不支持字典,LitJson支持(但是键只能是字符串)
        //5.JsonUtlity不能直接将数据反序列化为数据集合(数组字典),要包裹一层,LitJson可以
        //6.JsonUtlity对自定义类不要求有无参构造，LitJson需要
        //7.JsonUtlity存储空对象时会存储默认值而不是null，LitJson会存null
        #endregion

        #region 知识点三 如何选择两者
        //根据实际需求
        //建议使用LitJson
        //原因：LitJson不用加特性，支持字典，支持直接反序列化为数据集合，存储null更准确
        #endregion
    }
}

```