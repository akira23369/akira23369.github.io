---
title: 9.自定义单选框
date: 2025-02-27 15:47:17
toc: true
categories:
  - UI系统
  - GUI
  - GUI实践项目

tags:
  - UI系统
  - GUI
  - GUI实践项目
---

回顾闭包
**当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。**

**示例 1：基本闭包**
```cs
Func<int> CreateCounter()
{
    int count = 0;
    return () => ++count; // 闭包捕获了外部变量 count
}

var counter = CreateCounter();
Console.WriteLine(counter()); // 输出 1
Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态）
```
- **现象**：`count` 本应在 `CreateCounter` 方法执行完毕后被销毁，但闭包保留了它的状态。
- **原理**：编译器生成一个类，将 `count` 作为该类的字段存储，闭包通过这个类的实例访问 `count`。

**示例 2：循环中的闭包陷阱**
```cs
var actions = new List<Action>();
for (int i = 0; i < 3; i++)
{
    actions.Add(() => Console.WriteLine(i));
}
foreach (var action in actions)
{
    action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）
}
```
- **问题原因**：所有闭包共享同一个变量 `i`（在循环结束后，`i` 的值为 3）。
- **解决方案**：在循环内部创建临时变量，让闭包捕获独立的值：

```cs
for (int i = 0; i < 3; i++)
{
    int current = i; // 每次循环新建一个临时变量
    actions.Add(() => Console.WriteLine(current)); // 输出 0, 1, 2
}
```

# CustomGUIToggleGroup.cs
创建自定义单选框，**添加多选框数组，通过管理多选框实现单选框**，在添加一个记录上一次为true的toggle
```csharp
public class CustomGUIToggleGroup : MonoBehaviour
{
    [SerializeField]
    private CustomGUIToggle[] _toggles;

    private CustomGUIToggle _frontTrueToggle；    // 上一次为true的toggle
    // 注意只有游戏运行才能用
    void Start()
    {
        for (int i = 0; i < _toggles.Length; i++)
        {
            CustomGUIToggle tmp = _toggles[i];
            // 为每个Toggle添加一个一旦其值为true时, 其它Toggle变为false的委托
            // Lambda函数捕获了外部变量（tmp）!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            tmp.changeEvent += (value) =>
            {
                if (value)
                {
                    for (int j = 0; j < _toggles.Length; j++)
                    {
                        if (tmp != _toggles[j])    // 只要不是自己
                        {
                            _toggles[j].isSel = false;
                        }
                    }
                    // 这里可以记录上一次为true的toggle
                    _frontTrueToggle = tmp;
                }
                else if (_frontTrueToggle == tmp)    // 如果是上一次为true的toggle
                {
                    tmp.isSel = true;    // 永远保持选中的状态
                }
            };
        }
    }
}
```