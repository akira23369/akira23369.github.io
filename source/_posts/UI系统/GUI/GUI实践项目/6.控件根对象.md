---
title: 6.控件根对象
date: 2025-02-27 15:06:16
toc: true
categories:
  - UI系统
  - GUI
  - GUI实践项目

tags:
  - UI系统
  - GUI
  - GUI实践项目
---

# 解决两个问题
1. **所见即所得**（编辑模式下能看到GUI）
2. **可以控制控件的绘制顺序**

**创建所有自定义GUI的根部类,添加ExecuteAlways特性**
在类名添加`ExecuteAlways`特性，可以让编辑模式下指定代码运行。
```cs
[ExecuteAlways]
//所有自定义GUI的根部类
public class CustomGUIRoot : MonoBehaviour
{
}
```

**在Start方法中获取所有子对象的控件父类脚本**
```cs
void Start()
{
    //通过每一次绘制之前 得到所有子对象控件的 父类脚本
    allControls = this.GetComponentsInChildren<CustomGUIControl>();
}
```


在`OnGUI`方法中按照得到的顺序来绘制每个控件，用控件父类中定义好的绘制方法
```cs
//在这同一绘制子对象控件的内容
private void OnGUI()
{
    //编辑状态下 才会一直执行
    //if (!Application.isPlaying)
    //{
    //这句代码 浪费性能 因为每次 gui都会来获取所有的 控件对应的脚本 所以要在编辑状态下才会一直执行
    //在编辑状态下运行是因为想一直看到控件的移动

    //最后没开启是因为只得了一次子对象的CustomGUIControl 就算子对象被隐藏了也不会重写得CustomGUIControl 会有问题
    allControls = this.GetComponentsInChildren<CustomGUIControl>();

    //}

    //遍历每一个控件 让其 执行绘制
    for (int i = 0; i < allControls.Length; i++)
    {
        allControls[i].GUIDraw();
    }
}
```






# CustomGUIRoot.cs
```cs
[ExecuteAlways]
public class CustomGUIRoot : MonoBehaviour
{
    private CustomGUIControl[] _customGUIControls;
    private void Start()
    {
        _customGUIControls = this.GetComponentsInChildren<CustomGUIControl>();
    }

    // 统一控制所有子对象挂载的控件的 绘制
    private void OnGUI()
    {
        if (!Application.isPlaying)    // 这里的条件判断主要是为了性能, 实际运行可能会出错
        {
            _customGUIControls = this.GetComponentsInChildren<CustomGUIControl>();
        }
        for (int i = 0; i < _customGUIControls.Length; i++)
        {
            _customGUIControls[i].GUIDraw();
        }
    }
}
```