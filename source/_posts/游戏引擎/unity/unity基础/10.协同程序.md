---
title: 10.协同程序
date: 2025-03-02 19:15:55
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
---

# 简单回顾csharp中的多线程
{% post_link csharp多线程 %}

# Unity是否支持多线程？
1. Unity是支持多线程的，只是新开线程无法访问Unity相关场景上对象的内容。例如this.transform（必须在主线程调用）。
2. 注意：**Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑**
3. 在Unity中，不会开启多线程访问Unity相关。**当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。** 当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。

```cs
//新线程
Thread newThread;

//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西
Queue<Vector3> queue = new Queue<Vector3>();

//副线程可能也要拿主线程的数据用来判断做逻辑
Queue<Vector3> queue2 = new Queue<Vector3>();

void Start()
{
    //首先要明确一点
    //Unity是支持多线程的
    //只是新开线程无法访问Unity相关对象的内容
    
    //引用System.Threading命名空间
    newThread = new Thread(newThreadLogic);
    newThread.Start();
    
    //注意：
    //Unity中的多线程 要记住关闭
    //不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容
    //可以在OnDestroy执行关闭线程逻辑
}

void Update()
{
    //在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用
    if (queue.Count > 0)
    {
        //取出位置
        this.transform.position = queue.Dequeue();
    }
}

//新线程逻辑
private void newThreadLogic()
{
    while (true)
    {
        Thread.Sleep(1000);
        print("新线程逻辑 每隔一秒的打印");
        
        //我们在Unity中，不会开启多线程访问Unity相关
        //当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿
        //这时就可以开启多线程用于A星寻路算法，网络收发相关
        //当算好了结果或者收到了消息过后，放在公共的内存区域
        //主线程判断判断公共的内存区域有没有想要的对象，拿来使用
        
        //这句代码会报错 不能在副线程控制Unity相关
        //UnityException: get_transform can only be called from the main thread.
        //this.transform.Translate(Vector3.forward * Time.deltaTime);
        
        //相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中
        //用Unity的随机数都不能用 用C#里的随机数
        System.Random r = new System.Random();
        queue.Enqueue(new Vector3(r.Next(-10, 10), r.Next(-10, 10), r.Next(-10, 10)));
        
    }
}

private void OnDestroy()
{
    //关闭线程
    newThread.Abort();
    //关闭线程后置空
    newThread = null;
}

```

# **什么是协程？**
协程（Coroutine）是Unity中一种特殊的函数，可以**分步执行代码**并**跨越多帧运行**。它通过`yield`关键字暂停执行，并在特定条件（如等待时间结束、帧结束等）满足后继续执行。
- 它是“假”的多线程，它不是多线程
- **它的本质是{% post_link csharp迭代器 迭代器%}**

- C#的{% post_link csharp迭代器 迭代器%}**函数”分步执行”的特点
- 加上 Unity自己定义的一些协程调度逻辑
- 实现的一套分时执行函数的规则

#  **协程的主要作用**
将代码分时执行，不卡主线程
简单理解，是把可能会让主线程卡顿的耗时的逻辑**分时分步**执行
- **处理延时操作**：例如等待1秒后执行代码。
- **分步执行任务**：将复杂任务拆分成多个步骤，避免卡顿。
- **按帧控制逻辑**：逐帧处理动画、AI行为等。
- **异步加载资源**：分批加载资源防止主线程阻塞。
- **异步下载文件**
- **场景异步加载**
- **批量创建时防止卡顿**

# **主要使用场景**
- 角色技能冷却倒计时。
- 分批次加载大型场景或资源。
- 实现平滑的动画过渡（如物体渐隐）。
- 等待网络请求返回后更新UI。

# 协同程序和线程的区别
- 新开一个线程是独立的一个管道，与主线程并行执行。
- 新开一个协程是在原线程之上开启，进行**逻辑分时分步执行**。

# {% post_link csharp迭代器#yield-return-语法糖 回顾yield return相关知识点%}

# **协程的使用方法**
**基本规则**：
1. 协程方法的返回类型必须是 `IEnumerator`。
2. 使用 `yield return` 指定暂停条件（如 `new WaitForSeconds(2)`）。
3. 通过 `StartCoroutine()` 启动协程。

## **启动协程**：
**基本语法：**
```cs
public class CoroutineExample : MonoBehaviour
{
    void Start()
    {
        // 启动协程
        StartCoroutine(SimpleCoroutine());
    }

    IEnumerator MyCoroutine(string hello) {
        Debug.Log($"协程开始，say hello\n{hello}");
        yield return new WaitForSeconds(1); // 暂停1秒
        Debug.Log("1秒后执行");
        yield return new WaitForSeconds(2); // 再暂停2秒
        Debug.Log("又过了2秒");
    }
}
```

Unity 提供了多种内置的等待指令，可以直接在协程中使用：

| **指令**                    | **说明**                           | 指令满足之后在哪里执行                                |
| ------------------------- | -------------------------------- | ------------------------------------------ |
| `null 或者 数字`              | 等待到下一帧（等同 `yield return null`）   | `Update`和`LateUpdate`之间执行                  |
| `WaitForSeconds`          | 等待指定秒数（受`Time.timeScale`时间缩放影响）  | `Update`和`LateUpdate`之间执行                  |
| `WaitForSecondsRealtime`  | 等待指定秒数（不受`Time.timeScale`时间缩放影响） | `Update`之后                                 |
| `WaitForFixedUpdate`      | 等待到下一个 FixedUpdate               | 在`FixedUpdate`和碰撞检测相关函数之后执行                |
| `WaitForEndOfFrame`       | 等待到帧结束（截图功能）                     | 等待摄像机和GUI渲染完成后执行，在LateUpdate之后的渲染相关处理完毕后之后 |
| `WWW` 或 `UnityWebRequest` | 等待网络请求完成                         | `Update`之后                                 |

## 停止协程
```cs
// 停止单个协程
Coroutine coroutine = StartCoroutine(MyCoroutine());
StopCoroutine(coroutine);

// 停止所有协程
StopAllCoroutines();
```

# **协程的典型使用场景**
## **场景 1：延迟执行**
```cs
IEnumerator DelayedAction()
{
    yield return new WaitForSeconds(3);
    Debug.Log("3秒后执行爆炸效果");
    // 触发爆炸动画、音效等
}
```

## **场景 2：分帧处理大数据**
```cs
IEnumerator ProcessLargeData(List<Item> data)
{
    foreach (var item in data)
    {
        ProcessItem(item); // 处理单个数据
        yield return null; // 每帧处理一个，避免卡顿
    }
}
```

## **场景 3：按顺序执行多段逻辑**
```cs
IEnumerator DialogueSequence()
{
    ShowText("你好，旅行者！");
    yield return new WaitUntil(() => Input.GetKeyDown(KeyCode.Space)); // 等待玩家按空格
    ShowText("前方有危险...");
    yield return new WaitForSeconds(2);
    ShowText("准备好了吗？");
}
```

# 协程受对象和组件失活销毁的影响
- 协程开启后：
    - 组件或物体销毁，物体失活，则协程不再执行。
    - 组件失活时，协程仍然执行。

# 练习
## **协程实现的计秒器**
```cs
using UnityEngine;
using UnityEngine.UI;

public class Timer : MonoBehaviour
{
    public Text timerText; // 关联UI文本
    private float elapsedTime;
    private bool isRunning;

    void Start()
    {
        StartCoroutine(CountSeconds());
    }

    IEnumerator CountSeconds()
    {
        isRunning = true;
        while (isRunning)
        {
            elapsedTime += Time.deltaTime;
            // 显示格式化为整数秒（或保留1位小数）
            timerText.text = "Time: " + elapsedTime.ToString("F1"); 
            yield return null; // 每帧更新
        }
    }

    // 停止计时（可选）
    public void StopTimer()
    {
        isRunning = false;
    }
}
```

## **分帧创建10万立方体（无卡顿）**
原本 1帧 创建 10万个
现在 1帧 创建 cubesPerFrame 个

比较蠢的做法
```cs
for (int i = 0; i < 100000; i++)
{
    GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
    obj.transform.position = new Vector3(Random.Range(-100, 100), Random.Range(-100, 100), Random.Range(-100, 100));
}
```

```cs
using UnityEngine;

public class CubeSpawner : MonoBehaviour
{
    public GameObject cubePrefab; // 立方体预制体
    public int totalCubes = 100000;
    public int cubesPerFrame = 500; // 每帧生成的数量

    void Start()
    {
        StartCoroutine(SpawnCubes());
    }

    IEnumerator SpawnCubes()
    {
        int created = 0;
        while (created < totalCubes)
        {
            for (int i = 0; i < cubesPerFrame; i++)
            {
                if (created >= totalCubes) break;
                // 随机生成位置（范围可调）
                Vector3 pos = new Vector3(
                    Random.Range(-50f, 50f),
                    Random.Range(-50f, 50f),
                    Random.Range(-50f, 50f)
                );
                Instantiate(cubePrefab, pos, Quaternion.identity);
                created++;
            }
            yield return null; // 每帧分批生成
        }
        Debug.Log("生成完成");
    }
}
```

## 手动实现协程调度器（不使用Unity自带功能）

**启动协程流程**

1. 调用`StartCoroutine`并传入一个IEnumerator方法(如`MyTestFunc`)
2. 首先调用`MoveNext()`，这会执行协程直到第一个`yield return`语句
3. 此时会创建一个`CustomYieldReturn`对象，记录:
    - 当前时间 + yield返回的值(作为延迟时间)
    - IEnumerator对象(协程执行位置)
4. 将这个对象添加到管理列表中

**更新流程(在Update中)**

1. 每帧倒序遍历所有协程(倒序是为了安全删除)
2. 检查每个协程的Timer是否到期(当前时间 > Timer)
3. 如果到期:
    - 再次调用`MoveNext()`，这会执行到下一个`yield return`
    - 如果`MoveNext()`返回true(还有后续代码):
        - 更新Timer为当前时间 + 新的yield返回值
    - 如果返回false(协程结束):
        - 从列表中移除这个协程

```cs
// 存储协程的执行状态
public class CustomYieldReturn
{
    // 下次执行的时间点
    public float Timer;
    // 存储IEnumerator对象，代表协程的执行位置
    public IEnumerator Coroutine;
}
public class MyCoroutineMgr : MonoBehaviour
{
    private MyCoroutineMgr() { }
    private static MyCoroutineMgr _instance;
    public static MyCoroutineMgr Instance => _instance;

    // 迭代器函数对象的 容器 用于 一会继续执行（在Update中不断调用MoveNext）
    public List<CustomYieldReturn> customYieldReturns = new List<CustomYieldReturn>();
    void Awake()
    {
        _instance = this;
    }

    //开启协程的方法
    public void StartCoroutine(IEnumerator coroutine)
    {
        if (coroutine.MoveNext())
        {
            CustomYieldReturn tmp = new CustomYieldReturn();
            // 记录下次执行的时间点, 用于Update中判断是否执行
            tmp.Timer = Time.time + (float)coroutine.Current;
            // 记录当前的协程位置
            tmp.Coroutine = coroutine;
            customYieldReturns.Add(tmp);
        }
    }

    // Update is called once per frame
    void Update()
    {
        // 每一帧倒着遍历所有的协程，因为有可能会删除
        for (int i = customYieldReturns.Count - 1; i >= 0; i--)
        {
            CustomYieldReturn tmp = customYieldReturns[i];
            // 判断是否到了下次执行
            if (Time.time > tmp.Timer)
            {
                if (tmp.Coroutine.MoveNext())
                {
                    // 更新下一个yield return的条件
                    tmp.Timer = Time.time + (float)tmp.Coroutine.Current;
                }
                else
                {
                    customYieldReturns.RemoveAt(i);
                }
            }
        }
    }
}


// **使用自己的协程管理器**    Test.cs
public class Test : MonoBehaviour
{
    // 协程
    IEnumerator MyTestFunc()
    {
        Debug.Log("你好");
        yield return 1.0f;
        Debug.Log(1);
        yield return 2.0f;
        Debug.Log(2);
        yield return 3.0f;
        Debug.Log(3);
    }
    private void Start()
    {
        // 使用自己的协程管理器
        MyCoroutineMgr.Instance.StartCoroutine(MyTestFunc());
    }
}
```


**D老师写的版本**
```cs
// 迭代器状态机控制
// ----------------------------
// yield return 类型        | 对应处理方式
// ----------------------------
// null                    | 下一帧继续
// WaitForSeconds(秒数)    | 计时等待
// WaitForEndOfFrame       | 帧结束时继续
// 其他对象                | 特殊处理（本例暂不实现）


using System.Collections;
using UnityEngine;

public class CustomCoroutineRunner : MonoBehaviour
{
    // 自定义协程数据类
    private class CoroutineTask
    {
        public IEnumerator Routine; // 迭代器函数
        public object CurrentYield; // 当前等待条件
        public float Timer;         // 计时器
    }

    private List<CoroutineTask> activeCoroutines = new List<CoroutineTask>();

    // 启动协程
    public void StartCustomCoroutine(IEnumerator routine)
    {
        var task = new CoroutineTask
        {
            Routine = routine,
            CurrentYield = null,
            Timer = 0
        };
        activeCoroutines.Add(task);
    }

    void Update()
    {
        // 倒序遍历允许安全移除
        for (int i = activeCoroutines.Count - 1; i >= 0; i--)
        {
            var task = activeCoroutines[i];
            
            // 处理等待条件
            bool canContinue = false;
            
            if (task.CurrentYield == null)
            {
                canContinue = true;
            }
            else if (task.CurrentYield is WaitForSeconds waitForSeconds)
            {
                task.Timer += Time.deltaTime;
                if (task.Timer >= waitForSeconds.m_Seconds)
                {
                    canContinue = true;
                    task.Timer = 0;
                }
            }
            
            // 执行迭代器下一步
            if (canContinue)
            {
                if (task.Routine.MoveNext())
                {
                    // 更新下一个yield return的条件
                    task.CurrentYield = task.Routine.Current;
                }
                else
                {
                    activeCoroutines.RemoveAt(i);
                }
            }
        }
    }
}


// 使用示例 TestScript.cs
public class TestScript : MonoBehaviour
{
    void Start()
    {
        var runner = gameObject.AddComponent<CustomCoroutineRunner>();
        runner.StartCustomCoroutine(MyCustomCoroutine());
    }

    IEnumerator MyCustomCoroutine()
    {
        Debug.Log("步骤1：" + Time.time);
        yield return new WaitForSeconds(1); // 等待1秒
        
        Debug.Log("步骤2：" + Time.time);
        yield return new WaitForSeconds(1); // 再等1秒
        
        Debug.Log("最终步骤：" + Time.time);
    }
}


```