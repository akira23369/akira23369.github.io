---
title: 10.协同程序
date: 2025-03-02 19:15:55
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
---

# 简单回顾csharp中的多线程
{% post_link csharp多线程 %}

# Unity是否支持多线程？
1. Unity是支持多线程的，只是新开线程无法访问Unity相关场景上对象的内容。例如this.transform（必须在主线程调用）。
2. 注意：**Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑**
3. 在Unity中，不会开启多线程访问Unity相关。**当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。** 当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。

```cs
//新线程
Thread newThread;

//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西
Queue<Vector3> queue = new Queue<Vector3>();

//副线程可能也要拿主线程的数据用来判断做逻辑
Queue<Vector3> queue2 = new Queue<Vector3>();

void Start()
{
    //首先要明确一点
    //Unity是支持多线程的
    //只是新开线程无法访问Unity相关对象的内容
    
    //引用System.Threading命名空间
    newThread = new Thread(newThreadLogic);
    newThread.Start();
    
    //注意：
    //Unity中的多线程 要记住关闭
    //不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容
    //可以在OnDestroy执行关闭线程逻辑
}

void Update()
{
    //在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用
    if (queue.Count > 0)
    {
        //取出位置
        this.transform.position = queue.Dequeue();
    }
}

//新线程逻辑
private void newThreadLogic()
{
    while (true)
    {
        Thread.Sleep(1000);
        print("新线程逻辑 每隔一秒的打印");
        
        //我们在Unity中，不会开启多线程访问Unity相关
        //当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿
        //这时就可以开启多线程用于A星寻路算法，网络收发相关
        //当算好了结果或者收到了消息过后，放在公共的内存区域
        //主线程判断判断公共的内存区域有没有想要的对象，拿来使用
        
        //这句代码会报错 不能在副线程控制Unity相关
        //UnityException: get_transform can only be called from the main thread.
        //this.transform.Translate(Vector3.forward * Time.deltaTime);
        
        //相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中
        //用Unity的随机数都不能用 用C#里的随机数
        System.Random r = new System.Random();
        queue.Enqueue(new Vector3(r.Next(-10, 10), r.Next(-10, 10), r.Next(-10, 10)));
        
    }
}

private void OnDestroy()
{
    //关闭线程
    newThread.Abort();
    //关闭线程后置空
    newThread = null;
}

```

# **什么是协程？**
协程（Coroutine）是Unity中一种特殊的函数，可以**分步执行代码**并**跨越多帧运行**。它通过`yield`关键字暂停执行，并在特定条件（如等待时间结束、帧结束等）满足后继续执行。
- 它是“假”的多线程，它不是多线程
- **它的本质是{% post_link csharp迭代器 迭代器%}**

- C#的{% post_link csharp迭代器 迭代器%}**函数”分步执行”的特点
- 加上 Unity自己定义的一些协程调度逻辑
- 实现的一套分时执行函数的规则

#  **协程的主要作用**
将代码分时执行，不卡主线程
简单理解，是把可能会让主线程卡顿的耗时的逻辑**分时分步**执行
- **处理延时操作**：例如等待1秒后执行代码。
- **分步执行任务**：将复杂任务拆分成多个步骤，避免卡顿。
- **按帧控制逻辑**：逐帧处理动画、AI行为等。
- **异步加载资源**：分批加载资源防止主线程阻塞。
- **异步下载文件**
- **场景异步加载**
- **批量创建时防止卡顿**

# **主要使用场景**
- 角色技能冷却倒计时。
- 分批次加载大型场景或资源。
- 实现平滑的动画过渡（如物体渐隐）。
- 等待网络请求返回后更新UI。

# 协同程序和线程的区别
- 新开一个线程是独立的一个管道，与主线程并行执行。
- 新开一个协程是在原线程之上开启，进行**逻辑分时分步执行**。

# {% post_link csharp迭代器#yield-return-语法糖 回顾yield return相关知识点%}

# **协程的使用方法**
**基本规则**：
1. 协程方法的返回类型必须是 `IEnumerator`。
2. 使用 `yield return` 指定暂停条件（如 `new WaitForSeconds(2)`）。
3. 通过 `StartCoroutine()` 启动协程。

## **启动协程**：
**基本语法：**
```cs
public class CoroutineExample : MonoBehaviour
{
    void Start()
    {
        // 启动协程
        StartCoroutine(SimpleCoroutine());
    }

    IEnumerator MyCoroutine(string hello) {
        Debug.Log($"协程开始，say hello\n{hello}");
        yield return new WaitForSeconds(1); // 暂停1秒
        Debug.Log("1秒后执行");
        yield return new WaitForSeconds(2); // 再暂停2秒
        Debug.Log("又过了2秒");
    }
}
```

Unity 提供了多种内置的等待指令，可以直接在协程中使用：

| **指令**                    | **说明**                           | 指令满足之后在哪里执行                                |
| ------------------------- | -------------------------------- | ------------------------------------------ |
| `null 或者 数字`              | 等待到下一帧（等同 `yield return null`）   | `Update`和`LateUpdate`之间执行                  |
| `WaitForSeconds`          | 等待指定秒数（受`Time.timeScale`时间缩放影响）  | `Update`和`LateUpdate`之间执行                  |
| `WaitForSecondsRealtime`  | 等待指定秒数（不受`Time.timeScale`时间缩放影响） | `Update`之后                                 |
| `WaitForFixedUpdate`      | 等待到下一个 FixedUpdate               | 在`FixedUpdate`和碰撞检测相关函数之后执行                |
| `WaitForEndOfFrame`       | 等待到帧结束（截图功能）                     | 等待摄像机和GUI渲染完成后执行，在LateUpdate之后的渲染相关处理完毕后之后 |
| `WWW` 或 `UnityWebRequest` | 等待网络请求完成                         | `Update`之后                                 |

## 停止协程
```cs
// 停止单个协程
Coroutine coroutine = StartCoroutine(MyCoroutine());
StopCoroutine(coroutine);

// 停止所有协程
StopAllCoroutines();
```

# **协程的典型使用场景**
## **场景 1：延迟执行**
```cs
IEnumerator DelayedAction()
{
    yield return new WaitForSeconds(3);
    Debug.Log("3秒后执行爆炸效果");
    // 触发爆炸动画、音效等
}
```

## **场景 2：分帧处理大数据**
```cs
IEnumerator ProcessLargeData(List<Item> data)
{
    foreach (var item in data)
    {
        ProcessItem(item); // 处理单个数据
        yield return null; // 每帧处理一个，避免卡顿
    }
}
```

## **场景 3：按顺序执行多段逻辑**
```cs
IEnumerator DialogueSequence()
{
    ShowText("你好，旅行者！");
    yield return new WaitUntil(() => Input.GetKeyDown(KeyCode.Space)); // 等待玩家按空格
    ShowText("前方有危险...");
    yield return new WaitForSeconds(2);
    ShowText("准备好了吗？");
}
```

# 协程受对象和组件失活销毁的影响
- 协程开启后：
    - 组件或物体销毁，物体失活，则协程不再执行。
    - 组件失活时，协程仍然执行。

# 练习
## **协程实现的计秒器**
```cs
using UnityEngine;
using UnityEngine.UI;

public class Timer : MonoBehaviour
{
    public Text timerText; // 关联UI文本
    private float elapsedTime;
    private bool isRunning;

    void Start()
    {
        StartCoroutine(CountSeconds());
    }

    IEnumerator CountSeconds()
    {
        isRunning = true;
        while (isRunning)
        {
            elapsedTime += Time.deltaTime;
            // 显示格式化为整数秒（或保留1位小数）
            timerText.text = "Time: " + elapsedTime.ToString("F1"); 
            yield return null; // 每帧更新
        }
    }

    // 停止计时（可选）
    public void StopTimer()
    {
        isRunning = false;
    }
}
```

## **分帧创建10万立方体（无卡顿）**
原本 1帧 创建 10万个
现在 1帧 创建 cubesPerFrame 个

比较蠢的做法
```cs
for (int i = 0; i < 100000; i++)
{
    GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
    obj.transform.position = new Vector3(Random.Range(-100, 100), Random.Range(-100, 100), Random.Range(-100, 100));
}
```

```cs
using UnityEngine;

public class CubeSpawner : MonoBehaviour
{
    public GameObject cubePrefab; // 立方体预制体
    public int totalCubes = 100000;
    public int cubesPerFrame = 500; // 每帧生成的数量

    void Start()
    {
        StartCoroutine(SpawnCubes());
    }

    IEnumerator SpawnCubes()
    {
        int created = 0;
        while (created < totalCubes)
        {
            for (int i = 0; i < cubesPerFrame; i++)
            {
                if (created >= totalCubes) break;
                // 随机生成位置（范围可调）
                Vector3 pos = new Vector3(
                    Random.Range(-50f, 50f),
                    Random.Range(-50f, 50f),
                    Random.Range(-50f, 50f)
                );
                Instantiate(cubePrefab, pos, Quaternion.identity);
                created++;
            }
            yield return null; // 每帧分批生成
        }
        Debug.Log("生成完成");
    }
}
```