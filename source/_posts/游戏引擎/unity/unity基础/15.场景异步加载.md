---
title: 15.场景异步加载
date: 2025-03-04 19:11:28
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
---

# {% post_link 1.场景切换和游戏退出 回顾场景同步切换%}
**场景同步切换的缺点**
- 在切换场景时，Unity会删除当前场景上所有对象，并且去加载下一个场景的相关信息。
- 如果当前场景对象过多或者下一个场景对象过多，这个过程会非常耗时，会让玩家感受到卡顿。
- 所以异步切换就是来解决该问题的。

回顾一下`{% post_link 13.Resources异步加载#ResourceRequest的父类AsyncOperation AsyncOperation%}`

# 通过事件回调函数 异步加载
```cs
void Start()
{
    // 在后台异步加载场景。
    AsyncOperation asyncOperation = SceneManager.LoadSceneAsync("场景异步加载");

    asyncOperation.completed += (a) =>
    {
        print("加载结束");
    };
    asyncOperation.completed += AsynLoadOver;
    // 注意：
    // 直接用法这种方法异步加载场景的话，就算过场景脚本或脚本依附的对象被销毁，异步加载的回调也能执行
    // 因为异步加载的回调被存到事件中了
}


// 异步加载场景回调
private void AsynLoadOver(AsyncOperation ao)
{
    print("AsynLoadOver");
}

```

# 通过协程 异步加载
协程异步加载可以在过场景的时候做其他逻辑~~

需要注意的是，加载场景会把当前场景上没有特别处理的对象都删除了, {% post_link 10.协同程序#协程受对象和组件失活销毁的影响 %}，事件回调函数则不会有这个问题，因为函数被存着，垃圾回收不了
所以，协程中的部分逻辑可能是执行不了的
因为过场景会把脚本或者脚本依附的对象都销毁了
解决思路：让处理场景加载的脚本依附的对象过场景时不被移除`DontDestroyOnLoad(this.gameObject)`
```cs
void Start()
{
    // 让该脚本依附的对象过场景时不会被移除，这样脚本就不被移除，否则协程后面的逻辑会失效
    DontDestroyOnLoad(this.gameObject);
    // 协程后面的逻辑会失效是因为Unity的协程管理器的机制，只要依附的对象被删除或失活或者脚本被删除，协程就会失效，我们改不了这个机制

    StartCoroutine(CoroutineAsynLoadScene("Lesson21_场景异步加载Test"));
}


// 异步加载场景协程函数
IEnumerator CoroutineAsynLoadScene(string name)
{
    // 异步加载场景
    AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name);

    // 协程的好处是，在异步加载场景时，我可以在加载的同时做一些别的逻辑
    print("异步加载过程中打印的信息");

    // 比如，我们可以在异步加载过程中去更新进度条，一般有两种做法
    // 更新进度条第一种做法就是利用场景异步加载的进度去更新，但是不是特别准确，一般也不会直接用
    while (!asyncOperation.isDone)
    {
        print(asyncOperation.progress);
        yield return null;
    }

    // 离开循环后就会认为场景加载结束
    // 可以把进度条顶满，然后隐藏进度条

    // Unity内部的协程协调器发现是异步加载类型的返回对象，那么就会等待
    // 等待异步加载结束后才会继续执行迭代器函数中后面的步骤
    yield return asyncOperation;
    print("异步加载结束后打印的信息");

    // 更新进度条第二种做法就是根据你游戏的规则自己定义进度条变化的条件
    // 比如：当场景加载结束更新20%进度
    // 接着去加载场景中的其他信息，比如动态加载怪物
    // 这时进度条再更新20%
    // 动态加载场景模型，这时就认为加载结束了，进度条顶满，隐藏进度条
}

```


- **场景异步加载** 和 **资源异步加载** 一样，有两种方式
    - 通过事件回调函数
    - 协程异步加载
- 他们的优缺点表现和资源异步加载也是一样的
    - 事件回调函数
        - 优点：写法简单，逻辑清晰
        - 缺点：只能加载完场景做一些事情，不能再加载过程中处理逻辑
    - 协程异步加载
        - 优点：可以在加载过程中处理逻辑，比如进度条更新等
        - 缺点：写法较为麻烦，要通过协程


# 练习
**请写一个简单的场景管理器，提供统一的方法给外部用于场景异步切换，外部可以传入委托用于当异步切换结束时执行某些逻辑**
和这道题类似 {% post_link 13.Resources异步加载#练习 Resources异步加载练习题%}
```cs
// 场景管理类 
public class SceneMgr
{

    private static SceneMgr instance = new SceneMgr();
        
    public static SceneMgr Instance => instance;
    
    private SceneMgr() { }
    
    // 加载场景的方法，需要传入目标场景的名称和一个UnityAction类型的委托参数
    public void LoadScene(string name, UnityAction action)
    {
        AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name);
        
        asyncOperation.completed += (aO) =>
        {
            action();
        };
    }
}

```

使用
```cs
SceneMgr.Instance.LoadScene("场景异步加载", () => {
    print("加载结束");
});

// 没封装写法
AsyncOperation ao = SceneManager.LoadSceneAsync(name);
ao.completed += (ao) =>
{
    // 场景加载结束逻辑
}
```