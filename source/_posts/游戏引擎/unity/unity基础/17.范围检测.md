---
title: 17.范围检测
date: 2025-03-05 14:24:21
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
  - 物理系统
  - 核心系统
---

# 回顾物理系统之碰撞检测 
**碰撞产生的必要条件**
- 至少一个物体有刚体
- 两个物体都必须有碰撞器
**碰撞和触发**
- 碰撞会产生实际的物理效果
- 触发看起来不会产生碰撞，但是可以通过函数监听触发
- 碰撞检测主要用于实体物体之间产生物理效果时使用

# 什么是范围检测
游戏中瞬时的攻击范围判断一般会使用范围检测
举例：
玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害
玩家攻击，在前方1米圆形范围内对象都受到伤害
类似这种并没有实体物体，只想要检测在指定某一范围是否让敌方受到伤害时，便可以使用范围判断
在指定位置进行范围判断，我们可以得到处于指定范围内的对象
目的是对对象进行处理，比如受伤、减血等等


# LayerMask层级相关知识补充
1. Unity 顶部菜单 → `Edit` → `Project Settings` → `Tags and Layers`
2. 在 `Layers` 列表中添加/修改层级名称（如 "Enemy", "Player"）

`LayerMask.NameToLayer()`方法 传入层级名字返回层级索引
```cs
print(LayerMask.NameToLayer("UI")); // 5
```

**多层级组合检测**
```cs
// 同时检测 Enemy 和 NPC 层
LayerMask combinedMask = LayerMask.GetMask("Enemy", "NPC"); 

// 等效位运算写法
LayerMask combinedMask = (1 << LayerMask.NameToLayer("Enemy")) | (1 << LayerMask.NameToLayer("NPC")); 
```

**排除特定层级**
```cs
// 检测除了 Player 之外的所有层级
LayerMask mask = ~LayerMask.GetMask("Player");

// 射线检测排除自身层
RaycastHit hit;
int selfLayer = gameObject.layer;
LayerMask raycastMask = ~(1 << selfLayer);

if(Physics.Raycast(transform.position, transform.forward, out hit, 100f, raycastMask)) {
    // 检测到非自身层的物体
}

```


# 如何进行范围检测
**范围检测必备条件**：想要被范围检测到的对象必须具备碰撞器
**范围检测注意点：**
- 范围检测相关API只有当执行该句代码时进行一次范围检测，它是瞬时的
- 范围检测相关API并不会真正产生一个碰撞器，只是碰撞判断计算而已


# 范围检测API
## Physics.OverlapBox方法 盒状范围检测
查找与给定盒体接触或位于盒体内部的所有碰撞体。
**返回值：** 返回该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息）
**参数：**
- 立方体中心点
- 立方体三边大小，构成立方体的**长宽高的一半**（传入(1,1,1)，立方体的长宽高(2,2,2)）
- 立方体角度，传入四元数
- 检测指定层级（不填检测所有层）
- 是否忽略触发器，**UseGlobal**-使用全局设置， **Collide**-检测触发器， **Ignore**-忽略触发器，不填默认使用UseGlobal  （全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置）

```cs
[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up),
                    1 << LayerMask.NameToLayer("UI") |
                    1 << LayerMask.NameToLayer("Default"), QueryTriggerInteraction.UseGlobal);
```

另一个盒壮范围检测，返回值是检测到的Collider的个数
```cs
if (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) { // 处理碰撞器 }
```

## Physics.OverlapSphere方法 球形范围检测
**返回值：** 返回该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息）
**参数：**
- 球中心点
- 半径
- 检测指定层级（不填检测所有层）
- 是否忽略触发器，**UseGlobal**-使用全局设置， **Collide**-检测触发器， **Ignore**-忽略触发器
```cs
colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 << LayerMask.NameToLayer("Default"));
```

另一个球形范围检测，返回值是检测到的Collider的个数
```cs
if (Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0) { }
```

## Physics.OverlapCapsule方法 胶囊范围检测
**返回值：** 返回该范围内的碰撞器数组
**参数：**
- 半圆1中心点 
- 半圆2中心点 （前两个参数决定胶囊中间的圆柱体情况）
- 上下两个半球体半径
- 检测指定层级（不填检测所有层）
- 是否忽略触发器，**UseGlobal**-使用全局设置， **Collide**-检测触发器， **Ignore**-忽略触发器
```cs
colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 << LayerMask.NameToLayer("UI"), QueryTriggerInteraction.UseGlobal);
```

返回值是检测到的Collider的个数
```cs
if (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders) != 0) { }
```

# 练习
**世界坐标原点有一个立方体，键盘WASD键可以控制其前后移动和旋转,请结合所学知识实现,按J键在立方体面朝向前方1米处进行立方体范围检测,按K键在立方体前面5米范围内进行胶囊范围检测,按L键以立方体脚下为原点，半径10米内进行球形范围检测**

```cs
void Update()
{
    // 位移
    this.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis("Vertical"));

    // 旋转
    this.transform.Rotate(Vector3.up, Input.GetAxis("Horizontal") * roundSpeed * Time.deltaTime);

    // 按下J键
    if (Input.GetKeyDown(KeyCode.J))
    {
        Collider[] colliders = Physics.OverlapBox(
            this.transform.position + this.transform.forward, 
            Vector3.one * 0.5f, 
            this.transform.rotation, //创建出来的立方体要保持和当前立方体相同的旋转，否则不是刚好在前面
            1 << LayerMask.NameToLayer("Monster")
        );
        for (int i = 0; i < colliders.Length; i++)
        {
            print("盒子 物体受伤" + colliders[i].gameObject.name);
        }
    }

    // 按下K
    //可以理解为往前面吐火 或者刺出来长枪
    if (Input.GetKeyDown(KeyCode.K))
    {
        Collider[] colliders = Physics.OverlapCapsule(
            this.transform.position, 
            this.transform.position + this.transform.forward * 5, 
            0.5f, 
            1 << LayerMask.NameToLayer("Monster")
        );
        for (int i = 0; i < colliders.Length; i++)
        {
            print("胶囊 物体受伤" + colliders[i].gameObject.name);
        }
    }

    // 按下L键
    //比如有些时候范围内加buff或者震开敌人
    if (Input.GetKeyDown(KeyCode.L))
    {
        Collider[] colliders = Physics.OverlapSphere(
            this.transform.position, 
            10, 
            1 << LayerMask.NameToLayer("Monster")
        );
        for (int i = 0; i < colliders.Length; i++)
        {
            print("球 物体受伤" + colliders[i].gameObject.name);
        }
    }
}
```