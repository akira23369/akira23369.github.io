---
title: 13.Resources异步加载
date: 2025-03-04 16:25:58
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
---

# **Resources 异步加载是什么？**
**问题背景**：
同步加载（`Resources.Load`）大资源时，硬盘读取到内存的资源的越大，耗时操作会**阻塞主线程**，导致游戏卡顿、掉帧。

**异步加载原理**：Unity 内部会将资源加载任务分配到其他线程处理，主线程继续执行游戏逻辑，加载完成后通知主线程使用资源。
**注意**：虽然逻辑上是“多线程”，但 Unity 主线程仍需每帧检查加载状态，因此**要等待加载完毕(至少要等1帧)** 才能获取资源。


**两种实现方式**：
**事件监听**：简单直接，适合单一资源加载。
**协程**：灵活控制，适合复杂加载逻辑。

# **通过事件监听完成回调**
使用 `ResourceRequest` 的 `completed` 事件监听加载完成。
```cs
using UnityEngine;

public class AsyncLoadExample : MonoBehaviour
{
    void Start()
    {
        // 开始异步加载
        ResourceRequest request = Resources.LoadAsync<GameObject>("Prefabs/Dragon");
        // 注册完成事件
        request.completed += OnLoadCompleted;
    }

    // 加载完成后的回调
    private void OnLoadCompleted(AsyncOperation operation)
    {
        ResourceRequest request = operation as ResourceRequest;
        GameObject dragonPrefab = request.asset as GameObject;
        Instantiate(dragonPrefab);
    }
}
```

# **通过{% post_link 10.协同程序 协程 %}等待加载完成**
利用协程的 `yield return` 逐帧检查加载进度。

## `ResourceRequest`的父类`AsyncOperation`：
它代表一个异步操作。当你在 Unity 中执行一些可能会阻塞主线程的任务时，比如加载场景、加载资源等，Unity 会返回一个 `AsyncOperation` 对象，通过这个对象你可以监控异步操作的进度，以及在操作完成时执行特定的代码。

**常用属性**：
**`isDone`**：这是一个布尔类型的属性，用于表示异步操作是否已经完成。
**`progress`**：这是一个浮点类型的属性，范围从 0 到 1，表示异步操作的进度。0 表示操作还未开始，1 表示操作已经完成。
**`allowSceneActivation`**：在使用 `SceneManager.LoadSceneAsync` 加载场景时，这个属性非常有用。当 `allowSceneActivation` 为 `false` 时，场景加载到 90% 就会暂停，直到将其设置为 `true` 才会继续加载并激活场景。

**`completed`**：这是一个`Action<AsyncOperation>`事件，当异步操作完成时会触发该事件。你可以为这个事件添加一个委托，以便在操作完成时执行特定的代码。
```cs
public class ResourceRequest : AsyncOperation
{
    public Object asset { get; }   // 加载完成的资源
    public float progress { get; } // 加载进度(0.0~1.0)
    public bool isDone { get; }    // 是否完成加载
}
```

## **简单加载案例**
```cs
IEnumerator LoadCharacter()
{
    ResourceRequest request = Resources.LoadAsync<GameObject>("Characters/Player");
    yield return request; // 等待加载完成
    
    if (request.asset != null)
    {
        Instantiate(request.asset);
    }
    else
    {
        Debug.LogError("加载资源失败");
    }
}
```

## **带进度条的加载**
```cs
IEnumerator LoadWithProgress(Image progressBar)
{
    ResourceRequest request = Resources.LoadAsync<Texture2D>("Textures/Background");
    
    while (!request.isDone)
    {
        progressBar.fillAmount = request.progress;
        yield return null; // 每帧更新进度
    }
    
    if (request.asset != null)
    {
        GetComponent<Renderer>().material.mainTexture = request.asset as Texture2D;
    }
}
```

## **批量异步加载**
```cs
IEnumerator LoadMultipleResources()
{
    string[] paths = { "Audio/Music", "Prefabs/Enemies", "Materials/Weapons" };
    
    foreach (var path in paths)
    {
        ResourceRequest request = Resources.LoadAsync(path);
        yield return request;
        
        // 资源处理逻辑
        HandleLoadedAsset(request.asset);
        
        // 每加载完一个资源清理一次内存
        Resources.UnloadUnusedAssets();
    }
}
```

## **带优先级的加载队列**
```cs
IEnumerator PriorityLoading()
{
    // 第一步：先加载核心资源
    // StartCoroutine 用于启动一个协程，这里启动了 LoadEssentialResources 协程
    // yield return 会暂停当前协程的执行，直到 LoadEssentialResources 协程执行完毕
    yield return StartCoroutine(LoadEssentialResources());

    // 第二步：同时加载多个次要资源

    Coroutine[] backgroundLoads = {
        // UI 协程
        StartCoroutine(LoadUIElements()),
        // 环境纹理 协程
        StartCoroutine(LoadEnvironmentTextures())
    };

    // 第三步：等待所有次要资源加载完成
    // WaitUntil 是一个协程等待指令，它会暂停当前协程的执行，直到传入的委托返回 true
    // 这里使用 LINQ 的 All 方法来检查 backgroundLoads 数组中的所有协程是否都已经停止运行
    // IsCoroutineRunning 是一个自定义方法，用于判断一个协程是否正在运行
    yield return new WaitUntil(() => 
        backgroundLoads.All(c => !IsCoroutineRunning(c)));
}

// 这是一个自定义方法，用于检查一个协程是否正在运行
// 注意：Unity 本身没有直接提供检查协程是否运行的方法，这里只是一个示例实现
bool IsCoroutineRunning(Coroutine coroutine)
{
    // 实际实现需要根据具体情况来判断，这里简单返回 false 作为示例
    return false;
}

// 加载核心资源
IEnumerator LoadEssentialResources()
{
    // 这里可以添加具体的核心资源加载逻辑
    yield return null;
}

// 加载 UI 元素
IEnumerator LoadUIElements()
{
    // 这里可以添加具体的 UI 元素加载逻辑
    yield return null;
}

// 加载环境纹理
IEnumerator LoadEnvironmentTextures()
{
    // 这里可以添加具体的环境纹理加载逻辑
    yield return null;
}
```


# 练习
**请写一个简单的资源管理器，提供统一的方法给外部用于资源异步加载，外部可以传入委托用于当资源加载结束时使用资源**
注意到：**每次加载资源都在重复做两件事**：“这些重复代码能不能抽出来？”
1. 调用 `Resources.LoadAsync`
2. 处理 `completed` 事件并转换类型


- 识别重复代码中的「稳定部分」和「变化部分」
- 例：`LoadAsync`和回调处理是稳定部分，资源类型和路径是变化部分

**封装触发点：**  
当你第三次写出几乎相同的代码时，脑海中应该浮现：
> “这些加载操作的结构完全一样，只是**资源类型**、**路径**和**回调内容**不同。如果能写个方法把相同的部分抽出来，只要传递这三个变量就好了！”
这正是 `LoadRes<T>` 方法的诞生过程！

```cs
public class ResourcesMgr 
{
    private static ResourcesMgr _instance;
    public static ResourcesMgr Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new ResourcesMgr();
            }
            return _instance;
        }
    }
    private ResourcesMgr() { }

    // 自己封装的资源异步加载
    // T是要加载的资源类型 可以加载任意类型的Unity资源（如GameObject、Texture、AudioClip等）
    // 注意LoadAsync的T有一个约束,必须是Object的子类
    public void LoadRes<T>(string path, System.Action<T> callback) where T : Object
    {
        ResourceRequest rq = Resources.LoadAsync<T>(path);
        // 加载完成后的回调, a是 AsyncOperation 类型，需要转换为 ResourceRequest 
        rq.completed += (a) =>
        {
            // 执行外面传进来的回调逻辑，callback的函数参数是
            callback((a as ResourceRequest).asset as T);
        };
    }
}
```

**使用**
```cs
// 加载预制件
ResourcesMgr.Instance.LoadRes<GameObject>("Prefabs/Player", (prefab) => {
    Instantiate(prefab); // 实例化玩家
});

// 加载贴图
ResourcesMgr.Instance.LoadRes<Texture2D>("Textures/Icon", (texture) => {
    GetComponent<Renderer>().material.mainTexture = texture;
});
```

**对比着没有封装的写法**
```cs
// 没有使用管理器的情况
ResourceRequest rq = Resources.LoadAsync<GameObject>("Prefabs/Player");
rq.completed += (a) => {
    GameObject prefab = (a as ResourceRequest).asset as GameObject;
    Instantiate(prefab);
};
```

