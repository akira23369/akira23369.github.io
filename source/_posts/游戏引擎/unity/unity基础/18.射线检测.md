---
title: 18.射线检测
date: 2025-03-05 15:40:00
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
  - 物理系统
  - 核心系统
---

# 什么是射线检测
- 物理系统中
- 目前我们学习的物体相交判断
- **碰撞检测** - 必备条件 - 1刚体 2碰撞器
- **范围检测** - 必备条件 - 碰撞器

如果想要做这样的碰撞检测呢？
- 鼠标选择场景上一物体
- FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）
- 等等 需要判断一条线和物体的碰撞情况

射线检测 就是来解决这些问题的
- 它可以在指定点发射一个指定方向的射线
- 判断该射线与哪些碰撞器相交，得到对应对象
- 结合物理系统进行射线碰撞判断


注意：
- 距离、层级两个参数都是int类型
- 当我们传入参数时，一定要明确传入的参数代表的是距离还是层级


# Ray射线类
一条起点为坐标(1,0,0) 方向为世界坐标Z轴正方向的射线
**参数**：
- origin 起点
- direction 方向
```cs
Ray ray2 = new Ray(Vector3.right, Vector3.forward);
```

# Camera.ScreenPointToRay方法 摄像机发射出的射线
- 返回从摄像机通过屏幕点的光线
- 得到一条从屏幕位置作为起点，摄像机视口方向为方向的射线
```cs
Ray ray3 = Camera.main.ScreenPointToRay(Input.mousePosition);
```


# Physics.Raycast方法
## 是否碰撞到对象
```cs
// 返回值：bool 是否碰撞到对象
//参数一：射线 
//参数二: 检测的最大距离 超出这个距离不检测 
//参数三：检测指定层级（不填检测所有层） 
//参数四：是否忽略触发器
if (Physics.Raycast(ray, 1000, 1 << LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal)) { print("碰撞到了对象"); }
```

## 获取相交单个物体信息 RaycastHit结构体
**常用属性**：
`collider`
- **类型**：`Collider`
- **说明**：该属性返回与射线相交的碰撞体对象。通过这个属性，你可以访问碰撞体所在的游戏对象及其相关组件。

`point`
- **类型**：`Vector3`
- **说明**：该属性表示射线与碰撞体相交的点的世界坐标。在很多场景中，比如在碰撞点生成特效，被子弹打中飙血，墙壁被打贴图

`distance`
- **类型**：`float`
- **说明**：该属性表示从射线的起点到碰撞点的距离。可以用于判断射线与物体相交的远近。

`normal`
- **类型**：`Vector3`
- **说明**：该属性表示碰撞点处碰撞体表面的法线向量。法线向量在很多场景中都有重要作用，比如反射效果、物体表面的朝向，射击游戏特效计算相关等。

`transform`
- **类型**：`Transform`
- **说明**：该属性返回与射线相交的碰撞体所附着的游戏对象的 `Transform` 组件。

```cs
RaycastHit raycastHitInfo;
//返回值：bool 是否碰撞到对象
//参数一：射线
//参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中
//参数三：距离
//参数四：检测指定层级（不填检测所有层）
//参数五：是否忽略触发器 UseGlobal-使用全局设置 
if (Physics.Raycast(ray4, out raycastHitInfo, 1000, 1 << LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal))
{
    print("碰撞到了物体 得到了信息");

    print("碰撞到物体的名字" + raycastHitInfo.collider.gameObject.name);

    print(raycastHitInfo.point);

    print(raycastHitInfo.normal);

    print(raycastHitInfo.transform.position);

    print(raycastHitInfo.distance);

}
```

## 获取相交多个物体信息 `RaycastHit[]`
```cs
//返回值：RaycastHit[] 碰撞到对象
//参数一：射线
//参数二：距离
//参数三：检测指定层级（不填检测所有层）
//参数四：是否忽略触发器
//Physics.RaycastAll方法传入RaycastHit数组对象可以得到多个碰到的对象
RaycastHit[] raycastHitInfos = Physics.RaycastAll(ray4, 1000, 1 << LayerMask.NameToLayer("Monster"), QueryTriggerInteraction.UseGlobal);
for (int i = 0; i < raycastHitInfos.Length; i++)
{
    print("碰到的所有物体 名字分别是" + raycastHitInfos[i].collider.gameObject.name);
}
```

# 练习
## 子弹打墙
实现鼠标点击场景上一面墙，在点击的位置创建子弹特效和弹孔

```cs
void Update()
{
    // 将鼠标在屏幕上的位置通过主相机转换为世界坐标系中的一条视线射线并赋值给 ray1。
    Ray ray1 = Camera.main.ScreenPointToRay(Input.mousePosition);

    // 通过 Debug.DrawRay 方法可将检测到的射线绘制出来以便调试查看（仅在编辑模式下生效）。
    Debug.DrawRay(ray1.origin, ray1.direction);

    if (Input.GetMouseButtonDown(0))
    {
        if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out info, 1000, 1 << LayerMask.NameToLayer("Monster")))
        {
            GameObject obj = Instantiate(Resources.Load<GameObject>("Effect/HitEff"));

            // 设定打击特效在发生碰撞的物体前方偏移 0.2 米处
            obj.transform.position = info.point + info.normal * 0.2f;

            // 根据表面法线调整特效的朝向角度，以适应目标物体产生视觉效果。
            obj.transform.rotation = Quaternion.LookRotation(info.normal);

            Destroy(obj, 0.8f);

            // 特效 DDD 
            obj = Instantiate(Resources.Load<GameObject>("Effect/DDD"));

            obj.transform.position = info.point + info.normal * 0.2f;

            obj.transform.rotation = Quaternion.LookRotation(info.normal);
        }
    }
}

```

## 鼠标长按物体移动
场景上有一个平面，有一个立方体，当鼠标点击选中立方体时，长按鼠标左键 可以拖动立方体 在平面上移动，点击鼠标右键取消选中

注意：
- 想要让物体只在平面就和平面做射线检测
- 物体的中心点 和 平面的中心点 和 物体脚下
```cs
RaycastHit hit;

// 用于记录当前选中的对象的 Transform 组件。 
private Transform nowSel;

// 声明一个公共浮点型变量 offsetY，用于设定物体拖曳时的高度偏移量。 
public float offsetY;

// 射线检测获取要选中的物体, 然后让物体跟随鼠标移动

if (Input.GetMouseButtonDown(0))
{
    if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 
        100, 1 << LayerMask.NameToLayer("Player")))
    { 
        // 得到想要操作对象的transform
        nowSel = hit.transform;
    }
}

// 当前有选中的对象 并且是长按
if (nowSel != null && Input.GetMouseButton(0))
{
    if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 
        1000, 1 << LayerMask.NameToLayer("Floor")))
    {
        nowSel.position = hit.point + Vector3.up *offsetY;
    }
}

if (Input.GetMouseButtonDown(1))
{
    nowSel = null;
}
```
