---
title: 12.Resources同步加载
date: 2025-03-04 15:28:05
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础

---


# **Resources 资源动态加载的作用**
- **核心功能**：允许在运行时按需加载资源，避免将所有资源预先加载到内存中。
- 避免繁琐的拖曳操作
- **适用场景**：
    - 按需加载不常用的资源（如关卡特定素材）。
    - 动态替换资源（如角色换装）。
- **优点**：减少内存占用，提升启动速度。
- **缺点**：频繁加载可能引发卡顿，滥用会导致应用体积膨胀。



# **常用资源类型**
Resources 支持加载 Unity 支持的几乎所有资源类型，常见的有：
1. **预制体（Prefab）**：`.prefab`
2. **纹理（Texture）**：`.png`, `.jpg`
3. **音频（AudioClip）**：`.mp3`, `.wav`
4. **文本（TextAsset）**：`.txt`, `.json`,`.xml`,`.bytes`,`.html`,`.csv`
5. **材质（Material）**：`.mat`

预设体对象加载需要实例化，音效要关联，图片要使用，文本要打印
其它资源加载一般直接用。


# **资源同步加载 - 普通方法**
使用 `Resources.Load(string path)`，返回 `Object` 类型，需手动转换类型。
在一个工程当中， Resources可以有多个并放在任意的文件夹下， 通过API加载时候会自己去同名的Resources自己找
```cs
// 加载预制体，// 这里只是把预制体这个配置文件加载到内存, 还没实例化
GameObject prefab = Resources.Load("Prefabs/Enemy") as GameObject;
Instantiate(prefab);

// 加载纹理
Texture2D texture = Resources.Load("Textures/Icon") as Texture2D;
GetComponent<Renderer>().material.mainTexture = texture;

// 加载文本
TextAsset textAsset = Resources.Load("Configs/Data") as TextAsset;
Debug.Log(textAsset.text + " " + textAsset.bytes);


// 加载音效
public AudioSource audioSource;
Object obj3 = Resources.Load("Music/BKMusic");
//我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可
audioSource.clip = obj3 as AudioClip;
audioSource.Play();


// 加载图片
tex = Resources.Load("Tex/TestJPG") as Texture;
```

**问题：资源同名怎么办**
```cs
//Resources.Load加载同名资源时 无法准确加载出你想要的内容
//可以使用Load方法的重载，第二个参数传入加载的指定类型的资源
//加载指定类型的资源
tex = Resources.Load("Tex/TestJPG", typeof(Texture)) as Texture;
ta = Resources.Load("Tex/TestJPG", typeof(TextAsset)) as TextAsset;
print(ta.text);
```

# **资源同步加载 - 泛型方法**
使用 `Resources.Load<T>(string path)`，直接返回指定类型，无需强制转换。
```cs
// 加载预制体（直接指定类型）
GameObject prefab = Resources.Load<GameObject>("Prefabs/Enemy");
Instantiate(prefab);

// 加载音频
AudioClip clip = Resources.Load<AudioClip>("Audio/Explosion");
GetComponent<AudioSource>().PlayOneShot(clip);

// 加载材质
Material mat = Resources.Load<Material>("Materials/Glow");
GetComponent<Renderer>().material = mat;
```

# 练习
**请把之前{%post_link 8.Quaternion四元数计算#练习 四元数练习题%}四元数练习题中，发射散弹等相关逻辑改为动态加载资源并创建**

把子弹丢到Resources文件夹后，有两种改法
第一种是不在Inspector窗口拖拽Prefab，直接在Start()里Load，实例化的时候直接使用即可
```cs
// 直接在Start()里Load
private GameObject bullet;

void Start()
{
    bullet = Resources.Load<GameObject>("Bullet");
}
```

第二种是在实例化的时候每次都Resources.Load(“Bullet”)
注意：这样不会造成内存上的浪费，因为Unity加载好的资源放在缓存区，判断Load过了就不重新Load了，内存不会开销但是会造成**性能开销**
```cs
//声明发射类型枚举  
public enum E_FireType  
{  
    //单发  
    One,  
    //双发  
    Two,  
    //扇形  
    Three,  
    //环形  
    Round  
}  
  
public class Airplane : MonoBehaviour  
{  
    //声明发射类型变量   
    private E_FireType nowType = E_FireType.One;  
  
    //子弹  
    public GameObject bullet;  
  
    public int roundNum = 4;  
  
    void Update()  
    {  
        //Update内添加按按键切换发射类型逻辑  
        if (Input.GetKeyDown(KeyCode.Alpha1))  
        {  
            nowType = E_FireType.One;  
        }  
        else if (Input.GetKeyDown(KeyCode.Alpha2))  
        {  
            nowType = E_FireType.Two;  
        }  
        else if (Input.GetKeyDown(KeyCode.Alpha3))  
        {  
            nowType = E_FireType.Three;  
        }  
        else if (Input.GetKeyDown(KeyCode.Alpha4))  
        {  
            nowType = E_FireType.Round;  
        }  
  
        //Update内添加按按键发射子弹逻辑  
        if (Input.GetKeyDown(KeyCode.Space))  
        {  
            Fire();  
        }  
    }  
  
    //开火方法  
    private void Fire()  
    {  
        switch (nowType)  
        {  
            case E_FireType.One:  
                Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position, this.transform.rotation);  
                break;  
            case E_FireType.Two:  
                Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position - this.transform.right * 0.5f, this.transform.rotation);  
                Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position + this.transform.right * 0.5f, this.transform.rotation);  
                break;  
            case E_FireType.Three:  
                Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position, this.transform.rotation);  
                //左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加  
                Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position, this.transform.rotation * Quaternion.AngleAxis(-20, Vector3.up));  
                //右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加  
                Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position, this.transform.rotation * Quaternion.AngleAxis(20, Vector3.up));  
                break;  
            case E_FireType.Round:  
                float angle = 360 / roundNum;  
                for (int i = 0; i < roundNum; i++)  
                    //角度是当前偏移度数乘飞机自己的旋转  
                    Instantiate(Resources.Load<GameObject>("Bullet"), this.transform.position, this.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up));  
                break;  
        }  
    }  
}
```

