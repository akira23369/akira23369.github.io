---
title: 7.Quaternion四元数常用方法
date: 2025-03-02 11:00:47
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
  - 3D数学
---

![](7.Quaternion四元数常用方法/file-20250302110057184.png)

# 单位四元数
满足条件：`x² + y² + z² + w² = 1`
![](7.Quaternion四元数常用方法/file-20250302110228942.png)

```cs
// 单位四元数 [1, (0, 0, 0)]
 Quaternion i = Quaternion.identity;
 
 //Object的Instantiate方法有重载 第三个参数可以传入四元数角度 
 Instantiate(testCube, Vector3.zero, Quaternion.identity);
```

# 插值运算
![](../../../../../public/2025/03/02/游戏引擎/unity/unity基础/7.四元数常用方法/file-20250302110554680.png)

```cs
// 无限接近，先快后慢
A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);

// 匀速
time += Time.deltaTime; 
B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);
```

# 向量指向转四元数LookRotation
![](../../../../../public/2025/03/02/游戏引擎/unity/unity基础/7.四元数常用方法/file-20250302111627899.png)


```cs
public Transform target;
public float rotateSpeed = 2f;

void Update() {
    Vector3 dir = target.position - transform.position;
    Quaternion targetRot = Quaternion.LookRotation(dir);
    transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime);
}  
```

# 练习
## 为transform拓展方法实现LookAt
**使用{% post_link csharp拓展方法 拓展方法%} ，利用四元数的LookRotation方法，使transform实现LookAt的效果**
```cs
public static class Tools
{
    //自己写的看向目标的方法
    public static void MyLookAt(this Transform obj, Transform target)
    {
        //算出目标和自己的向量
        Vector3 vec = target.position - obj.position;
        //用LookRotation得到转向的四元数赋值给自己
        obj.transform.rotation = Quaternion.LookRotation(vec);
    }
}


void Update() { 
    //调用自己写的拓展方法看向B 
    lookA.MyLookAt(lookB); 
}
```

## 摄像机使用Slerp来缓慢看向玩家
```cs
// 当发现目标对象位置改变时
if (targetQ != Quaternion.LookRotation(target.position - this.transform.position))
{
    // 重新用目标的位置减去摄像机的位置计算出新的面朝向向量四元数
    targetQ = Quaternion.LookRotation(target.position - this.transform.position);
    // 清空累加时间 不然时间一直大于1 会一直盯着目标看 不能达到匀速旋转看向目标的效果
    roundTime = 0;
    // 重置摄像机开始旋转位置
    startQ = this.transform.rotation;
}

// 累加时间
roundTime += Time.deltaTime;

// 传入发现目标对象位置改变后定死的摄像机开始旋转位置，目标旋转位置，和累加的时间
this.transform.rotation = Quaternion.Slerp(startQ, targetQ, roundTime * roundSpeed);

```