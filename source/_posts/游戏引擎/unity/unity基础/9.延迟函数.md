---
title: 9.延迟函数
date: 2025-03-02 17:08:38
toc: true
categories:
  - 游戏引擎
  - unity
  - unity基础

tags:
  - 游戏引擎
  - unity
  - unity基础
---

# 什么是延迟函数
延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。
它是`MonoBehaviour`基类中实现好的方法。

# 延迟函数的使用
## Invoke方法 开启延迟函数
注意:
- 没法调用有参数的函数
- 必须是该脚本上申明的函数
- 可以用`DelayedFunction`间接调用到其它对象, 或者有参数的函数
- **只有挂载的脚本对象失活可以继续执行, 其它情况都会无法继续执行**

```cs
// 在time秒后调用methodName方法。 
// 参数一：函数名字符串 
// 参数二：延迟时间，秒为单位 
Invoke("DelayDoSomething", 1);
```

## InvokeRepeating方法 开启延迟重复执行函数
与`Invoke`类似，但可以设置重复调用的间隔时间。
参数2：第一次延迟的时间
参数3：以后每次延迟的时间
```csharp
void Start()
{
    InvokeRepeating("RepeatedFunction", 2.0f, 1.0f); // 延时2秒后每隔1秒调用一次RepeatedFunction方法
}

void RepeatedFunction()
{
    // 在这里写重复延时执行的代码
}
```

##  CancelInvoke 取消延时调用
```csharp
CancelInvoke("Fun");        // 只取消Fun，所有延迟执行Fun的都会没
CancelInvoke();             // 无参数取消所有延时函数
```


## IsInvoking方法 判断是否有延迟函数
```cs
// 是否有任何待处理的methodName调用？
// 不传入参数，判断该脚本上是否存在任何延迟函数
if (IsInvoking())
{
    print("存在延迟函数");
}
// 传入参数，判断该脚本上是否存在指定延迟函数
if (IsInvoking("DelayDoSomething"))
{
    print("存在延迟函数DelayDoSomething");
}
```

# 延迟函数受对象失活销毁影响
延迟函数在依附对象或者脚本失活时不受影响，但在对象销毁或者移除脚本时无法继续执行。
如果想在失活 或者 激活 的时候来执行延迟函数， 可以在{% post_link 9.生命周期函数 生命周期函数 %}`OnEnable`和`OnDisable`中做逻辑
```cs
private void OnEnable()
{
    // 对象激活的生命周期函数中，开启延迟（重复执行的延迟）
}

private void OnDisable()
{
    // 对象失活的生命周期函数中，停止延迟
}
```


# 练习
## 利用延时函数实现一个计秒器
```cs
// 使用延迟重复函数，一进来直接调用，然后每隔一秒调用，实现计时器
InvokeRepeating("DelayTimer", 0, 1);

// 直接执行函数 函数里面在写一个普通延迟函数每秒调用自己
DelayTimer2();

private void DelayTimer()
{
    print(time + "秒");
    ++time;
}

private void DelayTimer2()
{
    print(time + "秒");
    ++time;
    Invoke("DelayTimer2", 1);
}

```

## 请用两种方式延时销毁一个指定对象
一个只能销毁，一个销毁还可以写逻辑
```cs
// 通过Destroy来进行延迟销毁
Destroy(this.gameObject, 5);

// 延迟函数销毁，内部使用销毁逻辑，
// 包裹一层，相比于Destroy直接销毁，假如想有其他逻辑也可以写在延迟销毁函数中
Invoke("DelayDestroy", 5);

private void DelayDestroy()
{
    Destroy(this.gameObject);
}
```