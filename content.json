{"meta":{"title":"akiraの博客思密达","subtitle":"","description":"","author":"akira23369","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2025-02-06T20:57:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-02-06T20:57:21.000Z","updated":"2025-03-05T09:26:46.193Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-02-06T20:57:28.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2025-02-06T20:57:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"44.Spine骨骼动画代码控制","slug":"游戏引擎/unity/unity核心/44.Spine骨骼动画代码控制","date":"2025-03-19T14:07:12.000Z","updated":"2025-03-19T14:37:41.792Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/44.Spine骨骼动画代码控制/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/44.Spine%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"创建脚本挂载到spine对象上，声明一个SkeletonAnimation变量 1skeletonAnimation = this.GetComponent&lt;SkeletonAnimation&gt;(); 动画播放 方法一：直接改变SkeletonAnimation中的参数 SkeletonAnimation.AnimationName变量 设置动画名 SkeletonAnimation.loop变量 设置动画是否循环 12skeletonAnimation.loop = false;skeletonAnimation.AnimationName = &quot;jump&quot;; 方法二（建议）：使用SkeletonAnimation动画状态改变函数 SkeletonAnimation.AnimationState.SetAnimation方法 设置动画立即播放 SkeletonAnimation.AnimationState.AddAnimation方法 设置动画排队播放 Spine 动画系统里，动画轨道能够让你同时播放多个动画，并且可以对它们的混合、叠加等效果进行控制。每个轨道都可以独立播放一个动画，并且轨道之间可以相互影响，从而实现复杂的动画效果。 动画轨道索引：第一个参数指定了要在哪个轨道上播放动画。轨道索引从 0 开始计数，也就是 0 代表第一个轨道，1 代表第二个轨道，依此类推。 12345//马上播放 立即切换 传入 0 动画字符串 是否循环 skeletonAnimation.AnimationState.SetAnimation(0, &quot;jump&quot;, false);skeletonAnimation.AnimationState.SetAnimation(0, jumpName, false);//排队播放 等待上个动画播完切换 传入 0 动画字符串 是否循环 延迟时间skeletonAnimation.AnimationState.AddAnimation(0, &quot;walk&quot;, true, 0); 转向 SkeletonAnimation.skeleton.ScaleX变量 x的翻转 12// 翻转spine对象skeletonAnimation.skeleton.ScaleX = -1; 动画事件 SkeletonAnimation.AnimationState.Start事件 动画开始播放时的事件 12345//动画开始播放事件skeletonAnimation.AnimationState.Start += (t) =&gt;&#123; print( skeletonAnimation.AnimationName + &quot;动画开始播放&quot;);&#125;; SkeletonAnimation.AnimationState.End事件 动画中断或者清除时的事件 12345//动画被中断或者清除事件skeletonAnimation.AnimationState.End += (t) =&gt;&#123; print(skeletonAnimation.AnimationName + &quot;动画中断或者清除&quot;);&#125;; SkeletonAnimation.AnimationState.Complete事件 动画播放完成时的事件 12345//播放完成事件skeletonAnimation.AnimationState.Complete += (t) =&gt;&#123; print(skeletonAnimation.AnimationName + &quot;动画播放完成&quot;);&#125;; SkeletonAnimation.AnimationState.Event事件 自定义事件 123456//做动画时添加的自定义事件事件 这里的事件是美术在spine软件做动画的时候假如添加了的话才会调用的skeletonAnimation.AnimationState.Event += (t, e) =&gt;&#123; print(skeletonAnimation.AnimationName + &quot;自定义事件&quot;);&#125;; 便捷特性 动画特性 12345[SpineAnimation]public string jumpName;// 动画特性// 添加了这个特性之后外部可以下拉框选择动画 设置变量为动画名字 切换动画直接拿变量的值就行 就不用自己看动画什么名字了skeletonAnimation.AnimationState.SetAnimation(0, jumpName, false); 骨骼特性 和上面动画特性差不多用法 不然就要去debug窗口找 123[SpineBone]public string boneName;// 快捷得到骨骼的名字 就不用在其他组件或者Debug窗口里找了 插槽特性 123[SpineSlot]public string slotName;// 快捷得到插槽名 附件特性 123[SpineAttachment]public string attachmentName;// 快捷得到附件名 获取骨骼、设置插槽附件 SkeletonAnimation.skeleton.FindBone方法 获取骨骼 12// 获取骨骼Bone b = skeletonAnimation.skeleton.FindBone(boneName); SkeletonAnimation.skeleton.SetAttachment方法 设置插槽附件 12// 设置插槽附件 传入插槽名和附件名skeletonAnimation.skeleton.SetAttachment(slotName, attachmentName); 在UI中使用 将_SkeletonData文件拖入场景中","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"Spine","slug":"Spine","permalink":"http://example.com/tags/Spine/"}]},{"title":"43.Spine骨骼动画参数","slug":"游戏引擎/unity/unity核心/43.Spine骨骼动画参数","date":"2025-03-19T13:28:20.000Z","updated":"2025-03-19T14:04:19.377Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/43.Spine骨骼动画参数/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/43.Spine%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E5%8F%82%E6%95%B0/","excerpt":"","text":"_Atlas：材质和.atlas.txt文件（位置）的引用配置文件 _Material：材质文件 _SkeletonData：json（骨骼）和_Atlas资源的引用配置文件 Spine骨骼动画参数相关 点击放大思维导图 _SkeletonData骨骼数据文件 SkeletonData JSON:骨骼数据文件 （导入进Unity时会自动关联未导入前的json文件） Scale：缩放大小 （Spine里的100是unity中的1） Skeleton Data Modifiers*：骨骼数据修改器 Blend Mode Materizls*：混合模式材质 Apply Additive Material*：是否使用叠加材质 Additive Materials*：叠加材质 Multiply Materials*：相乘材质 Screen Materials*：屏幕材质 Atlas Assets：图集资源 （导入时会自动关联导入后生成的_Atalas文件） Mix Settings：混合设置 怎么理解？当两个动画在切换的时候过渡会产生的效果就可以在这里设置相关的时间 Animation State Data：动画状态数据 Default Mix Duration：默认混合持续时间 Add Custom Mix：添加自定义混合（可以指定某两个动画之间的持续时间） Preview：预览 Animations：动画 Setup Pose：设置姿势（还原到默认姿势） Create Animation Reference Assets：创建动画参考资源 （一般也没必要） Slots：插槽相关（一个部位有多张图片构成，可以在这预览） SkeletonMecanim：骨骼机制 Controller：关联动画控制器 SkeletonMecanim是SkeletonAnimation的替代品，它不是必须的 Skin：蒙皮选择 SkeletonAnimation骨骼动画脚本参数 SkeletonData Asset：关联的骨骼动画信息 Animation Name：当前播放的动画名 Loop：是否循环 Initial Skin*：初始蒙皮 美术在制作时可能有几套蒙皮 一般情况下只有一套 不需要修改 Time Scale：时间缩放，值越大动画播放的越快 Root Motion*：是否添加根运动的脚本一般情况下不添加 高级选项（一般用不着） Initial Flip X/Y：初始翻转X和Y Update When Invisible：不可见时是否更新 Nothing：不更新 Only Animation Status：仅动画状态 Only Event Timelines：仅事件 Everything Except Mesh：除了网格其它都更新 Full Update：更新所有 Use Single Submesh：使用单个子网格 Fix Draw Order：固定提取顺序 Immutable Triangles：不变三角形 Clear State On Disable：禁用时清楚状态 Separator Slot Names：分隔符插槽名称 Z Spacing：Z间距 Vertex Data：顶点数据 PMA Vertex Colors：PMA顶点颜色 Tint Black：淡黑色 Add Normals：添加法线 Solve Tangents：求解切线 Add Skeleton Utility：添加骨骼公共程序 Debug窗口也不常用 Show Bone Names：显示骨骼名字 Show Paths：显示路径 Show Shapes：显示形状 Show Constraints：显示约束条件 ScaleX/Y：XY的缩放 RGBA：颜色 Bone：骨骼 Show Bone Names：显示骨骼名字 Slots：插槽 Constraints：约束条件 Draw Order and Separators：提取顺序和分离器相关 Events：事件 Data Counts：数据数量 Bones：骨骼数量 Slots：插槽数量 Skins：蒙皮数量 Events：事件数量 IK Constraints：IK约束数量 Transform Constraints：位置约束数量 Path Constraints：路径约束数量","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"Spine","slug":"Spine","permalink":"http://example.com/tags/Spine/"}]},{"title":"42.Spine使用骨骼动画文件","slug":"游戏引擎/unity/unity核心/42.Spine使用骨骼动画文件","date":"2025-03-19T13:12:46.000Z","updated":"2025-03-19T13:33:41.193Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/42.Spine使用骨骼动画文件/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/42.Spine%E4%BD%BF%E7%94%A8%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E6%96%87%E4%BB%B6/","excerpt":"","text":"Spine导出的unity资源 Spine导出的资源有3个文件 .json：存储了骨骼信息 .png：使用的图片图集 .atlas.txt：图片在图集中的位置信息 当我们把这三个资源文件夹导入到已经引入了Spine运行库的Unity工程后，会自动为我们生成 _Atlas：材质和.atlas.txt文件（位置）的引用配置文件 _Material：材质文件 _SkeletonData：json（骨骼）和_Atlas资源的引用配置文件 使用Spine导出的骨骼动画 最关键的是_SkeletonData：json和_Atlas资源的引用配置文件 直接将_SkeletonData文件拖入到场景中，选择创建 SkeletonAnimation对象 可以点击SkeletonAnimation对象在右边Inspector窗口切换动画运行查看 或者创建空对象，然后手动添加SkeletonAnimation脚本对_SkeletonData文件进行关联","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"Spine","slug":"Spine","permalink":"http://example.com/tags/Spine/"}]},{"title":"41.Spine导入","slug":"游戏引擎/unity/unity核心/41.Spine导入","date":"2025-03-19T13:05:04.000Z","updated":"2025-03-19T13:10:44.286Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/41.Spine导入/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/41.Spine%E5%AF%BC%E5%85%A5/","excerpt":"","text":"Spine是什么 Spine是一个收费的跨平台的2D骨骼动画制作工具。 它支持Unity，UE，Cocos2D，Cocos2D-x等等游戏引擎。 相对Unity2018才推出的 2D Animation。 Spine是目前商业游戏中较为常用的骨骼动画制作方案，稳定且高效。 官方地址：http://zh.esotericsoftware.com/ 如何学习Spine 制作骨骼动画时美术人员的工作。 除非你是要做独立游戏，美术程序一人包。 那么我们没有必要去学习如何通过Spine制作骨骼动画。 我们只需要学习如何在Unity中通过程序使用Spine制作的资源。 如果想要学习如何制作Spine骨骼动画，可以根据官网提供的教学内容进行学习。 导入Unity使用的Spine运行库 有了Spine提供的支持Unity开发的运行库。 我们才能在Unity中使用Spine制作的骨骼动画。 你可以简单理解其实就是官方写好的识别文件处理文件呈现效果的代码。 我们只需要学习如何使用它提供的API即可。 下载完直接导入就行了","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"Spine","slug":"Spine","permalink":"http://example.com/tags/Spine/"}]},{"title":"40.换装不同文件资源","slug":"游戏引擎/unity/unity核心/40.换装不同文件资源","date":"2025-03-19T12:26:05.000Z","updated":"2025-03-19T13:02:04.886Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/40.换装不同文件资源/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/40.%E6%8D%A2%E8%A3%85%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90/","excerpt":"","text":"如何在不同psb文件中制作换装资源 保证个部位在PS文件中的统一，比如不同资源的头盔位置都要在同一位置 比如下面就不统一，使用就会出问题 基础部位可选择性隐藏，比如第一副图有的身体头四肢，下张图只有各个装备就行了 编辑换装资源的骨骼信息 注意事项：不同文件的骨骼信息必须统一,所以我们直接使用复制的方式 首先按选择psb图片，不勾选导入隐藏模式。进入精灵编辑器。按套路先创建骨骼，创建后生成蒙皮，生成蒙皮后会有些不该影响的骨骼，按套路在且到BoneInfluence和右边的精灵图片，一个一个删除或添加骨骼。有些情况下添加了骨骼要点击AutoWeights按钮选中添加的骨骼点击右下角Generate按钮生成权重 编辑好骨骼蒙皮权重 现在来编辑新的psb图片，如果重新编辑骨骼的话那咋保证骨骼的统一？ 打开另一张图片（这张图也不用打开import Hidden），点击粘贴，右下角只选中粘贴骨骼，不粘贴蒙皮。粘贴完点击应用。应用完继续按套路生成蒙皮，调整蒙皮骨骼和权重。 手动添加关键组件和数据文件 首先创建SpriteLibraryAsset数据文件 为根对象添加SpriteLibrary并关联数据文件 为换装部位关联SpriteResolver 创建空物体根对象，把psb图片放到他下面。 在Project窗口创建SpriteLibraryAsset数据文件 自己创建的SpriteLibraryAsset数据文件可以手动设置分组并关联图片。同一组关联的图片是两个psb文件下的相同类型的，比如不同的头盔。 为根对象添加SpriteLibrary并关联数据文件 为换装部位关联SpriteResolver 总结 如何选择 同一文件和 不同文件 制作换装资源两种方案？ 换装较少的游戏 比如只有面部表情更换 可以使用同一psb文件方案 换装较多的游戏 比如各部位有n种装备 可以使用不同psb文件方案 不同psb文件 拓展性更强 一切根据需求而定","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"}]},{"title":"39.换装同一文件资源","slug":"游戏引擎/unity/unity核心/39.换装同一文件资源","date":"2025-03-19T11:47:48.000Z","updated":"2025-03-19T12:33:08.330Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/39.换装同一文件资源/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/39.%E6%8D%A2%E8%A3%85%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90/","excerpt":"","text":"如何在同一个psb文件中制作换装资源 在ps中制作美术资源时，将一个游戏对象的所有换装资源都摆放好位置 当我们导入该资源时，要注意是否导入隐藏的图层 在ps软件制作图片时，是有很多图层的。可以设置图层显示隐藏控制当前用到是哪个图。比如控制各个武器图层的显示隐藏。想换装的话可以勾选导入隐藏图层的选项并应用。 每一类替换装备都需要单独的PSB，为了防止替换装备时产生的坐标错位，建议每一件装备都在图层内对齐。 例：所有衣袖需要向上对齐，所有鞋子需要向下对齐，不同武器需要手持位置对齐。 编辑换装资源的骨骼信息以及分组类别 打开精灵编辑器把模式调成SkinningEditor。因为导入了所有图片看起来比较乱，可以在右侧点击精灵选项，让同类型的图就显示一个。 创建骨骼，创建时假如发现原来的地方有骨骼挡着了可以切换到右边骨骼标签把挡着的骨骼想隐藏，创建好在显示刚刚隐藏的骨骼。创建好之后生成蒙皮。 打开Bone influence调整各个骨骼控制的部位 可以点击上方的SpriteSheet按钮，切换成图集模式，一个一个图查看关联的骨骼时候正确 我们可以看到右边面板上有Category分类和Label标签选项，这是Unity提供给我们换装用的。 每一个同类型的图片，比如不同的头盔，都可以放到同一组。点击三角形创建新的分组，输入分组名字，后面Label标签相当于当前图片在这个分组里的名字是啥，自动是图片名可以不用改，也可以改。 如何换装 两个关键组件： SpriteLibrary（精灵资料库）：它确定了精灵的类别分组信息。 SpriteResolver（精灵解算器）：用于确定精灵的部位类别以及使用的图片。 一个数据文件： SpriteLibraryAsset（精灵资料库资源）：这是一个具体记录了类别分组信息的文件。 创建空物体，把psb文件拖进来，可以看到由于设置了换装信息和分组，PSB图片对象上添加了SpriteLibrary精灵资料库组件并关联一个数据文件SpriteLibraryAsset精灵资料库资源，这个数据文件具体记录类别分组信息。 点击SpriteLibraryAsset精灵资料库资源如下图 不但生成了骨骼相关Sprite Skin的组件，发现有的自动添加了SpriteResolver（精灵解算器）脚本 代码换装 获取各部位的SpriteResolver（需要引用命名空间），比如获得头盔的SpriteResolver，创建SpriteResolver变量并在外面拖拽关联 使用SpriteResolver的API进行装备切换 12345678public SpriteResolver caskSpriteResolver;//GetCategory() 获取当前部位默认的类别名（分组名）//SetCategoryAndLabel 设置当前部位想要切换的图片信息//相当于没有设置分组，直接传入要切换的图片名进行设置caskSpriteResolver.SetCategoryAndLabel(caskSpriteResolver.GetCategory(), &quot;CASK 1&quot;); 如果你不想一个一个的拖 12345678910111213141516171819202122232425public SpriteResolver caskSpriteResolver;private Dictionary&lt;string, SpriteResolver&gt; equipDic = new Dictionary&lt;string, SpriteResolver&gt;();// 封装一下直接用分类+Label名public void ChangeEquip(string category, string equipName)&#123; if (equipDic.ContainsKey(category)) &#123; equipDic[category].SetCategoryAndLabel(category, equipName); &#125;&#125;void Start()&#123; SpriteResolver[] srs = this.GetComponentsInChildren&lt;SpriteResolver&gt;(); for (int i = 0; i &lt; srs.Length; i++) &#123; equipDic.Add(srs[i].GetCategory(), srs[i]); &#125; ChangeEquip(&quot;Cask&quot;, &quot;CASK 1&quot;);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"}]},{"title":"38.反向动力学IK","slug":"游戏引擎/unity/unity核心/38.反向动力学IK","date":"2025-03-19T02:04:23.000Z","updated":"2025-03-19T09:39:14.750Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/38.反向动力学IK/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/38.%E5%8F%8D%E5%90%91%E5%8A%A8%E5%8A%9B%E5%AD%A6IK/","excerpt":"","text":"什么是IK 在骨骼动画中，构建骨骼的方法被称为正向动力学。 它的表现形式是，子骨骼（关节）的位置根据父骨骼（关节）的旋转而改变。 用我们人体举例子，当我们抬起手臂时，是肩部关节带动的整个手臂的运动，用父子骨骼理解的话就是父带动了子。 而IK全称是Inverse Kinematics，翻译过来的意思就是反向动力学的意思。 它和正向动力学恰恰相反。 它的表现形式是，子骨骼（关节）末端的位置改变会带动自己以及自己的父骨骼（关节）旋转。 用我们人体举例子，当我们拿起一个杯子的时候是用手掌去拿，以杯子为参照物，我们移动杯子的位置，手臂会随着杯子一起移动，用父子骨骼理解的话就是子带动了父。 2DIK包引入 2022版本自带有 2DIK的使用 先给权杖也弄骨骼 新建一个空物体作为根对象，拖PSB图片做成子物体，给根物体添加IKManager2D组件 IK相关脚本参数 IK Manager 2D 脚本参数 IK Solvers：IK解算器，在这里添加IK Chain（CCD）：可以自定义影响N个关节点，不能反向 Chain（FABRIK）：可以自定义影响N个关节点，可以反向 Limb：只会影响3个关节点，一般四肢选这个 Weight：权重，当有多个IK控制同一点时权重会影响控制的百分比 Restore Default Pose：回复默认位置 给左右手和脚的末端和权杖的末端添加空物体，会利用这些空物体在对应位置添加IK点 在根对象的IKManager2D组件点击加号添加一个Chain（CCD）类型的IK，添加完会出现一个New CCDSolver2D子物体挂载NCCDSolver2D脚本 CCD Solver 2D参数 将权杖末端的空对象赋值进来。 Chain Length：IK影响的骨骼数量，往上影响多少个骨骼节点，加大数值，点变成绿色就意味着影响了那个骨骼。 Iterations：算法运行的次数。 Tolerance：容错程度。 Velocity：速度。 点击创建对象，会出来一个对象并关联，这个对象可以理解为创建出来的IK节点，通过这个IK节点反向控制骨骼，现在移动子物体因为有了IK父物体也会跟着动。 Effector：默认的IK点位置 Target：会根据IK点位置生成真正的IK点对象 Flip：反向 Constrain Rotation：约束旋转程度 Solve from Default Pose：从默认姿势进行求解计算 Weight：权重 CCD模式不能完全反向。 但FABRIK模式可以 和上面ccd模式基本一样操作 LimbSolver2D脚本参数 Effector：默认的IK点位置。 Target：会根据IK点位置生成真正的IK点对象。 Flip：反向。 Constrain Rotation：约束旋转程度。 Solve from Default Pose：从默认姿势进行求解计算。 Weight：权重。 Create Target：创建IK节点。 Restore Default Pose：重置默认形状。 为人物四肢创建IK 其实四肢也可以往上控制多个点的 先把左手这个删掉，重新选一个IK解算器 还可以改受IK点影响的到的骨骼颜色 下面的效果是一拳带动全身 现在IK点不会跟着人物的根骨骼动，而是锁死在原地如下。想要一起动的话把各个IK点放到根骨骼下就行 IK对于我们的意义 瞄准功能。 头部朝向功能。 拾取物品功能等等有指向性的功能时，我们都可以通过IK来达到目的。 最大的作用，可以方便我们进行动画制作。 练习 请制作一个鼠标指向哪，2D人物的手臂就指向哪里的功能 创建空物体，拖psb文件图片进来，在左手添加一个空物体 选择空对象，添加IKManager2D脚本，添加一个IK，选择四肢用的Limb。会创建一个IK位置节点 在IK位置节点关联左手空物体，点击创建目标按钮，生成IK目标对象 制作思路：我们可以控制IK目标对象的位置移动手臂，那么只要用鼠标控制IK目标对象就行了 123456789101112131415161718public Transform ikPoint; //IK点的位置private float z; //2D游戏所在平面的z轴坐标private Vector3 mousePos;void Start()&#123; z = Camera.main.WorldToScreenPoint(ikPoint.position).z; &#125;void Update()&#123; if (Input.GetMouseButton(0)) &#123; mousePos = Input.mousePosition; mousePos.z = z; ikPoint.position = Camera.main.ScreenToWorldPoint(mousePos); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"}]},{"title":"37.psb图片骨骼编辑","slug":"游戏引擎/unity/unity核心/37.psb图片骨骼编辑","date":"2025-03-19T01:22:05.000Z","updated":"2025-03-19T02:03:55.786Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/37.psb图片骨骼编辑/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/37.psb%E5%9B%BE%E7%89%87%E9%AA%A8%E9%AA%BC%E7%BC%96%E8%BE%91/","excerpt":"","text":"认识PSB文件 认识PS之前先认识PS PS（photoshop）是一款强大的图像处理软件，在各领域都被广泛使用。在游戏行业中也是美术同学使用最多的图像处理软件之一。 PSD和PSB两种格式，都是PS这款软件用于保存图像处理数据的文件格式。 PSD和PSB两种格式并没有太大的区别。最大的区别是PSD格式兼容除PS以外的其他一些软件，而PSB只能用PS打开。 在Unity中官方建议使用psb格式 在Unity中使用PSB文件 需要在Packages Manager窗口中引入 2D PSD Importer工具包 2D项目会自动下载，3D不会 在Unity中使用PSB文件做骨骼动画，可以让美术设置好图层，各图片位置，各个图片的名字，就不用像图集那样一个一个拼了 设置PSB文件关键参数 Extrude Edges*：图片边缘延伸网格 Import Hidden*：是否导入psb文件中隐藏的图层 Moszic： 启用后，将图层生成Sprite，并将他们合并成单个纹理 Character Rig：是否使用人物已经绑定的骨骼 Use Layer Grouping：使用psb文件中的层分组 一般不勾选 Pivot：轴心点位置 Reslice*： 一般不勾选 从导入层重新生成Sprite，并清除对Sprite的任何更改，只有启用Moszic后又用 Keep Duplicate Name*：保留PSB文件中的名字 让Sprite名称保留PSB文件中的名字 为PSB文件编辑骨骼信息 只能一部分一部分的生成蒙皮，但自动生成的蒙皮不知道哪个骨骼会影响哪部分就会有下面的效果，手臂影响身体 可以通过下面的操作取消掉关联的骨骼 对于这种没有骨骼关联的也可以添加骨骼关联 再做些细微调整 为PSB文件制作骨骼动画 创建一个空物体，直接拖进去其实就可以直接用了，也会自动创建子物体和骨骼 假如想把权杖拿到手上。要把拖进来的PS图片对象解预制体，不然无法移动权杖的父子关系，设置到拿到手上，调整层级","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"}]},{"title":"36.图集图片骨骼编辑","slug":"游戏引擎/unity/unity核心/36.图集图片骨骼编辑","date":"2025-03-19T01:04:50.000Z","updated":"2025-03-19T01:21:13.666Z","comments":true,"path":"2025/03/19/游戏引擎/unity/unity核心/36.图集图片骨骼编辑/","permalink":"http://example.com/2025/03/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/36.%E5%9B%BE%E9%9B%86%E5%9B%BE%E7%89%87%E9%AA%A8%E9%AA%BC%E7%BC%96%E8%BE%91/","excerpt":"","text":"注意事项 设置Sprite为图集模式 对图集图片进行切片 图集骨骼编辑 双击想要编辑的区域，会出现橙色边缘线 直接骨骼蒙皮权重就行 图集骨骼动画使用 设置一个空物体为根物体。拖拽图集下各个图片到根物体下。逐个添加SpriteSkin脚本并点击生成骨骼按钮。 通过手动设置各个图片的相对父对象来让头随着身体移动这种操作，并调整排序层级。注意调整根物体的子物体，让根物体的中心点在脚下。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"}]},{"title":"35.单张图片骨骼编辑","slug":"游戏引擎/unity/unity核心/35.单张图片骨骼编辑","date":"2025-03-18T12:22:59.000Z","updated":"2025-03-18T15:09:30.423Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/35.单张图片骨骼编辑/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/35.%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E9%AA%A8%E9%AA%BC%E7%BC%96%E8%BE%91/","excerpt":"","text":"什么是2d骨骼动画 首先回顾一下序列帧动画 传统的序列帧动画为了达到好的动画效果 理论上来说，图片越多，动作越流畅 往往需要较多的美术资源，虽然效果好但是资源占用较多 而2D骨骼动画是利用3D骨骼动画的制作原理进行制作的 将一张2D图片分割成n个部位，为每个部位绑上骨骼，控制骨骼旋转移动 达到用最少的2D美术资源做出流畅的2D动画效果 Unity中如何制作2d骨骼动画 主要方式有两种 使用Unity2018新加功能 2D Animation 工具制作 使用跨平台骨骼动画制作工具 Spine 制作 导入2d Animation工具 在Package Manager窗口 搜索 2D Animation并安装 假如不是2d项目，要手动导入，否则自动就有 可以自己查看示例场景和示例图片。切换成皮肤编辑模式查看骨骼 SkinningEditor模式下面板讲解 SkinningEditor模式下面板讲解 导入工具后 在Sprite Editor窗口会多一个选项 Skinning Editor 切换到Skinning Editor模式 因为官方示例的图都是设置好骨骼的 可以找到对应的图的路径在资源管理器中打开 删除对应的meta文件 回到unity 系统会默认生成新的meta文件 之前绑定的骨骼相关就丢失了 SkinningEditor模式下面板参数 左上方 Reset Pose 将角色骨骼和关节恢复到原始位置 Sprite Sheet：图集显示 Copy复制当前选择的数据 Paste粘贴复制数据 左方 Bone 骨骼相关 Preview Pose 预览模式，可以预览动作并不会真正的改变设置 Edit Bone 编辑骨骼，可以改变骨骼的位置、长度、方向、名称等等 Create Bone 创建骨骼 注意要双击图片 图片产生橙色边缘线后 再点击创建骨骼，根骨骼一般是人物的躯干或者脚下 这两个是没有父子关系的 如果想创建更多的子对象，就点击想创建的子对象的根部 进行设置起点和终点 Split Bone 拆分骨骼，将一个骨骼一分为二 Geometry 蒙皮相关 蒙皮决定了骨骼主要控制哪一部分 先自动再手动 Auto Geometry 自动蒙皮 OUtline Detail 边缘细节，值越大，轮廓越细致 Alpha Tolerance 阿尔法公差值，控制蒙皮细节 Subdivide 细化程度，控制蒙皮细节 Weights 是否自动设置权重，一般勾选 Edit Geometry 编辑蒙皮 Create Vertex 创建顶点 注意创建的顶点越多计算量越大 Create Edge 创建边线 Split Edge 拆分边，用一个新的顶点分离一个边 Weights 权重相关 决定了当骨骼动时如何印象顶点和边 比如控制如下图的顶点受到两边骨骼的程度 Auto Weights 自动赋予权重 Weight Slider 编辑顶点和边的权重 Mode：计算模式 Add And Subtract：加减法 （一般选这个） Grow And Shrink：增长和收缩 Smooth：平滑 Bone：设置权重的骨骼 Normalize：标准化设置 Amount：数量级（一般不会改不然如下） Vertex Weight：顶点权重 对应的骨骼 Weight Brush 用笔刷赋予权重 直接选个骨骼之后直接刷顶点权重 Size：笔刷大小 Hardness：笔刷强度，越大效果越明显 Step：步数 Bone Influence 选择骨骼用的Sprite 主要用于在psb图片中使用 骨骼控制点的图片关联 Visibility 切换选定精灵或骨骼的可见性 左侧拖动条 控制编辑时骨骼透明度 右侧拖动条 控制编辑时权重透明度 下方列表 浏览各骨骼名和骨骼层级信息 骨骼动画的使用 把设置好骨骼的图片丢到场景里，添加SpriteSKin脚本，点击CreateBones按钮，骨骼会自动关联 打开Animator的窗口来创建动画，调整各个骨骼子物体位置来生成动画效果","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"}]},{"title":"34.2D序列帧动画","slug":"游戏引擎/unity/unity核心/34.2D序列帧动画","date":"2025-03-18T11:42:08.000Z","updated":"2025-03-18T12:20:13.512Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/34.2D序列帧动画/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/34.2D%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB/","excerpt":"","text":"什么是序列帧动画 我们最常见的序列帧动画就是我们看的日本动画片，以固定时间间隔按序列切换图片就是序列帧动画的本质。当固定时间间隔足够短时，我们肉眼就会认为图片是连续动态的，进而形成动画（会动的画面）。 它的本质和游戏的帧率概念有点类似。 原理就是在一个循环中按一定时间间隔不停地切换显示的图片。 代码制作序列帧动画 12345678910111213141516171819202122232425262728public class Lesson37_2D动画_2D序列帧动画 : MonoBehaviour&#123; public Sprite[] sprs; //存放序列帧图片 private SpriteRenderer sr; //显示图片 private float time = 0; //记录帧间隔时间 private int nowIndex = 0; //记录当前显示的图片索引 void Start() &#123; sr = this.GetComponent&lt;SpriteRenderer&gt;(); sr.sprite = sprs[nowIndex]; &#125; void Update() &#123; //每一次增加帧间隔时间 time += Time.deltaTime; //当帧间隔时间达到某一个条件时就切换图片 if (time &gt;= 0.03f) &#123; //切换图片 nowIndex++; //记得从头显示 sr.sprite = sprs[nowIndex % sprs.Length]; time = 0; &#125; &#125;&#125; Animation窗口制作序列帧动画 方法一 创建一个空物体 创建一个动画 直接将某一个动作的序列帧拖入窗口中 方法二 适合第一次用 直接将图片拖入Hierarchy层级窗口中 默认你要创建序列帧动画 利用Animator进行动画控制 创建好动画，设置好切换参数和条件等 代码中拖拽得到动画控制器 123456789101112public class Lesson37_2D动画_2D序列帧动画 : MonoBehaviour&#123; public Animator animator; void Update() &#123; if (Input.GetKeyDown(KeyCode.Space)) animator.SetBool(&quot;isDown&quot;, true); else if (Input.GetKeyUp(KeyCode.Space)) animator.SetBool(&quot;isDown&quot;, false); &#125;&#125; 练习 在之前2D相关练习题的基础上，为控制的对象加上序列帧动画 给机器人创建待机动画，找到待机动画图集，拖入图片进去。注意图集要设置底部为轴心 给机器人创建走路动画，找到待机走路图集，拖入图片进去。注意图集要设置底部为轴心 给机器人创建跳跃动画，找到跳跃动画图集，拖入图片进去。注意图集要设置底部为轴心 创建x，y速度的int动画参数，并且添加过渡和切换条件。x速度等不等于0决定是Idle状态还是Walk状态，y速度等不等于0决定是跳跃状态还是非跳跃状态。 一般不用y的速度来判断是否播放跳跃动画，可以和地面碰撞器判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162using System.Collections;using System.Collections.Generic;using UnityEngine;public class Lesson37_练习题_PlayerObject : MonoBehaviour&#123; public float moveSpeed = 5; // 声明一个浮点数类型变量 h; private float h; // 声明 SpriteRenderer 类型变量 sr; private SpriteRenderer sr; private Rigidbody2D rigidBody2D; private float frontH; // 声明 Animator 类型变量 animator; private Animator animator; void Start() &#123; sr = this.GetComponent&lt;SpriteRenderer&gt;(); rigidBody2D = this.GetComponent&lt;Rigidbody2D&gt;(); animator = this.GetComponent&lt;Animator&gt;(); &#125; void Update() &#123; h = Input.GetAxisRaw(&quot;Horizontal&quot;); // 设置动画参数 xSpeed 为 h 的整数值 animator.SetInteger(&quot;xSpeed&quot;, (int)h); // 设置动画参数 ySpeed 为刚体 y 方向速度的整数值 animator.SetInteger(&quot;ySpeed&quot;, Mathf.CeilToInt(rigidBody2D.velocity.y)); if (h != 0) rigidBody2D.velocity = new Vector2(h * moveSpeed, rigidBody2D.velocity.y); if (h &lt; 0) sr.flipX = true; else if (h &gt; 0) sr.flipX = false; if (Input.GetKeyDown(KeyCode.Space)) &#123; GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;BulletObj&quot;), this.transform.position + new Vector3(sr.flipX ? -0.3f : 0.3f, 0.5f, 0), Quaternion.identity); obj.GetComponent&lt;BulletObj&gt;().ChangeMoveDir(sr.flipX ? Vector3.left : Vector3.right); &#125; // 当按下 J 键时，给刚体施加一个向上的瞬时力 if (Input.GetKeyDown(KeyCode.J)) &#123; rigidBody2D.AddForce(Vector2.up * 300); &#125; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d序列帧动画","slug":"2d序列帧动画","permalink":"http://example.com/tags/2d%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB/"}]},{"title":"33.AnimatorController动画控制器","slug":"游戏引擎/unity/unity核心/33.AnimatorController动画控制器","date":"2025-03-18T08:24:26.000Z","updated":"2025-03-18T11:38:34.906Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/33.AnimatorController动画控制器/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/33.AnimatorController%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"","text":"创建动画状态机 直接选择场景物体后在动画窗口点Create 创建动画 还可以手动在Project窗口创建动画控制器 新建的 Animator 文件是空的，可以拖 Animation 动画文件进去。 动画控制器（状态机） 编辑面板 左侧面板 Layers：动画层级页签，为动画添加更多的层级，层级高的动画播放会覆盖层级低的 Parameters：参数页签，为动画状态机添加控制状态切换的参数 眼睛图标：显隐左侧面板 右侧面板 网格化布局区域： 主要用于编辑状态之前的切换关系 窗口中的每一个矩形表示一个状态 窗口中的每一个箭头表示一个切换条件 默认三大矩形： 绿色Entry矩形：进入状态机流程 红色Exit矩形：退出状态机流程 Any State：任意状态，代表状态机中的任意状态 人为添加矩形： 橙色矩形：一开始的默认状态动画，和Entry相连 表示一开始播放的动画 灰色矩形：自己添加的某一种动作状态 添加动画 自动添加 为对象创建动画后会自动将动画添加到状态机中 直接将动画文件拖入到状态机 点击状态发现自动就关联了2 可以改名，但关联的还是2 直接在窗口里面右键一个状态再关联 添加切换连线 对一个矩形右键选择创建过渡。 添加连线后意味着这两个矩形状态可以进行状态切换，可以给连线设置切换的条件。没有连线的话两个状态不能进行切换。 选择矩形右键可以把该矩形状态设置为该层的默认状态。 添加切换条件 把左侧面板切换成参数标签，点击加号添加四种参数变量条件。 注意这里的Trigger 一个布尔参数，当被转换消耗时，由控制器重置（用圆形按钮表示）。可以理解为特殊的 bool 值，当设置为 true 完成切换条件后马上会自动设置为 false。 一般用于下面这种有来有回的连线（一但进入Test动画播放完成之后立马会去的 设置动画间切换条件 选择一个连线，点击下方条件列表添加切换条件，点击下拉框会出现我们刚刚设置好的切换条件参数进行选择。同理选择条件框后按减号可以删除。 Animator参数相关 Controller：对应的动画控制器（状态机） Avatar：对应的替身配置信息 （之后讲解3D模型时详细讲解） Apply Root Motion：是否启用动画位移更新 UpdateMode：更新模式（一般不修改它） Normal：正常更新 Animate Physics：物理更新 Unscaled Time：不受时间缩放影响 Culling Mode：裁剪剔除模式 Always Animate：始终播放动画，即使在屏幕外也不剔除 Cull Update Transforms：摄像机没有渲染该物体时，停止位置、IK的写入 Cull Completely：摄像机没有渲染物体时，整个动画被完全禁用 Animator 代码控制 1234//我们用代码控制状态机切换主要使用的就是Animator提供给我们的API//我们知道一共有四种切换条件 int float bool trigger//所以对应的API也是和这四种类型有关系的animator = this.GetComponent&lt;Animator&gt;(); Animator.SetXXX方法 通过状态机条件切换动画 123456//通过状态机条件切换动画//设置动画参数状态animator.SetFloat(&quot;条件名&quot;, 1.2f);animator.SetInteger(&quot;条件名&quot;, 5);animator.SetBool(&quot;条件名&quot;, true);animator.SetTrigger(&quot;条件名&quot;); Animator.GetXXX方法 获得动画参数状态 12345678//获得动画参数状态animator.GetFloat(&quot;条件名&quot;);animator.GetInteger(&quot;条件名&quot;);animator.GetBool(&quot;条件名&quot;);//直接切换动画 除非特殊情况 不然一般不使用//animator.Play(&quot;状态名&quot;);//注意：状态名和动画名不一样 动画名拖进来默认名字就是状态名 但是可以修改的和动画名不一样的 假如切换时发现有延迟，可能是因为连线切换的参数中勾选了有推出时间，注意的话会播完上个动画在继续播下个动画。取消勾选即可。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"32.有限状态机概念","slug":"游戏引擎/unity/unity核心/32.有限状态机概念","date":"2025-03-18T08:20:28.000Z","updated":"2025-03-18T08:23:07.046Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/32.有限状态机概念/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/32.%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A6%82%E5%BF%B5/","excerpt":"","text":"什么是有限状态机 有限状态机（Finite-state machine, FSM）是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。 有限：表示是有限度的不是无限的。 状态：指所拥有的所有状态。 举例说明： 假设我们人会做很多个动作，也就是有很多种状态，这些状态包括站立、走路、跑步、攻击、防守、睡觉等等。我们每天都会在这些状态中切换，而且这些状态虽然多但是是有限的。当达到某种条件时，我们就会在这些状态中进行切换，而且这种切换时随时可能发生的。 有限状态机对于我们的意义 有限状态机在游戏开发中具有重要意义，许多功能系统都是有限状态机。 最典型的状态机系统包括动作系统和AI（人工智能）系统。 例如，动作系统满足某个条件时切换一个动作，且动作是有限的；AI系统满足某个条件时切换一个状态，且状态是有限的。 最简单的状态机实现 最简单的状态机实现代码就是基于switch的实现。 假设我们只有一个值来控制当前玩家的状态： 12345678910111213141516string animName = &quot;idle&quot;;switch (animName)&#123; case &quot;idle&quot;: // 待机动作逻辑 break; case &quot;move&quot;: // 移动动作逻辑 break; case &quot;run&quot;: // 跑步动作逻辑 break; case &quot;atk&quot;: // 攻击动作逻辑 break;&#125; 总结 在游戏开发中，某些系统中存在有限种状态的切换变化时，我们可以使用有限状态机的设计思路来进行逻辑编写。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"}]},{"title":"31.老动画系统","slug":"游戏引擎/unity/unity核心/31.老动画系统","date":"2025-03-18T07:25:00.000Z","updated":"2025-03-18T08:14:24.204Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/31.老动画系统/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/31.%E8%80%81%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"什么是老动画系统 Unity中有两套动画系统： 新：Mecanim动画系统——主要用Animator组件控制动画。 老：Animation动画系统——主要用Animation组件控制动画（Unity4之前的版本可能会用到）。 目前我们为对象在Animation窗口创建的动画都会被新动画系统支配。有特殊需求或者针对一些简易动画，才会使用老动画系统。 老动画系统控制动画播放 注意： 在创建动画之前为对象添加Animation组件之后再制作动画。 这时制作出的动画和之前的动画格式是有区别的。 使用老动画系统来创建动画要先給物体添加一个Animation脚本，挂载过后Unity就会认为这个对象要使用老动画系统。 编辑和新动画系统一样 动画文件格式不一样 参数相关 Animation：默认播放的动画。（注意拖选的一定是老动画系统的动画文件） Animations：该动画组件可以控制的所有动画 Play AutoMatically：是否一开始就自动播放默认动画。 Animate Physics：动画是否与物理交互。 Culling Type：决定什么时候不播放动画。 Always Animate：始终播放。 Based On Renderers：基于默认动画姿势剔除，比如动画在屏幕外可能就不播了。 老动画文件参数 Default：读取设置得更高的默认重复模式 Once：播放一次就停止 Loop：从头到尾不停循环播放 PingPong：从头到尾从尾到头不停播放 ClampForever：播放结束会停在最后一帧，并且会一直播放最后一帧（相当于状态不停止），表现效果和Once一样，但是逻辑处理上不同 代码控制播放 123456private Animation animation;void Start()&#123; animation = this.GetComponent&lt;Animation&gt;();&#125; Animation.Play方法 播放动画 12345678910//播放没有混合的动画。//会直接生硬的切换动画 假如播放到一半切换动画 回强行停止第一个播放的动画 切换到第二个播放动画的初始状态 进行播放if (Input.GetKeyDown(KeyCode.Alpha1))&#123; animation.Play(&quot;1&quot;);&#125;if (Input.GetKeyDown(KeyCode.Alpha2))&#123; animation.Play(&quot;2&quot;);&#125; Animation.CrossFade方法 淡入播放,自动产生过渡效果 12345678//在后续 time 秒的时间段内，使名称为 animation 的动画淡入，使其他动画淡出。//会先淡出把状态慢慢变成要播放的动画的初始在状态，再播动画if (Input.GetKeyDown(KeyCode.Alpha3))&#123; //当你当前的动画的状态和播放动画的开始状态不一样的时候就会产生过渡效果 animation.CrossFade(&quot;3&quot;); //animation.Play(&quot;3&quot;);&#125; Animation.PlayQueued方法 前一个播完直接再播放下一个 1234567//在先前的动画播放完毕后再播放动画。//可以理解为把动画加到队列中 等上一个动画播放完再播 会生硬的切换初始状态if (Input.GetKeyDown(KeyCode.Alpha4))&#123; animation.PlayQueued(&quot;2&quot;); // animation.CrossFadeQueued(&quot;2&quot;); // 有过渡效果&#125; Animation.Stop方法 停止播放所有动画 1animation.Stop(); Animation.IsPlaying方法 是否在播放某个动画 1234if ( animation.IsPlaying(&quot;1&quot;) )&#123;&#125; Animation.wrapMode变量 播放模式设置 1animation.wrapMode = WrapMode.Loop;//设置成循环播放 其它（了解即可，新动画系统中会详细讲解） 123456789//层级和权重以及混合（老动画系统需要通过代码来达到动画的遮罩、融合等效果）//设置层级animation[&quot;1&quot;].layer = 1;//设置权重animation[&quot;1&quot;].weight = 1;//混合模式 叠加还是混合animation[&quot;1&quot;].blendMode = AnimationBlendMode.Additive;//设置混组相关骨骼信息animation[&quot;&quot;].AddMixingTransform(); 动画事件 动画事件主要用于处理当动画播放到某一时刻想要触发某些逻辑，比如进行伤害检测、发射子弹、特效播放等等。 在Animation窗口选择某一动画的某一帧下，点击添加动画事件的按钮添加动画事件。 添加后可以在时间轴看到一个蓝色的条。蓝色的条可以在时间轴任意拖动。 点击可以在右侧Inspector窗口看见动画事件相关参数，现在还没有绑定任何事件。 在挂载到执行动画对象上的代码上添加用于动画事件关联的函数。函数可以有参数，可以是int，float，GameObject类型。 1234public void AnimationEvent(GameObject go)&#123; print(&quot;动画事件触发&quot;);&#125; 总结 老动画系统主要用于处理老版本项目和简单的一些自制动画。 新项目都不建议大家使用了。 关键组件：Animation","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"30.创建和编辑Animation动画文件","slug":"游戏引擎/unity/unity核心/30.创建和编辑Animation动画文件","date":"2025-03-18T02:30:47.000Z","updated":"2025-03-18T07:22:10.432Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/30.创建和编辑Animation动画文件/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/30.%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BC%96%E8%BE%91Animation%E5%8A%A8%E7%94%BB%E6%96%87%E4%BB%B6/","excerpt":"","text":"创建动画 在场景中选中想要创建动画的对象 在Animation窗口中点击创建 选择动画文件将要保存到的位置 保存Animation动画文件时，Unity会帮助我们完成以下操作 创建一个 Animator Controller（动画控制器或称之为动画状态机） 资源（新动画系统） 将新创建的动画文件添加到Animator Controller动画状态机中 双击打开 为场景上的对象添加Animator组件 为Animator组件关联创建的Animator Controller文件 面板变化 左侧面板 多出一个可以选择当前动画的下拉列表 可以在这里创建新动画和切换动画 多出一个可以添加变化属性的按钮 在这里你可以任意添加你想要在动画中变化的脚本变量 右侧面板 时间轴可以拖动 注意： 时间轴上的单位为n秒n帧 一格代表一帧（并不是秒） 选择关键帧右键 关键帧模式下编辑动画 点击录制按钮，进入录制状态。就可以随便选择一个时间点给他添加关键帧。但是点击添加关键帧按钮会发现没有用。因为没有告诉这个动画会改变物体的哪些属性和变量。 还有一种添加关键帧的方法，点击录制按钮后直接改Inspector窗口的值，会自动在时间轴添加关键帧 曲线模式下编辑动画 曲线模式可以控制非匀速变化 在曲线模式下可以直接右键添加关键帧，添加完关键帧后切换成关键帧模式也能看到刚刚添加的关键帧。 在关键帧模式下或者曲线模式下，选择关键帧右键 Add Key：添加关键帧 Delete Key：删除关键帧 Clamped Auto：切线模式，自动设置切线 Auto：旧版切线模式，和Clamped Auto基本类似，主要用于老动画系统，建议不使用除非是老动画 Free Smooth：自由设置切线 Flat：切线设置为水平 Broken：单独控制左右曲线切线 Free：自由设置 Linear：直线 Constant：常量切换 Weighted：权重切换，可以拉长缩短切线 动画文件界面参数 Loop Time：是否是循环动画（在动画结尾时重新开始） Loop Pose：无缝循环运动 Cycle Offset：循环动画在其他时间开始时的周期偏移 对Animation打开Debug模式，注意Sample Rate帧率（采样率），和 Wrap Mode动画播放模式（贴图间拼接模式）这两个参数 在Animation里面改和在Animation文件改一样的","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"29.认识Animation动画窗口","slug":"游戏引擎/unity/unity核心/29.认识Animation动画窗口","date":"2025-03-18T02:11:57.000Z","updated":"2025-03-18T02:31:22.151Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/29.认识Animation动画窗口/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/29.%E8%AE%A4%E8%AF%86Animation%E5%8A%A8%E7%94%BB%E7%AA%97%E5%8F%A3/","excerpt":"","text":"打开Animation窗口 Animation窗口是用来干嘛的 Animation窗口直译就是动画窗口，主要用于在Unity内部创建和修改动画。所有在场景中的对象都可以通过Animation窗口为其制作动画。 原理： 制作动画时：记录在固定时间点对象挂载的脚本的变量变化。 播放动画时：将制作动画时记录的数据在固定时间点进行改变，产生动画效果。 动画关键词说明 动画时间轴 每一个动画文件都有自己的一个生命周期，从动画开始到结束。我们可以在动画时间轴上编辑每一个动画生命周期中的变化。 动画中的帧 假设某个动画的帧率为60帧每秒，意味着该动画1秒钟最多会有60次改变机会。每一帧的间隔时间是 1s/60 ≈ 16.67毫秒。也就是说，我们最快可以每16.67毫秒改变一次对象状态。 关键帧 动画在时间轴上的某一个时间节点上处于的状态。 Animation 面板功能 面板左侧 从左至右： 1.预览模式（开关） 2.录制模式（开关）打开后预览模式默认开启 3.回到动画开头 4.上一关键帧（快捷键：键盘逗号） 5.播放动画（快捷键：键盘Alt+逗号） 6.下一关键帧（快捷键：键盘句号） 7.回到动画结尾（快捷键：键盘Alt+句号） 8.当前处于第几帧 从左至右： Dopesheet：关键帧模式 Curves：曲线模式 从左至右： 按选择筛选 添加关键帧 添加事件 面板右侧 动画时间轴面板：当编辑动画时，会在该面板上编辑关键帧等信息","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"28.瓦片地图代码控制","slug":"游戏引擎/unity/unity核心/28.瓦片地图代码控制","date":"2025-03-18T01:49:51.000Z","updated":"2025-03-18T02:08:34.065Z","comments":true,"path":"2025/03/18/游戏引擎/unity/unity核心/28.瓦片地图代码控制/","permalink":"http://example.com/2025/03/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/28.%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"获取Tilemap和TileBase和Grid Tilemap组件：用于管理瓦片地图。 TileBase组件：单张瓦片资源对象基类。 Grid组件：用于坐标转换。 12345678using UnityEngine.Tilemaps;// 瓦片地图信息，可以通过它得到瓦片格子public Tilemap tilemap;// 格子位置相关控制，可以通过它进行坐标转换public Grid grid;// 瓦片资源基类，通过它可以得到瓦片资源public TileBase tileBase; 重要API Tilemap.ClearAllTiles方法 清空瓦片地图 123//Tilemap类中的ClearAllTiles方法 清空瓦片地图//清除 Tilemap 中放置的所有瓦片。tilemap.ClearAllTiles(); Tilemap.GetTile方法 获取指定坐标格子的瓦片格子 1234//传入的是Vector3Int类型//根据给定的瓦片地图中某个单元格的 XYZ 坐标，获取瓦片。TileBase tempTileBase = tilemap.GetTile(Vector3Int.zero);print(tempTileBase); Tilemap.SetTile方法 设置瓦片和删除瓦片 12345//根据给定的瓦片地图中某个单元格的 XYZ 坐标，设置瓦片。//设置瓦片tilemap.SetTile(new Vector3Int(0, 2, 0), tileBase);//删除瓦片tilemap.SetTile(new Vector3Int(1, 0, 0), null); Tilemap.SwapTile方法 替换瓦片 123//将 changeTile 的所有现有瓦片交换为 newTile 并刷新所有交换的瓦片。//是将瓦片资源图片替换的意思 资源所有使用到瓦片资源的图片都会进行变化tilemap.SwapTile(tempTileBase, tileBase); Tilemap.WorldToCell方法 世界坐标转格子坐标 将世界位置转换为单元格位置。 传入的参数是Vector3类型世界坐标 我们可以先屏幕坐标转世界坐标，再世界坐标转格子坐标","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Tilemap","slug":"Tilemap","permalink":"http://example.com/tags/Tilemap/"}]},{"title":"27.瓦片地图扩展包","slug":"游戏引擎/unity/unity核心/27.瓦片地图扩展包","date":"2025-03-16T12:42:41.000Z","updated":"2025-03-18T01:42:19.208Z","comments":true,"path":"2025/03/16/游戏引擎/unity/unity核心/27.瓦片地图扩展包/","permalink":"http://example.com/2025/03/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/27.%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E6%89%A9%E5%B1%95%E5%8C%85/","excerpt":"","text":"导入瓦片地图扩展包 Project右键 新增瓦片类型 规则瓦片 Rule Tile (Hexagonal、Isometric) Default Sprite：默认图片 Default GameObject ：默认游戏对象 Default Collider：默认碰撞器规则 Tiling Rules：平铺规则 可以自己添加删除 当满足x的地方没图，绿的地方有图就会使用右边选择的图 将RuleTile规则瓦片拖入到调色板中，在场景绘制时就会有相应的规则 对应情况的瓦片可以关联游戏对象，但是一般不会关联 还可以更改Output来设置随机输出的图片 输出类型改成动画模式的话可以关联多张图片，出现当前图片时会在多张图片按一定速度进行顺序轮播，看起来就像动画 动画瓦片 Animated Tile 可以指定序列帧，产生可以播放序列帧动画的瓦片 角色一般不用这个，角色一般用2d对象去做，一般用场景上随风飘扬的小草什么的 设置好了把瓦片拖拽文件拖到平铺调色板，在拖到场景里，场景里的动画瓦片就会不停的播放了。 Number Of Animated Sprites：动画有多少张图构成 Minimum Speed：最小播放速度 Maximum Speed：最大播放速度 Start Time：开始播放的时间 Strat Frame：从那一帧开始播放 管道瓦片 Pipeline Tile None：一个都不相邻时使用的图片 One——Four：相邻1~4个时使用的图片 随机瓦片 Random Tile Number Of Sprites：随机图片数量（之后会随机取一个图片来使用） 地形瓦片 TerrainTile 跟规则瓦片差不多一样 Filled:填满 Three Sides:三个面 Two Sides and One Corner:两面一角 Two Adjacent Sides:相邻两侧 Two Opposite Sides:两个相对的侧面 One Side and Two Corners:一侧和两个角 One Side and One Upper Corner:一边和上角 One Side:一面 Four Corners:四个角 Three Corners:三个角 Two Adjacent Corners:两个相邻角 Two Opposite Corners：两个相反的角 One Corner：一个角 Empty：空 权重随机瓦片 WeightedRandomTile 规则覆盖瓦片 Rule Override Tile 在规则瓦片的基础上，改变图片或指定启用的规则 新增笔刷类型 GameObject Brush Random Brush Tile Set Size Coordinate Brush* 坐标笔刷 可以实时的看到格子的坐标 Group Brush 组合笔刷 可以设置参数，当点击一个瓦片样式时，会自动取出一个范围内的瓦片。 Gap决定x、y、z遇到几个空格之后就不继续扩充吸取的范围。 Limit决定最大的吸取范围，从0开始。 Line Brush 线性笔刷 决定起点和终点画一条线出来。 选择线性笔刷后点击画笔可以在瓦片地图中点击确定起点和终点，会用选择的瓦片连成线。 Line Start Active 是否以上一次绘制的起点作为新的起点。 Fill Gaps 自动填充，会把线画的更粗。 Tint Brush* 着色笔刷 可以给瓦片着色，瓦片的颜色锁要开启（Inspector窗口切换Debug模式 修改Flags）。 不开启颜色锁没有作用。 找到瓦片资源图片，右上角把图片设置成Debug模式，修改Flag为None。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Tilemap","slug":"Tilemap","permalink":"http://example.com/tags/Tilemap/"}]},{"title":"26.瓦片地图关键脚本和碰撞器","slug":"游戏引擎/unity/unity核心/26.瓦片地图关键脚本和碰撞器","date":"2025-03-16T10:35:30.000Z","updated":"2025-03-16T12:33:42.883Z","comments":true,"path":"2025/03/16/游戏引擎/unity/unity核心/26.瓦片地图关键脚本和碰撞器/","permalink":"http://example.com/2025/03/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/26.%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE%E5%85%B3%E9%94%AE%E8%84%9A%E6%9C%AC%E5%92%8C%E7%A2%B0%E6%92%9E%E5%99%A8/","excerpt":"","text":"回顾瓦片地图编辑 瓦片地图关键脚本和碰撞器参数 Grid Cell Size：网格单元格的大小 Cell Gap：网格之间的间隔大小 改图片的Pixels Per Unit也可以达成影响效果 Cell Layout：网格单元的形状和排列 Rectangle：矩形 Hexagon：六边形 Isometric：等距布局，单元格为菱形 Isometric Z as Y：等距布局，但Unity将单元格Z轴转换为局部Y坐标 Cell Swizzle*： Unity将XYZ单元格坐标重新排序为你选择的类型 Tilemap* Animation Frame Rate：动画的速率 Unity播放瓦片动画的速率。相当于倍速 Color：瓦片色调颜色 Tile Anchor：瓦片的锚点偏移 Orientation：瓦片地图上瓦片的方向。 相当于2D平面使用的是Unity中的哪两个轴 Tilemap Renderer Sort Order：排序方向 设置所选瓦片地图上的瓦片排序方向 Mode：渲染模式 Chunk：按位置对瓦片进行分组，并将瓦片精灵一起批处理进行渲染，性能较好 Individual：单独渲染每个瓦片，会考虑他们的位置和排序顺序。会让瓦片精灵和场景中其它渲染器或自定义排序轴进行交互 Detect Chunk Culling*：渲染器如何剔除瓦片地图的边界 Auto：自动检测 Manual：手动设置拓展边界 Chunk Culling Bounds*： 当选择手动设置剔除拓展边界时，可以在这里自己填写拓展的值 瓦片地图碰撞器 为挂载TilemapRenerer脚本的对象添加Tilemap Collider2D脚本，会自动添加碰撞器。注意：想要生成碰撞器的瓦片Collider Type类型要进行设置。 可以添加个复合碰撞器来合并碰撞器 练习题 横版通关的地图 请用TileMap制作一个横版通关的地图 让一个角色可以在其中移动 创建一个2D精灵作为玩家，给他添加碰撞器和刚体。注意调整两个瓦片地图和玩家对象的层级。 123456789101112131415161718192021222324252627public class PlayerObject1 : MonoBehaviour&#123; public float moveSpeed = 3; private SpriteRenderer sr; private Rigidbody2D rigidBody2D; private float h; void Start() &#123; rigidBody2D = this.GetComponent&lt;Rigidbody2D&gt;(); sr = this.GetComponent&lt;SpriteRenderer&gt;(); &#125; void Update() &#123; h = Input.GetAxis(&quot;Horizontal&quot;); rigidBody2D.velocity = new Vector2(h * moveSpeed, rigidBody2D.velocity.y); if (h &lt; 0) sr.flipX = true; else if (h &gt; 0) sr.flipX = false; if (Input.GetKeyDown(KeyCode.Space)) &#123; rigidBody2D.AddForce(Vector2.up * 300); &#125; &#125;&#125; 如果想要左上红框做平台效用器的话，可以重新在瓦片调色板中在添加一个一模一样的图片，可以把新生成的瓦片图片资源设置碰撞器类型为None。我们可以创建空物体添加平台碰撞器，调整位置和大小放到瓦片碰撞器的位置。这样就做成瓦片碰撞器了。 不要局限于瓦片碰撞器。假如做一个可以被跳跃销毁的顶箱子或者踩怪，可以直接拖入图片作为2D对象，然后写逻辑，不使用瓦片相关也没问题。 伪Z轴的地图 请用TileMap制作一个有伪Z轴的地图 让一个角色可以在其中移动 伪Z轴：将Y轴有跳跃功能，也有前进功能 等距瓦片的两项重要设置 首先 等距瓦片和等距瓦片z和y的区别 开启了下面改变Z轴的选项。等距瓦片把瓦片丢到场景里按-和+不会调整伪Z轴的距离，等距瓦片z和y会改变。（一般不用zy，会有排序啥的问题） 设置轴心点 等距瓦片的排序问题 轴心点排序 设置角色渲染器按照轴心排序 还是有问题？ 规则是什么？y轴 排序层排序 更改角色的排序层 有产生新的问题 可以利用Tilemap可以加多个情况来解决 又又又有新问题 还可以创建一个不同层级的和玩家同一排序层的Tilemap，通过轴心点排序 自己添加的图的排序点一定要选泽pivot排序 可以用自己拖精灵来制作场景，和Tilemap区别如下 2d精灵图片对象可以密集的放很多个对象。 等距瓦片地图角色不使用重力 控制移动不应该用刚体来移动，要用transform来移动 玩家Rigidbody组件设置如下 等距瓦片碰撞器相关问题 中间黄色地面是不产生碰撞的 将中间的图片资源的碰撞模式改为空 对于等距瓦片围墙这种一般不按照碰撞类型不按Sprite来生成，一般按照Grid来生成 编写角色脚本 123456789101112131415161718192021222324public class PlayerObject2 : MonoBehaviour&#123; public float moveSpeed = 3; private float h; private float v; public SpriteRenderer sr; void Start() &#123; sr = this.GetComponent&lt;SpriteRenderer&gt;(); &#125; void Update() &#123; h = Input.GetAxis(&quot;Horizontal&quot;); v = Input.GetAxis(&quot;Vertical&quot;); this.transform.Translate(Vector3.right * moveSpeed * Time.deltaTime * h); this.transform.Translate(Vector3.up * moveSpeed * Time.deltaTime * v); if (h &lt; 0) sr.flipX = true; else if (h &gt; 0) sr.flipX = false; &#125;&#125; 想将围墙的碰撞范围往外一点，以达到更好的角色移动视觉效果 在拿同样的图再次拖到TilePalette中生成右侧红框的，将其碰撞类型改为None，再用其覆盖掉里面那一圈 等距瓦片的角色跳跃问题 创建一个空物体Root，将角色设置为其子对象，然后将角色身上的Collider和rigidbody脚本移动到Root中 通过设置角色的y轴（相对root）来控制跳跃","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Tilemap","slug":"Tilemap","permalink":"http://example.com/tags/Tilemap/"}]},{"title":"25.TilePalette瓦片调色板窗口","slug":"游戏引擎/unity/unity核心/25.TilePalette瓦片调色板窗口","date":"2025-03-16T07:17:41.000Z","updated":"2025-03-16T10:32:08.201Z","comments":true,"path":"2025/03/16/游戏引擎/unity/unity核心/25.TilePalette瓦片调色板窗口/","permalink":"http://example.com/2025/03/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/25.TilePalette%E7%93%A6%E7%89%87%E8%B0%83%E8%89%B2%E6%9D%BF%E7%AA%97%E5%8F%A3/","excerpt":"","text":"瓦片调色板窗口使用 创建相关 Name：瓦片调色器名称 Grid：瓦片的网格布局 Rectangle：矩形瓦片 Hexagon：六边形瓦片 Hexagon Type：六边形瓦片地图类型 Point Top：点朝顶部的六边形 Flat Top：面朝顶部的六边形 Isometric：等距瓦片，单元格为菱形 Isometric Z as Y：等距瓦片并且Unity将单元格Z轴转换为局部Y坐标 （伪z轴） Cell Size：瓦片绘制到单元格的大小 Automatic：基于瓦片资源的精灵大小自动设置 Manual：自定义大小 操作技巧 单击瓦片——选择瓦片 在多个瓦片上移动——选择多个瓦片 Alt+左键拖动——平移 滚轮键拖动——平移 旋转滚轮键——放大/缩小 面板相关 编辑瓦片地图 现在场景中创建瓦片地图 可以在场景中再创建一个瓦片地图，作为天空层，设置层级比原来那层低。激活的瓦片地图要选择成天空层。可以框选天空的图片上去。 创建等距瓦片地图ISOmetric x y，拖拽资源进去，会发现资源和瓦片格子不适配。是因为原图片中心点造成的。把原图片中心点调成菱形的中心点。就对准了。 改为 在场景创建一个z和y的等距瓦片地图，直接把z和y等距的瓦片放上去会发现有点奇怪。 可以不改图片的轴心点来调整高低，关掉下面的锁定z位置然后按±来调整 不同的瓦片地图的作用 矩形瓦片地图用于做横版游戏地图 六边形瓦片地图用于做策略游戏地图 等距瓦片地图用于做有”Z”轴的2D游戏 注意： 在编辑等距瓦片地图时： 需要修改工程的自定义轴排序以Y轴决定渲染顺序。 如果地图存在前后关系需要修改TileRenderer的渲染模式。 可以通过Z轴偏移来控制绘制单个瓦片时的高度。（±） 精灵纹理的中心点会影响最终的显示效果。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Tilemap","slug":"Tilemap","permalink":"http://example.com/tags/Tilemap/"}]},{"title":"24.Tilemap瓦片资源","slug":"游戏引擎/unity/unity核心/24.Tilemap瓦片资源","date":"2025-03-16T06:45:40.000Z","updated":"2025-03-16T07:17:02.225Z","comments":true,"path":"2025/03/16/游戏引擎/unity/unity核心/24.Tilemap瓦片资源/","permalink":"http://example.com/2025/03/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/24.Tilemap%E7%93%A6%E7%89%87%E8%B5%84%E6%BA%90/","excerpt":"","text":"什么是Tilemap Tilemap，通常称为瓦片地图或平铺地图，是Unity2017中新增的功能。 Tilemap主要用于快速编辑2D游戏中的场景，通过复用资源的形式提升地图多样性。 Tilemap工作原理就是用一张张的小图排列组合为一张大地图。 Tilemap和SpriteShape的异同： 共同点：他们都是用于制作2D游戏的场景或地图的。 不同点： SpriteShape可以让地形有弧度，TileMap不行。 TileMap可以快捷制作有伪“Z”轴的地图，SpriteShape不行。 从PackageManager中引入Tilemap包 Tilemap的最小单位——“瓦片资源” 在Tile Palette瓦片调色板窗口创建。 打开Tile Palete平铺调色板 新建一个Palette 把Sprite直接拖到平铺调色板中，并选择保存的路径 参数相关 Preview：预览图 Sprite：瓦片关联的精灵纹理 Color：瓦片色调颜色 Collider Type：碰撞器类型 None：不生成碰撞器 Sprite精灵：基于精灵轮廓生成碰撞器形状 Grid网格：基于瓦片单元格生成碰撞器形状","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Tilemap","slug":"Tilemap","permalink":"http://example.com/tags/Tilemap/"}]},{"title":"23.SpriteShapeRenderer精灵形状渲染器和SpriteShapeController精灵形状控制器","slug":"游戏引擎/unity/unity核心/23.SpriteShapeRenderer精灵形状渲染器和SpriteShapeController精灵形状控制器","date":"2025-03-14T14:23:52.000Z","updated":"2025-03-16T06:43:17.900Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/23.SpriteShapeRenderer精灵形状渲染器和SpriteShapeController精灵形状控制器/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/23.SpriteShapeRenderer%E7%B2%BE%E7%81%B5%E5%BD%A2%E7%8A%B6%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8CSpriteShapeController%E7%B2%BE%E7%81%B5%E5%BD%A2%E7%8A%B6%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"","text":"回顾怎么使用精灵形状概述文件 创建一个关闭的精灵形状概述文件，设置好四个角度的图和下面八个角列表的图，直接拖拽到场景里。 精灵形状渲染器和控制器参数 Sprite Shape Renderer 精灵形状渲染器 该控件主要是控制 材质 颜色 以及和其它Sprite交互时的排序等等信息 Color：颜色 Mask Interaction：遮罩相互作用规则设置 Fill Material和Edge Material：填充材质和边缘材质 Sorting Layer和Order in Layer：排序相关 Sprite Shape Controller 精灵形状控制器 Profile：使用的精灵形状概述文件 Detail：精灵形状的质量 高中低三种质量 Is Open Ended：是否是开放的，不封闭的 封闭的 开放的 Adaptive UV：自适应UV 如果开启，会自动帮助我们判断是平铺还是拉伸 开启后只有宽度够才会平铺，如果宽度不够会拉伸 先拉伸 后平铺 不开启始终平铺，但是可能会出现裁剪效果 一般根据你的实际效果进行选择 Optimize Geometry：优化三角形数量 勾选后会最小化精灵图形中的三角形数量 Enable Tangents*：是否启用切线计算功能 如果你的着色器中需要切线信息参与计算，则勾选 Cache Geometry*：缓存几何体 一般不开启 Corner Threshold：角阈值 当拐角处的角度达到这个阈值（a）时将使用角图片 Stretch UV*：是否拉伸UV 如果勾选纹理的UV将伸展到整个精灵形状的直线上 在封闭里面拉伸 封闭区域里面平铺 Pixel Per Unit*：Unity单位对应多少像素 禁用拉伸UV时才有 较高的值会较少纹理的大小 Worldspace UV*：根据世界控件的UV填充纹理 启用编辑状态后 Tangent Mode ：切线模式 从左至右依次是： 顶点模式-点两侧不构成曲线 切线模式-点两侧构成曲线，并且可以控制切线弧度 左右切线模式-点两侧构成曲线，并且可以分别控制左右两侧切线弧度 Position：选中点的局部坐标位置 Height：控制点左右两侧精灵图片的高度 Corner：是否使用角度图片 Disabled：不使用角度图片 Automatic：自动 Sprite Variant：选择使用的精灵图片 Snapping*：是否开启捕捉设置控制点 生成碰撞器 使用边界碰撞器 使用多边形碰撞器 配合复合碰撞器 先添加多边形碰撞器 再添加复合碰撞器，并把多边形碰撞器应用于复合碰撞器","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"22.SpriteShapeProfile精灵形状概述文件","slug":"游戏引擎/unity/unity核心/22.SpriteShapeProfile精灵形状概述文件","date":"2025-03-14T13:49:03.000Z","updated":"2025-03-16T06:43:08.837Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/22.SpriteShapeProfile精灵形状概述文件/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/22.SpriteShapeProfile%E7%B2%BE%E7%81%B5%E5%BD%A2%E7%8A%B6%E6%A6%82%E8%BF%B0%E6%96%87%E4%BB%B6/","excerpt":"","text":"SpriteShape是用来做什么的 顾名思义，SpriteShape是用于定义精灵的形状。 从名称上难以确定其具体功能。 它主要用于节约美术资源，方便制作2D游戏场景地形或背景。 导入SpriteShape工具 在Package Manager中导入相关工具 可以选择性导入示例和拓展资源 准备并创建精灵形状概括资源 在Asset右键 Sprite Shape Profile参数 精灵形状概述文件配置 Use Sprite Borders：是否使用精灵边框 用于九宫格拉伸，默认勾选就行 Texture：用于填充实心部分的纹理 （使用的纹理的平铺模式必须是Repeat重复模式） Offset：纹理偏移量 一般不修改 Angle Ranges 拖入场景后 稍微改变一下 这里的设置主要用于封闭图形 在不同角度范围内使用的图片不同 可以达到一个封闭效果 Angle Ranges：角度范围 Start：起始角度 End：结束角度 Order：Sprite相交时的优先级，优先级高的显示在前面 Sprites：指定角度范围内的精灵列表 在该角度范围内，可以选择使用的图片资源 Corners：指定角显示的精灵图片 主要用于封闭图形 外部四个角用的图片 内部四个角用的图片 使用精灵形状概述资源创建地形 直接拖入到场景中就行 点右边的红框 选择一个起点可以改图","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"21.Effector2D效应器组件","slug":"游戏引擎/unity/unity核心/21.Effector2D效应器组件","date":"2025-03-14T12:40:49.000Z","updated":"2025-03-14T13:44:59.881Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/21.Effector2D效应器组件/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/21.Effector2D%E6%95%88%E5%BA%94%E5%99%A8%E7%BB%84%E4%BB%B6/","excerpt":"","text":"2d效应器是什么 2D效应器是配合2D碰撞器一起使用，可以让游戏对象在相互接触时产生一些特殊的物理作用力。 通过2D效应器，可以快捷的实现一些传送带、互斥、吸引、漂浮、单向碰撞等等效果。 各种2d效应器参数 要想将一个Sprite的表示成一个效应器，要添加一个Collider和任意一个Effector2d，isTrigger和used by Effector都要打开 Area Effector区域效应器 主要作用：在一个区域内让游戏对象受到力和扭矩力的作用 Use Collider Mask：是否启用碰撞器遮罩 如果开启才会出现下面的Collider Mask，可以通过选择层，决定该效应器只会作用于哪些层的对象 Use Global Angle：是否使用世界坐标系角度 如果不勾选，角度为局部角度 Force Angle：施加力的角度 Force Magnitude：施加力的大小 Force Variation：施加力的随机大小变化 会在 ± Force Magnitude基础上根据该值进行随机变化 ForceTarget：效应器在目标对象上施加力的作用点 Collider：以碰撞器的当前位置（如果碰撞器有偏移，没有位于质心，可能会产生扭矩力，带来旋转） Rigidbody：以刚体的当前质心（不会产生扭矩力） Drag：阻力 Angular Drag：扭矩阻力 Buoyancy Effector浮力效应器 主要作用：模拟流体行为，浮动和阻力相关设置，让玩家在该区域看起来像在水里移动 Density：流体密度 密度较大，碰撞体会下沉，密度越小碰撞体会上浮 密度和流体相同的碰撞体会浮在流体中 Surface Level：定义浮力流体的表面位置 对象高于此线时，不会对其施加浮力，以下或者相交会施加浮力。沿世界Y轴偏移 Linear Drag：对象在水中移动的阻力系数 Angular Drag：对象在水中旋转的阻力系数 Flow Angle： 流体流动方向相对世界控件的角度，沿指定方向施加浮力 Flow Magnitude： 与FlowAngle结合使用，前者决定力的角度，该值确定浮力大小 Flow Variation： 随机改变流体力的值 Point Effector 点效应器 主要作用：模拟磁铁 吸引或者排斥的效果 Force Magnitude：力的大小 Force Variation：力的大小变化 Distance Scale：效应器和目标之间距离的缩放。 计算距离时，会按该比值对距离进行缩放 Force Source：力来源 从该点计算距离。 Collider：碰撞器的位置 Rigidbody：刚体的位置 Force Target：作用力目标位置 用改点计算位置 Collider：碰撞器的位置，如果碰撞器有偏移，可能会产生扭矩力 Rigidbody：刚体的位置，不会产生扭矩力 Force Mode：计算力的模式 Constant：忽略源和目标之间相隔的距离 Inverse Linear：反线性距离计算，距离越远，力的大小呈线性减小 Inverse Squared：反平方距离计算，力的大小呈指数减小（按平方下降），类似现实世界重力 Platform Effector平台效应器 平台效应器的碰撞器可以不做成Trigger 主要作用：2D游戏当中的平台或可往上跳跃的墙壁 Rotational Offset：旋转偏移量 控制平台角度偏移 Use One Way：是否使用单向碰撞行为 一般勾选，不勾选的话从下面跳不上去 Use One Way Grouping： 当平台式有多个碰撞器组合时，可以通过它将所有碰撞器设置为单向碰撞行为 Surface Arc：以局部坐标系下向上的方向为中心，填写一个角度值，定义不允许通过的表面，该角度外的其它地方视为单向碰撞 Use Side Friction：是否应该在平台两侧使用摩擦 Use Side Bounce：是否应该在平台两侧使用弹性 Side Arc：用于定义左右两侧平台的响应弧度 下面红弧就是平台两侧的作用范围 Surface Effector 表面效应器 表面效应器也不用开Trigger 主要作用：模拟传送带 Speed：表面保持的速度 Speed Variation：速度的随机增加值 Force Scale：缩放沿表面移动时施加的力。 如果是0表示不施加力，相当于禁用。值越低越慢，值越高越快，建议不要设置为1，因为当设置为1时可能会抵消施加在物体上的其它力，比如跳跃的力 Use Contact Force：是否对接触物体表面的出点施加力 如果选择会让对象旋转（打滚），如果不开启则不会旋转 Use Friction：是否使用摩擦力 Use Bounce：是否使用弹力 总结 效应器其实只是Unity为我们写好的一些2D游戏中常用功能的一些代码。在实际开发中我们不应该过于依赖效应器。如果发现效应器和自己的游戏需求不太匹配时，我们完全可以自己实现符合需求的“效应器”。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"2d物理系统","slug":"2d物理系统","permalink":"http://example.com/tags/2d%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"20.ConstantForce2D恒定力组件","slug":"游戏引擎/unity/unity核心/20.ConstantForce2D恒定力组件","date":"2025-03-14T12:33:05.000Z","updated":"2025-03-14T12:39:56.505Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/20.ConstantForce2D恒定力组件/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/20.ConstantForce2D%E6%81%92%E5%AE%9A%E5%8A%9B%E7%BB%84%E4%BB%B6/","excerpt":"","text":"什么是恒定力 恒定力是一个特殊的脚本。 它可以给一个2D刚体持续添加一个力。 在做一些随着时间推移而加速的对象时很适用，比如类似火箭发射等效果。 恒定力脚本会线性地为对象添加力和扭矩力，让其移动和旋转。 恒定力脚本参数 Force：物理更新时施加于2D刚体上的线性力。 Relative Force：物理更新时施加的线性力（相对刚体对象坐标系）。 Torque：物理更新时施加于2D刚体的扭矩力。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"2d物理系统","slug":"2d物理系统","permalink":"http://example.com/tags/2d%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"19.PhysicsMaterial2D物理材质","slug":"游戏引擎/unity/unity核心/19.PhysicsMaterial2D物理材质","date":"2025-03-14T12:22:17.000Z","updated":"2025-03-14T12:30:27.144Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/19.PhysicsMaterial2D物理材质/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/19.PhysicsMaterial2D%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/","excerpt":"","text":"什么是物理材质 物理材质是用于决定在物体产生碰撞时这些物体之间的摩擦和弹性表现的。 通过物理材质，我们可以做出类似斜坡不滑落，小球反弹等效果。 创建物理材质 参数 Dynamic Friction 动摩擦，为0表示没摩擦 Static Friction 静摩擦 Bounciness 反弹程度，0表示没有弹力，1表示完美弹力无能量损失 Friction Combine 决定了两个碰撞体接触时，它们之间动摩擦力（Dynamic Friction）和静摩擦力（Static Friction）的组合方式。 Bounce Combine 确定两个碰撞体接触时，它们之间弹力（Bounciness）的组合方式。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"2d物理系统","slug":"2d物理系统","permalink":"http://example.com/tags/2d%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"18.Collision2D碰撞器和碰撞检测函数","slug":"游戏引擎/unity/unity核心/18.Collision2D碰撞器和碰撞检测函数","date":"2025-03-14T08:11:14.000Z","updated":"2025-03-14T12:21:23.295Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/18.Collision2D碰撞器和碰撞检测函数/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/18.Collision2D%E7%A2%B0%E6%92%9E%E5%99%A8%E5%92%8C%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/","excerpt":"","text":"碰撞器是用来干嘛的 碰撞器是用于在物理系统中表示物体体积的的（形状或范围）。 刚体通过得到碰撞器的范围信息进行计算，判断两个物体的范围是否接触。 如果接触，刚体就会模拟力的效果产生速度和旋转。 2d碰撞器参数 圆形碰撞器 Material：物理材质 用于确定碰撞的属性，控制摩擦和弹性 Is Trigger：是否是触发器 Used By Effector：是否被附加的2D效应器使用 Offset：圆心偏移位置 Radius：圆形的半径 2.盒状碰撞器 Use by Composite 由复合使用 如果勾选，则该碰撞器将附加到2D复合碰撞器中使用。 勾选后将消失一些属性，这些属性将在复合碰撞器中配置。 Auto Tiling 自动拼接 如果SpriteRender精灵渲染器组件中的DrawMode设置为Tiled平铺模式。勾选该选项后，当改变精灵大小时将自动更新碰撞器的尺寸。 Edge Radius 边缘半径 使四个定点为圆角。 3.多边形碰撞器 虽然可以手动修改，但是一般情况下 我们通过数值编辑太复杂了 都通过Edit Collider编辑，或者让Unity自动识别创建 4.边界碰撞器 由线段组成的范围 一般用来做地形 边界碰撞器的编辑主要还是通过Edit Collider 一般不会手动去通过数值加点 5.胶囊碰撞器 Size：胶囊的宽高 Direction：竖直还是水平胶囊 6.复合碰撞器 由复数个碰撞器组成，一定要有个刚体组件 给他们添加一个父物体，并添加复合碰撞器 Geometry Type：几何学类型 合并碰撞体时，碰撞体顶点将组合为两种不同的几何体类型 Outlines：空心轮廓，类似边界碰撞器 Polygons：实心多边形，类似多边形碰撞器 Generation Type：生成类型 复合碰撞器在何时生成新几何体 Synchronous：对2D复合碰撞器或使用的其它碰撞器修改时，Unity立即生成新几何体 Manual：手动生成新几何体，通过代码生成或者点击下发的Regenerate Geometry生成按钮 Vertex Distance：最小间距值 从复合碰撞器收集顶点时允许的最小间距值 碰撞检测函数 碰撞检测函数和3D碰撞检测函数除了名字不同外其他基本一致。 在这里只简单讲解不赘述，它是非常重要的知识点。 1234567891011121314151617181920212223private void OnCollisionEnter2D(Collision2D collision)&#123;&#125;private void OnCollisionExit2D(Collision2D collision)&#123;&#125;private void OnCollisionStay2D(Collision2D collision)&#123; &#125;private void OnTriggerEnter2D(Collider2D collision)&#123;&#125;private void OnTriggerExit2D(Collider2D collision)&#123;&#125;private void OnTriggerStay2D(Collider2D collision)&#123;&#125; 练习 在之前练习题的基础上，请用2D刚体和碰撞器制作一个玩家，它可以在一个平台上移动跳跃。（注意：移动和跳跃都通过刚体的API进行制作，类似3D物理系统中刚体加力和给速度，之前练习题是通过直接改变坐标移动位置的） 给Player添加碰撞体和刚体，创建几个方形精灵图片添加盒型碰撞器作为要跳跃的平台 记得把角色的z轴旋转关了 1234567891011121314151617181920212223242526272829303132333435363738394041public class PlayerObj : MonoBehaviour&#123; // 玩家移动速度 public float moveSpeed = 5; private float h; private SpriteRenderer sr; private Rigidbody2D rb; void Start() &#123; sr = this.GetComponent&lt;SpriteRenderer&gt;(); &#125; void Update() &#123; // 获取水平方向输入值 h = Input.GetAxis(&quot;Horizontal&quot;); rb = GetComponent&lt;Rigidbody2D&gt;(); rb.velocity = new Vector2(h * moveSpeed, rb.velocity.y); //改变刚体速度 // 如果h小于0，则设置sr.flipX为true，否则如果h大于0，则设置sr.flipX为false if (h &lt; 0) sr.flipX = true; else if (h &gt; 0) sr.flipX = false; // 检查是否按下了空格键 if (Input.GetKeyDown(KeyCode.Space)) &#123; //创建子弹预设体 GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;BulletObj&quot;), this.transform.position + new Vector3(sr.flipX ? -0.3f : 0.3f, 0.5f, 0), Quaternion.identity); //告诉子弹应该朝哪里动 obj.GetComponent&lt;BulletObj&gt;().ChangeMoveDir(sr.flipX ? Vector3.left : Vector3.right); &#125; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"2d物理系统","slug":"2d物理系统","permalink":"http://example.com/tags/2d%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"17.Rigidbody2D刚体","slug":"游戏引擎/unity/unity核心/17.Rigidbody2D刚体","date":"2025-03-14T07:34:15.000Z","updated":"2025-03-14T08:07:16.054Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/17.Rigidbody2D刚体/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/17.Rigidbody2D%E5%88%9A%E4%BD%93/","excerpt":"","text":"学习2D物理系统的前提 学习2D物理系统之前建议先学习Unity入门当中的3D物理系统，因为它们非常的类似。 由于我们之前详细讲解了3D物理系统，所以在讲解2D物理系统时会相对简洁一些，一些讲过的知识点就不过多赘述了。 2D物理系统中的刚体组件 刚体是物理系统中用于帮助我们进行模拟物理碰撞中力的效果的。 2D物理系统中的刚体和3D中的刚体基本是一样的，最大的区别是对象只会在XY平面中移动，并且只在垂直于该平面的轴上旋转。 碰撞产生的条件和3D是一样的，都是必须要两个碰撞器，和至少一个刚体rigidbody2d 刚体组件 Dynamic：动态类型 受重力和力的影响移动和旋转 Material：物理材质 在刚体上设置了物理材质，如果子物体有碰撞器但是没有设置材质则会通用刚体的物理材质 如果不设置，将使用在Physics 2D窗口中设置的默认材质 碰撞器Collider和刚体rigidbody都有Material物理材质？ 一般在碰撞器上设置 rigidbody有子物体，子物体就默认使用父物体刚体的材质 物理材质的使用优先级 2D碰撞器上指定的2D物理材质 2D刚体上指定的2D物理材质 Physics 2D窗口指定的2D默认物理材质 Simulated：模拟的 默认开启就行 如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果 需要启用该选项 Use Auto Mass：是否使用自动质量 一般不开，不准 Mass：质量 Linear Dray：影响位置移动的阻力系数 Angular Drag：影响旋转移动的阻力系数 Gravity Scale：受重力影响的程度 Collision Detection：碰撞检测算法 Discrete：离散检测算法，只会用新位置进行计算，速度过快时会穿过 Continuous：连续检测算法，计算量更大，但是不会发生穿过的情况 Sleeping Mode：对象处于静止状态时进入睡眠模式 Never Sleep：从不休眠，会一直进行检测计算，性能消耗较大 Start Awake：最初处于唤醒状态 Start Asleep：最初处于睡眠状态，但是可以被碰撞唤醒 Interpolate：物理更新间隔之间的插值运算 None：不应用移动平滑 Interpolate：根据前一帧进行平滑处理 Extrapolate：根据后一帧位置进行平滑处理 Constraints：约束限制 可以让某一个轴不受力影响位移或者旋转 Kinematic：运动学类型 不受力的影响，只能通过代码让其动起来 能和Dynamic 2D刚体产生碰撞，但是不会动，只会进入碰撞检测函数 因此它没有了质量莫摩擦系数等属性 因此它的性能能消耗较低，主要会通过代码来处理其移动旋转 Simulated：模拟的 如果希望2D刚体以及所有子对象2D碰撞器和2D关节都能模拟物理效果 需要启用该选项 当启用时，会充当一个无限质量的不可移动对象，可以和所有2D刚体产生碰撞 如果Use Full Kinematic Contacts禁用，它只会和Dynamic 2D刚体碰撞 Use Full Kinematic Contacts： 如果希望能和所有2D刚体碰撞，启用它 如果不启用，它不会和Kinematic 2D和Static 2D刚体碰撞 Static：静态类型 完全不动的需要检测碰撞的对象 相当于是无限质量不可移动的对象 它的性能消耗最小，它只能和Dynamic 2D刚体碰撞 和它类似的有只加碰撞器而不加刚体的物体 它们会和刚体物体产生碰撞，但是自己不会动 如何选择不同类型的刚体 Dynamic动态刚体：受力的作用，要动要碰撞的对象。 Kinematic运动学刚体：通过刚体API移动的对象，不受力的作用，但是想要进行碰撞检测。 Static静态刚体：不动不受力作用的静态物体，但是想要进行碰撞检测（只能和Dynamic动态刚体进行检测）。 刚体API 12345678// GetComponent() 得到 2D 刚体Rigidbody2D rigid = this.GetComponent&lt;Rigidbody2D&gt;();// Rigidbody2D.AddForce方法 加力rigid.AddForce(new Vector2(0, 100));// Rigidbody2D.velocity属性 刚体速度rigid.velocity = new Vector2(1, 0);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"2d物理系统","slug":"2d物理系统","permalink":"http://example.com/tags/2d%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"16.SpriteAtlas精灵图集","slug":"游戏引擎/unity/unity核心/16.SpriteAtlas精灵图集","date":"2025-03-14T06:38:40.000Z","updated":"2025-03-14T07:30:53.090Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/16.SpriteAtlas精灵图集/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/16.SpriteAtlas%E7%B2%BE%E7%81%B5%E5%9B%BE%E9%9B%86/","excerpt":"","text":"为什么要打图集 打图集的目的就是减少DrawCall 提高性能 在2D游戏开发，以及UI开发中是会频繁使用的功能 平时做游戏直接用，到最后游戏要打包的时候做图集就行了 ps：打图集是将小图合并成图集，和使用图集不同10.SpriteEditor之Multiple 在Unity中打开自带的打图集功能 在工程设置面板中选择Edit -&gt; Project Setting -&gt; Editor来打开Sprite Packer。 Disabled：默认设置，不会打包图集。假如创建不是2D项目可能就是这个选项。 Enabled For Builds（Legacy Sprite Packer）：Unity仅在构建时打包图集，在编辑模式下不会打包图集。 Always Enabled（Legacy Sprite Packer）：Unity在构建时打包图集，在编辑模式下运行前会打包图集。 Legacy Sprite Packer传统打包模式相对于下面两种模式来说，多了一个设置图片之间的Padding Power间隔距离。Padding Power选项用于选择打包算法在计算打包的精灵之间以及精灵与生成的图集边缘之间的间隔距离。这里的数字代表2的n次方。 Enabled For Build：Unity仅在构建时打包图集，在编辑器模式下不会打包。 Always Enabled：Unity在构建时打包图集，在编辑模式下运行前会打包图集。 创建图集 图集参数 Type：图集类型 Master：主图集 Variant：变体类型的图集 Include in Build：选中可以在当前构建中包含图集 一般默认勾选就行 Allow Rotation：允许图片旋转 选中此选项将在打包图集时对图片元素进行旋转，可以最大限度提高组合后的图集密度； 注意！！！如果是UI图集，请禁用此选项，因为打包时会将场景中UI元素旋转 Tight Packing：紧密包装 选中此选项在打包图集时使用图片轮廓来打包而不是根据矩形，可以最大限度提高组合后的图集密度 Padding 填充：图集中各图片的间隔像素 Variant*：变体类型的图集（用很少） 就是在一个图集之上产生的变体副本，一般用的很少 Master Atlas：关联的主图集（图集类型必须是Master） Include in Build：选中可以在当前构建中包含图集 Scale：设置变体图集的缩放因子（0~1），变体图集的大小是主图集乘以Scale的结果 变体图集的主要作用是以主图集为基础，对它进行缩放产生一个新的图集副本。如果想使用变体图集中的内容，只需要勾选变体图集的Include in build选项，而主图集禁用此选项即可 Read/Write Enabled： 6.纹理高级设置 允许通过脚本访问纹理数据。如果启用，会创建纹理数据的副本。会让内存翻倍，一般情况下不需要开启它 Generate Mip Maps：生成Mipmap Mipmap是一种性能优化手段，用内存换性能。一般情况下不用开启 SRGB：伽马矫正 启用此属性可指定将纹理存储在伽马空间中。对于非 HDR 颜色纹理（例如反照率和镜面反射颜色），应始终选中此复选框。如果纹理存储了有特定含义的信息，并且您需要着色器中的确切值（例如，平滑度或金属度），请禁用此属性。 默认情况下会启用此属性。 Filter Mode：纹理在3D变化拉伸时如何进行过滤 7.纹理平铺拉伸设置 Point：纹理靠近时变为块状 Bilinear：纹理靠近时变得模糊 Trilinear：与Bilinear类似，但是纹理在不同的MIP级别之间模糊 Objects for Packing：关联打图集的图片们 注意： 一定是Sprite类型的图片 可以直接拖一个文件夹 Default Max Texture Size：纹理的最大尺寸，像素为单位 Format：指定纹理的内部表示 在不同平台上会有不同的参数 Compression：纹理压缩类型 不压缩 低质量 普通质量 高质量 质量越高占用内存越多，不压缩质量最好 Use Crunch Compression：使用Crunch压缩 是一种有损压缩格式，压缩耗时长，但是运行时解压速度快 Compressor Quality：压缩质量，质量越高纹理越大，耗时越长 观察Drawcall数量 带卡Stats状态面板来观察Batches 运行后 代码控制 怎么通过代码加载图集中的某一资源？ 然后显示在场景中 12345678910111213GameObject gameObject = new GameObject();// 添加一个SpriteRenderer组件SpriteRenderer sr = gameObject.AddComponent&lt;SpriteRenderer&gt;();// SpriteAtlas类要引用UnityEngine.U2D命名空间// 加载名为&quot;MyAtlas&quot;的SpriteAtlas资源SpriteAtlas spriteAtlas = Resources.Load&lt;SpriteAtlas&gt;(&quot;MyAtlas&quot;);//SpriteAtlas中的GetSprite方法 获得图集中的图//克隆此图集中与打包的名称匹配的第一个 Sprite 并将其返回。// 从图集中获取名为&quot;dead1&quot;的小图sr.sprite = spriteAtlas.GetSprite(&quot;dead1&quot;);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"15.SortingGroup排序分组","slug":"游戏引擎/unity/unity核心/15.SortingGroup排序分组","date":"2025-03-14T06:26:21.000Z","updated":"2025-03-14T06:37:42.856Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/15.SortingGroup排序分组/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/15.SortingGroup%E6%8E%92%E5%BA%8F%E5%88%86%E7%BB%84/","excerpt":"","text":"SortingGroup是什么 SortingGroup（排序分组）就如其名，是用于对多个精灵图片进行分组排序的组件。 它的主要作用是管理和排序同一组内的精灵，使它们的渲染顺序保持一致，就好像它们是单个游戏对象一样。 主要用于分层管理，特别适用于2D游戏开发中需要整体排序的场景。 SortingGroup的使用 创建一个空物体，然后添加SortingGroup组件。 设置图层和图层顺序，用于管理该物体下所有子物体的排序。 注意： 子物体也可以添加SortingGroup脚本，但整体子物体先受父对象的影响再受到你同一级的影响（子排序组先排序子对象，然后再和同层的其他对象进行比较（即同层和同层比））。 SortingGroup脚本比SpriteRenderer上面的Sorting Layer相关的要更加优先 在多个预设体中挂载SortingGroup组件时，可以通过修改排序索引号来决定它们的前后顺序。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"14.SpriteMask精灵遮罩","slug":"游戏引擎/unity/unity核心/14.SpriteMask精灵遮罩","date":"2025-03-14T03:18:37.000Z","updated":"2025-03-14T06:25:30.952Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/14.SpriteMask精灵遮罩/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/14.SpriteMask%E7%B2%BE%E7%81%B5%E9%81%AE%E7%BD%A9/","excerpt":"","text":"SpriteMask是什么 顾名思义，SpriteMask是精灵遮罩的意思 它的主要作用就是对精灵图片产生遮罩 制作一些特殊的功能，比如只显示图片的一部分让玩家看到 SpriteMask创建 Sprite Mask参数 Sprite：遮罩图片 Alpha Cutoff：Alpha修剪 如果Alpha包含透明区域和不透明区域之间的混合（半透明），则可以手动确定所显示区域的分界点（0~1） Custom Range：自定义遮罩范围 当场景上有不同的遮罩，不同的遮罩控制的图范围是不一样的 开启后可以设置遮罩的范围，按照排序层来划分 如果想要图片受到遮罩的影响 那么图片的排序层+排序数 应处于[遮罩的back, 遮罩的front] 练习 制作一个类似放大镜的功能 创建两个小猪图片，一大一小，大的比例是2，小的是1，位置调整的一样。大的层级比小的更高，并且设置成遮罩中可见。 给放大镜添加一个遮罩（层级更高）","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"13.SpriteCreator精灵创造者","slug":"游戏引擎/unity/unity核心/13.SpriteCreator精灵创造者","date":"2025-03-14T02:57:48.000Z","updated":"2025-03-14T03:17:47.596Z","comments":true,"path":"2025/03/14/游戏引擎/unity/unity核心/13.SpriteCreator精灵创造者/","permalink":"http://example.com/2025/03/14/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/13.SpriteCreator%E7%B2%BE%E7%81%B5%E5%88%9B%E9%80%A0%E8%80%85/","excerpt":"","text":"SpriteCreator是什么 顾名思义，Sprite Creator是精灵创造者 我们可以利用Sprite Editor的多边形工具创造出各种多边形 Unity也为我们提供了现成的一些多边形 它的主要作用是2D游戏的替代资源 在等待美术出资源时我们可以用他们作为替代品 有点类似Unity提供的自带几何体 替代资源是做demo和学习时的必备品 使用Sprite Creator 在Project窗口右键创建各种形状的Sprite精灵图片 这样创建出来图可以用于美术还没做好时的替代资源。当出来正式图进行替代就行。有点类似3D场景创建立方体那些基本模型。之后可能也用于遮罩的基本图。 练习 使用替代资源，制作一个按空格键让角色发射子弹的功能 创建BulletObj脚本，添加到子弹预制体上。用于控制子弹对象的移动。设置子弹移动的速度和子弹当前的移动方向变量。3秒后销毁子弹对象。创建ChangeMoveDir方法，用于改变子弹的移动方向。接受一个参数dir表示新的移动方向。将nowDir字段设置为新的移动方向。 1234567891011121314151617181920212223242526public class BulletObj : MonoBehaviour&#123; public float moveSpeed; private Vector3 nowDir; void Start() &#123; // 在3秒后销毁子弹对象 Destroy(this.gameObject, 3); &#125; // 改变子弹的移动方向 public void ChangeMoveDir(Vector3 dir) &#123; // 设置新的移动方向 nowDir = dir; &#125; // Update方法在每一帧中都会被调用 void Update() &#123; // 移动子弹对象 this.transform.Translate(moveSpeed * Time.deltaTime * nowDir); &#125;&#125; 在PlayerObj.cs 12345678// 检查是否按下了空格键if (Input.GetKeyDown(KeyCode.Space))&#123; //创建子弹预设体 GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;BulletObj&quot;), this.transform.position + new Vector3(sr.flipX ? -0.3f : 0.3f, 0.5f, 0), Quaternion.identity); //告诉子弹应该朝哪里动 obj.GetComponent&lt;BulletObj&gt;().ChangeMoveDir(sr.flipX ? Vector3.left : Vector3.right);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"12.SpriteRenderer精灵渲染器","slug":"游戏引擎/unity/unity核心/12.SpriteRenderer精灵渲染器","date":"2025-03-13T13:04:14.000Z","updated":"2025-03-14T02:56:37.356Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/12.SpriteRenderer精灵渲染器/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/12.SpriteRenderer%E7%B2%BE%E7%81%B5%E6%B8%B2%E6%9F%93%E5%99%A8/","excerpt":"","text":"知识回顾 我们目前已经学习了如何设置导入的图片 如果我们想将导入的图片用于2D游戏开发，需要将图片类型设置为 Sprite精灵类型 我们还学习了使用Sprite Editor精灵图片编辑器来对精灵图片进行编辑 但是我们还没有真正的使用这些图片 这节课我们就来讲解Sprite精灵图片的使用 Sprite Renderer 是什么 顾名思义，Sprite Renderer是精灵渲染器 是一个组件 所有2D游戏中游戏资源（除UI外）都是通过Sprite Renderer让我们看到的 它是2D游戏开发中的一个极为重要的组件 2D对象创建 直接拖入Sprite图片 右键创建 关联想要的图片 空物体添加脚本 Sprite Renderer Sprite：渲染的精灵图片 Color*：定义着色，一般没有特殊需求不会修改 Filp：水平或竖直翻转精灵图片 通过transform也可以改变水平反转的效果的 Draw Mode： 绘制模式，当尺寸变化时的缩放方式 Simple：简单模式，缩放时整个图像一起缩放 Sliced：切片模式 9宫格切片模式，十字区域缩放，4个角不变化 一般用于变化不大的纯色图 （注意：需要把精灵的网格类型设置为Full Rect） Tiled：平铺模式 将中间部分进行平铺而不是缩放 （注意：需要把精灵的网格类型设置为Full Rect） Continuous：当尺寸变化时，中间部分将均匀平铺 Adaptive：当尺寸变化时，类似Simple模式，当更改尺寸达到Stretch Value时，中间才开始平铺 Mask Interaction：与精灵遮罩交互时的方式 None：不与场景中任何精灵遮罩交互 Visible inside Mask：精灵遮罩覆盖的地方可见 而遮罩外部不可见 Visible Outside Mask：精灵遮罩外部的地方可见 而遮罩覆盖处不可见 Sprite Sort Point*： 计算摄像机和精灵之间距离时，使用精灵中心Center还是轴心点Pivot，一般情况下不用修改 Material*：材质 可以使用一些自定义材质来显示一些特殊效果 一般情况不修改。默认材质是不会受到光照影响的，如果想要受光照影响，可以选择Default-Diffuse Additional Settings：高级设置 Sorting Layer：排序层选择 排序层一样的话会，谁先显示谁后显示是受z轴影响的 可以新增加排序层，排序层越前，显示越前面，会越后面渲染 Order in Layer：层级序列号，数值越大约会显示在前面 先会比较排序图层，再比较图层顺序的 代码相关 12345678910111213141516//新建空物体GameObject gameObject = new GameObject();//添加精灵渲染器组件SpriteRenderer spriteRenderer = gameObject.AddComponent&lt;SpriteRenderer&gt;();//SpriteRenderer类中sprite变量 当前渲染的精灵图片 传入精灵图片名字//要渲染的精灵。//动态的改变图片spriteRenderer.sprite = Resources.Load&lt;Sprite&gt;(&quot;dead1&quot;);//动态的加载 图集中的图 传入图集名字Sprite[] sprites = Resources.LoadAll&lt;Sprite&gt;(&quot;RobotBoyIdleSprite&quot;);//动态的改变成图集中的图片spriteRenderer.sprite = sprites[10];print(sprites[10].name);//RobotBoyIdleSprite_10 总结 主要掌握参数含义 和 如何代码控制 其中重要的参数是 绘制模式 控制缩放规则 遮罩相关 层级相关 练习 写一个工具类，让我们可以更加方便的加载Multiple类型的图集资源（提示：提供个方法给外部，传入一个图集名字和这个单张图的名字） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Multiple类型的图集管理类public class MultipleMgr&#123; private static MultipleMgr instance = new MultipleMgr(); public static MultipleMgr Instatnce =&gt; instance; private MultipleMgr() &#123;&#125; //存储 大图对应的小图资源的信息 的字典 private Dictionary&lt;string, Dictionary&lt;string, Sprite&gt;&gt; dic = new Dictionary&lt;string, Dictionary&lt;string, Sprite&gt;&gt;(); /// &lt;summary&gt; /// 获取Multiple图集中的某一张小图 /// &lt;/summary&gt; /// &lt;param name=&quot;multipleName&quot;&gt;图集名&lt;/param&gt; /// &lt;param name=&quot;spriteName&quot;&gt;单张图片名&lt;/param&gt; /// &lt;returns&gt;返回获取到的Sprite&lt;/returns&gt; public Sprite GetSprite(string multipleName, string spriteName) &#123; //判断是否加载过该大图 if (dic.ContainsKey(multipleName)) &#123; //判断大图中是否有该小图的信息 有的话直接返回 if (dic[multipleName].ContainsKey(spriteName)) return dic[multipleName][spriteName]; &#125; else &#123; //加载该大图 Dictionary&lt;string, Sprite&gt; dicTmp = new Dictionary&lt;string, Sprite&gt;(); Sprite[] sprs = Resources.LoadAll&lt;Sprite&gt;(multipleName); //将其对应的小图信息存储到字典中 for (int i = 0; i &lt; sprs.Length; i++) &#123; dicTmp.Add(sprs[i].name, sprs[i]); &#125; dic.Add(multipleName, dicTmp); if (dicTmp.ContainsKey(spriteName)) return dicTmp[spriteName]; &#125; return null; &#125; /// &lt;summary&gt; /// 清空字典中的信息，并卸载未使用的资源 /// &lt;/summary&gt; public void ClearInfo() &#123; //清空字典中的信息 dic.Clear(); //卸载未使用的资源 Resources.UnloadUnusedAssets(); &#125;&#125; 用提供的角色资源，制作一个通过wasd键 控制其上下左右移动的功能 将要设置的Sprite的轴心设置为脚底一般 12345678910111213141516171819202122232425262728public class PlayerObj : MonoBehaviour&#123; // 玩家移动速度 public float moveSpeed = 5; private float h; private SpriteRenderer sr; void Start() &#123; sr = this.GetComponent&lt;SpriteRenderer&gt;(); &#125; void Update() &#123; // 获取水平方向输入值 h = Input.GetAxis(&quot;Horizontal&quot;); // 移动玩家对象 this.transform.Translate(5 * Time.deltaTime * Vector3.right * h); // 如果h小于0，则设置sr.flipX为true，否则如果h大于0，则设置sr.flipX为false if (h &lt; 0) sr.flipX = true; else if (h &gt; 0) sr.flipX = false; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"11.SpriteEditor之Polygon多边形编辑","slug":"游戏引擎/unity/unity核心/11.SpriteEditor之Polygon多边形编辑","date":"2025-03-13T12:58:09.000Z","updated":"2025-03-13T13:02:43.419Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/11.SpriteEditor之Polygon多边形编辑/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/11.SpriteEditor%E4%B9%8BPolygon%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%BC%96%E8%BE%91/","excerpt":"","text":"Polygon多边形编辑 如果我们使用的资源是多边形资源，我们可以在设置时将模式设置为Polygon，然后可以在Sprite Editor中进行快捷设置。 但是一般这种模式在实际开发中使用较少。 参数讲解 进入SpriteEditor，修改Sides （3~128） 可以填完数字后再切换Outline自动设置渲染范围","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"10.SpriteEditor之Multiple","slug":"游戏引擎/unity/unity核心/10.SpriteEditor之Multiple","date":"2025-03-13T12:40:11.000Z","updated":"2025-03-13T12:55:38.657Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/10.SpriteEditor之Multiple/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/10.SpriteEditor%E4%B9%8BMultiple/","excerpt":"","text":"Multiple图集元素分割 当我们的图片资源是图集时，我们需要在设置时将sprite mode 设置为Multiple。这时我们可以使用Sprite Editor自带的功能进行图集元素分割。 参数 自动分割 Pivot：单张图片轴心点位置 Custom Pivot：自定义轴心点 Method：如何处理现有对象 如果有自己鼠标自行的分割该如何处理 Delete Existing：替换掉已经选择的任何矩形 Smart：尝试创建新矩形同时保留或调整现有矩形 Safe：添加新矩形而不更改任何已经存在的矩形 按单元格大小分割 Pixel Size：单元格宽高 Offset：偏移位置 Padding：和边缘的偏移位置 Keep Empty Rects：是否保留空矩形 其它两种模式一般都不用","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"9.SpriteEditor之Single","slug":"游戏引擎/unity/unity核心/9.SpriteEditor之Single","date":"2025-03-13T09:36:39.000Z","updated":"2025-03-13T12:45:24.067Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/9.SpriteEditor之Single/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/9.SpriteEditor%E4%B9%8BSingle/","excerpt":"","text":"SpriteEditor是什么？ SpriteEditor就是精灵图片编辑器。它主要用于编辑2D游戏开发中使用的Sprite精灵图片。它可以用于编辑图集中提取元素，设置精灵边框，设置九宫格，设置轴心（中心）点等等功能。打开SpriteEditor需要把一张图片的纹理类型切换成Sprite模式。 引入SpriteEditor 如果一开始是一个3d的工程，需要安装2D Sprite包才能使用SpriteEditor。 可以点击SpriteEditor按钮跳转下载或者直接打开PackageManager搜索2DSprite并导入。 Single图片编辑 功能讲解 Single图片编辑主要讲解的就是在设置图片时 将精灵图片模式（Sprite Mode）设置为Single的精灵图片在Sprite Editor窗口中如何编辑 打开sprite editor Sprite Editor Sprite Editor右下角设置窗口 Name：图片名字 Position：在图片中的偏移位置和宽高 Border：边框，用于设置九宫格的4条边 用一些切片模式就会用到 Pivot：轴心（中心）点位置 Pivot Unit Mode：轴心点单位模式 Normalized：标准化模式，0~1 Pixels：像素模式 Custom Pivot：自定义轴心点 Custom Outline 自定义边缘线 自定义边缘线设置，可以自定义精灵网格的轮廓形状。默认情况下不修改都是在矩形网格上渲染4.纹理类型设置，边缘外部透明区域会被渲染，浪费性能。使用自定义轮廓，可以调小透明区域，提高性能。 Snap：将控制点贴近在最近的像素 Outline Tolerance：轮廓点的复杂性和准确性，0~1 值越大轮廓点越多，越准确 Generate：生成网格轮廓 Custom Physics Shape（决定碰撞判断区域） 自定义精灵图片的物理形状，主要用于设置需要物理碰撞判断的2D图形。 它决定了之后产生碰撞检测的区域。参数和操作和自定义边缘线中基本一致 Skinning Editor 皮肤编辑器 Secondary Textures（为图片添加特殊效果） 次要纹理设置，可以将其它纹理和该精灵图片关联。点击加号添加要关联的图片作为辅助纹理，设置名字。着色器可以得到这些辅助纹理然后用于做一些效果处理，让精灵应用其它效果。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"}]},{"title":"8.纹理平台打包相关设置","slug":"游戏引擎/unity/unity核心/8.纹理平台打包相关设置","date":"2025-03-13T09:12:39.000Z","updated":"2025-03-13T09:35:10.623Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/8.纹理平台打包相关设置/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/8.%E7%BA%B9%E7%90%86%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"平台设置主要设置什么？ 平台设置主要设置纹理最终打包时在不同平台的尺寸、格式、压缩方式。它非常的重要，因为它影响了你的包大小和读取性能方面的问题。 平台打包相关参数 平台打包相关参数.svg Max Size：纹理的最大尺寸 设置导入的纹理的最大尺寸，即使美术出的很大的图，也可以通过这里把它们限制在一定范围内 一般选2048就行，有的设备不支持很大的纹理 Resize Algorithm：缩小算法 当纹理尺寸大于指定的Max Size时，使用的缩小算法 Mitchell：默认米切尔算法来调整大小，该算法是常用的尺寸缩小算法 Bilinear：使用双线性插值来调整大小。如果细节很重要的图片，可以使用它，它比米切尔算法保留的细节更多 Format：纹理格式 各平台支持的格式有所不同 如果选择Automatic 会根据平台使用默认设置 都支持的格式 移动端和网页端特有格式 关于格式选择的注意事项 根据不同平台单独进行设置 IOS：选择默认的纹理压缩设置 (PVRTC) 可获得更大的兼容性。 如果您的应用程序不包含 OpenGL ES 2 支持，则可以选择一种 ASTC 格式。这些格式提供更好的质量和灵活性，并且压缩速度比 PVRTC 快。 Andorid： 由于安卓设备众多，设备标准都不同一，一般会根据不同的设备标准制作多个安装包 构建一个以 OpenGL ES 3 为目标的 APK 1-1访问 Android 的 Player Settings （菜单：Edit &gt; Project Settings &gt;Player Settings， 然后选择 Android 类别）。 1-2.向下滚动到 Graphics APIs 部分。 1-3.确保 OpenGL ES 2 不在列表中。 1-4.构建 APK （菜单：File &gt; Build Settings，然后单击 Build）。 构建一个以 OpenGL ES 2 为目标的单独 APK 2-1访问 Android Player Settings。 2-2.向下滚动到 Graphics APIs 部分。 2-3.在列表中添加 OpenGL ES 2 并删除 OpenGL ES 3 和 Vulkan。 2-4.构建 APK。 Compression：选择纹理的压缩类型 帮助Unity正确选择压缩格式 会根据平台和压缩格式的可用性进行压缩 None：不压缩纹理 Low Quality：以低质量格式压缩纹理 Normal Quality：以标准格式压缩纹理 High Quality：以高质量格式压缩纹理 Use Crunch Compression：使用Crunch压缩 Crunch是一种基于DXT或ETC纹理压缩的有损压缩格式。压缩时间长，解压速度快。 压缩质量：质量越高意味着纹理越大，压缩事件越长 Split Alpha Channel：Alpha通道分离 Alpha通道分离，节约内存。会把一张图分成两张纹理。一张包含RGB数据，一张包含Alpha数据，在渲染时再合并渲染。 Override ETC2 fallback：不支持ETC2压缩的设备上，使用的格式","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"}]},{"title":"7.纹理平铺拉伸设置","slug":"游戏引擎/unity/unity核心/7.纹理平铺拉伸设置","date":"2025-03-13T08:56:32.000Z","updated":"2025-03-13T09:35:19.603Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/7.纹理平铺拉伸设置/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/7.%E7%BA%B9%E7%90%86%E5%B9%B3%E9%93%BA%E6%8B%89%E4%BC%B8%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"平铺拉伸主要是做什么 平铺拉伸主要设置纹理的平铺规则以及拉伸规则 纹理平铺拉伸参数 Wrap Mode：平铺纹理时的方式 一般情况下不需要自己设置，是美术会帮你设置好 先创建一个材质球，设置shader，然后直接将材质球直接给场景上的Quad Repeat：在区块中重复纹理 Clamp：拉伸纹理的边缘 Mirror：在每个整数边界上镜像纹理以创建重复图案 Mirror Once：镜像纹理一次，然后将拉伸边缘纹理 Per-axis：单独控制如何在U轴和V轴上包裹纹理 Filter Mode：纹理在通过3D变化拉伸时如何进行过度 Point：纹理在靠近时变为块状 Bilinear：纹理在靠近时变得模糊 Trilinear：与Bilinear类似，但纹理也在不同的Mip级别之间模糊 Aniso Level：以大角度查看纹理时提高纹理质量。性能消耗高","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"}]},{"title":"6.纹理高级设置","slug":"游戏引擎/unity/unity核心/6.纹理高级设置","date":"2025-03-13T08:29:06.000Z","updated":"2025-03-13T09:35:22.154Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/6.纹理高级设置/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/6.%E7%BA%B9%E7%90%86%E9%AB%98%E7%BA%A7%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"高级设置是设置什么？ 高级设置主要是纹理的一些尺寸规则、读写规则、以及MipMap相关设置 纹理高级设置参数 Non-Power of 2 如果纹理尺寸非2的幂如何处理 为什么纹理要设置为2的N次方？ 因为图形学规则，纹理必须是2的幂尺寸 None 纹理尺寸大小保持不变 To nearest 将纹理缩放到最接近2的幂的大小 （注意：PVRTC格式要求纹理为正方形） To larger 将纹理缩放到最大尺寸大小值的2的幂的大小 To smaller 将纹理缩放到最小尺寸大小值的2的幂的大小 Read/Write Enabled 纹理中获取数据 启用可以使用Unity中提供的一些方法从纹理中获取到数据（一般需要获取图片数据时才开启） Streaming Mipmaps 启用则可以使用纹理串流，主要用于在控制加载在内存中的Mipmap级别，用于减少Unity对于纹理所需的内存总量，用性能换内存 Mip Map Priority：Mipmap优先级，Unity根据优先级来确定分配资源时优先考虑哪些Mipmap Generate Mip Maps：允许生成MipMap 2d游戏一般不会用，3d游戏如果内存十分紧张就不用 Border Mip Maps：启用可避免颜色向外渗透到较低MIP级别的边缘（默认启动） Mip Map Filtering：优化图像质量的过滤方法 Box：随着尺寸减小，级别更加平滑 Kaiser：随着Mipmap尺寸大小下降而使用的锐化算法，如果远处纹理太模糊，可以使用该算法 Mip Maps Preserve Coverage：Mipmap的Alpha通道在Alpha测试期间保留覆盖率 Alpha Cutoff Value：覆盖率参考值 Fadeout Mip Maps：级别递减时使Mipmap淡化为灰色（一般不勾选） MipMap是什么？ Mipmap是三维计算机图形中常用的一种贴图渲染技术。它通过预先计算和优化一系列图片来加快渲染速度，减少图像锯齿。这样的贴图被称为 mipmap，它需要占用一定的内存空间。 Mipmap 中每个层级的小图都是主图的一个特定比例的缩小细节的复制品。当贴图被缩小或从远处观看时，mipmap 会转换到适当的层级。这样可以提高渲染速度，减少实时渲染的负担，并使放大和缩小更有效率。 例如，如果贴图的基本尺寸是 256x256 像素，它的 mipmap 就会有 8 个层级，每个层级是上一层级的四分之一大小。依次层级大小就是：128x128; 64x64; 32x32; 16x16; 8x8; 4x4;2x2; 1x1(一个像素) 简单来说，开启 MipMap 功能后，Unity 会根据图片信息生成不同分辨率的图片，在场景中根据距离选择合适尺寸的图片用于渲染，提升渲染效率。 下图就是一个MipMap","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"}]},{"title":"5.纹理形状设置","slug":"游戏引擎/unity/unity核心/5.纹理形状设置","date":"2025-03-13T08:20:08.000Z","updated":"2025-03-13T09:35:24.544Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/5.纹理形状设置/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/5.%E7%BA%B9%E7%90%86%E5%BD%A2%E7%8A%B6%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"纹理形状主要是设置什么 纹理不仅可以用于模型贴图 还可以用于制作天空盒和反射探针 纹理形状设置主要就是用于在2D模式和立方体模式这两种模式之间进行切换 Texture Shape：纹理形状 参数 2D：2D纹理，最常用设置，这些纹理将使用到模型和GUI元素上 Cube：立方体贴图，主要用于天空盒和反射探针 Mapping：如何将纹理投影到游戏对象上 Auto：根据纹理信息创建布局 6 Frames Layout：纹理包含标准立方体贴图布局之一排列的六个图像 Latitude-Longitude Layout：将纹理映射到2D维度/经度 Mirrored Ball：将纹理映射到类似球体的立方体贴图上 Convolution Type：纹理的过滤类型 None：无过滤 Specular：将立方体作为反射探针 Diffuse：将纹理进行过滤表示辐照度，可作为光照探针 Fixup Edge Seams Convolution Type 为None 和 Diffuse下才有用。解决低端设备上面之间立方体贴图过滤错误","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"}]},{"title":"4.纹理类型设置","slug":"游戏引擎/unity/unity核心/4.纹理类型设置","date":"2025-03-13T07:02:04.000Z","updated":"2025-03-13T13:23:47.355Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/4.纹理类型设置/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/4.%E7%BA%B9%E7%90%86%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"纹理类型主要是设置什么？ 设置纹理类型主要是为了让纹理图片有不同的主要用途 指明其是用于哪项工作的纹理 Texture Type：纹理类型参数 Default 默认纹理 大部分导入的模型贴图都是该类型 sRGB(Color Texture)* ：启用可以将纹理存储在伽马空间中（对每一个像素做一次幂函数运算） Alpha Source：指定如何生成纹理的Alpha通道 None：无论输入纹理是否有Alpha通道，导入的纹理都没有Alpha通道 Input Texture Alpha：输入纹理中的Alpha From Gray Scale：从输入纹理RGB值的平均值生成Alpha Alpha Is Transparency：启用可以避免边缘上的过滤瑕疵 Normal map 法线贴图格式 法线贴图（凹凸贴图）-Unity 手册就是在原物体的凹凸表面的每个点上均作法线 法线就是垂直于某个点的切线的方向向量 Create From Grayscale： 启用此属性可以从灰度高度贴图创建法线贴图 Bumpiness： 控制凹凸程度，值越大凹凸感越强 Filtering： 如何计算凹凸值 Smooth：使用标准算法生成法线贴图 Sharp：生成比标准模式更锐利的法线贴图 Editor GUI and Legacy GUI 一般在编辑器中或者GUI上使用的纹理 Sprite（2D and UI） 2D游戏或者UGUI中使用的格式 Sprite Mode： 图像中提取精灵图形的方式 Single：按原样使用精灵图像 Multiple：瓦片模式，如果是图集，使用该选项，可以在Sprite Editor编辑窗口自定义图片 Polygon：网格精灵模式 Pixels Per Unit：世界空间中的一个距离单位对应多少像素 MeshType：网格类型Unity Sprites: Full-Rect or Tight? | TheGamedev.Guru；只有Single和Multiple模式才支持 Full Rect：创建四边形，将精灵显示在四边形上 先说 Full Rect 模式的优点，对于 CPU 和 GPU 来说，矩形的计算很容易。 对于 Full Rect 模式有一个最大的弊端是，Sprite 的内容可能并不是一个矩形，也就说生成的矩形网格中，可能会有很大一部分透明区域，也被渲染了。如果这样的 Sprite 很多，那最终会有很大一部分的性能浪费，直接影响了帧率，特别是在移动设备上。 Tight：基于像素Alpha值来生成网格，更加贴合精灵图片的形状 任何小于32 * 32的精灵都使用FullRect模式，即使设置成Tight模式也是 Extrude Edges：使用滑动条确定生成的网格中精灵周围流出的区域大小 Pivot：精灵图片的轴心点，Single模式才有此选项 对应九宫格布局的九个点，还可以自定义 或者在Sprite Editor中也可以定义 Generate Physics Shape：启用此选项，Unity会自动根据精灵轮廓生成默认物理形状 只有Single 和Multiple模式才可使用 Sprite Editor：编辑Sprite，需要安装2D Sprite包，之后单独讲解 Cursor 自定义光标 设置鼠标图 Cookie 光源剪影格式 Light Type：应用的光源类型 一般点光源的剪影需要设置为立方体纹理 方向光和聚光灯的剪影设置为2D纹理 Spotlight：聚光灯类型，需要边缘纯黑色纹理 Directional：方向光，平铺纹理 Point：点光源，需要设置为立方体形状 Lightmap 光照贴图格式 Single Channel 纹理只需要单通道的格式 Channel：希望将纹理处理为Alpha还是Red通道 Alpha：使用Alpha通道，不允许进行压缩 Red：使用红色通道","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"}]},{"title":"3.图片导入概述","slug":"游戏引擎/unity/unity核心/3.图片导入概述","date":"2025-03-13T06:46:02.000Z","updated":"2025-03-13T09:35:30.108Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/3.图片导入概述/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/3.%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E6%A6%82%E8%BF%B0/","excerpt":"","text":"Unity支持的图片格式 BMP：是Windows操作系统的标准图像文件格式，特点是几乎不进行压缩，占磁盘空间大。 TIF：基本不损失图片信息的图片格式，缺点是体积大。 JPG：一般指JPEG格式，属于有损压缩格式，能够让图像压缩在很小的存储空间，一定程度上会损失图片数据，无透明通道。 PNG：无损压缩算法的位图格式，压缩比高，生成文件小，有透明通道。 TGA：支持压缩，使用不失真的压缩算法，还支持编码压缩。体积小，效果清晰，兼备BMP的图像质量和JPG的体积优势，有透明通道。 PSD：是PhotoShop（PS）图形处理软件专用的格式，通过一些第三方工具或自制工具可以直接将PSD界面转为UI界面。 此外，Unity还支持EXR、GIF、HDR、IFF、PICT等格式。其中，在Unity中最常用的图片格式是JPG、PNG和TGA三种。 图片设置的六大部分 图片导入设置包括以下几个主要参数： 纹理类型 纹理形状 高级设置 平铺拉伸 平台设置 预览窗口","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"}]},{"title":"2.模型制作流程","slug":"游戏引擎/unity/unity核心/2.模型制作流程","date":"2025-03-13T06:22:14.000Z","updated":"2025-03-13T06:41:16.480Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/2.模型制作流程/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/2.%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"建模 展UV 就是只要在2d图那里上色，再贴到3d模型哪里 材质和纹理贴图 在Project窗口创建材质球 将更改后的材质球直接拖到场景上的Cube 骨骼绑定 动画制作 模型制作过程-总结","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"}]},{"title":"1.unity核心概述","slug":"游戏引擎/unity/unity核心/1.unity核心概述","date":"2025-03-13T06:16:22.000Z","updated":"2025-03-13T06:21:08.012Z","comments":true,"path":"2025/03/13/游戏引擎/unity/unity核心/1.unity核心概述/","permalink":"http://example.com/2025/03/13/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/1.unity%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"}]},{"title":"25.NGUI总结","slug":"UI系统/NGUI/NGUI基础知识/25.NGUI总结","date":"2025-03-13T01:54:21.000Z","updated":"2025-03-13T02:59:53.393Z","comments":true,"path":"2025/03/13/UI系统/NGUI/NGUI基础知识/25.NGUI总结/","permalink":"http://example.com/2025/03/13/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.NGUI%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"24.NGUI之其它","slug":"UI系统/NGUI/NGUI基础知识/24.NGUI之其它","date":"2025-03-12T14:35:10.000Z","updated":"2025-03-13T01:50:18.135Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/24.NGUI之其它/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.NGUI%E4%B9%8B%E5%85%B6%E5%AE%83/","excerpt":"","text":"NGUI 事件响应 播放音效 NGUI提供一个现成的脚本PlaySound让我们在响应事件的时候播放一些音效 创建一个按钮来举例，给按钮添加PlaySound脚本 然后关联一个音效就行 NGUI控件和键盘按键绑定 NGUI提供一个KeyBinding脚本 给按钮添加KeyBinding脚本 key code ：绑定的按键 Modifier：组合键 Action：动作 （默认是按下和点击） PC端 tab键快捷切换选中 NGUI提供KeyNavigation脚本。 给按钮添加KeyNavigation脚本。 添加按tab要被选中的Sprite对象，记得要添加碰撞器，记得其它4个也要加KeyNavigation脚本 语言本地化 在Resources下创建一个txt文件，命名必须为Localization。 配置文件，第一行是key和不同语言通过逗号隔开，下面通过Key关联不同语言的文字，也通过逗号隔开。 给想要切换多语言文字的Label对象下挂载Localize脚本，关联Key。直接运行会默认显示第一个关联语言的key。 运行后 给用于切换语言的下拉列表下添加脚本LanguageSelection 也可以用于图片不同选项下的切换，添加keyValue是图片名字，给Sprite添加Localize脚本选择key。这样切换多语言下拉框时也会切换图片。 也可以不通过下拉列表来操作，还可以通过Localization.language属性来改 练习 在NGUI缓动的练习题基础上了，请用现在所学知识，制作一个这样的功能，所有按钮上的中文可以和英文进行语言切换，通过Toggle单选框切换语言 可以查看LanguageSelection是怎么切换的 可以发现是通过Localization.language来改的 添加两个单选框，分组都为1 配置Localization.txt如下 为Label添加Localize脚本","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"22.3d模型和粒子特效显示在UI之前","slug":"UI系统/NGUI/NGUI基础知识/22.3d模型和粒子特效显示在UI之前","date":"2025-03-12T14:08:11.000Z","updated":"2025-03-12T14:34:00.301Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/22.3d模型和粒子特效显示在UI之前/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.3d%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88%E6%98%BE%E7%A4%BA%E5%9C%A8UI%E4%B9%8B%E5%89%8D/","excerpt":"","text":"NGUI中显示3d模型 方法一：使用UI摄像机渲染3D模型 改变NGUI的整体层级为UI层 把拖入的3d模型的层级也要改为UI层，因为UIRoot默认的缩放很小，所以一拖进来模型可能也回很小。 改变主摄像机和NGUI摄像机的渲染层级 注意主摄像机的渲染不要选择UI层，因为NGUI有自己的摄像机只渲染UI层，否则可能渲染多个模型。 将想要被UI摄像机渲染的对象层级改为UI层 调整模型和UI控件的z轴距离 注意3D模型的深度不会收到NGUI的深度影响，只和z轴有关。 方法二：使用多摄像机渲染 Render Texture 制作流程类似小地图制作思路。 创建一个RenderTexture 创建一个摄像机，只渲染某一特定的层级，让主摄像机不渲染这一层级。 拖入3D模型，层级也改成那一特定的层级。 把刚刚创建的RenderTexture拖拽到摄像机的目标纹理上，可以看到RenderTexture的图片上是摄像机的渲染。 NGUI下创建一个纹理图片，拖拽RenderTexture到纹理图片上，可以看到模型的显示，这一做的好处是可以设置不同层级摄像机渲染的模式，比如UI要正交3D模型要人眼近大远小。 NGUI中显示粒子特效 在UI层级创建一个粒子特效，会发现无论怎么移动都显示在UI后面。 让Panel和粒子特效处于一个排序层，比如都是Default。 在粒子特效的 Render参数中 设置自己的层级，或者调高特效的Order in Layer","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"21.NGUI缓动","slug":"UI系统/NGUI/NGUI基础知识/21.NGUI缓动","date":"2025-03-12T13:19:54.000Z","updated":"2025-03-12T14:02:30.652Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/21.NGUI缓动/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.NGUI%E7%BC%93%E5%8A%A8/","excerpt":"","text":"什么是NGUI缓动？ NGUI缓动就是让控件交互时进行缩放变化、透明变化、位置变化、角度变化等行为。 从某一种状态慢慢的变成另一种状态 NGUI自带Tween功能来实现这些缓动效果。 使用NGUI缓动 关键组件 Tween缓动相关组件 关键组件 Play Tween可以通过它让该对象和输入事件关联 给一个Sprite添加缓动效果 Tween相关参数 这里拿Tween Scale来举例，其它的大同小异 From 开始状态 To 结束状态 Update Table 一般不开启 PlayStyle 播放方式 一次 循环 循环 从头到尾 从尾到头 Animation Curve* 动画曲线 可以调整两个值的变化曲线 Duration 持续时间 Start Delay 开始播放前的延迟时间 Delay Affects* 延迟影响 正向播放 反转播放 都影响（默认， TweenGroup 分组ID 用于一个对象多个动画时分组 Ignore TimeScale 忽略时间暂停 Use Fixed Update* 使用物理更新更新动画 Play Tween可以通过它让该对象和输入事件关联 给Sprite添加Play Tween脚本 Tween Target 控制对象 Include Children 是否带着子对象一起变化 字体开始往往也希望跟着一起变化 Start State 如果为真，则在激活触发之前 Play Tween将在启动时将所有关联的Tween重置为其起始状态 就一开始不要不放的话就勾上 TweenGroup 控制的是哪一组缓动 上面的Tween的分组为0，不受下面分组为1的Play Tween控制 Trigger condition 触发条件 ps：别忘了添加NGUI碰撞器 Play direction 播放的方向 Reverse 反转播放（一开始是结束状态然后变到开始状态） Toggle 正反状态转换 （一开始开始状态，播放到结束状态后保留到结束状态，再点一次从上一次的状态在再变） Forward 正向播放（默认） If target is disabled* 如果控制对象失活 处理方式 啥也不做 为了播放激活它 忽略失活状态 On activation* 激活时 继续当前 重新开始 如果没有播放重新开始 When finished* 播放完毕做啥 执行完后隐藏 什么也不做 如果是倒着播，播放完后隐藏 练习 给开火按钮添加一个Tween脚本和两个PlayTween脚本，做按着放大功能","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"20.NGUI字体","slug":"UI系统/NGUI/NGUI基础知识/20.NGUI字体","date":"2025-03-12T12:39:14.000Z","updated":"2025-03-12T13:59:43.765Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/20.NGUI字体/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.NGUI%E5%AD%97%E4%BD%93/","excerpt":"","text":"NGUI字体的作用 降低DrawCall 自定义美术字体 制作NGUI字体 NGUI内部提供了字体制作工具，根据字体文件生成指定内容文字，达到降低DrawCall的目的 使用第三方工具BitmapFont生成字体信息和图集，通过NGUI字体工具使用第三方工具生成的内容制作字体，达到自定义美术字体 假如Label选择Unity字体，可以理解为是动态字体。里面显示的文字会动态生成一个图，把它放到一个大图集里面。所以就会占用一次DrawCall。 制作NGUI字体第一步打开Font Maker Type主要有三个模式： 生成图片制作的自定义字体 导入图片制作的自定义字体 动态字体。动态字体一般不用，用Unity的字体就是动态字体。 Output是你要把NGUI的字体图打入到哪个图集中 创建的字体 不过图片上如果没有文字就不会显示 使用第三方工具如BitmapFont生成字体信息和 图集 导出的图片选择为png 可以按照字文件中的文本来选，txt的文件格式是：带有bom的utf-8 拖入生成的两个文件到工程中 然后把图片和字体信息拖入到Font Maker中 打开BitmapFont的 Image Manager自定义美术字体 Unity动态字体和NGUI字体如何选择 文字变化较多用Unity动态字体，变化较少用NGUI字体。 想要减少DrawCall用NGUI字体，用内存换性能。 美术字用NGUI字体 练习 在DrawCall的练习题基础上，请用现在所学知识，制作一个这样的功能，请制作一个自定义的美术数字字体，用于显示战斗力，在右上角显示坦克战斗力","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"19.Drawcall","slug":"UI系统/NGUI/NGUI基础知识/19.Drawcall","date":"2025-03-12T12:13:55.000Z","updated":"2025-03-12T12:35:57.755Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/19.Drawcall/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.Drawcall/","excerpt":"","text":"Drawcall 概念 字面理解DrawCall就是绘制呼叫的意思，表示CPU（中央处理器）通知GPU（图形处理器-显卡）。 DrawCall概念：CPU准备好渲染数据（顶点，纹理，法线，Shader等等）后，告知GPU开始渲染（将命令放入命令缓冲区）的命令。 简单来说，一次DrawCall就是CPU准备好渲染数据通知GPU渲染的这个过程。 如果游戏中DrawCall数量较高会影响CPU的效率，最直接的感受就是游戏会卡顿。 举例说明：以拷贝文件来进行类比。如果我们创建10000个小文件，每个文件大小为1kb，然后把这些文件拷贝到另一个文件夹中，你会发现，即使这些文件加起来不超过10MB，但是拷贝花费的时间是很长的。如果我们单独创建1个10MB的文件拷贝到另一个文件夹，基本可以瞬间拷贝完毕。因为每一个文件赋值动作都需要很多额外的操作，比如分配内存，创建数据等等，这些操作就会带来一些额外的性能开销，进行10000个这样的操作额外开销会非常大。简单理解，文件越多额外开销就越大。 渲染过程和上面的例子很类似，每次DrawCall，CPU都需要准备很多数据发送给GPU，那么如果DrawCall越多那么额外开销就越大。其实GPU的渲染效率是很强大的，往往影响渲染效率的都是因为CPU提交命令的速度。如果DrawCall太多CPU就会把大量时间花在提交DrawCall上，造成CPU过载，游戏卡顿。 如何降低Drawcall的数量？ 在UI层面上，主要是小图合成大图 （图集） 小图合成大图，即多个小DrawCall变为一次大DrawCall。比如当前要绘制的六张图毫无关系，那么会DrawCall六次，有六次开销。假如把当前六张图打成一张图集，那就只会DrawCall一次，减少了开销。 制作UI时降低Drawcall的技巧 通过NGUI Panel上提供的DrawCall查看工具 同一图集下的三张图，点击Panel下ShowDrawCall按钮，只有一次Drawcall 独立的显示三张图的Drawcall为3 注意不同图集之间的层级关系 如果更改Sprite012的层级分别为123，再修改Sprite1的图集不和Sprite0和Sprite2不一样，这样DrawCall会有三次。因为即使0和2属于同一个图集，但是他们在1和3层级，2层级插入了一个不同图集的Sprite1，会导致DrawCall增加。（同图集之间的合并渲染被打断了） 注意label的层级关系 Label其实最后也会打成一个动态的图集。 假如把他放在相同图集的Sprite的层级中间，也会打断相同图集的Sprite的合并渲染增加DrawCall。 可以设置Label的层级更高一些避免打断相同图集的合并DrawCall。","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"18.EventListener和EventTrigger事件相关","slug":"UI系统/NGUI/NGUI基础知识/18.EventListener和EventTrigger事件相关","date":"2025-03-12T08:43:32.000Z","updated":"2025-03-12T12:13:04.303Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/18.EventListener和EventTrigger事件相关/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.EventListener%E5%92%8CEventTrigger%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3/","excerpt":"","text":"控件自带事件的局限性 目前复合控件只提供了一些常用的事件监听方式，比如： Button —— 点击 uIButton.onClick.Add(new EventDelegate(ClickDoSomthing)); Toggle —— 值变化 uIToggle.onChange.Add(new EventDelegate(Change)); 如果想要制作按下、抬起、长按等功能，利用现有的知识是无法完成的。 NGUI事件响应函数 添加了碰撞器的对象 NGUI提供了一些利用反射调用的函数 原理是NGUI会在EventSystem不停地检测玩家输入，当触发到某种输入时，会去触发对象身上的各个脚本找是否有对应的函数，有的话执行对应事件。 Lesson14 有响应函数 常用NGUI事件响应函数有 经过 OnHover(bool isOver) 按下 OnPress(bool pressed) 点击 OnClick() 双击 OnDoubleClick() 拖曳开始 OnDragStart() 拖曳中 OnDrag(Vector2 delta) 拖曳结束 OnDragEnd() 拖曳经过某对象 OnDragOver(GameObject go) 拖曳离开某对象 OnDragOut(GameObject go) 等等等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void OnPress(bool pressed)&#123; if (pressed) &#123; print(&quot;按下&quot;); &#125; else &#123; print(&quot;抬起&quot;); &#125;&#125;void OnHover(bool isOver)&#123; if (isOver) &#123; print(&quot;鼠标经过&quot;); &#125; else &#123; print(&quot;鼠标离开&quot;); &#125;&#125;void OnClick()&#123; print(&quot;点击相关&quot;);&#125;void OnDoubleClick()&#123; print(&quot;双击相关&quot;);&#125;void OnDragStart()&#123; print(&quot;开始拖曳&quot;);&#125;void OnDrag(Vector2 delta)&#123; print(&quot;拖曳中&quot; + delta);&#125;void OnDragEnd()&#123; print(&quot;拖曳结束&quot;);&#125;void OnDragOver(GameObject obj)&#123; // 这个函数传进来的是我拖的对象 print(&quot;拖曳经过&quot; + obj.name);&#125;void OnDragOut(GameObject obj)&#123; // 这个函数传进来的是我拖的对象 print(&quot;拖曳离开&quot; + obj.name);&#125; 更加方便事件监听的UIEventListener和UIEventTrigger 如果使用上述的NGUI事件响应函数，那么Panel下的所有子控件都要写一个脚本挂上去，很不方便、不面向对象。 NGUI提供了更加方便的UIEventListener和UIEventTrigger。 UIEventListener和UIEventTrigger帮助我们封装了所有特殊响应函数，可以通过它们进行事件监听管理添加。 UIEventListener 用代码给对象添加事件监听 适合代码添加 在Panel的脚本添加想要监听事件的对象 12345678910111213public UISprite A; public UISprite B;UIEventListener uIEventListener = UIEventListener.Get(A.gameObject);uIEventListener.onPress += (obj, isPress) =&gt; &#123; print(obj.name + &quot;被按下或者抬起了&quot; + isPress);&#125;;uIEventListener.onDragStart += BeginDrag;private void BeginDrag(GameObject obj)&#123; print(obj.name + &quot;开始拖曳&quot;);&#125; UIEventTrigger 适合Inspector面板关联脚本添加 UIEventTrigger 在Inspector面板给 B 添加UIEventTrigger脚本 添加按下事件监听 UIEventListener和UIEventTrigger区别 Listener更适合代码添加监听，Trigger适合拖曳对象添加监听。 Listener传入的参数更具体，Trigger则不会传入参数，我们需要在函数中去判断处理逻辑。 联系 在Anchor锚点的练习题基础上，请用现在所学知识，制作一个这样的功能，制作一个NGUI摇杆可以控制场景上的坦克移动 在GamePanel下创建一大一小两个Sprite作为摇杆背景和摇杆，小的摇杆是大摇杆背景的子物体并且层级更高。给小的摇杆添加碰撞器 GamePanel.cs 123456789101112131415161718192021222324252627282930313233public UISprite controller;void Start()&#123; // 通过给控制图标 GameObject 对象添加的 UIEventListener 组件来监听鼠标/手指的拖曳操作 UIEventListener listener = UIEventListener.Get(controller.gameObject); listener.onDrag = (obj, vector) =&gt; &#123; // 根据拖曳偏移量实现控制图标跟随鼠标移动 给本地坐标加位置 本地坐标默认(0,0) controller.transform.localPosition += new Vector3(vector.x, vector.y, 0); // 判断是否超出了可拖曳区域，并进行限制，使其不至于越过设定的最大半径 magnitude是向量求模 if (controller.transform.localPosition.magnitude &gt; 130) //大于最大拖拽区域就把他变成130 controller.transform.localPosition = controller.transform.localPosition.normalized * 130; Vector2 dir = new Vector2(controller.transform.localPosition.x, controller.transform.localPosition.y).normalized; // 更改玩家对象当前的朝向和位移信息 player.Move(dir); &#125;; listener.onDragEnd = (obj) =&gt; &#123; // 回到原点位置 controller.transform.localPosition = Vector3.zero; // 结束时让玩家停止移动 player.StopMove(); &#125;;&#125; TankObj.cs 12345678910111213141516171819202122232425262728293031323334353637public class TankObj : MonoBehaviour&#123; // 移动速度 public float moveSpeed = 10; // 旋转速度 public float roundSpeed = 20; // 移动标识 private bool isMoving = false; // 要移动的方向向量 private Vector3 moveDir; private void Update() &#123; if (isMoving) &#123; // 坦克沿着前方方向移动 this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); // 旋转坦克使其朝向移动方向 this.transform.rotation = Quaternion.Lerp(this.transform.rotation, Quaternion.LookRotation(moveDir), roundSpeed * Time.deltaTime); &#125; &#125; // 设置位移方向 public void Move(Vector3 dir) &#123; // 设置实际要转的角度 摇杆的x轴对应坦克的x轴 摇杆的y轴对应坦克的z轴 moveDir.x = dir.x; moveDir.z = dir.y; isMoving = true; // 设置为移动状态 &#125; // 停止移动 public void StopMove() &#123; isMoving = false; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"17.Anchor锚点","slug":"UI系统/NGUI/NGUI基础知识/17.Anchor锚点","date":"2025-03-12T07:19:26.000Z","updated":"2025-03-12T08:07:58.306Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/17.Anchor锚点/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.Anchor%E9%94%9A%E7%82%B9/","excerpt":"","text":"Anchor是什么？ 用于9宫格布局的锚点。 有两个关键知识点： 老版本——锚点组件——用于控制对象对齐方式。 新版本——3大基础控件自带锚点内容——用于控制对象相对父对象布局。 老版本锚点组件 主要用于设置面板相对屏幕的9宫格位置。 用于控制对象对齐方式。 将想要控制的对象设置为Anchor的子对象，子对象就会依照Anchor 创建老版本锚点组件 老版本Anchor锚点组件参数* UICamera 关联UI摄像机 会自动关联，一般不用设置 Container 控制的容器对象 一般无需专门设置 Side 9宫格位置 Run Only Once 是否只对齐一次 一般情况下 设备分辨率都定死的 横屏竖屏也是定死的 所以勾选 除非分辨率要变化才取消勾选 Relative Offset 相对比例偏移位置（0~1） Pixel Offset 像素偏移位置 新版本锚点组件 自带锚点信息 用于控制对象相对父对象布局。 Type：尺寸对齐方式。 Execute：什么时候执行更新。 激活时更新 每帧更新 开始时更新。 高级模式下 Left Right Bottom Top：控件左右底顶每条边都可以关联一个父Panel对象。 练习 在ScrollView滚动视图的练习题基础上，请用现在所学知识，制作一个这样的功能，让之前做的面板都能够分辨率自适应 逐个设置GamePanel下的控件的Anchor 给BagPanel添加老版本Anchor脚本，设置右对齐，调整BagPanel下控件位置，取消勾选RunOnlyOnce","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"16.ScrollView滚动视图","slug":"UI系统/NGUI/NGUI基础知识/16.ScrollView滚动视图","date":"2025-03-12T02:21:57.000Z","updated":"2025-03-12T07:05:46.858Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/16.ScrollView滚动视图/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/16.ScrollView%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE/","excerpt":"","text":"ScrollView是用来干啥的？ 滚动视图，我们的vs代码窗口就是典型的滚动视图 主要用于背包、商店、排行榜等功能。 制作ScrollView 直接在工具栏创建即可 NGUI——Create——ScrollView。（要先创建根对象） 若需要ScrollBar，自行创建ScrollBar，在ScrollView脚本中关联水平滚动条或者竖直滚动条。 给ScrollView添加子对象，为子对象添加Drag ScrollView脚本和NGUI碰撞器。（下图的示例是添加了一个Sprite） 给Sprite添加一个Drag Scroll View 和 NGUI碰撞器脚本（注意：这里不需要关联，它自己运行的时候会自动关联） Panel 脚本 可以更改滚动视图的可视范围 Sprite的大小 滚动视图只能看到的大小 ScrollView 脚本 Content Origin 内容子对象对其方式 正常情况下是从左到右，从上到下 一般选左上角Top Left就行 Movement 子对象拖曳的方向 绿色的框是子对象 水平 垂直 自由 自定义 Drag Effect 拖动特效 不使用任何效果 动量（惯性）效果（差异不明显） 动量（惯性）和弹力效果 （默认，用的最多） Scroll Wheel Factor 滚动因子 如果不为0，鼠标中键滚动可以滚动它 可以通过它控制速度和方向 Momentum Amount 动量 拖曳一下鼠标，动的快慢 可以理解成惯性大小 Sppring Strength 弹力大小 移动到边缘时弹回时弹力大小 Dampen Strength 阻尼强度 影响回弹效果 Restrict Within Panel* 限制在Panel中 一般情况勾选 不勾选，不会产生弹力效果 Constrain On Drag* 阻力约束 一般不修改 Cancel Drag if fits 子对象溢出后能否拖动相关 若勾选 滚动视图的内容是否应该是可拖动的 取决于它们当前子对象大小是否溢出 如果内容没有溢出， 上下不可以拖动 内容溢出上下可以拖动 Smooth Drag Start* 平滑拖动 一般开启， 不修改 IOS Drag Emulation* IOS阻力模拟 一般开启，不修改 ScrollBars 滚动条关联 Horizontal 水平滚动条 Vertical 竖直滚动条 ShowCondition 显示时机 一直显示 需要时显示 拖动时显示 Grid 自动对齐脚本 实际开发中更多的是会自己写代码来对位置进行放置，而不是直接用现成的Grid 在Scroll View中添加很多物品 在Scroll View对象上添加Grid脚本 上面的添加的物体自动布局 可以通过设置Grid的参数来进行调整 Arrangement 排序对其方式 水平 竖直 元素大小 Cell width 元素宽 Cell Height 元素高 Row Limit 元素个数 会自动换行 比如现在是水平的 （一般是这样用） 下面填个3后如下：n行 3 列 比如现在是竖直的就会变成下图 Sorting* 排序顺序 没有排序 按字母排序 水平放置顺序 垂直放置顺序 自定义 Inverted* 倒转 若选择了排序方式 勾选这里 可以翻转排序规则 Pivot* 锚点位置 9宫格9个位置 Smooth Tween* 平缓缓动动画 是否会平滑地将其子对象设置为正确的位置 Hide Inactive* 是否隐藏不活动组件 Constrain To panel 约束面板 是否将网格子对象的更改通知父容器Panel 会用于更新ScrollBar等显示信息 练习 在ScrollBar滚动条和ProgressBar进度条的练习题基础上，请用现在所学知识，制作一个这样的功能，有一个背包按钮，点击后可以打开一个背包面板，面板中有一个滚动视图，滚动视图中动态创建10个道具图标 动态创建问题 布局问题 滑动条更新问题 创建背包面板，修改面板深度 给背包面板创建一个遮罩背景（bk2），一个背包面板背景（bk）。创建一个标题标签写上文字（lableTitle）。 创建滚动视图，设置好大小并设置位置和背包面板背景一致。 创建一个滚动条（ScrollBar），设置好图片和位置，在滚动视图上关联。 注意修改滚动条的子Sprite的层级深度，并且把滚动条模式修改成从上到下。 创建一个关闭按钮。 给背包滚动视图添加Grid以解决布局问题，目标是设置格子创建的位置为左上角并排列好。 要先全选所有子对象，设置成以左上角对齐。 同时修改滚动视图Panel中心点Center的位置。中心点设置X位置为大小Size X的一半,Y取SIze Y的一半且是负数，就是左上角。修改中心点可能会导致上方xy的Offset变化，把它设置为0就好。设置好后重新调整滚动视图到合适的位置即可。注意修改后要重新失活激活Grid组件才能重新排列 在GamePanel脚本创建背包按钮变量，创建一个背包按钮，关联后在代码添加点击出背包面板的监听 12345678910111213public class GamePanel : MonoBehaviour&#123; public UIButton btnBag; void Start() &#123; // 点击背包按钮 打开背包 btnBag.onClick.Add(new EventDelegate(() =&gt; &#123; BagPanel.Instance.gameObject.SetActive(true); &#125;)); &#125;&#125; 创建BagPanel背包面板脚本。动态创建预制体对象Item（背包物品），并且刷新滚动视图的滚动条。这样能让滚动条显示正常。可以选择是否使用滚动视图的Grid来限制动态创建预制体对象Item的位置。如果不使用的话就要通过代码手算。以后假如要自己定义排序规则最好用自己手写代码手算位置。 123456789101112131415161718192021222324252627282930313233343536public class BagPanel : MonoBehaviour&#123; private static BagPanel instance; public static BagPanel Instance =&gt; instance; public UIScrollView sv; public UIButton btnClose; private void Awake() &#123; instance = this; &#125; void Start() &#123; // 点击关闭按钮 让自己隐藏 btnClose.onClick.Add(new EventDelegate(() =&gt; &#123; this.gameObject.SetActive(false); &#125;)); // 动态创建10个道具图标 for (int i = 0; i &lt; 60; i++) &#123; GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Item&quot;)); obj.transform.SetParent(sv.transform, false); // 如果通过代码 来自己设置位置 就在这里设置即可 obj.transform.localPosition = new Vector3(120 * (i % 5), 120 * (i / 5), 0); &#125; // 通过sv控制 滚动条更新 sv.UpdateScrollbars(); this.gameObject.SetActive(false); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"15.ScrollBar滚动条和ProgressBar进度条","slug":"UI系统/NGUI/NGUI基础知识/15.ScrollBar滚动条和ProgressBar进度条","date":"2025-03-12T01:44:27.000Z","updated":"2025-03-12T02:18:44.814Z","comments":true,"path":"2025/03/12/UI系统/NGUI/NGUI基础知识/15.ScrollBar滚动条和ProgressBar进度条/","permalink":"http://example.com/2025/03/12/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/15.ScrollBar%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%92%8CProgressBar%E8%BF%9B%E5%BA%A6%E6%9D%A1/","excerpt":"","text":"ScrollBar滚动条和ProgressBar进度条 是啥的？ ScrollBar滚动条一般不单独使用，都是配合滚动视图使用，类似VS右侧的滚动条，随着内容的增多滚动条可能变短。 ProgressBar进度条一般不咋使用，一般直接用Sprite的Filled填充模式即可。 他们的参数和之前的知识很类似，所以这两个知识点不是重点，了解如何制作即可。 Scrollbar 制作Scrollbar 两个Sprite对象，一个Sprite对象充当背景，一个Sprite对象充当滚动条。 给Sprite背景父对象添加脚本ScrollBar脚本。 给Sprite背景父对象添加NGUI碰撞器。 ScrollBar脚本关联对象。 参数相关和Slider基本一样 ProgressBar 制作ProgressBar 两个Sprite对象，一个Sprite对象充当背景，一个Sprite对象充当进度条。 给Sprite背景父对象添加脚本ProgressBar脚本。 ProgressBar脚本关联对象。 不添加碰撞器的原因是因为进度条不需要玩家手动改变。 练习 在Slider滑动条的练习题基础上，请用现在所学知识，制作一个这样的功能，长按鼠标可以蓄能，会出现一个进度条表示当前的蓄能进度，按下鼠标出现进度条，松开鼠标进度条消失，鼠标长按过程中，进度条更新，5秒钟后蓄能满，进度条满，坦克的血量+10 GamePanel下创建一个两个sprite充当成进度条，添加进度条脚本，关联两个sprite 在GamePanel脚本下创建进度条变量，关联进度条对象。添加给外部显示隐藏更新蓄能条的方法，开始时默认隐藏 1234567891011121314151617181920212223242526272829303132333435public class GamePanel : MonoBehaviour&#123; public UIProgressBar progressBar; void Start() &#123; HideHpPro(); &#125; /// &lt;summary&gt; /// 显示蓄能条 /// &lt;/summary&gt; public void ShowHpPro() &#123; progressBar.gameObject.SetActive(true); &#125; /// &lt;summary&gt; /// 隐藏蓄能条 /// &lt;/summary&gt; public void HideHpPro() &#123; progressBar.gameObject.SetActive(false); &#125; /// &lt;summary&gt; /// 更新蓄能条 /// &lt;/summary&gt; /// &lt;param name=&quot;nowValue&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;maxValue&quot;&gt;&lt;/param&gt; public void UpdatePro(float nowValue, float maxValue) &#123; progressBar.value = nowValue / maxValue; &#125;&#125; 添加蓄能计时变量和当前血量变量。在Update里处理鼠标操作相关逻辑。鼠标按下时显示蓄能条，重置蓄能条事件。长按时间累加蓄能条也一直增加。五秒后加血重置时间。抬起鼠标隐藏蓄能条 123456789101112131415161718192021222324252627282930313233343536373839public class TankObj : MonoBehaviour&#123; // 用于蓄能计时 private float nowTime; // 当前血量 public int nowHp = 100; private void Update() &#123; // 处理按下鼠标蓄能相关 if (Input.GetMouseButtonDown(0)) &#123; GamePanel.Instance.ShowHpPro(); nowTime = 0; // 更新蓄能条 GamePanel.Instance.UpdatePro(nowTime, 5); &#125; else if (Input.GetMouseButtonUp(0)) &#123; GamePanel.Instance.HideHpPro(); &#125; else if (Input.GetMouseButton(0)) &#123; // 按下状态时间一直加 nowTime += Time.deltaTime; // 更新蓄能条 GamePanel.Instance.UpdatePro(nowTime, 5); // 判断最大时间 if (nowTime &gt;= 5) &#123; // 重置时间 nowTime = 0; nowHp += 10; print(&quot;当前血量：&quot; + nowHp); &#125; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"14.Slider滑动条","slug":"UI系统/NGUI/NGUI基础知识/14.Slider滑动条","date":"2025-03-11T03:51:46.000Z","updated":"2025-03-12T01:42:24.088Z","comments":true,"path":"2025/03/11/UI系统/NGUI/NGUI基础知识/14.Slider滑动条/","permalink":"http://example.com/2025/03/11/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/14.Slider%E6%BB%91%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"Slider是啥？ 滑动条控件，主要用于设置音乐音效大小等。 制作Slider 3个Sprite （一个sprite对象做为根对象的为背景，一个sprite对象作为背景对象的子对象当做进度条对象，一个sprite对象作为进度条对象的子对象当做滑动块对象。） 设置层级 （背景对象最小，进度条对象其次，滑动块对象最大。下图的是滑动块sliderBar的） 为根背景添加Slider脚本。 添加NGUI的碰撞器（背景对象或者滑动块对象） 添加到背景上按背景所有地方都可以影响到 添加到滑动块对象上只能鼠标只影响到滑块 Slider脚本上关联背景对象、进度条对象和滑动块对象。 Slider脚本参数 Value 当前值0~1 Steps 步数 将1平分 Appearance 外观设置 Foreground 前景（用于缩放） Background 背景 Thumb 拖动块 Direction 拖动方向 从左到右 从右到左 从下到上 从上到下 OnValueChange 值变化时监听脚本 Slider滑动条监听滑动条改变事件的两种方式 拖脚本监听滑动条改变的点击事件 代码监听滑动条改变的点击事件 123456789//值变化监听uISlider.onChange.Add(new EventDelegate(() =&gt; &#123; print(&quot;通过代码监听值变化&quot; + uISlider.value);&#125;));//拖拽结束后监听uISlider.onDragFinished += () =&gt; &#123; print(&quot;拖曳结束&quot; + uISlider.value);&#125;; 练习 在PopupList下拉列表的练习题基础上，请用现在所学知识，制作一个这样的功能，场景上有一个滑动条，可以通过它控制音效的音量大小 按创建slider的套路创建三个sprite图片，给背景对象添加slider脚本和碰撞器，调整三个sprite对象的层级，关联slider脚本上的三个对象 音乐数据类添加全局静态控制音量大小的变量 MusicData.cs 1234567public class MusicData&#123; // 音效开关 public static bool isOpenSound = true; // 音效大小 public static float soundValue = 1;&#125; 坦克的开火函数的时候设置开火时的音量大小 TankObj.cs 12345public void Fire()&#123; // 设置音效的音量 source.volume = MusicData.soundValue;&#125; GamePanel中添加slider变量并在外面关联创建的slider对象，添加改变slider后的监听，设置给音乐数据类的全局音量大小 GamePanel.cs 12345678910111213public class GamePanel : MonoBehaviour&#123; public UISlider sliderSound; void Start() &#123; sliderSound.onChange.Add(new EventDelegate(() =&gt; &#123; // 音量大小 MusicData.soundValue = sliderSound.value; &#125;)); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"13.PopupList下拉列表","slug":"UI系统/NGUI/NGUI基础知识/13.PopupList下拉列表","date":"2025-03-11T02:51:52.000Z","updated":"2025-03-12T01:46:25.659Z","comments":true,"path":"2025/03/11/UI系统/NGUI/NGUI基础知识/13.PopupList下拉列表/","permalink":"http://example.com/2025/03/11/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13.PopupList%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8/","excerpt":"","text":"PopupList是啥？ 下拉列表 类似在vs中点窗口后下面的功能 制作PopupList 一个sprite做背景，一个label做显示内容。 为Sprite对象添加PopupList脚本。 为Sprite对象添加NGUI的碰撞器。 关联label做信息更新，选择Label中的SetCurrentSelection函数。（假如发现点击下拉列表没有反应，检查一下字体设置是不是为空 PopupList脚本参数 Options 下拉列表显示内容（空一行表示加一个） Position 列表出现位置 自动（建议自动 让其自动判断） 向上 向下 Selection* 选中操作 按下选中（一般选这个） 点击选中 Alignment 对其方式 自动对齐 左对齐 居中对齐 右对齐 调整会自动变化 Open on 下拉列表打开方式 点击或者触碰（一般这个） 右键 双击 手动（相当于关闭。自己代码处理，一般不选择） On Top 始终显示在所有面板之前 默认选择 Localized* 是否将对弹出列表的值进行本地化 Keep Value 始终保持有列表中的某个默认值 Intial Value 默认选择的内容 Atlas Atlas 图集 Background 下拉列表 背景图 Highlight 下拉列表 选中图 Background 背景颜色叠加 Highlight 选中图颜色叠加 Overlap* 弹出窗口边框与打开它的内容重叠的数量 Animated 是否有默认的弹出动画 禁用可以节约性能 Font Font 字体 Font Size 字体大小 TextColor 字体颜色 Padding* 偏移位置 Modifier* 修饰方式，强制大小写字母 没有限制 大写字母 小写字母 自定义 OnValueChange 值选择改变时监听脚本 事件监听两种方式 和Button的类似 拖脚本监听输入完成和输入改变的点击事件 代码监听下拉框改变的点击事件 1234public void OnChange()&#123; print(&quot;选项变化&quot; + uIPopupList.value);&#125; 1234567//动态添加选项uIPopupList.items.Add(&quot;新加 选项4&quot;);//代码添加选项监听uIPopupList.onChange.Add(new EventDelegate(() =&gt; &#123; print(&quot;代码添加的监听&quot; + uIPopupList.value);&#125;)); 练习 在Input文本输入练习题基础上，请用现在所学知识，制作一个这样的功能，场景上有一个下拉列表，可以通过改变下拉列表来改变当前场景是白天还是黑夜 白天和黑夜可以通过改变光源的角度来做 在GamePanel创建下拉框对象，设置好文字字体等，注意添加碰撞器，而且要关联子物体label并设置关联的SetCurrentSelection函数 123456789101112131415161718192021222324public class GamePanel : MonoBehaviour&#123; public UIPopupList list; // 下拉列表控件 public Light lightObj; // 灯光对象 void Start() &#123; // 下拉列表选项状态改变时添加对应的回调方法 list.onChange.Add(new EventDelegate(() =&gt; &#123; //根据选中的选项，切换游戏场景灯光的强度 switch (list.value) &#123; case &quot;白天&quot;: lightObj.intensity = 1; // 切换到白天灯光强度为1 break; case &quot;黑夜&quot;: lightObj.intensity = 0.2f; // 切换到夜晚灯光强度为0.2 break; &#125; &#125;)); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"12.Input输入框","slug":"UI系统/NGUI/NGUI基础知识/12.Input输入框","date":"2025-03-11T02:06:53.000Z","updated":"2025-03-12T01:47:20.038Z","comments":true,"path":"2025/03/11/UI系统/NGUI/NGUI基础知识/12.Input输入框/","permalink":"http://example.com/2025/03/11/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.Input%E8%BE%93%E5%85%A5%E6%A1%86/","excerpt":"","text":"Input是啥？ 文本输入框，可以用来制作账号、密码、聊天输入框等。 制作Input 一个Sprite做背景，一个Label显示文字。 为Sprite对象添加Input脚本。 为Sprite对象添加NGUI的碰撞器。 Input脚本参数 Label 关联的文本组件 Starting Value 开始默认显示的内容 Saved As* 若此处填写内容 会使用PlayerPrefs将输入内容作为 此处填写的该key的值进行存储 一般不使用 ActiveTextColor 选中激活时颜色 Inactive Color 未选中失活时颜色 Caret Color 插入光标的颜色 Selection Color 选中文字的背景颜色 InputType 输入类型 默认模式 自动更正 密码输入（输入内容看不到） Validation 输入限制 None：无限制 Integer：只能输入整形 Float：可以输入浮点数 Alphanumeric：只能是数字和字母 Username：用户名 Name：姓名 Filename：文件名 Mobile Keyboard* 手机键盘模式 英文 数字符号 连接 数字 手机 名字 邮箱地址 Hide Input* 键盘下 隐藏输入框 On Return Key 完成键（回车键）做什么操作 默认操作 结束输入 换行 Character Limit 最大可输入字符数 OnSubmit 输入完成时响应脚本 OnChange 输入变化时响应脚本 Input文本输入监听输入完成和输入改变事件的两种方式 和Button的类似 拖脚本监听输入完成和输入改变的点击事件 代码监听输入完成和输入改变的点击事件 123456789101112131415161718192021222324252627public UIInput uIInput;void Start()&#123; //1.拖曳脚本 //2.通过代码关联 uIInput.onSubmit.Add(new EventDelegate(() =&gt; &#123; print(&quot;完成输入 通过代码添加的监听函数&quot;); &#125;)); uIInput.onChange.Add(new EventDelegate(() =&gt; &#123; print(&quot;输入变化 通过代码添加的监听函数&quot;); &#125;));&#125;public void OnSubmit()&#123; print(&quot;输入完成&quot; + uIInput.value);&#125;public void OnChange()&#123; print(&quot;输入变化&quot; + uIInput.value);&#125; 练习 在Toggle单选框多选框练习题基础上，请用现在所学知识，制作一个这样的功能，场景左上角会显示玩家的姓名，右侧有一个改名按钮，点击改名按钮后会弹出一个改名窗口，在窗口上可以输入你的新名字，点击确定键后，原左上角的名字将改变 在GamePanel下添加一个用于显示用户名的Label和一个用于点击改名的按钮 在GamePanel脚本创建一个UILabel变量和UIButton，拖拽赋值给刚刚创建的用户名文本和打开改名面板按钮 GamePanel.cs 12345public class GamePanel : MonoBehaviour&#123; public UILabel labName; // 文本标签组件，用于呈现玩家名称等信息 public UIButton btnChangeName; // 改名按钮组件，用于打开 UI 以修改玩家名称 &#125; 创建一个更详细的面板来改名，注意层级还要给背景添加NGUI碰撞器遮挡后面的 添加相关的显示面板的信息 创建ChangeNamePanel脚本，创建变量并关联改名输入框和改名按钮，添加点击改名按钮的的事件监听，并且把ChangeNamePanel做成单例模式 1234567891011121314151617181920212223242526272829public class ChangeNamePanel : MonoBehaviour&#123; private static ChangeNamePanel instance; public static ChangeNamePanel Instance =&gt; instance; public UIButton btnChange; // UI 按钮组件，用于提交玩家修改的名称 public UIInput inputName; // UI 输入框组件，用于接收玩家输入的新名称字符串 private void Awake() &#123; instance = this; &#125; void Start() &#123; // 为按钮注册点击事件，以触发相关操作 btnChange.onClick.Add(new EventDelegate(() =&gt; &#123; // 修改主面板上显示的名字 GamePanel.Instance.labName.text = inputName.value; // 隐藏自己的面板 this.gameObject.SetActive(false); &#125;)); // 初始化时将自身面板隐藏起来 this.gameObject.SetActive(false); &#125;&#125; 把GamePanel也做成单例模式，给打开改名面板按钮添加点击打开改名面板的监听 GamePanel.cs 123456789void Start()&#123; // 为改名按钮注册点击事件，以打开 UI 以修改玩家名称 btnChangeName.onClick.Add(new EventDelegate(() =&gt; &#123; // 处理打开改名 UI 的逻辑 ChangeNamePanel.Instance.gameObject.SetActive(true); &#125;));&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"11.Toggle单多选框","slug":"UI系统/NGUI/NGUI基础知识/11.Toggle单多选框","date":"2025-03-11T01:27:21.000Z","updated":"2025-03-12T01:47:56.538Z","comments":true,"path":"2025/03/11/UI系统/NGUI/NGUI基础知识/11.Toggle单多选框/","permalink":"http://example.com/2025/03/11/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.Toggle%E5%8D%95%E5%A4%9A%E9%80%89%E6%A1%86/","excerpt":"","text":"Toggle是用来干嘛的？ 单选框和多选框都可以使用它来制作。 制作Toggle 创建两个Sprite对象，一个父对象，一个子对象。 为Sprite父对象添加Toggle脚本。 为Sprite父对象添加NGUI的碰撞器。 还没完，父与子还没建立联系，将子对象拖到Toggle脚本关联 Toggle脚本参数 Group 多选框分组 多个多选框分为一组则变为单选框 三个单选框 把参数Group都改成1组，（0组是不分组的意思） 三个就会互斥，只能选一个 State of None 单选框状态时 是否允许不选中 Starting State开始默认状态 勾选为选中 Sprite 选中用图片 Invert State 反转状态 如果选中不显示 不选中显示 就勾选它 Animator 状态变化时播放动画（新动画系统） Animation 状态变化时播放动画（老动画系统） Tween 状态变化时缓动 Transition 过渡模式 平滑过渡 瞬间过渡 OnValueChange 状态变化时响应脚本 监听Toggle单多选框选择改变事件的两种方式 和Button的类似 拖脚本 代码获取按钮监听 1234567891011121314151617181920212223242526272829303132public UIToggle uIToggle;public UIToggle uIToggle1;public UIToggle uIToggle2;public UIToggle uIToggle3;void Start()&#123; //代码进行监听添加 uIToggle1.onChange.Add(new EventDelegate(Change2)); uIToggle2.onChange.Add(new EventDelegate(Change2)); uIToggle3.onChange.Add(new EventDelegate(Change2));&#125;//代码进行监听添加，建议privateprivate void Change2()&#123; print(&quot;Toggle变化执行的内容&quot;); //UIToggle的value变量可以判断单选框有没有被选中 if (uIToggle1.value) &#123; print(&quot;tog1选中&quot;); &#125; else if (uIToggle2.value) &#123; print(&quot;tog2选中&quot;); &#125; else if (uIToggle3.value) &#123; print(&quot;tog3选中&quot;); &#125;&#125; 练习 在Button按钮的练习题基础上，请用现在所学知识，制作一个这样的功能，场景上坦克发射子弹有音效，通过用NGUI的Toggle开关 控制音效开关 把开火的音效资源放到Resource文件夹下 在坦克脚本的开火函数里添加播放音效的逻辑 注意： 这里是讨巧写法，真正开发会有音效管理器之类的东西 TankObj.cs 123456789101112131415161718192021222324252627282930public class TankObj : MonoBehaviour&#123; public Transform shootPos; // 音效片段文件 private AudioClip clip; public void Fire() &#123; // 添加一个 Audio Source 组件以用于播放声音 AudioSource source = this.gameObject.AddComponent&lt;AudioSource&gt;(); // 设置音效片段文件 if (clip == null) clip = Resources.Load&lt;AudioClip&gt;(&quot;Sound/CannonShoot&quot;); source.clip = clip; // 命令 Audio Source 组件开始播放音效 source.Play(); // 控制声音开关的代码 // 如果设置了静音，则将声音关闭 source.mute = !MusicData.isOpenSound; // 为了避免组件过多，可以在一定时间后移除当前添加的组件 Destroy(source, 2); Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Obj/Bullet&quot;), shootPos.position, shootPos.rotation); &#125;&#125; 制作一个Toggle 创建一个音效数据管理类，创建一个静态变量设置音效的开关，这个静态的音效开关变量可以在坦克脚本的开火函数中设置开火是否开音效，也可以监听面板音效框是否选中的回调 MusicData.cs 12345public class MusicData&#123; //音效开关 public static bool isOpenSound = true;&#125; GamePanel.cs 123456789101112131415161718192021222324public class GamePanel : MonoBehaviour&#123; public UIButton btn; public TankObj player; // 此变量用于存储一个 UIToggle 类型的引用，代表音效开关组件 public UIToggle togSound; void Start() &#123; btn.onClick.Add(new EventDelegate(() =&gt; &#123; player.Fire(); &#125;)); // 注册音效开关事件，让静态的 MusicData.isOpenSound 与当前 UIToggle 组件中 value 值进行同步 togSound.onChange.Add(new EventDelegate(() =&gt; &#123; //将“是否打开声效”设置为 toggle 的值：如果它被选中，则为 true；否则为 false MusicData.isOpenSound = togSound.value; &#125;)); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"10.Button按钮","slug":"UI系统/NGUI/NGUI基础知识/10.Button按钮","date":"2025-03-10T07:09:25.000Z","updated":"2025-03-10T08:16:14.282Z","comments":true,"path":"2025/03/10/UI系统/NGUI/NGUI基础知识/10.Button按钮/","permalink":"http://example.com/2025/03/10/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.Button%E6%8C%89%E9%92%AE/","excerpt":"","text":"所有组合控件的共同特点 组合控件都是在三大基础控件 精灵图片、标签文本、纹理大图对象上添加对应组件。 如果希望响应点击等事件，需要添加NGUI碰撞器。 Button是用来干嘛的？ UI界面中的按钮，当点击按钮后我们可以进行一些处理。 制作Button 添加一个Sprite（需要文字再加一个Label子对象） 为Sprite添加Button脚本 添加NGUI的碰撞器 Button参数相关 Twen Target 按钮控制的目标 一般是3个基础控件之一 会自动设置 Drag Over 拖曳结束后做什么 一般不使用不改变 Transition 颜色变化效果的持续时间 Colors 按钮各状态颜色设置 普通 经过 按下 失活 默认 Sprites 按钮各状态图片设置 普通 经过 按下 失活 自动设置原始大小 OnClick 点击按钮响应脚本 Pixel Snap 是否使用图片默认大小 勾选后，点击或者经过等各种按钮的状态就会使用原有的图片的大小 监听Button按钮点击事件的两种方式 拖脚本监听按钮点击事件 在脚本里写要按钮点击要执行的函数 1234public void ClickDoSomthing1()&#123; print(&quot;按钮点击1&quot;);&#125; 挂载脚本到一个对象上（这里挂载了Panel上），把对象拖拽到按钮的Notify变量上 选择按钮点击要执行的函数所在的脚本，再选择点击要执行的函数 注意： 点击执行的函数是私有的，就不能在Inspector的窗口选择关联。 可以选择多个对象拖拽到按钮的Notify变量上，然后可以选择多个按钮点击要执行函数，这样按钮点击时可以执行多个函数。 代码获取按钮对象监听 （更常用 123456789101112131415161718192021222324public UIButton uIButton;void Start()&#123; //获取UIButton实例对象后，给UIButton添加监听，传入要监听的函数 //其中onClick其实是UIButton实例对象中的一个List&lt;EventDelegate&gt;类型的变量 //无非就是调用Add方法给这个列表 添加一个新的EventDelegate类型的对象 //EventDelegate类型有一个构造函数 是传入一个无参无返回的委托 我们就传入我们的无参无返回值的函数即可 //public delegate void Callback(); //添加一个名为ClickDoSomthing2的方法作为UIButton组件的点击事件处理程序，该方法在按钮被点击时被调用 uIButton.onClick.Add(new EventDelegate(ClickDoSomthing2)); //添加一个匿名方法作为UIButton组件的第二个点击事件处理程序，在按钮被点击时执行打印语句 uIButton.onClick.Add(new EventDelegate(() =&gt; &#123; print(&quot;那么大表达式添加的 点击事件处理&quot;); &#125;));&#125;public void ClickDoSomthing2()&#123; print(&quot;按钮点击2&quot;);&#125; 练习 请用现在所学知识，制作一个这样的功能:场景上有一个坦克，点击NGUI的发射按钮，可以让坦克发射一颗子弹 场景中创建地板对象，坦克对象，子弹对象 子弹脚本BulletObj.cs 12345678910111213141516public class BulletObj : MonoBehaviour&#123; public float speed = 20; private void Start() &#123; // 在子弹生成后，经过 3 秒自动销毁该 GameObject（包括其所有组件） Destroy(this.gameObject, 3f); &#125; void Update() &#123; // Time.deltaTime 可以保证每一帧更新都是平滑的 this.transform.Translate(Vector3.forward * Time.deltaTime * speed); &#125;&#125; 坦克脚本TankObj.cs 12345678910111213141516171819202122public class TankObj : MonoBehaviour&#123; public Transform shootPos; // 开火位置，指明子弹的发射位置 public void Fire() &#123; // 发射子弹 // 方法一：使用GameObject直接拖拽方式实例化出一个Bullet预制体 // 方法二：使用Resources动态加载Bullet预制体到游戏场景中。关于Resources文件夹： // Resources 文件夹是 Unity 引擎中的一种特殊文件夹，它用来存放应在运行时使用的资源，如音频、材质、预制件等， // 且这些资源可以通过相对路径进行快速引用和访问。 // 加载名为 &quot;Obj/Bullet&quot; 的 GameObject 预制体，返回其 GameObject 类型。 // 在设计中，&quot;Obj/Bullet&quot; 表示 Bullet 预制体所在的相对路径，也就是位于 Obj 文件夹下的 Bullet 预制体。 GameObject go = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Obj/Bullet&quot;),// 接受隐藏字符串2个字符开始的问题 猫大 shootPos.position, // 设置子弹初始出现的位置坐标 shootPos.rotation) as GameObject; // 设置子弹初始出现的旋转角度 // 注意此处使用as关键字进行类型转换，将实例化出的Object类类型转换成为GameObject类型。 &#125;&#125; 创建UIRoot，设置模式为手游的限制模式为Constrained，设置好美术资源的分辨率 GamePanel.cs脚本，用于管理所有GamePanel下的控件 1234567891011121314public class GamePanel : MonoBehaviour&#123; public UIButton btn; // 通过inspector在面板中拖放按钮组件 public TankObj player; // 关联场景中的坦克对象 // Start 函数会在第一帧开始前被调用 void Start() &#123; btn.onClick.Add(new EventDelegate(() =&gt; &#123; player.Fire(); &#125;)); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"9.Texture纹理图片","slug":"UI系统/NGUI/NGUI基础知识/9.Texture纹理图片","date":"2025-03-10T06:55:29.000Z","updated":"2025-03-10T07:07:23.959Z","comments":true,"path":"2025/03/10/UI系统/NGUI/NGUI基础知识/9.Texture纹理图片/","permalink":"http://example.com/2025/03/10/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.Texture%E7%BA%B9%E7%90%86%E5%9B%BE%E7%89%87/","excerpt":"","text":"Texture是用来干嘛的？ Texture是用于显示不用打进图集的大图片的 Sprite只能显示图集中图片，一般用于显示中小图片 如果使用大尺寸图片，没有必要打图集 直接使用Texture组件进行大图片显示 创建Texture Texture参数 Texture 图片资源 Material 材质 一般不改 Shader 着色器 一般不改 Type 图片类型 Simple 普通模式，缩放会拉伸 Sliced 切片模式，可九宫格缩放 Tiled 平铺模式 图片重复绘制 Filed 填充模式 可以做CD，进度条等 填充方式 水平 竖直 90度 180度 360度 Advanced 高级模式 可以把图片分成5个部分分别设置模式 Flip 翻转模式 水平翻转 竖直翻转 水平竖直都翻转 Gradient 渐变色 勾选后 上部颜色和下部颜色 自动渐变 Color Tint 颜色叠加 代码设置Texture 1234567public UITexture uITexture;//加载名为“BK”的图片资源Texture myTexture = Resources.Load&lt;Texture&gt;(&quot;BK&quot;);//如果成功加载了图片资源，则将UITexture组件的主纹理(mainTexture)替换成该图片if (myTexture != null) uITexture.mainTexture = myTexture;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"8.Label文本","slug":"UI系统/NGUI/NGUI基础知识/8.Label文本","date":"2025-03-10T06:24:16.000Z","updated":"2025-03-10T06:53:56.203Z","comments":true,"path":"2025/03/10/UI系统/NGUI/NGUI基础知识/8.Label文本/","permalink":"http://example.com/2025/03/10/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.Label%E6%96%87%E6%9C%AC/","excerpt":"","text":"Label是用来干嘛的？ NGUI中所有文本显示都使用Label来显示 创建Label文本 方法一：NGUI菜单栏下拉框创建Label文本控件 方法二：选中UIRoot，点击红框创建Label文本控件 Label参数 Font 字体 使用Unity字体可以使用fft的字体文件 也可以使用NGUI字体图集（之后专门讲解） 系统自带字体：C:\\Windows\\Fonts Material材质 一般不会修改 FontSize字体大小 普通 加粗 斜体 加粗并斜体 Text 显示内容 Modifier 修饰方式 强制大小写字母 没有限制 大写字母 小写字母 自定义 Overflow Shrink Content 收缩内容 文字显示的大小与Label的大小自动适应 Label控件尺寸不足显示较大字体时 字体的尺寸会自动适应Label控件的尺寸 Clamp Content 夹紧内容 裁减掉无法显示的字体内容 字体会按照FontSize大小来显示 如果Label控件大小不足以装下字体时 对应内容被裁剪掉不会显示 Resize Freely 自动调整大小（比较常用） Label大小去适应字体内容的大小 Resize Height 自动调整高 Label控件高度无法手动调节 会随着字体内容的大小需求去适配字体内容 只能手动调节Label控件的宽度 Alignment 对其方式 自动对齐 居左 中心 居右 调整会自动变化 Keep crispp 动态字体锐化 这是一个动态字体功能，可以确保文本在收缩时清晰 从不 OnDesktop和Always区别不大都会开启 Gradient 渐变 Effect 特效 None：没有 Shadow：阴影效果 OutLine和Outline8：边缘线，计算参数不同 8粗一点 Float spacing 开启浮点数间隔调整 默认整形 Spacing 字符间隔 Max Lines 最大行数 BBCode 是否开启富文本 Color Tint 字体颜色 富文本 [ff0000]颜色[-] [b]加粗[/b] [i]斜体[/i] [u]下划线[/u] [s]直线穿过文字[/s] [sub]左下角显示[/sub] [sup]右上角显示[/sup] url=http://www.baidu.com/超链接/u 希望点击超链接能打开页面 1.添加碰撞器 （NGUI菜单栏下拉框创建 2.添加脚本Open URL On Click 代码设置Label 创建UILabel实例，首先一定要得到NGUI的Label对象，可以拖拽场景中的游戏对象到代码的Inspector窗口赋值 12//NGUI中的UILabelpublic UILabel uILabel; 想修改Label的相关变量，用UILabel实例.出相关变量修改赋值即可 123//创建UILabel实例 首先一定要得到NGUI的Label对象 可以拖拽场景中的游戏对象到代码的Inspector窗口赋值//想修改Label的相关变量 用UILabel实例.出相关变量修改赋值即可uILabel.text = &quot;123123123123&quot;;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"7.Sprite精灵图片","slug":"UI系统/NGUI/NGUI基础知识/7.Sprite精灵图片","date":"2025-03-10T03:16:41.000Z","updated":"2025-03-10T06:23:12.114Z","comments":true,"path":"2025/03/10/UI系统/NGUI/NGUI基础知识/7.Sprite精灵图片/","permalink":"http://example.com/2025/03/10/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.Sprite%E7%B2%BE%E7%81%B5%E5%9B%BE%E7%89%87/","excerpt":"","text":"Sprite精灵图片 NGUI中所有中小尺寸图片显示都用Sprite显示 使用它来显示图集中的单个图片资源 可以简单的理解为Sprite就是用来显示图片的控件 创建Sprite精灵图片 方法一：NGUI菜单栏下拉框创建精灵Sprite 方法二：选中UIRoot，点击红框创建精灵Sprite Sprite精灵组件参数 Atlas 图集 选择使用的图集 Sprite 选择使用图集中的精灵图片 （点击旁边的Edit编辑按钮可以编辑选中的跳转到图集文件编辑选中的图集中的小图，但是一般不会去编辑，保持默认就行 Material 材质 一般不修改 Fixed Aspect 固定宽高比 不管如何变化尺寸 适中保持宽高比 Type 图片类型 Simple 普通模式，缩放会拉伸 Sliced 切片模式，可九宫格缩放，拉升的时候不会改变4个角 要用切片模式一定要去设置单张图片 拉伸变形如下图： 对使用的精灵图片设置如下： 设置完拉伸后的效果： Tiled 平铺模式 图片重复绘制 Filed 填充模式 可以做CD，进度条等 填充方式 水平 竖直 90度 180度 360度 Advanced 高级模式 可以把图片分成5个部分分别设置模式 Flip 翻转模式 水平翻转 竖直翻转 水平竖直都翻转 Gradient 渐变色 勾选后 上部颜色和下部颜色 自动渐变 Color Tint颜色叠加 公共内容参数 Wiget Pivot 控制对象中心点 决定用于对其的中心点 比如设置左上点 Depth 深度层级 当不同组件在同一面板下，用于决定渲染顺序 值越大越后渲染，显示在前方 以Panel组件Depth排完序之后在按照这里的Depth排 Size 尺寸 Snap 原始尺寸显示 Aspect 宽高比 随意缩放 基于宽 基于高 Sprite精灵图片代码控制 创建UISprite实例，首先一定要得到NGUI的精灵图片游戏对象，可以拖拽场景中的游戏对象到代码的Inspector窗口赋值 12//NGUI中的UISpritepublic UISprite uISprite; 修改精灵图片宽高： 123//修改精灵图片宽高uISprite.width = 200;uISprite.height = 300; 改变精灵图片的图为当前同一图集中选择的图片，直接设置名字即可： 1uISprite.spriteName = &quot;bk&quot;; 改变精灵图片的图为其他图集中的图片： 123456// 先加载图集，指定类型为NGUIAtlasNGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;(&quot;Atlas/login&quot;);// 设置精灵图片图集uISprite.atlas = atlas;// 再设置精灵图片的图uISprite.spriteName = &quot;ui_DL_anniuxiao_01&quot;;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"6.图集制作","slug":"UI系统/NGUI/NGUI基础知识/6.图集制作","date":"2025-03-10T02:48:30.000Z","updated":"2025-03-10T03:13:54.275Z","comments":true,"path":"2025/03/10/UI系统/NGUI/NGUI基础知识/6.图集制作/","permalink":"http://example.com/2025/03/10/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%9B%BE%E9%9B%86%E5%88%B6%E4%BD%9C/","excerpt":"","text":"图集是用来干啥的？ NGUI中的最小图片控件Sprite要使用图集中的图片进行显示 图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集 目的：提高渲染性能 打开图集制作工具 方法一：Project窗口右键 方法二：工具栏 Open 新建图集 在图集制作工具点击New，进入创建图集界面，假如点不了New直接下一步 选择要打成图集的文件 点击Create创建图集，一般创建在Resources文件夹下 可以在Resources文件夹下看到创建出来的图集，图集关键文件有三个，分别是：图集文件，图集材质，图集图片 参数相关 点击会弹出图集选择窗口，点击ShowAll可以显示这个项目里的所有图集，点击Select可以选择切换编辑哪个图集 点击这三个按钮可以分别让指定的图集文件，图集材质，图集图片在Project窗口显示出来 Padding 图片间像素间隔 Trim Alpha 移除图片多余空白空间 PMA Shader* 预乘透明通道 Unity Packer* 自定义打包器 Truecolor 强制ARGB32纹理 Auto-upgrade* 自动更新，用精灵替换纹理 Force Square 如果启用，将强制方形图集纹理 长宽都为2的n次方 Pre-processor 预处理器 修改删除图集元素 选中想新增加到图集里的的图，点击Add/Update添加或更新，等一会后新加的图片就会打到图集里去了 删除","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"5.EventSystem事件系统组件","slug":"UI系统/NGUI/NGUI基础知识/5.EventSystem事件系统组件","date":"2025-03-07T09:11:36.000Z","updated":"2025-03-10T05:50:14.561Z","comments":true,"path":"2025/03/07/UI系统/NGUI/NGUI基础知识/5.EventSystem事件系统组件/","permalink":"http://example.com/2025/03/07/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.EventSystem%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/","excerpt":"","text":"EventSystem是用来干嘛的？ 输入事件监听的基础，主要作用是让摄像机渲染出来的物体，能够接收到NGUI的事件。大部分设置不需要我们去修改，有了它我们通过鼠标 触碰 键盘 控制器 操作UI 响应玩家的输入 注意：UIRoot下的只要创建UI控件就会默认创建一个Camera对象，Camera对象默认有一个Camera组件和EventSystem组件 。Camera组件会根据创建的是2DUI还是3DUI调整是正交模式或者是透视模式 EventSystem很重要，如果没有它，我们没有办法监听玩家输入 创建UI时的 2DUI 和3DUI 主要就是摄像机的模式不一样 EventSystem的2D和3D主要是 采用2D碰撞器 还是3D碰撞器 不能直接改变摄像机模式 参数相关 Event Type 事件类型 决定了脚本如何对鼠标和触屏事件进行响应 UI模式，那么他们处理事件的方式是根据组件的深度 world模式，那么则会根据距离离主摄像机的远近来进行响应排序 2D和3D的区别是，碰撞器是用3D碰撞器还是2D碰撞器 Events go to* 事件通过刚体还是碰撞盒传递 Process Events In* 事件更新进度在Update中还是LateUpdate中 一般不改，默认在Update中 Event Mask 决定哪个游戏对象层级将会接受事件 Debug 是否开启调试模式 如果开启，可以帮助你在点击时 判断当前和鼠标事件交互的是什么对象 能在Scene窗口看到信息 Command Click* 苹果电脑上是否用Command按键模拟右键操作 Allow Multi Touch 是否支持多点触碰 Auto Hide Cursor* 当游戏有控制器或者其他输入设备时 是否自动隐藏光标 Sticky Tooltip* 是否使用tooltip Long Press Tooltip* 是否长按出提示 Tooltip Delay* 停留多久出现tip Raycast Range* 射线长度，一般不修改 EventSources 接收的事件来源 Mouse 鼠标 Touch 触摸 Keyboard 键盘 Controller 控制器 Thresholds* 调整鼠标事件的 点击、拖、轻拍等行为 Mouse Drag Mouse Click Touch Drag Touch Tap Axes and keys* 热键关系 一般不修改","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"4.Panel组件(UIPanel)","slug":"UI系统/NGUI/NGUI基础知识/4.Panel组件(UIPanel)","date":"2025-03-07T06:36:59.000Z","updated":"2025-03-07T09:02:20.735Z","comments":true,"path":"2025/03/07/UI系统/NGUI/NGUI基础知识/4.Panel组件(UIPanel)/","permalink":"http://example.com/2025/03/07/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.Panel%E7%BB%84%E4%BB%B6(UIPanel)/","excerpt":"","text":"Panel是用来干啥的 它是用于让UI元素能够被渲染的关键组件 一般情况下 一个面板 就需要一个UIPanel 所有的UI元素会依托在离自己最近的Panel下 用于管理一个UI面板的渲染顺序 用于管理一个UI面板上的所有子控件 UIRoot默认就会带一个Panel组件，如果Panel组件失活了，其他在UIRoot下暴露在外不在其他Panel下的UI控件都显示不了 也可以创建Panel，创建的Panel自带Panel组件，拖拽其他UI控件到创建Panel对象上，就可以显示了 参数相关 Alpha 控制所有子UI元素的透明度 Depth 控制该Panel的层级 层级高Panel会把成绩低的Panel遮挡住，后渲染会把层级低的先渲染的遮挡住 Clipping 裁剪 None不处理 正常 Texture Mask根据图片信息进行遮罩 比如人物头像 Soft Clip自己定范围裁剪 比如拖动框 Constrain But Dont Clip约束但不剪裁 不裁剪画面 只限制响应范围 Sorting Layer 排序层 Advanced Options 渲染相关高级选项 Render Q渲染队列 Sort Order排序 Normals是否需要灯光着色器 UV2是否用于自定义着色器效果 Shadow Mode Cull元素组件拖动时提出 Visible检查元素组件是否离开屏幕 Padding边界内容 Offset抵消偏移位置 Static检查子元素是否会移动 Panel Tool是否显示面板工具 Anchors 锚点设置相关 用于分辨率自适应设置大小 总结 没有Panel父对象 UI控件看不到 Panel一般用于管理面板 控制层级 Panel可以有多个 一般一个Panel管理一个面板","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.Root组件(UIRoot)","slug":"UI系统/NGUI/NGUI基础知识/3.Root组件(UIRoot)","date":"2025-03-07T06:12:19.000Z","updated":"2025-03-10T07:52:29.322Z","comments":true,"path":"2025/03/07/UI系统/NGUI/NGUI基础知识/3.Root组件(UIRoot)/","permalink":"http://example.com/2025/03/07/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.Root%E7%BB%84%E4%BB%B6(UIRoot)/","excerpt":"","text":"分辨率相关概念 分辨率 屏幕宽高两个方向的像素点 比如1920 * 1080 宽1920个像素 高1080个像素 像素 像素即px 是画面中最小的点(单位色块) 屏幕尺寸 屏幕对角线长度 屏幕比例 宽高比 PC显示器 1920:1080=16:9 苹果手机 iPhone7,8：1334 * 750 = 16:9 iPhone 7,8 Plus：1920 * 1080 = 16:9 iPhoneX：2436 * 1125 = 19.5:9 iPhone12:2532 * 1170 = 19.5:9 目前市面上设备分辨率比例传统的有： 4:3( ipad ) 16:10 16:9( 老手机 、电脑显示器 ) 18:9（去掉留海屏幕） 19.5:9（ 新款手机） 19.9:9 dpi 像素密度 单位面积上有多少个像素点 一般指一英寸有多少个像素点 Root根组件的作用 Root是用于分辨率自适应的根对象，是控制分辨率自适应模式的基础，可以设置基本分辨率，用于设置UI显示区域，并且管理所有UI控件的分辨率自适应 可以简单理解 它管理一个 UI画布 所有的UI都是显示在这个画布上的，它会管理 UI画布 和 不同屏幕分辨率的 适应关系 创建Root组件 方式1：在Project面板右键中创建 方式2：在窗口旁白的NGUI创建 Root相关参数 Flexible 灵活模式 （一般电脑游戏用） 在该模式下，UI都是以像素为基础，100像素的物体无论在多少分辨率上都是100像素 这就意味着，100像素在分辨率低的屏幕上可能显示正常，但是在高分辨率上就会显得很小 Minimum Height 屏幕高小于该值时 开始按比例缩放 Maximum Height 屏幕高大于改值时 开始按比例缩放 Shrink Portrait UI 竖屏时，按宽度来适配 Adjust by DPI 使用dpi做适配计算 建议勾选 Constrained 约束模式 （这个用的多） 填写美术作图的标准分辨率 该模式下，屏幕按尺寸比例来适配，不管实际屏幕有多大 NGUI都会通过合适的缩放来适配屏幕。 这样在高分辨率上显示的UI就会被放大保持原有大小，但有可能会模糊，好处是各设备看到的UI和屏幕比例是一样的 红框：就是game窗口的分辨率大小就是多少 蓝框：就是NGUI的Root的面板上的Content Width 和 Content Height的宽高（美术同学在制作UI的时候采用的标准分辨率） 蓝框 包裹住 红框， 游戏全屏 Content Width 按照该宽度值适配屏幕 制作资源时的默认分辨率宽 Content Height 按照该高度值适配屏幕 制作资源时的默认分辨率高 Fit表示以那个值做适配 勾选Width （一般做竖屏游戏用，高拉长UI大小不变但会有黑边或裁剪，宽拉长UI会跟着变大但始终充满屏幕） 屏幕比例变化时，按照宽度来适配（宽度始终不变） 勾选Height （默认勾选上的，一般做横屏游戏用，宽拉长UI大小不变但会有黑边或裁剪，高拉长UI会跟着变大但始终充满屏幕） 屏幕比例变化时，按照高度来适配（高度始终不变） 两个都勾选 （支持横屏和竖屏都有的游戏） 不会被裁剪，但是有黑边 当适配宽高比大于实际宽高比时，就会按照宽度适配， 反之按照高度适配 如果两个都不勾选 始终保证屏幕被UI填充满 不会有黑边 可能会被裁剪 Constrained On Mobiles 上两种模式的综合体 在PC和Mac等桌面设备上用Flexible模式 在移动设备上用Constrained模式 总结 Flexible 适用于可以手动拖窗口改变分辨率的设备 比如pc端 Constrained 适用于移动设备 因为移动设备都是全屏应用 不会频繁改变分辨率 只用适配不同分辨率的设备 横屏勾选 高 fit 竖屏 勾选 宽 fit 一般就可以比较好的进行分辨率适应了 需要注意的是 背景图 一定要考虑 极限 宽高比来出 最大宽高比 19.9:9 Constrained On Mobiles 是上面两者的综合体 适用于多平台发布的游戏和应用","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.NGUI下载和导入","slug":"UI系统/NGUI/NGUI基础知识/2.NGUI下载和导入","date":"2025-03-07T05:49:54.000Z","updated":"2025-03-07T05:54:52.573Z","comments":true,"path":"2025/03/07/UI系统/NGUI/NGUI基础知识/2.NGUI下载和导入/","permalink":"http://example.com/2025/03/07/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.NGUI%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%AF%BC%E5%85%A5/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.XMLDataMgr存储读取功能","slug":"数据/数据持久化/XML/XML实践项目/2.XMLDataMgr存储读取功能","date":"2025-03-07T05:22:34.000Z","updated":"2025-03-07T05:36:20.092Z","comments":true,"path":"2025/03/07/数据/数据持久化/XML/XML实践项目/2.XMLDataMgr存储读取功能/","permalink":"http://example.com/2025/03/07/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.XMLDataMgr%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96%E5%8A%9F%E8%83%BD/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738public class XmlDataMgr&#123; private static XmlDataMgr _instance = new XmlDataMgr(); public static XmlDataMgr Instance =&gt; _instance; private XmlDataMgr() &#123; &#125; public void SaveData(object obj, string fileName) &#123; string path = $&quot;&#123;Application.persistentDataPath&#125;/&#123;fileName&#125;.xml&quot;; using (StreamWriter writer = new StreamWriter(path)) &#123; XmlSerializer serializer = new XmlSerializer(obj.GetType()); serializer.Serialize(writer, obj); &#125; &#125; public object LoadData(Type type, string fileName) &#123; string path = $&quot;&#123;Application.persistentDataPath&#125;/&#123;fileName&#125;.xml&quot;; if (!File.Exists(path)) &#123; path = $&quot;&#123;Application.streamingAssetsPath&#125;/&#123;fileName&#125;.xml&quot;; &#125; if (!File.Exists(path)) &#123; //如果根本不存在文件 两个路径都找过了 //那么直接new 一个对象 返回给外部 无非 里面都是默认值 return Activator.CreateInstance(type); &#125; using (StreamReader reader = new StreamReader(path)) &#123; XmlSerializer serializer = new XmlSerializer(type); object obj = serializer.Deserialize(reader); return obj; &#125; &#125; &#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142public class TestData&#123; public string name; public int age; public TestData(string name, int age) &#123; this.name = name; this.age = age; &#125; public TestData() &#123; &#125;&#125;public class Test : MonoBehaviour&#123; public SerializerDictionary&lt;string, int&gt; dic; private void Start() &#123; // 创建测试数据对象 TestData originalData = new TestData(&quot;John&quot;, 25); // 定义文件名 string fileName = &quot;testData&quot;; // 保存数据到 XML 文件 XmlDataMgr.Instance.SaveData(originalData, fileName); Debug.Log(&quot;数据已保存到 XML 文件。&quot;); // 从 XML 文件加载数据 TestData loadedData = (TestData)XmlDataMgr.Instance.LoadData(typeof(TestData), fileName); Debug.Log(&quot;数据已从 XML 文件加载。&quot;); // 验证加载的数据是否与原始数据一致 if (loadedData != null &amp;&amp; loadedData.name == originalData.name &amp;&amp; loadedData.age == originalData.age) &#123; Debug.Log(&quot;数据加载成功，内容一致。&quot;); &#125; else &#123; Debug.LogError(&quot;数据加载失败，内容不一致。&quot;); &#125; &#125;&#125; 生成的xml文件 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TestData xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;name&gt;John&lt;/name&gt; &lt;age&gt;25&lt;/age&gt;&lt;/TestData&gt;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML实践项目","slug":"数据/数据持久化/XML/XML实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML实践项目","slug":"XML实践项目","permalink":"http://example.com/tags/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.需求分析+XML数据管理类创建","slug":"数据/数据持久化/XML/XML实践项目/1.需求分析+XML数据管理类创建","date":"2025-03-07T05:17:28.000Z","updated":"2025-03-07T05:21:49.031Z","comments":true,"path":"2025/03/07/数据/数据持久化/XML/XML实践项目/1.需求分析+XML数据管理类创建/","permalink":"http://example.com/2025/03/07/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90+XML%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B1%BB%E5%88%9B%E5%BB%BA/","excerpt":"","text":"需求分析 目标： 提供公共的序列化和反序列化方法给外部 方便外部存储和获取数据 12345678910111213141516public class XmlDataMgr&#123; private static XmlDataMgr _instance = new XmlDataMgr(); public static XmlDataMgr Instance =&gt; _instance; private XmlDataMgr() &#123; &#125; public void SaveData(object obj, string fileName) &#123; &#125; public void LoadData(Type type, string fileName) &#123; &#125; &#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML实践项目","slug":"数据/数据持久化/XML/XML实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML实践项目","slug":"XML实践项目","permalink":"http://example.com/tags/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.让Dictionary支持序列化和反序列化","slug":"数据/数据持久化/XML/XML基础知识/11.让Dictionary支持序列化和反序列化","date":"2025-03-07T04:25:45.000Z","updated":"2025-03-07T05:16:17.344Z","comments":true,"path":"2025/03/07/数据/数据持久化/XML/XML基础知识/11.让Dictionary支持序列化和反序列化/","permalink":"http://example.com/2025/03/07/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.%E8%AE%A9Dictionary%E6%94%AF%E6%8C%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"思考如何让Dictionary支持xml序列和反序列化？ 我们没办法修改C#自带的类 那我们可以重写一个类 继承Dictionary 然后让这个类继承序列化拓展接口IXmlSerializable 实现里面的序列化和反序列化方法即可 自定义序列化Dictionary 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SerializerDictionary&lt;TKey, TValue&gt; : Dictionary&lt;TKey, TValue&gt;, IXmlSerializable&#123; public XmlSchema GetSchema() =&gt; null; public void ReadXml(XmlReader reader) &#123; XmlSerializer keySerializer = new XmlSerializer(typeof(TKey)); XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue)); this.Clear(); bool isEmpty = reader.IsEmptyElement; // 检查是否是空元素 reader.ReadStartElement(); // 跳过根节点， 读到根节点&lt;root&gt;下面的第一个节点 if (isEmpty) return; while (reader.NodeType != XmlNodeType.EndElement) &#123; // 反序列化键 TKey key = (TKey)keySerializer.Deserialize(reader); // 反序列化值 TValue value = (TValue)valueSerializer.Deserialize(reader); this.Add(key, value); &#125; reader.ReadEndElement(); // 消费结束标签 &#125; public void WriteXml(XmlWriter writer) &#123; XmlSerializer keySerializer = new XmlSerializer(typeof(TKey)); XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue)); foreach (KeyValuePair&lt;TKey, TValue&gt; pair in this) &#123; keySerializer.Serialize(writer, pair.Key); valueSerializer.Serialize(writer, pair.Value); &#125; &#125;&#125; 测试类 12345678910111213141516171819202122232425public class Test : MonoBehaviour&#123; public SerializerDictionary&lt;string, int&gt; dic; private void Start() &#123; string path = $&quot;&#123;Application.persistentDataPath&#125;/Test.xml&quot;; print(path); dic = new SerializerDictionary&lt;string, int&gt;(); dic[&quot;nihao&quot;] = 1; dic[&quot;世界&quot;] = 2; XmlSerializer serializer = new XmlSerializer(typeof(SerializerDictionary&lt;string, int&gt;)); using (StreamWriter sw = new StreamWriter(path)) &#123; serializer.Serialize(sw, dic); &#125; XmlSerializer serializer2 = new XmlSerializer(typeof(SerializerDictionary&lt;string, int&gt;)); SerializerDictionary&lt;string, int&gt; newDic = new SerializerDictionary&lt;string, int&gt;(); using (StreamReader r = new StreamReader(path)) &#123; newDic = serializer2.Deserialize(r) as SerializerDictionary&lt;string, int&gt;; &#125; &#125;&#125; 生成的xml文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;SerializerDictionaryOfStringInt32&gt; &lt;string&gt;nihao&lt;/string&gt; &lt;int&gt;1&lt;/int&gt; &lt;string&gt;世界&lt;/string&gt; &lt;int&gt;2&lt;/int&gt;&lt;/SerializerDictionaryOfStringInt32&gt;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"10.IXmlSerializable接口","slug":"数据/数据持久化/XML/XML基础知识/10.IXmlSerializable接口","date":"2025-03-06T11:29:51.000Z","updated":"2025-03-07T05:06:27.217Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/10.IXmlSerializable接口/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.IXmlSerializable%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"IXmlSerializable是什么 C# 的 XmlSerializer 接口提供了可拓展内容，可以让一些不能被序列化和反序列化的特殊类能够被处理。通过让特殊类继承 IXmlSerializable 接口并实现其中的方法，就能实现这一点。例如，字典就不能直接序列化，但可以通过自定义拓展让其序列化。 自定义序列化（实现IXmlSerializable接口） ReadXml 方法中 XmlReader 的常用属性和方法 属性 Name ：获取当前节点的名称。 NodeType ：获取当前节点的类型（如元素、文本、注释等）。 Value ：获取当前节点的值。 方法 ReadStartElement ：读取当前元素的开始标记，并将读取器推进到下一个节点。 ReadElementContentAsString ：读取当前元素的内容并将其作为字符串返回，同时将读取器推进到下一个节点 ReadElementContentAsInt ：读取当前元素的内容并将其转换为整数返回，同时将读取器推进到下一个节点。 ReadEndElement ：读取当前元素的结束标记，并将读取器推进到下一个节点。 ReadToFollowing ：将读取器推进到具有指定名称的下一个元素。eg:reader.ReadToFollowing(&quot;Person&quot;); WriteXml 方法中 XmlWriter 的常用属性和方法 属性 Settings ：获取用于创建 XmlWriter 的 XmlWriterSettings 对象，可用于控制 XML 输出的格式，如缩进、编码等。 方法 WriteStartElement ：写入指定名称的元素开始标记。 WriteElementString ：写入包含指定值的元素。 WriteAttributeString ：写入包含指定值的属性。 WriteEndElement ：写入当前元素的结束标记。 WriteString ：写入指定的文本内容。 WriteWhitespace ：写入空白字符，可用于格式化 XML 输出。 writer.WriteAttributeString 和 reader[&quot;&quot;] 123456789101112131415161718192021222324public class TestClass : IXmlSerializable&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public TestClass(string name, int age) =&gt; (Name, Age) = (name, age); public XmlSchema GetSchema() =&gt; null; public void ReadXml(XmlReader reader) &#123; // 读写规则要同步 this.Name = reader[&quot;这里填属性的名字&quot;]; this.Age = int.Parse(reader[&quot;Age要tostring&quot;]); &#125; public void WriteXml(XmlWriter writer) &#123; writer.WriteAttributeString(&quot;这里填属性的名字&quot;, this.Name); writer.WriteAttributeString(&quot;Age要tostring&quot;, this.Age.ToString()); &#125; public TestClass() &#123; &#125;&#125; 序列化后如下 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TestClass 这里填属性的名字=&quot;名字&quot; Age要tostring=&quot;18&quot; /&gt; &lt;!-- 直接就在根节点上面写了--&gt; reader.Read() 和 writer.WriteElementString 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TestClass : IXmlSerializable&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public TestClass(string name, int age) =&gt; (Name, Age) = (name, age); public XmlSchema GetSchema() =&gt; null; public void ReadXml(XmlReader reader) &#123; // 读写规则要同步 //this.Name = reader[&quot;这里填属性的名字&quot;]; //this.Age = int.Parse(reader[&quot;Age要tostring&quot;]); //// 读节点什么都没做是默认的根节点 //reader.Read(); // 是读到根节点的第一个节点 即 &lt;生成的节点名字&gt; //reader.Read(); // 是读到第一个节点的值 //this.Name = reader.Value; //reader.Read(); // 是读到第一个节点的结束标签 //reader.Read(); // 是读到第二个节点的开始标签 //reader.Read(); // 是读到第二个节点的值 //this.Age = int.Parse(reader.Value); // 或者这样 while (reader.Read()) &#123; if (reader.NodeType == XmlNodeType.Element) &#123; switch (reader.Name) &#123; case &quot;生成的节点名字&quot;: reader.Read(); this.Name = reader.Value; break; case &quot;Age&quot;: reader.Read(); this.Age = int.Parse(reader.Value); break; &#125; &#125; &#125; &#125; public void WriteXml(XmlWriter writer) &#123; //writer.WriteAttributeString(&quot;这里填属性的名字&quot;, this.Name); //writer.WriteAttributeString(&quot;Age要tostring&quot;, this.Age.ToString()); writer.WriteElementString(&quot;生成的节点名字&quot;, this.Name); writer.WriteElementString(&quot;Age&quot;, this.Age.ToString()); &#125; public TestClass() &#123; &#125;&#125; 序列化后如下 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TestClass&gt; &lt;生成的节点名字&gt;名字&lt;/生成的节点名字&gt; &lt;Age&gt;18&lt;/Age&gt;&lt;/TestClass&gt; writer.WriteStartElement 和 reader.ReadStartElement 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class TestClass : IXmlSerializable&#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; public TestClass(string name, int age) =&gt; (Name, Age) = (name, age); public XmlSchema GetSchema() =&gt; null; public void ReadXml(XmlReader reader) &#123; // 读写规则要同步 //this.Name = reader[&quot;这里填属性的名字&quot;]; //this.Age = int.Parse(reader[&quot;Age要tostring&quot;]); //// 读节点什么都没做是默认的根节点 //reader.Read(); // 是读到根节点的第一个节点 即 //reader.Read(); // 是读到第一个节点的值 //this.Name = reader.Value; //reader.Read(); // 是读到第一个节点的结束标签 //reader.Read(); // 是读到第二个节点的开始标签 //reader.Read(); // 是读到第二个节点的值 //this.Age = int.Parse(reader.Value); // 或者这样 //while (reader.Read()) //&#123; // if (reader.NodeType == XmlNodeType.Element) // &#123; // switch (reader.Name) // &#123; // case &quot;生成的节点名字&quot;: // reader.Read(); // this.Name = reader.Value; // break; // case &quot;Age&quot;: // reader.Read(); // this.Age = int.Parse(reader.Value); // break; // &#125; // &#125; //&#125; XmlSerializer s = new XmlSerializer(typeof(int)); // 先跳过根节点 reader.Read(); reader.ReadStartElement(&quot;名字int&quot;); this.Age = int.Parse(s.Deserialize(reader).ToString()); reader.ReadEndElement(); XmlSerializer s2 = new XmlSerializer(typeof(string)); reader.ReadStartElement(&quot;名字string&quot;); this.Name = s2.Deserialize(reader).ToString(); reader.ReadEndElement(); &#125; public void WriteXml(XmlWriter writer) &#123; //writer.WriteAttributeString(&quot;这里填属性的名字&quot;, this.Name); //writer.WriteAttributeString(&quot;Age要tostring&quot;, this.Age.ToString()); //writer.WriteElementString(&quot;生成的节点名字&quot;, this.Name); //writer.WriteElementString(&quot;Age&quot;, this.Age.ToString()); XmlSerializer s = new XmlSerializer(typeof(int)); writer.WriteStartElement(&quot;名字int&quot;); s.Serialize(writer, this.Age); writer.WriteEndElement(); XmlSerializer s2 = new XmlSerializer(typeof(string)); writer.WriteStartElement(&quot;名字string&quot;); s2.Serialize(writer, this.Name); writer.WriteEndElement(); &#125; public TestClass() &#123; &#125;&#125; 序列化后如下 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TestClass&gt; &lt;名字int&gt; &lt;int&gt;18&lt;/int&gt; &lt;/名字int&gt; &lt;名字string&gt; &lt;string&gt;名字&lt;/string&gt; &lt;/名字string&gt;&lt;/TestClass&gt; 其它示例 目标XML格式 12345678&lt;Player profile=&quot;hero&quot;&gt; &lt;Name&gt;Arthur&lt;/Name&gt; &lt;Level&gt;45&lt;/Level&gt; &lt;Inventory&gt; &lt;Item id=&quot;1&quot;&gt;Excalibur&lt;/Item&gt; &lt;Item id=&quot;2&quot;&gt;HolyGrail&lt;/Item&gt; &lt;/Inventory&gt;&lt;/Player&gt; 对应的C#类实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class PlayerData : IXmlSerializable&#123; public string ProfileType &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Level &#123; get; set; &#125; public List&lt;InventoryItem&gt; Inventory &#123; get; set; &#125; = new(); public XmlSchema? GetSchema() =&gt; null; public void WriteXml(XmlWriter writer) &#123; writer.WriteStartElement(&quot;Player&quot;); writer.WriteAttributeString(&quot;profile&quot;, ProfileType); writer.WriteElementString(&quot;Name&quot;, Name); writer.WriteElementString(&quot;Level&quot;, Level.ToString()); writer.WriteStartElement(&quot;Inventory&quot;); foreach (var item in Inventory) &#123; writer.WriteStartElement(&quot;Item&quot;); writer.WriteAttributeString(&quot;id&quot;, item.Id.ToString()); writer.WriteString(item.Name); writer.WriteEndElement(); // Item &#125; writer.WriteEndElement(); // Inventory writer.WriteEndElement(); // Player &#125; public void ReadXml(XmlReader reader) &#123; ProfileType = reader.GetAttribute(&quot;profile&quot;); reader.ReadStartElement(&quot;Player&quot;); Name = reader.ReadElementContentAsString(&quot;Name&quot;, &quot;&quot;); Level = reader.ReadElementContentAsInt(&quot;Level&quot;, &quot;&quot;); reader.ReadStartElement(&quot;Inventory&quot;); while (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.LocalName == &quot;Item&quot;) &#123; var item = new InventoryItem &#123; Id = int.Parse(reader.GetAttribute(&quot;id&quot;)), Name = reader.ReadElementContentAsString() &#125;; Inventory.Add(item); &#125; reader.ReadEndElement(); // Inventory reader.ReadEndElement(); // Player &#125;&#125;public class InventoryItem&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"9.CSharp中XML反序列化","slug":"数据/数据持久化/XML/XML基础知识/9.CSharp中XML反序列化","date":"2025-03-06T11:07:07.000Z","updated":"2025-03-06T11:29:05.213Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/9.CSharp中XML反序列化/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.CSharp%E4%B8%ADXML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"知识回顾 序列化 判断文件是否存在 123456string path = Application.persistentDataPath + &quot;/Lesson1Test.xml&quot;;// 存在再进行反序列化的处理，不存在就不能反序列化if (File.Exists(path))&#123; // 反序列化处理&#125; 反序列化 关键类和语法 XmlSerializer StreamReader csharp的using语句 注意 public List&lt;int&gt; listInt = new List&lt;int&gt; &#123; 1, 2, 3 &#125;; 反序列化出来的 listInt 会有 {1, 2, 3, 1, 2, 3 }; 最好不要在读取的类的列表成员变量声明时初始化就赋值 12345678910public PlayerData LoadPlayerData(string path)&#123; if (!File.Exists(path)) return null; XmlSerializer serializer = new XmlSerializer(typeof(PlayerData)); using (StreamReader reader = new StreamReader(path)) &#123; return (PlayerData)serializer.Deserialize(reader); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"csharp的using语句","slug":"编程语言/Csharp/csharp的using语句","date":"2025-03-06T09:11:17.000Z","updated":"2025-03-06T09:18:50.454Z","comments":true,"path":"2025/03/06/编程语言/Csharp/csharp的using语句/","permalink":"http://example.com/2025/03/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84using%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"using语句 基本概念 using 语句提供了一种简洁的方式来管理实现了 System.IDisposable 接口的对象。实现了 IDisposable 接口的对象通常包含需要手动释放的非托管资源，如文件句柄、数据库连接、网络连接、图形资源等。using 语句会在代码块结束时自动调用对象的 Dispose 方法，从而确保资源被正确释放，避免资源泄漏。 工作原理 using 语句的基本语法如下： 1234using (ResourceType resource = new ResourceType())&#123; // 使用资源的代码&#125; 当执行到 using 语句时，会创建 ResourceType 类型的对象并将其赋值给 resource 变量。然后进入 using 语句的代码块，在代码块中可以使用该资源。当代码块执行完毕（无论是正常结束还是因为异常而跳出），using 语句会自动调用 resource 对象的 Dispose 方法，释放其所占用的资源。 实际上，上述 using 语句等价于以下 try - finally 代码结构： 12345678910ResourceType resource = new ResourceType();try&#123; // 使用资源的代码&#125;finally&#123; if (resource != null) ((IDisposable)resource).Dispose();&#125; 使用场景 一般配合内存占用比较大，有读写操作使用 文件操作：在使用 FileStream、StreamReader、StreamWriter 等类进行文件读写时，这些类都实现了 IDisposable 接口，使用 using 语句可以确保文件句柄在使用完毕后被正确关闭。 数据库连接：在使用 SqlConnection、MySqlConnection 等数据库连接类时，使用 using 语句可以确保数据库连接在使用完毕后被关闭和释放。 图形资源：在使用 Bitmap、Pen、Brush 等图形资源类时，使用 using 语句可以确保图形资源被正确释放。 文件操作示例 1234567891011121314151617181920212223using System;using System.IO;class Program&#123; static void Main() &#123; // 使用 using 语句创建 StreamWriter 对象 using (StreamWriter writer = new StreamWriter(&quot;test.txt&quot;)) &#123; // 向文件中写入内容 writer.WriteLine(&quot;Hello, World!&quot;); &#125; // 代码块结束，自动调用 writer.Dispose() 方法，关闭文件 // 使用 using 语句创建 StreamReader 对象 using (StreamReader reader = new StreamReader(&quot;test.txt&quot;)) &#123; // 从文件中读取内容 string line = reader.ReadLine(); Console.WriteLine(line); &#125; // 代码块结束，自动调用 reader.Dispose() 方法，关闭文件 &#125;&#125; 数据库连接示例（假设使用 SQL Server） 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Data.SqlClient;class Program&#123; static void Main() &#123; string connectionString = &quot;Data Source=YOUR_SERVER;Initial Catalog=YOUR_DATABASE;User ID=YOUR_USER;Password=YOUR_PASSWORD&quot;; // 使用 using 语句创建 SqlConnection 对象 using (SqlConnection connection = new SqlConnection(connectionString)) &#123; try &#123; // 打开数据库连接 connection.Open(); Console.WriteLine(&quot;数据库连接已打开。&quot;); // 执行 SQL 查询等操作 string query = &quot;SELECT * FROM YourTable&quot;; using (SqlCommand command = new SqlCommand(query, connection)) &#123; using (SqlDataReader reader = command.ExecuteReader()) &#123; while (reader.Read()) &#123; // 处理查询结果 Console.WriteLine(reader[0].ToString()); &#125; &#125; // 代码块结束，自动调用 reader.Dispose() 方法，关闭数据读取器 &#125; // 代码块结束，自动调用 command.Dispose() 方法，释放命令对象 &#125; catch (Exception ex) &#123; Console.WriteLine($&quot;数据库操作出错: &#123;ex.Message&#125;&quot;); &#125; &#125; // 代码块结束，自动调用 connection.Dispose() 方法，关闭数据库连接 &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"8.CSharp中XML序列化","slug":"数据/数据持久化/XML/XML基础知识/8.CSharp中XML序列化","date":"2025-03-06T08:35:03.000Z","updated":"2025-03-06T11:34:20.605Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/8.CSharp中XML序列化/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.CSharp%E4%B8%ADXML%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"什么是序列化？ 将对象状态转换为可存储/传输的格式（如XML、JSON、二进制）的过程。 游戏开发典型应用场景： 玩家存档/读档 网络数据传输 配置文件管理（如画质设置、按键绑定） 对象池的持久化 关键类和语法 XmlSerializer Xml序列化器类：用于序列化对象为XML的关键类 StreamWriter 流写入器类：用于存储文件 csharp的using语句：用于方便流对象释放和销毁 StreamWriter/StreamReader简单介绍 所属命名空间：System.IO 功能：文本文件的读写操作 12345678910111213141516171819202122232425262728using System.IO;using UnityEngine;public class StreamWriterExample : MonoBehaviour&#123; void Start() &#123; // 定义文件路径 string filePath = Application.dataPath + &quot;/example.txt&quot;; try &#123; // 创建一个 StreamWriter 对象，指定文件路径和编码格式 using (StreamWriter writer = new StreamWriter(filePath, false, System.Text.Encoding.UTF8)) &#123; // 写入一行文本 writer.WriteLine(&quot;Hello, World!&quot;); // 写入另一行文本 writer.WriteLine(&quot;This is a test.&quot;); &#125; Debug.Log(&quot;文件写入成功！&quot;); &#125; catch (System.Exception e) &#123; Debug.LogError(&quot;文件写入失败：&quot; + e.Message); &#125; &#125;&#125; XmlSerializer 简单介绍 所属命名空间：System.Xml.Serialization 序列化：当你使用 XmlSerializer 对一个对象进行序列化时，它会反射对象的类型信息，查找对象的公共属性和字段，并根据这些信息生成相应的 XML 元素和属性。序列化过程会将对象的属性值转换为 XML 文本，然后将这些 XML 文本写入到指定的流（如文件流、内存流等）中。 123456789// 创建 XmlSerializer 对象，指定要序列化的类型XmlSerializer serializer = new XmlSerializer(typeof(Person));// 创建一个 StreamWriter 对象，用于将 XML 数据写入文件using (StreamWriter writer = new StreamWriter(filePath))&#123; // 执行序列化操作 (第一个参数是文件流对象，第二个是想要序列化的对象) serializer.Serialize(writer, person);&#125; XML序列化 注意： 只能序列化公共成员 不支持字典序列化 stream相关和using相关 序列化时，对象中的引用成员为空，那么序列化后的xml里面是看不到该字段的 123456789101112131415161718[Serializable]public class PlayerData&#123; [XmlAttribute(&quot;id&quot;)] // 作为XML属性 public int PlayerID; [XmlElement(&quot;name&quot;)] // 作为XML元素 节点名为name public string PlayerName; public Vector3 Position; // 需要特殊处理的结构体 [XmlIgnore] // 忽略不需要序列化的字段 public bool IsDirty; [XmlArray(&quot;IntList&quot;)] [XmlArrayItem(&quot;Int32&quot;)] public List&lt;int&gt; listInt = new List&lt;int&gt; &#123; 1, 2, 3, 4 &#125;;&#125; 12345678public void SavePlayerData(PlayerData data, string path)&#123; XmlSerializer serializer = new XmlSerializer(typeof(PlayerData)); using (StreamWriter writer = new StreamWriter(path)) &#123; serializer.Serialize(writer, data); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"7.XML总结","slug":"数据/数据持久化/XML/XML基础知识/7.XML总结","date":"2025-03-06T08:31:57.000Z","updated":"2025-03-06T08:32:33.808Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/7.XML总结/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.XML%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"6.CSharp存储XML文件","slug":"数据/数据持久化/XML/XML基础知识/6.CSharp存储XML文件","date":"2025-03-06T07:35:19.000Z","updated":"2025-03-06T08:30:01.708Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/6.CSharp存储XML文件/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.CSharp%E5%AD%98%E5%82%A8XML%E6%96%87%E4%BB%B6/","excerpt":"","text":"Xml决定存储在哪个文件夹下 注意：存储xml文件 在Unity中一定是使用各平台都可读可写可找到的路径 Resources 可读 不可写 打包加密后通过路径找不到 × Application.streamingAssetsPath 可读 PC端可写 但是其他平台不可写 打包加密后通过路径找得到 可以存些不会改的xml文件 × Application.dataPath 编辑器上操作看起来没什么问题 但是打包后找不到 × Application.persistentDataPath 可读可写 各个平台找得到 √ 12string path = Application.persistentDataPath + &quot;/player_data.xml&quot;;print(Application.persistentDataPath); 存储XML文件 手动构建XML文档 具体的五个步骤： 创建XmlDocument文档对象 添加固定版本信息 添加根节点 为根节点添加子节点 保存 适用场景：简单配置、快速原型开发 12345678910111213141516171819202122232425262728// 创建XML文档对象XmlDocument doc = new XmlDocument();// 这一句代码 相当于就是创建&lt;?xmlDocument version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;这句内容XmlDeclaration xmlDec = xmlDocument.CreateXmlDeclaration(&quot;1.0&quot;, &quot;UTF-8&quot;, &quot;&quot;);// 创建根节点XmlElement root = doc.CreateElement(&quot;PlayerData&quot;);doc.AppendChild(root);// 添加基础属性XmlElement player = doc.CreateElement(&quot;Player&quot;);player.SetAttribute(&quot;id&quot;, &quot;1001&quot;);player.SetAttribute(&quot;class&quot;, &quot;Warrior&quot;);// 添加子节点// HPXmlElement hpNode = doc.CreateElement(&quot;HP&quot;);hpNode.InnerText = &quot;500&quot;;// AtkXmlElement atkElement = xmlDoc.CreateElement(&quot;Atk&quot;);atkElement.InnerText = &quot;200&quot;;player.AppendChild(hpNode);player.AppendChild(atkElement);// 保存到文件doc.Save(path); // player_data.xml 生成的结果 123456&lt;PlayerData&gt; &lt;Player id=&quot;1001&quot; class=&quot;Warrior&quot;&gt; &lt;HP&gt;500&lt;/HP&gt; &lt;Atk&gt;200&lt;/Atk&gt; &lt;/Player&gt;&lt;/PlayerData&gt; 修改XML文件 判断文件是否存在 1234//File类中的Exists方法 判断路径是否存在if (File.Exists(path))&#123;&#125; 加载后利用学过的方法修改xml文件 1234// 创建 XmlDocument 对象XmlDocument xmlDoc = new XmlDocument();// 加载 XML 文件xmlDoc.Load(&quot;player_data.xml&quot;); 添加节点 1234567891011// 假设已经加载了 XML 文件到 xmlDoc 中// 获取根节点XmlElement root = xmlDoc.DocumentElement;// 创建新的元素节点XmlElement newElement = xmlDoc.CreateElement(&quot;newNode&quot;);// 设置元素节点的文本内容newElement.InnerText = &quot;New Node Content&quot;;// 将新节点添加到根节点下root.AppendChild(newElement); 删除节点 1234567891011// 假设已经加载了 XML 文件到 xmlDoc 中// 使用 XPath 选择要删除的节点XmlNode nodeToDelete = xmlDoc.SelectSingleNode(&quot;//Atk&quot;);if (nodeToDelete != null)&#123; // 获取父节点 XmlNode parentNode = nodeToDelete.ParentNode; // 从父节点中移除该节点 parentNode.RemoveChild(nodeToDelete);&#125; 练习 定义一个名为 SaveData 的公共方法，参数为文件名字符串 fileName 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//定义一个名为 SaveData 的公共方法，参数为文件名字符串 fileNamepublic void SaveData(string fileName)&#123; //决定存储路径 string path = Application.persistentDataPath + &quot;/&quot; + fileName + &quot;.xml&quot;; //输出该XML文档将保存在何处。 Debug.Log(Application.persistentDataPath); //初始化5步操作。 //1.创建XmlDocument对象。稍后它将包含所需的Xml数据。 XmlDocument xml = new XmlDocument(); //2.使用CreateXmlDeclaration()方法创建XmlDeclaration对象声明文档类型和版本。 XmlDeclaration xmlDec = xml.CreateXmlDeclaration(&quot;1.0&quot;, &quot;UTF-8&quot;, &quot;&quot;); //将XmlDeclaration对象添加到XmlDocument对象中。 //这将把该声明作为XML文件的第一行。 xml.AppendChild(xmlDec); //3.添加根节点 //使用CreateElement()方法，创建一个根节点XmlElement对象并命名为“PlayerInfo”。 XmlElement playerInfo = xml.CreateElement(&quot;PlayerInfo&quot;); //向XmlDocument对象添加根节点XmlElement对象“playerInfo” xml.AppendChild(playerInfo); //4.添加子节点 或者 属性相关 //使用CreateElement方法创建Xml子项XmlElement对象并设置它们的InnerText值。 //XmlElement对象表示不带数据的标记或元素。 XmlElement name = xml.CreateElement(&quot;name&quot;); name.InnerText = this.name; playerInfo.AppendChild(name); XmlElement atk = xml.CreateElement(&quot;atk&quot;); atk.InnerText = this.atk.ToString(); playerInfo.AppendChild(atk); XmlElement def = xml.CreateElement(&quot;def&quot;); def.InnerText = this.def.ToString(); playerInfo.AppendChild(def); XmlElement moveSpeed = xml.CreateElement(&quot;moveSpeed&quot;); moveSpeed.InnerText = this.moveSpeed.ToString(); playerInfo.AppendChild(moveSpeed); XmlElement roundSpeed = xml.CreateElement(&quot;roundSpeed&quot;); roundSpeed.InnerText = this.roundSpeed.ToString(); playerInfo.AppendChild(roundSpeed); //创建XmlElement对象表示装备与其属性 XmlElement weapon = xml.CreateElement(&quot;weapon&quot;); XmlElement id = xml.CreateElement(&quot;id&quot;); id.InnerText = this.weapon.id.ToString(); weapon.AppendChild(id); XmlElement num = xml.CreateElement(&quot;num&quot;); num.InnerText = this.weapon.num.ToString(); weapon.AppendChild(num); playerInfo.AppendChild(weapon); //创建XmlAttribute对象表示一个整数列表（listInt） XmlElement listInt = xml.CreateElement(&quot;listInt&quot;); for (int i = 0; i &lt; this.listInt.Count; i++) &#123; //使用CreateElement方法创建名为“int”的子节点，设置InnerText值并添加到根节点中的列表项。 XmlElement intNode = xml.CreateElement(&quot;int&quot;); intNode.InnerText = this.listInt[i].ToString(); listInt.AppendChild(intNode); &#125; playerInfo.AppendChild(listInt); //构建名为$itemList的XmlElement对象，该对象将保存所有的Item项目 . XmlElement itemList = xml.CreateElement(&quot;itemList&quot;); for (int i = 0; i &lt; this.itemList.Count; i++) &#123; //使用CreateElement方法分别在itemList根节点下创建三个Xml子项&lt;Element&gt;对象。 XmlElement itemNode = xml.CreateElement(&quot;Item&quot;); //谁每个XmlElement对象的ID和Num属性各自包含了itemList中的Item对象的ID属性和Num属性。 itemNode.SetAttribute(&quot;id&quot;, this.itemList[i].id.ToString()); itemNode.SetAttribute(&quot;num&quot;, this.itemList[i].num.ToString()); //将三个XmlElement对象都添加到itemList节点之下。 itemList.AppendChild(itemNode); &#125; playerInfo.AppendChild(itemList); //创建一个名为itemDict的XmlElement对象，该对象将保存所有Item相关数据 XmlElement itemDic = xml.CreateElement(&quot;itemDic&quot;); foreach (int key in this.itemDic.Keys) &#123; //分别实例化intNode和itemNode对象来存储Dictionary&lt;int,Item&gt;对象的键值对数据。 XmlElement intNode = xml.CreateElement(&quot;int&quot;); intNode.InnerText = key.ToString(); //key作为标记内部的InnerText值 //itemNode的ID属性和Num属性包含字典项的Id属性和Num属性。 XmlElement itemNode = xml.CreateElement(&quot;Item&quot;); itemNode.SetAttribute(&quot;id&quot;, this.itemDic[key].id.ToString()); itemNode.SetAttribute(&quot;num&quot;, this.itemDic[key].num.ToString()); //添加这两个XmlElement对象到XmlDocument对象中。 itemDic.AppendChild(intNode); itemDic.AppendChild(itemNode); &#125; //将此XmlElement对象添加到根XmlElement对象之下 playerInfo.AppendChild(itemDic); //5.使用XmlDocument类的Save()方法将生成的XML文本与指定路径path的文件进行存储。 xml.Save(path);&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"5.CSharp读取XML文件","slug":"数据/数据持久化/XML/XML基础知识/5.CSharp读取XML文件","date":"2025-03-06T03:16:38.000Z","updated":"2025-03-06T07:34:53.779Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/5.CSharp读取XML文件/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.CSharp%E8%AF%BB%E5%8F%96XML%E6%96%87%E4%BB%B6/","excerpt":"","text":"在 C# 中操作 XML 主要有 三种常用方式：XmlDocument（DOM 模式）、XmlTextReader/XmlTextWriter（流式读写）和 LINQ to XML。 特性 XmlDocument (DOM) XmlTextReader LINQ to XML 内存占用 高（全加载到内存） 低（流式读取） 中等 读写灵活性 高（可随意修改节点） 只读 高（支持增删改查） 语法复杂度 中等（需手动操作节点） 高（需处理读取状态） 低（类似 SQL 查询） 适用场景 小文件、需频繁修改结构 超大文件、只读 大多数常规场景（推荐） Unity 兼容性 全平台支持 全平台支持 全平台支持 XmlDocumentXml文档类 XmlDocument 是一个表示 XML 文档的类，它提供了一种基于文档对象模型（DOM）的方式来处理 XML 数据。DOM 模型将整个 XML 文档加载到内存中，形成一个树形结构，你可以通过该结构方便地访问、修改和操作 XML 文档的各个部分，如元素、属性、文本节点等。 主要属性 DocumentElement：获取 XML 文档的根元素。 ChildNodes：获取文档的所有子节点。 FirstChild：获取文档的第一个子节点。 LastChild：获取文档的最后一个子节点。 主要方法 Load(string filename)：从指定的文件中加载 XML 文档。 LoadXml(string xml)：从字符串中加载 XML 数据。 Save(string filename)：将 XML 文档保存到指定的文件中。 CreateElement(string name)：创建一个具有指定名称的新元素。 CreateAttribute(string name)：创建一个具有指定名称的新属性。 SelectSingleNode(string xpath)：使用 XPath 表达式选择单个节点。 SelectNodes(string xpath)：使用 XPath 表达式选择多个节点。 XmlNode节点信息类 主要属性 Name：获取节点的名称。 InnerText：获取或设置节点及其所有子节点的串联值。对于元素节点，它会返回该元素内所有文本节点的文本内容。 NodeType：获取节点的类型，例如元素节点（XmlNodeType.Element）、属性节点（XmlNodeType.Attribute）、文本节点（XmlNodeType.Text）等。 ParentNode：获取该节点的父节点。 ChildNodes：获取该节点的所有子节点，返回一个 XmlNodeList 对象。 主要方法 AppendChild(XmlNode newChild)：将指定的节点添加到该节点的子节点列表的末尾。 RemoveChild(XmlNode oldChild)：从该节点的子节点列表中移除指定的子节点。 SelectSingleNode(string xpath)：使用 XPath 表达式选择单个子节点。 SelectNodes(string xpath)：使用 XPath 表达式选择多个子节点，返回一个 XmlNodeList 对象。 XPath 表达式 一句话定义： XPath 是一种用于在 XML/HTML 文档中精准定位节点的查询语言。 1234567891011121314151617&lt;GameSkills&gt; &lt;!-- 战士技能 --&gt; &lt;Skill category=&quot;melee&quot;&gt; &lt;Name&gt;旋风斩&lt;/Name&gt; &lt;Damage&gt;120&lt;/Damage&gt; &lt;Cooldown&gt;8&lt;/Cooldown&gt; &lt;Effect&gt;AOE&lt;/Effect&gt; &lt;/Skill&gt; &lt;!-- 法师技能 --&gt; &lt;Skill category=&quot;magic&quot;&gt; &lt;Name&gt;火球术&lt;/Name&gt; &lt;Damage&gt;200&lt;/Damage&gt; &lt;Cooldown&gt;5&lt;/Cooldown&gt; &lt;Requires&gt;法杖&lt;/Requires&gt; &lt;/Skill&gt;&lt;/GameSkills&gt; 路径表达式 类型 符号 作用 游戏案例 绝对路径 / 从根节点开始 /GameSkills/Skill → 所有Skill节点 相对路径 // 任意层级查找 //Damage → 所有伤害数值节点 当前节点 . 当前上下文节点 ./Name → 当前Skill下的名字 父节点 .. 返回上级节点 Cooldown/.. → 包含冷却时间的Skill节点 游戏示例：快速找到火球术的伤害值 1/GameSkills/Skill[Name=&#x27;火球术&#x27;]/Damage 节点选择 语法 作用 游戏案例 element 标签名选择 Skill → 所有技能节点 * 通配符匹配任何元素 //*[@category] → 带category属性的节点 @attr 属性选择器 //Skill[@category='magic'] → 魔法类技能 text() 获取文本内容 //Name/text() → “旋风斩”, “火球术” node() 匹配任何类型节点 //Effect/node() → 包含文本和子节点 游戏示例：找出需要法杖的技能名称 1//Skill[Requires=&#x27;法杖&#x27;]/Name 谓词（Predicates） 用方括号 [ ] 过滤节点 表达式 含义 游戏案例 [1] 位置索引（从1开始） /GameSkills/Skill[1] → 第一个技能节点 [last()] 最后一个元素 //Skill[last()] → 法师技能节点 [Damage &gt; 150] 数值比较 筛选伤害&gt;150的技能 [contains(Name, '火')] 文本包含 名称含「火」的技能 游戏示例：找冷却时间≥5的物理技能 1//Skill[@category=&#x27;melee&#x27; and Cooldown &gt;=5] 读取XMl文件信息 读取放在Resources文件夹和StreamingAssets文件夹的TestXml.xml 12345678XmlDocument xmlDocument = new XmlDocument();//加载存放在Resorces文件夹下的xml文件 类型是TextAssetTextAsset textAsset = Resources.Load&lt;TextAsset&gt;(&quot;TestXml&quot;);print(textAsset.text);//可以输出xml文本//XmlDocument类中的LoadXml方法 能够翻译字符串为xml对象xmlDocument.LoadXml(textAsset.text); XML文件要在StreamingAssets文件夹下 因为StreamingAssets不会被压缩加密 Resources文件夹会 123//XmlDocument类中的Load方法 传入xml文件的路径直接加载xmlxmlDocument.Load(Application.streamingAssetsPath + &quot;/TestXml.xml&quot;); 读取元素和属性信息 1234567891011//XmlDocument中的SelectSingleNode方法 获取xml当中的根节点XmlNode root = xmlDocument.SelectSingleNode(&quot;Root&quot;);//XmlNode中的SelectSingleNode方法 再通过根节点 去获取下面的子节点XmlNode nodeName = root.SelectSingleNode(&quot;name&quot;);print(nodeName.InnerText);XmlNode nodeAge = root.SelectSingleNode(&quot;age&quot;);print(nodeAge.InnerText); 获取属性信息 12345XmlNode nodeItem = root.SelectSingleNode(&quot;Item&quot;);//XmlNode中的Attributes用中括号传入对应属性名字后.出Value 直接中括号获取信息print(nodeItem.Attributes[&quot;id&quot;].Value);//1print(nodeItem.Attributes[&quot;num&quot;].Value);//10 获取所有同一名字节点 12345678910//XmlNodeList中的SelectNodes方法 获取一个节点下的同名节点的方法XmlNodeList friendList = root.SelectNodes(&quot;Friend&quot;);// 遍历所有节点for (int i = 0; i &lt; friendList.Count; i++)&#123; print(friendList[i].SelectSingleNode(&quot;name&quot;).InnerText); print(friendList[i].SelectSingleNode(&quot;age&quot;).InnerText);&#125; 读取XML文件 XmlDocument xmlDocument = new XmlDocument(); 读取文本方式1-xmlDocument.LoadXml(传入xml文本字符串) 读取文本方式2-xmlDocument.Load(传入路径) 读取元素和属性 获取单个节点 : XmlNode node = xmlDocument.SelectSingleNode(节点名) 获取多个节点 : XmlNodeList nodeList = xmlDocument.SelectNodes(节点名) 获取节点元素内容：node.InnerText 获取节点元素属性： item.Attributes[“属性名”].Value item.Attributes.GetNamedItem(“属性名”).Value 通过迭代器遍历或者循环遍历XmlNodeList对象可以获取到各单个元素节点 练习 有一个玩家数据类，请为该类写一个方法结合XML读取知识点，将XML中数据读取到PlayerInfo的一个对象中 PlayerInfo.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192using System;using System.Collections;using System.Collections.Generic;using System.IO;using System.Xml;using UnityEngine;public class Item&#123; public int id; public int num;&#125;public class PlayerInfo&#123; public string name; public int atk; public int def; public float moveSpeed; public float roundSpeed; public Item weapon; public List&lt;int&gt; listInt; public List&lt;Item&gt; itemList; public Dictionary&lt;int, Item&gt; itemDic; public void LoadData(string fileName) &#123; string path = Application.persistentDataPath + &quot;/&quot; + fileName + &quot;.xml&quot;; if (!File.Exists(path)) &#123; path = Application.streamingAssetsPath + &quot;/&quot; + fileName + &quot;.xml&quot;; &#125; //加载 XML 文件信息 XmlDocument xml = new XmlDocument(); //加载 xml.Load(path); //加载根节点才能加载后面的内容 XmlNode playerInfo = xml.SelectSingleNode(&quot;PlayerInfo&quot;); //通过根节点去加载具体的信息 this.name = playerInfo.SelectSingleNode(&quot;name&quot;).InnerText; this.atk = int.Parse(playerInfo.SelectSingleNode(&quot;atk&quot;).InnerText); this.def = int.Parse(playerInfo.SelectSingleNode(&quot;def&quot;).InnerText); this.moveSpeed = float.Parse(playerInfo.SelectSingleNode(&quot;moveSpeed&quot;).InnerText); this.roundSpeed = float.Parse(playerInfo.SelectSingleNode(&quot;roundSpeed&quot;).InnerText); //加载武器信息节点 XmlNode weaponNode = playerInfo.SelectSingleNode(&quot;weapon&quot;); this.weapon = new Item(); this.weapon.id = int.Parse(weaponNode.SelectSingleNode(&quot;id&quot;).InnerText); this.weapon.num = int.Parse(weaponNode.SelectSingleNode(&quot;num&quot;).InnerText); //加载整数列表节点 XmlNode listIntNode = playerInfo.SelectSingleNode(&quot;listInt&quot;); XmlNodeList intList = listIntNode.SelectNodes(&quot;int&quot;); this.listInt = new List&lt;int&gt;(); for (int i = 0; i &lt; intList.Count; i++) &#123; this.listInt.Add(int.Parse(intList[i].InnerText)); &#125; //加载物品列表节点 XmlNode itemListNode = playerInfo.SelectSingleNode(&quot;itemList&quot;); XmlNodeList items = itemListNode.SelectNodes(&quot;Item&quot;); this.itemList = new List&lt;Item&gt;(); foreach (XmlNode item in items) &#123; Item item2 = new Item(); item2.id = int.Parse(item.Attributes[&quot;id&quot;].Value); item2.num = int.Parse(item.Attributes[&quot;num&quot;].Value); this.itemList.Add(item2); &#125; //加载物品字典节点 XmlNode itemDicNode = playerInfo.SelectSingleNode(&quot;itemDic&quot;); XmlNodeList keyInt = itemDicNode.SelectNodes(&quot;int&quot;); XmlNodeList valueItem = itemDicNode.SelectNodes(&quot;Item&quot;); this.itemDic = new Dictionary&lt;int, Item&gt;(); for (int i = 0; i &lt; keyInt.Count; i++) &#123; int key = int.Parse(keyInt[i].InnerText); Item value = new Item(); value.id = int.Parse(valueItem[i].Attributes[&quot;id&quot;].Value); value.num = int.Parse(valueItem[i].Attributes[&quot;num&quot;].Value); this.itemDic.Add(key, value); &#125; &#125;&#125; Test.cs 12345678public class Test : MonoBehaviour&#123; void Start() &#123; PlayerInfo p = new PlayerInfo(); p.LoadData(&quot;PlayerInfo&quot;); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"4.XML文件存放的位置","slug":"数据/数据持久化/XML/XML基础知识/4.XML文件存放的位置","date":"2025-03-06T03:09:36.000Z","updated":"2025-03-06T03:15:38.914Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/4.XML文件存放的位置/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.XML%E6%96%87%E4%BB%B6%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"回顾特殊文件夹 只读不写的XML文件可以放在Resources或者StreamingAssets 文件夹下 动态存储的XML文件放在Application.persistentDataPath 路径下 创建Resources和StreamAssets文件夹，放入相同的测试XML文件","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.XML属性","slug":"数据/数据持久化/XML/XML基础知识/3.XML属性","date":"2025-03-06T02:48:24.000Z","updated":"2025-03-06T03:04:32.329Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/3.XML属性/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.XML%E5%B1%9E%E6%80%A7/","excerpt":"","text":"属性语法 作用：为元素附加额外信息。 规则： 属性值必须用引号包裹（单引号或双引号）。 同一元素不能有重复属性名。 123&lt;Student id=&quot;101&quot; class=&quot;A班&quot;&gt; &lt;!-- id 和 class 是属性 --&gt; &lt;Name&gt;李四&lt;/Name&gt;&lt;/Student&gt; 和元素节点区别 用元素：当数据是核心内容或需要嵌套时。 用属性：当数据是次要信息或简单键值对。 12345678&lt;!-- 元素表示法 --&gt;&lt;Student&gt; &lt;Id&gt;101&lt;/Id&gt; &lt;Name&gt;王五&lt;/Name&gt;&lt;/Student&gt;&lt;!-- 属性表示法 --&gt;&lt;Student id=&quot;101&quot; name=&quot;王五&quot; /&gt; 练习 请把上面的类结构用XML文档的形式翻译过来 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;PlayerInfo&gt; &lt;!--自己定一个xml代表 类对象数据的规则 我们的元素节点名 就用我们的变量名命名 --&gt; &lt;name&gt;你爹&lt;/name&gt; &lt;atk&gt;10&lt;/atk&gt; &lt;def&gt;5&lt;/def&gt; &lt;moveSpeed&gt;20&lt;/moveSpeed&gt; &lt;roundSpeed&gt;20&lt;/roundSpeed&gt; &lt;weapon&gt; &lt;id&gt;1&lt;/id&gt; &lt;num&gt;1&lt;/num&gt; &lt;/weapon&gt; &lt;!--当出现没有变量名的数据时 我们就用变量类型名命名--&gt; &lt;listInt&gt; &lt;int&gt;1&lt;/int&gt; &lt;int&gt;2&lt;/int&gt; &lt;int&gt;3&lt;/int&gt; &lt;/listInt&gt; &lt;itemList&gt; &lt;Item id=&quot;1&quot; num=&quot;10&quot;/&gt; &lt;Item id=&quot;2&quot; num=&quot;20&quot;/&gt; &lt;Item id=&quot;3&quot; num=&quot;30&quot;/&gt; &lt;Item id=&quot;4&quot; num=&quot;40&quot;/&gt; &lt;/itemList&gt; &lt;itemDic&gt; &lt;int&gt;1&lt;/int&gt; &lt;Item id=&quot;1&quot; num=&quot;1&quot;/&gt; &lt;int&gt;2&lt;/int&gt; &lt;Item id=&quot;2&quot; num=&quot;1&quot;/&gt; &lt;int&gt;3&lt;/int&gt; &lt;Item id=&quot;3&quot; num=&quot;1&quot;/&gt; &lt;!-- 另一种写法 但是建议大家都统一 &lt;int&gt;4&lt;/int&gt; &lt;Item&gt; &lt;id&gt;4&lt;/id&gt; &lt;num&gt;1&lt;/num&gt; &lt;/Item&gt; --&gt; &lt;/itemDic&gt;&lt;/PlayerInfo&gt;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.XML基础语法","slug":"数据/数据持久化/XML/XML基础知识/2.XML基础语法","date":"2025-03-06T02:29:32.000Z","updated":"2025-03-06T02:56:22.525Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/2.XML基础语法/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.XML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"注释 固定内容 12345678910111213&lt;!--XML 声明（可选）：定义版本和编码--&gt;&lt;!--version代表版本 encoding代表编码格式--&gt;&lt;!--编码格式就 是读取文件时 解析字符串使用的编码是什么编码格式：不同的字符 在内存中的二进制是不一样的 每个字符对应一个数字不同的编码格式 字符 对应的 二进制 是不一样的举个例子ASCII:A-11UTF-8:A-21乱码的出现就是因为用来不同的编码格式解析文本内容由于字符和对应的二进制不匹配 就会出现乱码--&gt;&lt;? xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; 基本语法 根元素：唯一的最外层标签。 子元素：嵌套在根元素内部。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- 声明 --&gt;&lt;School&gt; &lt;!-- 根元素 --&gt; &lt;Student id=&quot;101&quot;&gt; &lt;!-- 子元素 --&gt; &lt;Name&gt;张三&lt;/Name&gt; &lt;Age&gt;18&lt;/Age&gt; &lt;/Student&gt;&lt;/School&gt; XML 命名规则 标签和属性名基本遵守C#中的变量命名规则： 以字母或下划线开头。 不能包含空格。 避免使用特殊符号（如 !@$%）。 区分大小写（推荐全小写或驼峰式）。 1 特殊字符转义 当内容包含 &lt;、&gt;、&amp; 等符号时，需用转义符： 字符 转义符 &lt; &amp;lt; &gt; &amp;gt; &amp; &amp;amp; &quot; &amp;quot; ' &amp;apos; 1&lt;Formula&gt;3 &amp;lt; 5&lt;/Formula&gt; &lt;!-- 显示为 3 &lt; 5 --&gt;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.XML基础知识概述","slug":"数据/数据持久化/XML/XML基础知识/1.XML基础知识概述","date":"2025-03-06T02:09:16.000Z","updated":"2025-03-06T02:28:46.003Z","comments":true,"path":"2025/03/06/数据/数据持久化/XML/XML基础知识/1.XML基础知识概述/","permalink":"http://example.com/2025/03/06/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.NGUI基础知识概述","slug":"UI系统/NGUI/NGUI基础知识/1.NGUI基础知识概述","date":"2025-03-05T09:12:05.000Z","updated":"2025-03-07T05:49:21.922Z","comments":true,"path":"2025/03/05/UI系统/NGUI/NGUI基础知识/1.NGUI基础知识概述/","permalink":"http://example.com/2025/03/05/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"19.unity基础总结","slug":"游戏引擎/unity/unity基础/19.unity基础总结","date":"2025-03-05T08:55:39.000Z","updated":"2025-03-05T09:09:05.873Z","comments":true,"path":"2025/03/05/游戏引擎/unity/unity基础/19.unity基础总结/","permalink":"http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"18.射线检测","slug":"游戏引擎/unity/unity基础/18.射线检测","date":"2025-03-05T07:40:00.000Z","updated":"2025-03-05T08:56:35.551Z","comments":true,"path":"2025/03/05/游戏引擎/unity/unity基础/18.射线检测/","permalink":"http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/18.%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/","excerpt":"","text":"什么是射线检测 物理系统中 目前我们学习的物体相交判断 碰撞检测 - 必备条件 - 1刚体 2碰撞器 范围检测 - 必备条件 - 碰撞器 如果想要做这样的碰撞检测呢？ 鼠标选择场景上一物体 FPS射击游戏（无弹道-不产生实际的子弹对象进行移动） 等等 需要判断一条线和物体的碰撞情况 射线检测 就是来解决这些问题的 它可以在指定点发射一个指定方向的射线 判断该射线与哪些碰撞器相交，得到对应对象 结合物理系统进行射线碰撞判断 注意： 距离、层级两个参数都是int类型 当我们传入参数时，一定要明确传入的参数代表的是距离还是层级 Ray射线类 一条起点为坐标(1,0,0) 方向为世界坐标Z轴正方向的射线 参数： origin 起点 direction 方向 1Ray ray2 = new Ray(Vector3.right, Vector3.forward); Camera.ScreenPointToRay方法 摄像机发射出的射线 返回从摄像机通过屏幕点的光线 得到一条从屏幕位置作为起点，摄像机视口方向为方向的射线 1Ray ray3 = Camera.main.ScreenPointToRay(Input.mousePosition); Physics.Raycast方法 是否碰撞到对象 123456// 返回值：bool 是否碰撞到对象//参数一：射线 //参数二: 检测的最大距离 超出这个距离不检测 //参数三：检测指定层级（不填检测所有层） //参数四：是否忽略触发器if (Physics.Raycast(ray, 1000, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;), QueryTriggerInteraction.UseGlobal)) &#123; print(&quot;碰撞到了对象&quot;); &#125; 获取相交单个物体信息 RaycastHit结构体 常用属性： collider 类型：Collider 说明：该属性返回与射线相交的碰撞体对象。通过这个属性，你可以访问碰撞体所在的游戏对象及其相关组件。 point 类型：Vector3 说明：该属性表示射线与碰撞体相交的点的世界坐标。在很多场景中，比如在碰撞点生成特效，被子弹打中飙血，墙壁被打贴图 distance 类型：float 说明：该属性表示从射线的起点到碰撞点的距离。可以用于判断射线与物体相交的远近。 normal 类型：Vector3 说明：该属性表示碰撞点处碰撞体表面的法线向量。法线向量在很多场景中都有重要作用，比如反射效果、物体表面的朝向，射击游戏特效计算相关等。 transform 类型：Transform 说明：该属性返回与射线相交的碰撞体所附着的游戏对象的 Transform 组件。 12345678910111213141516171819202122RaycastHit raycastHitInfo;//返回值：bool 是否碰撞到对象//参数一：射线//参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中//参数三：距离//参数四：检测指定层级（不填检测所有层）//参数五：是否忽略触发器 UseGlobal-使用全局设置 if (Physics.Raycast(ray4, out raycastHitInfo, 1000, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;), QueryTriggerInteraction.UseGlobal))&#123; print(&quot;碰撞到了物体 得到了信息&quot;); print(&quot;碰撞到物体的名字&quot; + raycastHitInfo.collider.gameObject.name); print(raycastHitInfo.point); print(raycastHitInfo.normal); print(raycastHitInfo.transform.position); print(raycastHitInfo.distance);&#125; 获取相交多个物体信息 RaycastHit[] 1234567891011//返回值：RaycastHit[] 碰撞到对象//参数一：射线//参数二：距离//参数三：检测指定层级（不填检测所有层）//参数四：是否忽略触发器//Physics.RaycastAll方法传入RaycastHit数组对象可以得到多个碰到的对象RaycastHit[] raycastHitInfos = Physics.RaycastAll(ray4, 1000, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;), QueryTriggerInteraction.UseGlobal);for (int i = 0; i &lt; raycastHitInfos.Length; i++)&#123; print(&quot;碰到的所有物体 名字分别是&quot; + raycastHitInfos[i].collider.gameObject.name);&#125; 练习 子弹打墙 实现鼠标点击场景上一面墙，在点击的位置创建子弹特效和弹孔 1234567891011121314151617181920212223242526272829303132void Update()&#123; // 将鼠标在屏幕上的位置通过主相机转换为世界坐标系中的一条视线射线并赋值给 ray1。 Ray ray1 = Camera.main.ScreenPointToRay(Input.mousePosition); // 通过 Debug.DrawRay 方法可将检测到的射线绘制出来以便调试查看（仅在编辑模式下生效）。 Debug.DrawRay(ray1.origin, ray1.direction); if (Input.GetMouseButtonDown(0)) &#123; if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out info, 1000, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;))) &#123; GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Effect/HitEff&quot;)); // 设定打击特效在发生碰撞的物体前方偏移 0.2 米处 obj.transform.position = info.point + info.normal * 0.2f; // 根据表面法线调整特效的朝向角度，以适应目标物体产生视觉效果。 obj.transform.rotation = Quaternion.LookRotation(info.normal); Destroy(obj, 0.8f); // 特效 DDD obj = Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Effect/DDD&quot;)); obj.transform.position = info.point + info.normal * 0.2f; obj.transform.rotation = Quaternion.LookRotation(info.normal); &#125; &#125;&#125; 鼠标长按物体移动 场景上有一个平面，有一个立方体，当鼠标点击选中立方体时，长按鼠标左键 可以拖动立方体 在平面上移动，点击鼠标右键取消选中 注意： 想要让物体只在平面就和平面做射线检测 物体的中心点 和 平面的中心点 和 物体脚下 12345678910111213141516171819202122232425262728293031323334RaycastHit hit;// 用于记录当前选中的对象的 Transform 组件。 private Transform nowSel;// 声明一个公共浮点型变量 offsetY，用于设定物体拖曳时的高度偏移量。 public float offsetY;// 射线检测获取要选中的物体, 然后让物体跟随鼠标移动if (Input.GetMouseButtonDown(0))&#123; if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Player&quot;))) &#123; // 得到想要操作对象的transform nowSel = hit.transform; &#125;&#125;// 当前有选中的对象 并且是长按if (nowSel != null &amp;&amp; Input.GetMouseButton(0))&#123; if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 1000, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Floor&quot;))) &#123; nowSel.position = hit.point + Vector3.up *offsetY; &#125;&#125;if (Input.GetMouseButtonDown(1))&#123; nowSel = null;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"}]},{"title":"17.范围检测","slug":"游戏引擎/unity/unity基础/17.范围检测","date":"2025-03-05T06:24:21.000Z","updated":"2025-03-05T08:56:24.531Z","comments":true,"path":"2025/03/05/游戏引擎/unity/unity基础/17.范围检测/","permalink":"http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/17.%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B/","excerpt":"","text":"回顾物理系统之碰撞检测 碰撞产生的必要条件 至少一个物体有刚体 两个物体都必须有碰撞器 碰撞和触发 碰撞会产生实际的物理效果 触发看起来不会产生碰撞，但是可以通过函数监听触发 碰撞检测主要用于实体物体之间产生物理效果时使用 什么是范围检测 游戏中瞬时的攻击范围判断一般会使用范围检测 举例： 玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害 玩家攻击，在前方1米圆形范围内对象都受到伤害 类似这种并没有实体物体，只想要检测在指定某一范围是否让敌方受到伤害时，便可以使用范围判断 在指定位置进行范围判断，我们可以得到处于指定范围内的对象 目的是对对象进行处理，比如受伤、减血等等 LayerMask层级相关知识补充 Unity 顶部菜单 → Edit → Project Settings → Tags and Layers 在 Layers 列表中添加/修改层级名称（如 “Enemy”, “Player”） LayerMask.NameToLayer()方法 传入层级名字返回层级索引 1print(LayerMask.NameToLayer(&quot;UI&quot;)); // 5 多层级组合检测 12345// 同时检测 Enemy 和 NPC 层LayerMask combinedMask = LayerMask.GetMask(&quot;Enemy&quot;, &quot;NPC&quot;); // 等效位运算写法LayerMask combinedMask = (1 &lt;&lt; LayerMask.NameToLayer(&quot;Enemy&quot;)) | (1 &lt;&lt; LayerMask.NameToLayer(&quot;NPC&quot;)); 排除特定层级 123456789101112// 检测除了 Player 之外的所有层级LayerMask mask = ~LayerMask.GetMask(&quot;Player&quot;);// 射线检测排除自身层RaycastHit hit;int selfLayer = gameObject.layer;LayerMask raycastMask = ~(1 &lt;&lt; selfLayer);if(Physics.Raycast(transform.position, transform.forward, out hit, 100f, raycastMask)) &#123; // 检测到非自身层的物体&#125; 如何进行范围检测 范围检测必备条件：想要被范围检测到的对象必须具备碰撞器 范围检测注意点： 范围检测相关API只有当执行该句代码时进行一次范围检测，它是瞬时的 范围检测相关API并不会真正产生一个碰撞器，只是碰撞判断计算而已 范围检测API Physics.OverlapBox方法 盒状范围检测 查找与给定盒体接触或位于盒体内部的所有碰撞体。 返回值： 返回该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息） 参数： 立方体中心点 立方体三边大小，构成立方体的长宽高的一半（传入(1,1,1)，立方体的长宽高(2,2,2)） 立方体角度，传入四元数 检测指定层级（不填检测所有层） 是否忽略触发器，UseGlobal-使用全局设置， Collide-检测触发器， Ignore-忽略触发器，不填默认使用UseGlobal （全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置） 123[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(45, Vector3.up), 1 &lt;&lt; LayerMask.NameToLayer(&quot;UI&quot;) | 1 &lt;&lt; LayerMask.NameToLayer(&quot;Default&quot;), QueryTriggerInteraction.UseGlobal); 另一个盒壮范围检测，返回值是检测到的Collider的个数 1if (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != 0) &#123; // 处理碰撞器 &#125; Physics.OverlapSphere方法 球形范围检测 返回值： 返回该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息） 参数： 球中心点 半径 检测指定层级（不填检测所有层） 是否忽略触发器，UseGlobal-使用全局设置， Collide-检测触发器， Ignore-忽略触发器 1colliders = Physics.OverlapSphere(Vector3.zero, 5, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Default&quot;)); 另一个球形范围检测，返回值是检测到的Collider的个数 1if (Physics.OverlapSphereNonAlloc(Vector3.zero, 5, colliders) != 0) &#123; &#125; Physics.OverlapCapsule方法 胶囊范围检测 返回值： 返回该范围内的碰撞器数组 参数： 半圆1中心点 半圆2中心点 （前两个参数决定胶囊中间的圆柱体情况） 上下两个半球体半径 检测指定层级（不填检测所有层） 是否忽略触发器，UseGlobal-使用全局设置， Collide-检测触发器， Ignore-忽略触发器 1colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, 1, 1 &lt;&lt; LayerMask.NameToLayer(&quot;UI&quot;), QueryTriggerInteraction.UseGlobal); 返回值是检测到的Collider的个数 1if (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, 1, colliders) != 0) &#123; &#125; 练习 世界坐标原点有一个立方体，键盘WASD键可以控制其前后移动和旋转,请结合所学知识实现,按J键在立方体面朝向前方1米处进行立方体范围检测,按K键在立方体前面5米范围内进行胶囊范围检测,按L键以立方体脚下为原点，半径10米内进行球形范围检测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void Update()&#123; // 位移 this.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis(&quot;Vertical&quot;)); // 旋转 this.transform.Rotate(Vector3.up, Input.GetAxis(&quot;Horizontal&quot;) * roundSpeed * Time.deltaTime); // 按下J键 if (Input.GetKeyDown(KeyCode.J)) &#123; Collider[] colliders = Physics.OverlapBox( this.transform.position + this.transform.forward, Vector3.one * 0.5f, this.transform.rotation, //创建出来的立方体要保持和当前立方体相同的旋转，否则不是刚好在前面 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;) ); for (int i = 0; i &lt; colliders.Length; i++) &#123; print(&quot;盒子 物体受伤&quot; + colliders[i].gameObject.name); &#125; &#125; // 按下K //可以理解为往前面吐火 或者刺出来长枪 if (Input.GetKeyDown(KeyCode.K)) &#123; Collider[] colliders = Physics.OverlapCapsule( this.transform.position, this.transform.position + this.transform.forward * 5, 0.5f, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;) ); for (int i = 0; i &lt; colliders.Length; i++) &#123; print(&quot;胶囊 物体受伤&quot; + colliders[i].gameObject.name); &#125; &#125; // 按下L键 //比如有些时候范围内加buff或者震开敌人 if (Input.GetKeyDown(KeyCode.L)) &#123; Collider[] colliders = Physics.OverlapSphere( this.transform.position, 10, 1 &lt;&lt; LayerMask.NameToLayer(&quot;Monster&quot;) ); for (int i = 0; i &lt; colliders.Length; i++) &#123; print(&quot;球 物体受伤&quot; + colliders[i].gameObject.name); &#125; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"}]},{"title":"16.LineRenderer画线组件","slug":"游戏引擎/unity/unity基础/16.LineRenderer画线组件","date":"2025-03-04T12:06:43.000Z","updated":"2025-03-04T13:16:11.350Z","comments":true,"path":"2025/03/04/游戏引擎/unity/unity基础/16.LineRenderer画线组件/","permalink":"http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/","excerpt":"","text":"LineRenderer画线渲染器组件是什么？ LineRenderer 是Unity提供的一个用于画线的组件。 使用它我们可以在场景中绘制线段，一般可以用于：绘制攻击范围，武器红外线，辅助功能，其它画线功能 参数 场景点编辑模式 Loop 循环 是否终点起始自动相连。 Positions 位置 默认以世界坐标系为基准，设置线段的点并连接。 可以在 Use World Space 是否使用世界坐标系修改是否以世界坐标系为基准。 设置开不开启 Loop 循环 就能选择是否收尾线段点相连。 Width 宽度 线段宽度曲线调整。 可以在宽度表里右键添加key，添加秘钥，修改划线宽度曲线。 Color 颜色 修改颜色变化，颜色也可以是渐变的，假如没有材质修改颜色不起作用。 Corner Vertices 角顶点 角顶点可以理解为把划线的角变成圆角。 此属性指示在一条线中绘制角时使用了多少额外的顶点。 增加此值，使线角看起来更圆。 End Cap Vertices 末端顶点 终端顶点也变成圆角。 Alignment 对其方式* View：视点线段对着摄像机。 Transform Z：线段面向其Z轴。 Texture Mode 纹理模式* Stretch：拉伸，沿整条线映射纹理一次。 Tile：瓷砖平铺，不停的重复纹理。 Distribute Per Segment：分配执行。 Repeat Per Segment：重复显示。 Shadow Bias 阴影偏移* Generate Lighting Data 生成光源数据* Use World Space 是否使用世界坐标系 勾选了，不管怎么改都是相对于世界坐标的线段点。 不勾选，就会是当前依附的游戏对象的相对坐标点，移动游戏对象也会移动划线。 Materials 划线使用的材质球 我们可以新建一个材质，使用默认shader，关联一张图片，拖拽到划线组件的材质球上。 注意：假如一些材质需要光源，要开Generate Lighting Data 生成光源数据，不然可能变黑显示不出来。 Lighting 光照影响* Cast Shadows：投射阴影，是否开启阴影。 Receive Shadows：接收阴影。 Probes 光照探针* Light Probes：光探测器模式 不使用光探针 使用内插光探针 使用三维网格内插光探针 自定义从材质决定 Reflection Probes：反射探测器模式* 不使用反射探针 启用混合反射探针 启用混合反射探针并且和天空和混合 启用普通探针，重叠式不混合 Additional Settings 附加设置* Motion Vectors：运动矢量 使用相机运动来跟踪运动 特定对象来跟踪运动 不跟踪 Dynamic Occludee：动态遮挡剔除 Sorting Layer：排序图层 Order in Layer：此线段在排序图层中的顺序 代码相关 123456789101112131415161718192021222324252627282930313233GameObject line = new GameObject();line.name = &quot;myLine&quot;;LineRenderer myLine = line.AddComponent&lt;LineRenderer&gt;();// 是否首尾相连myLine.loop = true;// 开始结束宽myLine.startWidth = 0.02f;myLine.endWidth = 0.02f;// 开始结束颜色myLine.startColor = Color.black;myLine.endColor = Color.white;// 设置材质myLine.material = Resources.Load&lt;Material&gt;(&quot;Material地址&quot;);// 设置点// 先设置数量, 在设置每个点的位置myLine.positionCount = 4;myLine.SetPositions(new Vector3[]&#123; new Vector3(0, 0, 0), new Vector3(5, 0, 0), new Vector3(5, 0, 5), //new Vector3(0, 0, 5) // 没有设置最后一个点，默认0,0,0&#125;);myLine.SetPosition(3, new Vector3(0, 0, 5));// 是否使用世界坐标myLine.useWorldSpace = false;//是否接受光照进行着色计算myLine.generateLightingData = true; 练习 请写一个方法，传入一个中心点，传入一个半径，用 LineRenderer 画一个圆出来 添加画圆函数，需要传入圆心位置(centerPos)，半径®，点的数量(pointNum) 1234567891011121314151617181920212223242526// 圆心位置(centerPos)，半径，点的数量(pointNum)public void DrawLineRenderer(Vector3 centerPos, float r, int pointNum)&#123; GameObject obj = new GameObject(); obj.name = &quot;R&quot;; LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;(); line.loop = true; line.positionCount = pointNum; float angle = 360f / pointNum; for (int i = 0; i &lt; pointNum; i++) &#123; // 1. 点加向量相当于平移点 // 2. 四元数 * 向量相当于在旋转向量 // 通过四元数进行旋转后，再进行位移操作 Vector3 pos = Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r + centerPos; line.SetPosition(i, pos); &#125;&#125; 请实现，在 Game 窗口长按鼠标用 LineRenderer 画出鼠标移动的轨迹 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 练习题二用来装 LineRenderer 的临时变量private LineRenderer line2;void Start()&#123; #region 练习题二 // 在 Game 窗口长按鼠标用 LineRenderer 画出鼠标移动的轨迹 ////假如没有添加鼠标左键被按下时的逻辑，那么每次只能接着上次画，会和上次画的末尾连接起来 //line2 = this.gameObject.AddComponent&lt;LineRenderer&gt;(); //line2.loop = false; //line2.startWidth = 0.5f; //line2.endWidth = 0.5f; //line2.positionCount = 0; #endregion&#125;// 定义一个类成员变量 nowPos，记录当前鼠标指针所在的位置private Vector3 nowPos;// 在 Update 函数中，检测鼠标点击事件，实现从当前鼠标指针处开始划线的功能。private void Update()&#123; // 鼠标左键被按下时 if (Input.GetMouseButtonDown(0)) &#123; // 鼠标左键被按下时，创建新的游戏对象，并且新增为其 LineRenderer 组件 GameObject obj = new GameObject(); line2 = obj.AddComponent&lt;LineRenderer&gt;(); // 设置线段状态为非闭合状态，设置开始和结束的宽度为 0.5 line2.loop = false; line2.startWidth = 0.5f; line2.endWidth = 0.5f; // 设置顶点数目为 0 表示该线段暂时为空 line2.positionCount = 0; &#125; // 鼠标左键持续按压时 if (Input.GetMouseButton(0)) &#123; // 鼠标左键持续按压时，不断新增线段中增加顶点，记录每个顶点的世界坐标，直到松开鼠标键停止绘制。 line2.positionCount += 1; // 如何得到鼠标转世界坐标的对应点 // 知识点 // 1. 如何得到鼠标位置 // Input.mousePosition // 2. 怎么把鼠标转世界坐标 // 使用 Camera.main.ScreenToWorldPoint() 方法来将当前鼠标所在的屏幕像素坐标转换到和场景中对象相对应的世界坐标上。 nowPos = Input.mousePosition; // 这个 z 是设置和摄像机的距离的，这样画出来的线一直和摄像机的距离是 10 nowPos.z = 10; // 将 Z 轴坐标设置为一个固定值，使得线段可以显示在屏幕上方 line2.SetPosition(line2.positionCount - 1, Camera.main.ScreenToWorldPoint(nowPos)); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"15.场景异步加载","slug":"游戏引擎/unity/unity基础/15.场景异步加载","date":"2025-03-04T11:11:28.000Z","updated":"2025-03-04T12:05:29.401Z","comments":true,"path":"2025/03/04/游戏引擎/unity/unity基础/15.场景异步加载/","permalink":"http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/15.%E5%9C%BA%E6%99%AF%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"回顾场景同步切换 场景同步切换的缺点 在切换场景时，Unity会删除当前场景上所有对象，并且去加载下一个场景的相关信息。 如果当前场景对象过多或者下一个场景对象过多，这个过程会非常耗时，会让玩家感受到卡顿。 所以异步切换就是来解决该问题的。 回顾一下&#123;% post_link 13.Resources异步加载#ResourceRequest的父类AsyncOperation AsyncOperation%&#125; 通过事件回调函数 异步加载 12345678910111213141516171819202122void Start()&#123; // 在后台异步加载场景。 AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(&quot;场景异步加载&quot;); asyncOperation.completed += (a) =&gt; &#123; print(&quot;加载结束&quot;); &#125;; asyncOperation.completed += AsynLoadOver; // 注意： // 直接用法这种方法异步加载场景的话，就算过场景脚本或脚本依附的对象被销毁，异步加载的回调也能执行 // 因为异步加载的回调被存到事件中了&#125;// 异步加载场景回调private void AsynLoadOver(AsyncOperation ao)&#123; print(&quot;AsynLoadOver&quot;);&#125; 通过协程 异步加载 协程异步加载可以在过场景的时候做其他逻辑~~ 需要注意的是，加载场景会把当前场景上没有特别处理的对象都删除了, 10.协同程序，事件回调函数则不会有这个问题，因为函数被存着，垃圾回收不了 所以，协程中的部分逻辑可能是执行不了的 因为过场景会把脚本或者脚本依附的对象都销毁了 解决思路：让处理场景加载的脚本依附的对象过场景时不被移除DontDestroyOnLoad(this.gameObject) 123456789101112131415161718192021222324252627282930313233343536373839404142void Start()&#123; // 让该脚本依附的对象过场景时不会被移除，这样脚本就不被移除，否则协程后面的逻辑会失效 DontDestroyOnLoad(this.gameObject); // 协程后面的逻辑会失效是因为Unity的协程管理器的机制，只要依附的对象被删除或失活或者脚本被删除，协程就会失效，我们改不了这个机制 StartCoroutine(CoroutineAsynLoadScene(&quot;Lesson21_场景异步加载Test&quot;));&#125;// 异步加载场景协程函数IEnumerator CoroutineAsynLoadScene(string name)&#123; // 异步加载场景 AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name); // 协程的好处是，在异步加载场景时，我可以在加载的同时做一些别的逻辑 print(&quot;异步加载过程中打印的信息&quot;); // 比如，我们可以在异步加载过程中去更新进度条，一般有两种做法 // 更新进度条第一种做法就是利用场景异步加载的进度去更新，但是不是特别准确，一般也不会直接用 while (!asyncOperation.isDone) &#123; print(asyncOperation.progress); yield return null; &#125; // 离开循环后就会认为场景加载结束 // 可以把进度条顶满，然后隐藏进度条 // Unity内部的协程协调器发现是异步加载类型的返回对象，那么就会等待 // 等待异步加载结束后才会继续执行迭代器函数中后面的步骤 yield return asyncOperation; print(&quot;异步加载结束后打印的信息&quot;); // 更新进度条第二种做法就是根据你游戏的规则自己定义进度条变化的条件 // 比如：当场景加载结束更新20%进度 // 接着去加载场景中的其他信息，比如动态加载怪物 // 这时进度条再更新20% // 动态加载场景模型，这时就认为加载结束了，进度条顶满，隐藏进度条&#125; 场景异步加载 和 资源异步加载 一样，有两种方式 通过事件回调函数 协程异步加载 他们的优缺点表现和资源异步加载也是一样的 事件回调函数 优点：写法简单，逻辑清晰 缺点：只能加载完场景做一些事情，不能再加载过程中处理逻辑 协程异步加载 优点：可以在加载过程中处理逻辑，比如进度条更新等 缺点：写法较为麻烦，要通过协程 练习 请写一个简单的场景管理器，提供统一的方法给外部用于场景异步切换，外部可以传入委托用于当异步切换结束时执行某些逻辑 和这道题类似 Resources异步加载练习题 12345678910111213141516171819202122// 场景管理类 public class SceneMgr&#123; private static SceneMgr instance = new SceneMgr(); public static SceneMgr Instance =&gt; instance; private SceneMgr() &#123; &#125; // 加载场景的方法，需要传入目标场景的名称和一个UnityAction类型的委托参数 public void LoadScene(string name, UnityAction action) &#123; AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name); asyncOperation.completed += (aO) =&gt; &#123; action(); &#125;; &#125;&#125; 使用 12345678910SceneMgr.Instance.LoadScene(&quot;场景异步加载&quot;, () =&gt; &#123; print(&quot;加载结束&quot;);&#125;);// 没封装写法AsyncOperation ao = SceneManager.LoadSceneAsync(name);ao.completed += (ao) =&gt;&#123; // 场景加载结束逻辑&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"14.Resources资源卸载","slug":"游戏引擎/unity/unity基础/14.Resources资源卸载","date":"2025-03-04T10:46:52.000Z","updated":"2025-03-04T11:09:16.011Z","comments":true,"path":"2025/03/04/游戏引擎/unity/unity基础/14.Resources资源卸载/","permalink":"http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/14.Resources%E8%B5%84%E6%BA%90%E5%8D%B8%E8%BD%BD/","excerpt":"","text":"Resources重复加载资源会浪费内存吗？ 其实Resources加载一次资源过后 该资源就一直存放在内存中作为缓存 第二次加载时发现缓存中存在该资源，会直接取出来进行使用 所以，多次重复加载不会浪费内存 但是会浪费性能（每次加载都会去查找取出，始终伴随一些性能消耗） 手动释放掉缓存中的资源 Resources.UnloadAsset方法 卸载指定资源 可以在 window的 分析器查看内存是否卸载 123456789//从内存中卸载 / assetToUnload ///注意：//该方法 不能释放 GameObject对象 因为它会用于实例化对象//它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等//一般情况下 我们很少单独使用它//GameObject obj = Resources.CoroutineAsynLoad&lt;GameObject&gt;(&quot;Cube&quot;)//即使是没有实例化的 GameObject对象也不能进行卸载//Resources.UnloadAsset(obj);//报错 不能卸载GameObject Resources中的UnloadUnusedAssets方法 卸载未使用的资源 1234//卸载未使用的资源。//注意：一般在过场景时和GC一起使用Resources.UnloadUnusedAssets();GC.Collect(); // 手动触发垃圾回收","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"13.Resources异步加载","slug":"游戏引擎/unity/unity基础/13.Resources异步加载","date":"2025-03-04T08:25:58.000Z","updated":"2025-03-04T10:05:03.200Z","comments":true,"path":"2025/03/04/游戏引擎/unity/unity基础/13.Resources异步加载/","permalink":"http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/13.Resources%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"Resources 异步加载是什么？ 问题背景： 同步加载（Resources.Load）大资源时，硬盘读取到内存的资源的越大，耗时操作会阻塞主线程，导致游戏卡顿、掉帧。 异步加载原理：Unity 内部会将资源加载任务分配到其他线程处理，主线程继续执行游戏逻辑，加载完成后通知主线程使用资源。 注意：虽然逻辑上是“多线程”，但 Unity 主线程仍需每帧检查加载状态，因此要等待加载完毕(至少要等1帧) 才能获取资源。 两种实现方式： 事件监听：简单直接，适合单一资源加载。 协程：灵活控制，适合复杂加载逻辑。 通过事件监听完成回调 使用 ResourceRequest 的 completed 事件监听加载完成。 1234567891011121314151617181920using UnityEngine;public class AsyncLoadExample : MonoBehaviour&#123; void Start() &#123; // 开始异步加载 ResourceRequest request = Resources.LoadAsync&lt;GameObject&gt;(&quot;Prefabs/Dragon&quot;); // 注册完成事件 request.completed += OnLoadCompleted; &#125; // 加载完成后的回调 private void OnLoadCompleted(AsyncOperation operation) &#123; ResourceRequest request = operation as ResourceRequest; GameObject dragonPrefab = request.asset as GameObject; Instantiate(dragonPrefab); &#125;&#125; 通过协程等待加载完成 利用协程的 yield return 逐帧检查加载进度。 ResourceRequest的父类AsyncOperation： 它代表一个异步操作。当你在 Unity 中执行一些可能会阻塞主线程的任务时，比如加载场景、加载资源等，Unity 会返回一个 AsyncOperation 对象，通过这个对象你可以监控异步操作的进度，以及在操作完成时执行特定的代码。 常用属性： isDone：这是一个布尔类型的属性，用于表示异步操作是否已经完成。 progress：这是一个浮点类型的属性，范围从 0 到 1，表示异步操作的进度。0 表示操作还未开始，1 表示操作已经完成。 allowSceneActivation：在使用 SceneManager.LoadSceneAsync 加载场景时，这个属性非常有用。当 allowSceneActivation 为 false 时，场景加载到 90% 就会暂停，直到将其设置为 true 才会继续加载并激活场景。 completed：这是一个Action&lt;AsyncOperation&gt;事件，当异步操作完成时会触发该事件。你可以为这个事件添加一个委托，以便在操作完成时执行特定的代码。 123456public class ResourceRequest : AsyncOperation&#123; public Object asset &#123; get; &#125; // 加载完成的资源 public float progress &#123; get; &#125; // 加载进度(0.0~1.0) public bool isDone &#123; get; &#125; // 是否完成加载&#125; 简单加载案例 1234567891011121314IEnumerator LoadCharacter()&#123; ResourceRequest request = Resources.LoadAsync&lt;GameObject&gt;(&quot;Characters/Player&quot;); yield return request; // 等待加载完成 if (request.asset != null) &#123; Instantiate(request.asset); &#125; else &#123; Debug.LogError(&quot;加载资源失败&quot;); &#125;&#125; 带进度条的加载 123456789101112131415IEnumerator LoadWithProgress(Image progressBar)&#123; ResourceRequest request = Resources.LoadAsync&lt;Texture2D&gt;(&quot;Textures/Background&quot;); while (!request.isDone) &#123; progressBar.fillAmount = request.progress; yield return null; // 每帧更新进度 &#125; if (request.asset != null) &#123; GetComponent&lt;Renderer&gt;().material.mainTexture = request.asset as Texture2D; &#125;&#125; 批量异步加载 12345678910111213141516IEnumerator LoadMultipleResources()&#123; string[] paths = &#123; &quot;Audio/Music&quot;, &quot;Prefabs/Enemies&quot;, &quot;Materials/Weapons&quot; &#125;; foreach (var path in paths) &#123; ResourceRequest request = Resources.LoadAsync(path); yield return request; // 资源处理逻辑 HandleLoadedAsset(request.asset); // 每加载完一个资源清理一次内存 Resources.UnloadUnusedAssets(); &#125;&#125; 带优先级的加载队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152IEnumerator PriorityLoading()&#123; // 第一步：先加载核心资源 // StartCoroutine 用于启动一个协程，这里启动了 LoadEssentialResources 协程 // yield return 会暂停当前协程的执行，直到 LoadEssentialResources 协程执行完毕 yield return StartCoroutine(LoadEssentialResources()); // 第二步：同时加载多个次要资源 Coroutine[] backgroundLoads = &#123; // UI 协程 StartCoroutine(LoadUIElements()), // 环境纹理 协程 StartCoroutine(LoadEnvironmentTextures()) &#125;; // 第三步：等待所有次要资源加载完成 // WaitUntil 是一个协程等待指令，它会暂停当前协程的执行，直到传入的委托返回 true // 这里使用 LINQ 的 All 方法来检查 backgroundLoads 数组中的所有协程是否都已经停止运行 // IsCoroutineRunning 是一个自定义方法，用于判断一个协程是否正在运行 yield return new WaitUntil(() =&gt; backgroundLoads.All(c =&gt; !IsCoroutineRunning(c)));&#125;// 这是一个自定义方法，用于检查一个协程是否正在运行// 注意：Unity 本身没有直接提供检查协程是否运行的方法，这里只是一个示例实现bool IsCoroutineRunning(Coroutine coroutine)&#123; // 实际实现需要根据具体情况来判断，这里简单返回 false 作为示例 return false;&#125;// 加载核心资源IEnumerator LoadEssentialResources()&#123; // 这里可以添加具体的核心资源加载逻辑 yield return null;&#125;// 加载 UI 元素IEnumerator LoadUIElements()&#123; // 这里可以添加具体的 UI 元素加载逻辑 yield return null;&#125;// 加载环境纹理IEnumerator LoadEnvironmentTextures()&#123; // 这里可以添加具体的环境纹理加载逻辑 yield return null;&#125; 练习 请写一个简单的资源管理器，提供统一的方法给外部用于资源异步加载，外部可以传入委托用于当资源加载结束时使用资源 注意到：每次加载资源都在重复做两件事：“这些重复代码能不能抽出来？” 调用 Resources.LoadAsync 处理 completed 事件并转换类型 识别重复代码中的「稳定部分」和「变化部分」 例：LoadAsync和回调处理是稳定部分，资源类型和路径是变化部分 封装触发点： 当你第三次写出几乎相同的代码时，脑海中应该浮现： “这些加载操作的结构完全一样，只是资源类型、路径和回调内容不同。如果能写个方法把相同的部分抽出来，只要传递这三个变量就好了！” 这正是 LoadRes&lt;T&gt; 方法的诞生过程！ 123456789101112131415161718192021222324252627282930public class ResourcesMgr &#123; private static ResourcesMgr _instance; public static ResourcesMgr Instance &#123; get &#123; if (_instance == null) &#123; _instance = new ResourcesMgr(); &#125; return _instance; &#125; &#125; private ResourcesMgr() &#123; &#125; // 自己封装的资源异步加载 // T是要加载的资源类型 可以加载任意类型的Unity资源（如GameObject、Texture、AudioClip等） // 注意LoadAsync的T有一个约束,必须是Object的子类 public void LoadRes&lt;T&gt;(string path, System.Action&lt;T&gt; callback) where T : Object &#123; ResourceRequest rq = Resources.LoadAsync&lt;T&gt;(path); // 加载完成后的回调, a是 AsyncOperation 类型，需要转换为 ResourceRequest rq.completed += (a) =&gt; &#123; // 执行外面传进来的回调逻辑，callback的函数参数是 callback((a as ResourceRequest).asset as T); &#125;; &#125;&#125; 使用 123456789// 加载预制件ResourcesMgr.Instance.LoadRes&lt;GameObject&gt;(&quot;Prefabs/Player&quot;, (prefab) =&gt; &#123; Instantiate(prefab); // 实例化玩家&#125;);// 加载贴图ResourcesMgr.Instance.LoadRes&lt;Texture2D&gt;(&quot;Textures/Icon&quot;, (texture) =&gt; &#123; GetComponent&lt;Renderer&gt;().material.mainTexture = texture;&#125;); 对比着没有封装的写法 123456// 没有使用管理器的情况ResourceRequest rq = Resources.LoadAsync&lt;GameObject&gt;(&quot;Prefabs/Player&quot;);rq.completed += (a) =&gt; &#123; GameObject prefab = (a as ResourceRequest).asset as GameObject; Instantiate(prefab);&#125;;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"12.Resources同步加载","slug":"游戏引擎/unity/unity基础/12.Resources同步加载","date":"2025-03-04T07:28:05.000Z","updated":"2025-03-04T08:11:30.180Z","comments":true,"path":"2025/03/04/游戏引擎/unity/unity基础/12.Resources同步加载/","permalink":"http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/12.Resources%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"Resources 资源动态加载的作用 核心功能：允许在运行时按需加载资源，避免将所有资源预先加载到内存中。 避免繁琐的拖曳操作 适用场景： 按需加载不常用的资源（如关卡特定素材）。 动态替换资源（如角色换装）。 优点：减少内存占用，提升启动速度。 缺点：频繁加载可能引发卡顿，滥用会导致应用体积膨胀。 常用资源类型 Resources 支持加载 Unity 支持的几乎所有资源类型，常见的有： 预制体（Prefab）：.prefab 纹理（Texture）：.png, .jpg 音频（AudioClip）：.mp3, .wav 文本（TextAsset）：.txt, .json,.xml,.bytes,.html,.csv 材质（Material）：.mat 预设体对象加载需要实例化，音效要关联，图片要使用，文本要打印 其它资源加载一般直接用。 资源同步加载 - 普通方法 使用 Resources.Load(string path)，返回 Object 类型，需手动转换类型。 在一个工程当中， Resources可以有多个并放在任意的文件夹下， 通过API加载时候会自己去同名的Resources自己找 1234567891011121314151617181920212223// 加载预制体，// 这里只是把预制体这个配置文件加载到内存, 还没实例化GameObject prefab = Resources.Load(&quot;Prefabs/Enemy&quot;) as GameObject;Instantiate(prefab);// 加载纹理Texture2D texture = Resources.Load(&quot;Textures/Icon&quot;) as Texture2D;GetComponent&lt;Renderer&gt;().material.mainTexture = texture;// 加载文本TextAsset textAsset = Resources.Load(&quot;Configs/Data&quot;) as TextAsset;Debug.Log(textAsset.text + &quot; &quot; + textAsset.bytes);// 加载音效public AudioSource audioSource;Object obj3 = Resources.Load(&quot;Music/BKMusic&quot;);//我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可audioSource.clip = obj3 as AudioClip;audioSource.Play();// 加载图片tex = Resources.Load(&quot;Tex/TestJPG&quot;) as Texture; 问题：资源同名怎么办 123456//Resources.Load加载同名资源时 无法准确加载出你想要的内容//可以使用Load方法的重载，第二个参数传入加载的指定类型的资源//加载指定类型的资源tex = Resources.Load(&quot;Tex/TestJPG&quot;, typeof(Texture)) as Texture;ta = Resources.Load(&quot;Tex/TestJPG&quot;, typeof(TextAsset)) as TextAsset;print(ta.text); 资源同步加载 - 泛型方法 使用 Resources.Load&lt;T&gt;(string path)，直接返回指定类型，无需强制转换。 1234567891011// 加载预制体（直接指定类型）GameObject prefab = Resources.Load&lt;GameObject&gt;(&quot;Prefabs/Enemy&quot;);Instantiate(prefab);// 加载音频AudioClip clip = Resources.Load&lt;AudioClip&gt;(&quot;Audio/Explosion&quot;);GetComponent&lt;AudioSource&gt;().PlayOneShot(clip);// 加载材质Material mat = Resources.Load&lt;Material&gt;(&quot;Materials/Glow&quot;);GetComponent&lt;Renderer&gt;().material = mat; 练习 请把之前四元数练习题四元数练习题中，发射散弹等相关逻辑改为动态加载资源并创建 把子弹丢到Resources文件夹后，有两种改法 第一种是不在Inspector窗口拖拽Prefab，直接在Start()里Load，实例化的时候直接使用即可 1234567// 直接在Start()里Loadprivate GameObject bullet;void Start()&#123; bullet = Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;);&#125; 第二种是在实例化的时候每次都Resources.Load(“Bullet”) 注意：这样不会造成内存上的浪费，因为Unity加载好的资源放在缓存区，判断Load过了就不重新Load了，内存不会开销但是会造成性能开销 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//声明发射类型枚举 public enum E_FireType &#123; //单发 One, //双发 Two, //扇形 Three, //环形 Round &#125; public class Airplane : MonoBehaviour &#123; //声明发射类型变量 private E_FireType nowType = E_FireType.One; //子弹 public GameObject bullet; public int roundNum = 4; void Update() &#123; //Update内添加按按键切换发射类型逻辑 if (Input.GetKeyDown(KeyCode.Alpha1)) &#123; nowType = E_FireType.One; &#125; else if (Input.GetKeyDown(KeyCode.Alpha2)) &#123; nowType = E_FireType.Two; &#125; else if (Input.GetKeyDown(KeyCode.Alpha3)) &#123; nowType = E_FireType.Three; &#125; else if (Input.GetKeyDown(KeyCode.Alpha4)) &#123; nowType = E_FireType.Round; &#125; //Update内添加按按键发射子弹逻辑 if (Input.GetKeyDown(KeyCode.Space)) &#123; Fire(); &#125; &#125; //开火方法 private void Fire() &#123; switch (nowType) &#123; case E_FireType.One: Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position, this.transform.rotation); break; case E_FireType.Two: Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position - this.transform.right * 0.5f, this.transform.rotation); Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position + this.transform.right * 0.5f, this.transform.rotation); break; case E_FireType.Three: Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position, this.transform.rotation); //左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加 Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position, this.transform.rotation * Quaternion.AngleAxis(-20, Vector3.up)); //右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加 Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position, this.transform.rotation * Quaternion.AngleAxis(20, Vector3.up)); break; case E_FireType.Round: float angle = 360 / roundNum; for (int i = 0; i &lt; roundNum; i++) //角度是当前偏移度数乘飞机自己的旋转 Instantiate(Resources.Load&lt;GameObject&gt;(&quot;Bullet&quot;), this.transform.position, this.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up)); break; &#125; &#125; &#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"11.特殊文件夹","slug":"游戏引擎/unity/unity基础/11.特殊文件夹","date":"2025-03-04T06:33:29.000Z","updated":"2025-03-04T07:26:14.822Z","comments":true,"path":"2025/03/04/游戏引擎/unity/unity基础/11.特殊文件夹/","permalink":"http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/11.%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9/","excerpt":"","text":"对比总结 文件夹 用途 是否打包 可读写性 Resources 动态加载资源 是 只读 StreamingAssets 存放原始文件（视频、数据库） 是 只读（移动端） persistentDataPath 用户数据持久化 否 可读写 Plugins 原生插件 是 只读 Editor 编辑器扩展脚本 否 可读写 工程路径获取 作用：获取项目根目录或特定子文件夹的路径。 常用 API：Application.dataPath：项目根目录的绝对路径（不包含 Assets 文件夹）（该方式 获取到的路径 一般情况下 只在 编辑模式下使用，我们不会在实际发布游戏后 还使用该路径）例如： 1Debug.Log(Application.dataPath); // 输出：D:/MyProject/Assets Application.streamingAssetsPath：StreamingAssets 文件夹的路径（后文详解）。 Application.persistentDataPath：持久化数据目录的路径（后文详解）。 Resources 资源文件夹 如果你希望在代码中动态加载资源，可以将这些资源放在 Resources 文件夹中，然后使用 Resources.Load 方法来加载。 路径：Assets/Resources 特点： 打包后只读 只能通过Resources相关API加载，通过 Resources.Load(&quot;资源名&quot;) 动态加载资源（无需路径）。 打包时Unity会对其压缩加密 所以一般不会用Application.dataPath + “/Resources” 得到路径 打包时会压缩：所有资源会被打包到应用中。 慎用：过度使用会导致应用体积膨胀，且加载效率较低。（不要把所有游戏资源都丢进去 一般放在美术资源文件夹就行了 需要动态加载或者打包的再丢进去） 需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错 StreamingAssets 流动资源文件夹 用于存放项目运行时需要访问的静态数据文件，如音频、视频、配置文件等。这些文件在构建项目时会被打包到应用程序的可执行文件中，可以通过路径访问。 路径：Assets/StreamingAssets 特点： 可以放入一些需要自定义动态加载的初始资源 不压缩：资源保持原始格式，适用于视频、数据库等文件，打包出去不会被压缩加密，可以任由我们摆布。 只读：在移动平台（如 Android、iOS）上不可写入，PC平台可读可写。 访问方式：通过 Application.streamingAssetsPath 获取路径。 需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错 平台路径差异： PC：直接文件路径（如 D:/MyProject/Assets/StreamingAssets/data.txt）。 Android：路径在 APK 内部，需用 UnityWebRequest 读取。 persistentDataPath 持久数据文件夹 固定数据文件夹, 通常用于存储应用程序的配置文件、用户数据、游戏进度等重要数据，确保数据在应用程序关闭后仍然能够被保留和访问 还可以用于放置动态下载或者动态创建的文件, 游戏中创建或者获取的文件都放在其中 路径：不同平台路径不同：Application.persistentDataPath Windows：C:/Users/用户名/AppData/LocalLow/公司名/应用名 Android：/data/data/包名/files iOS：Application.persistentDataPath 特点： 可读写：用于保存用户生成的数据（如存档、配置文件）。 持久化：应用更新或重启后数据不会丢失。 所有平台可读可写 不需创建StreamingAssets文件夹 12string savePath = Path.Combine(Application.persistentDataPath, &quot;save.dat&quot;);File.WriteAllText(savePath, &quot;游戏存档数据&quot;); Plugins 插件文件夹 存放原生插件（如 .dll、.so、.a 文件）或平台特定代码。 不同平台的插件相关文件放在其中 比如IOS和Android平台 可能需要对应平台提供的代码包才能在Unity使用 以后搞SDK相关的时候可能才用得到 路径：Assets/Plugins 特点： 需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错 平台子文件夹： Android：存放安卓平台的 .so 文件。 iOS：存放 iOS 的 .a 文件。 注意事项：插件需按平台分类存放，Unity 会自动识别。 Editor 编辑器文件夹 存放编辑器扩展脚本（如自定义 Inspector、工具）。 路径：Assets/Editor 特点： 需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错 脚本只在 Unity 编辑器中运行，不会被打包到应用中。 可继承 Editor 类实现自定义功能。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"csharp迭代器","slug":"编程语言/Csharp/csharp迭代器","date":"2025-03-03T12:31:58.000Z","updated":"2025-03-04T06:16:05.803Z","comments":true,"path":"2025/03/03/编程语言/Csharp/csharp迭代器/","permalink":"http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"迭代器是什么 在 C# 中，迭代器（Iterator） 是一种用于遍历集合（如数组、列表等）元素的机制，它允许你按顺序访问集合中的每个元素而不必暴露集合的内部结构。迭代器的核心是通过 IEnumerable 和 IEnumerator 接口实现的，但 C# 提供了更简洁的语法（yield 关键字）来简化迭代器的创建。 在表现效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口。设计人员无需关心容器对象的内存分配的实现细节，可以用foreach遍历的类，都是实现了迭代器的。 迭代器的基本概念 IEnumerable 接口：表示一个集合可以被迭代，包含一个 GetEnumerator 方法。 IEnumerator 接口：提供了遍历集合的能力，包含 MoveNext()、Reset() 和 Current 属性。 标准迭代器实现（手动版） 接口定义： 1234567891011public interface IEnumerable&#123; IEnumerator GetEnumerator();&#125;public interface IEnumerator&#123; bool MoveNext(); object Current &#123; get; &#125; void Reset(); // 实际开发中通常不实现&#125; 完整实现示例： 123456789101112131415161718192021222324252627282930public class MyCollection : IEnumerable&#123; private int[] data = &#123; 1, 2, 3 &#125;; public IEnumerator GetEnumerator() =&gt; new MyEnumerator(data); // 自定义枚举器 private class MyEnumerator : IEnumerator &#123; private int[] data; private int index = -1; public MyEnumerator(int[] data) =&gt; this.data = data; public bool MoveNext() &#123; index++; return index &lt; data.Length; &#125; public object Current =&gt; data[index]; public void Reset() =&gt; index = -1; &#125;&#125;// 使用：foreach (int num in new MyCollection())&#123; Console.WriteLine(num); // 输出 1 2 3&#125; foreach本质 foreach本质: 先获取in后面这个对象的 IEnumerator 会调用对象其中的GetEnumerator方法 执行得到这个IEnumerator对象中的 MoveNext方法 只要MoveNext()方法的返回值时true 就会去得到Current然后复制给 item 123456789101112131415161718192021foreach (var item in collection) &#123; // code&#125;// 等价于：IEnumerator enumerator = collection.GetEnumerator();try &#123; while (enumerator.MoveNext()) &#123; var item = enumerator.Current; // code &#125;&#125;finally &#123; IDisposable disposable = enumerator as IDisposable; disposable?.Dispose();&#125; yield return 语法糖 C# 的 yield return 关键字可以快速定义迭代器，无需手动实现 IEnumerator 基本作用：简化迭代器 yield return 的作用是告诉编译器：“帮我自动生成一个迭代器，按我写的顺序逐个返回这些值”。例如： 123456IEnumerable&lt;int&gt; GetNumbers()&#123; yield return 10; yield return 20; yield return 30;&#125; 当调用 GetNumbers() 时，它不会一次性返回所有值，而是返回一个“待执行的迭代器”。只有当你用 foreach 遍历时，才会按顺序取出每个值。 关键特性：延迟执行（Lazy） yield return 的代码不会一次性全部执行，而是按需执行。看这个例子： 12345678910111213141516IEnumerable&lt;string&gt; GetMessages()&#123; Console.WriteLine(&quot;开始迭代&quot;); yield return &quot;第一步&quot;; Console.WriteLine(&quot;执行到中间&quot;); yield return &quot;第二步&quot;; Console.WriteLine(&quot;结束迭代&quot;);&#125;// 测试代码：var messages = GetMessages(); // 这里不会输出任何内容！Console.WriteLine(&quot;准备遍历&quot;);foreach (var msg in messages) // 此时才开始真正执行&#123; Console.WriteLine(msg);&#125; 关键点： 调用 GetMessages() 时，代码不会运行，只是返回一个“迭代器对象”。 当 foreach 开始遍历时，代码才从头执行，每次遇到 yield return 时： 返回一个值， 暂停当前方法，记录当前位置（状态）。 下次循环时，从暂停的位置继续执行。 底层原理：状态机 编译器会将 yield return 代码转换为一个隐藏的“状态机”类。例如，上述 GetMessages() 会被编译成一个类似如下的类： 12345678910111213141516171819202122232425262728class GeneratedStateMachine : IEnumerator&lt;string&gt;&#123; private int _state = 0; public string Current &#123; get; private set; &#125; public bool MoveNext() &#123; switch (_state) &#123; case 0: Console.WriteLine(&quot;开始迭代&quot;); Current = &quot;第一步&quot;; _state = 1; return true; case 1: Console.WriteLine(&quot;执行到中间&quot;); Current = &quot;第二步&quot;; _state = 2; return true; case 2: Console.WriteLine(&quot;结束迭代&quot;); return false; // 结束 default: return false; &#125; &#125; // 其他接口方法（略）&#125; yield break yield break 的基本作用 功能：在迭代器方法中，yield break 会立即终止迭代，不再生成后续的值。 1234567891011121314IEnumerable&lt;int&gt; GetNumbers()&#123; yield return 1; yield return 2; yield break; // 这里终止，后续的 yield return 不会执行 yield return 3; // 永远不会执行&#125;// 使用foreach (var num in GetNumbers())&#123; Console.WriteLine(num);&#125;// 输出：1, 2 实际应用案例 分页加载数据 1234567891011121314IEnumerable&lt;int&gt; LoadBigData()&#123; int pageSize = 1000; for (int page = 0; ; page++) &#123; var data = QueryDatabase(page, pageSize); if (data.Count == 0) yield break; foreach (var item in data) &#123; yield return item; &#125; &#125;&#125; 游戏技能连招系统： 123456789101112IEnumerator ComboAttack()&#123; yield return PlayAnimation(&quot;Attack1&quot;); if (Input.GetButton(&quot;Attack&quot;)) &#123; yield return PlayAnimation(&quot;Attack2&quot;); if (Input.GetButton(&quot;Attack&quot;)) &#123; yield return PlayAnimation(&quot;FinalBlow&quot;); &#125; &#125;&#125; 树形结构遍历： 1234567891011public IEnumerable&lt;Node&gt; Traverse(Node root)&#123; yield return root; foreach (var child in root.Children) &#123; foreach (var node in Traverse(child)) &#123; yield return node; &#125; &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp多线程","slug":"编程语言/Csharp/csharp多线程","date":"2025-03-03T12:20:16.000Z","updated":"2025-03-03T12:20:30.543Z","comments":true,"path":"2025/03/03/编程语言/Csharp/csharp多线程/","permalink":"http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园 线程基础 创建线程 Thread t = new Thread(PrintNumbers) 12345678910111213141516static void Main(string[] args)&#123; Thread t = new Thread(PrintNumbers); t.Start();//线程开始执行 PrintNumbers(); Console.ReadKey();&#125;static void PrintNumbers()&#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Console.WriteLine(i); &#125;&#125; 暂停线程 Thread.Sleep 工作原理： 当线程处于休眠状态时，它会占用尽可能少的 CPU 时间。结果我们会发现通常后运行的 PrintNumbers 方法中的代码会比独立线程中的 PrintNumbersWithDelay暂停2S 方法中的代码先执行。 1234567891011121314151617181920212223242526272829class Program&#123; static void Main(string[] args) &#123; Thread t = new Thread(PrintNumbersWithDelay); t.Start(); PrintNumbers(); Console.ReadKey(); &#125; static void PrintNumbers() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Console.WriteLine(i); &#125; &#125; static void PrintNumbersWithDelay() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2));//暂停2S Console.WriteLine(i); &#125; &#125;&#125; 线程等待 t.Join() 工作原理： 但我们在主程序中调用了 t.Join 方法，该方法允许我们等待直到线程 t 完成。当线程 t 完成时，主程序会继续运行。 借助该技术可以实现在两个线程间同步执行步骤。第一个线程会等待另一个线程完成后再继续执行。第一个线程等待时是处于阻塞状态 (正如暂停线程中调用 Thread.Sleep 方法一样)。 123456789101112131415161718192021class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Starting program...&quot;); Thread t = new Thread(PrintNumbersWithDelay); t.Start(); t.Join(); Console.WriteLine(&quot;Thread completed&quot;); &#125; static void PrintNumbersWithDelay() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(i); &#125; &#125;&#125; 终止线程 t.Abort() 弃用了 工作原理： 当主程序和单独的数字打印线程运行时，我们等待 6 秒后对线程调用了 t.Abort 方法。 这给线程注入了 ThreadAbortException 方法，导致线程被终结。这非常危险，因为该异常可以在任何时刻发生并可能彻底摧毁应用程序。 另外，使用该技术也不一定总能终止线程。目标线程可以通过处理该异常并调用 Thread.ResetAbort 方法来拒绝被终止。因此并不推荐使用 Abort 方法来关闭线程。 可优先使用一些其他方法，比如提供一个 CancellationToken 方法来取消线程的执行。 12345678910111213141516171819202122class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Starting program...&quot;); Thread t = new Thread(PrintNumbersWithDelay); t.Start(); Thread.Sleep(TimeSpan.FromSeconds(6)); t.Abort(); Console.WriteLine(&quot;A thread has been aborted&quot;); &#125; static void PrintNumbersWithDelay() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(i); &#125; &#125;&#125; 监测线程状态 Thread 对象的 ThreadState: Unstarted：线程已被创建，但尚未调用 Start 方法启动。 Running ：线程正在执行。当调用 Start 方法后，线程进入此状态并开始执行其关联的方法。 WaitSleepJoin：线程正在等待、休眠或被阻塞。当线程调用 Sleep、Wait 或 Join 方法时，会进入此状态。 Suspended（不推荐使用）：线程已被挂起。可以使用 Suspend 方法将线程挂起，但该方法已被弃用，因为它可能会导致死锁等问题。 Stopped：线程已完成执行或被终止，处于停止状态。 Aborted：线程已被调用 Abort 方法终止，但尚未完全停止执行。 。。。。。。。。。 工作原理： 当主程序启动时定义了两个不同的线程。一个将被终止，另一个则会成功完成运行。 线程状态位于 Thread 对象的 ThreadState 属性中。ThreadState 属性是一个 C# 枚举对象。 刚开始线程状态为 ThreadState.Unstarted, 然后我们启动线程，并估计在一个周期为 30 次迭代的区间中，线程状态会从 ThreadState.Running 变为 ThreadState.WaitSleepJoin。 请注意始终可以通过 Thread.CurrentThread 静态属性获得当前 Thread 对象。 如果实际情况与以上不符，请增加迭代次数。终止第一个线程后，会看到现在该线程状态为 ThreadState.Aborted, 程序也有可能会打印出 ThreadState.AbortRequested 状态。这充分说明了同步两个线程的复杂性。请记住不要在程序中使用线程终止。我在这里使用它只是为了展示相应的线程状态。 最后可以看到第二个线程 t2 成功完成并且状态为 ThreadState.Stopped。另外还有一些其他的线程状态，但是要么已经被弃用，要么没有我们实验过的几种状态有用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Starting program...&quot;); Thread t = new Thread(PrintNumbersWithStatus); Thread t2 = new Thread(DoNothing); // 线程 t 的初始状态 Console.WriteLine(t.ThreadState.ToString()); t2.Start(); t.Start(); // 循环 29 次，输出线程 t 的状态 for (int i = 1; i &lt; 30; i++) &#123; Console.WriteLine(t.ThreadState.ToString()); &#125; // 主线程休眠 6 秒 Thread.Sleep(TimeSpan.FromSeconds(6)); // 终止线程 t t.Abort(); Console.WriteLine(&quot;A thread has been aborted&quot;); // 线程 t 终止后的状态 Console.WriteLine(t.ThreadState.ToString()); // 线程 t2 的状态 Console.WriteLine(t2.ThreadState.ToString()); Console.ReadKey(); &#125; static void DoNothing() &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); &#125; static void PrintNumbersWithStatus() &#123; Console.WriteLine(&quot;Starting...&quot;); // 输出当前线程的状态 Console.WriteLine(Thread.CurrentThread.ThreadState.ToString()); // 循环 9 次，每次打印一个数字，每次循环间隔 2 秒 for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(i); &#125; &#125;&#125; 线程优先级 Thread.CurrentThread.Priority 工作原理： 当主程序启动时定义了两个不同的线程。 第一个线程优先级为 ThreadPriority.Highest, 即具有最高优先级。 第二个线程优先级为 ThreadPriority.Lowest, 即具有最低优先级。 我们先打印出主线程的优先级值，然后在所有可用的 CPU 核心上启动这两个线程。如果拥有一个 1 以上的计算核心，将在两秒钟内得到初步结果。最高优先级的线程通常会计算更多的迭代，但是两个值应该很接近。然而，如果有其他程序占用了所有的 CPU 核心运行负载，结果则会截然不同。 为了模拟该情形，我们设置了 ProcessorAffinity 选项，让操作系统将所有的线程运行在单个 CPU 核心 (第一个核心) 上。现在结果完全不同，并且计算耗时将超过 2 秒钟。这是因为 CPU 核心大部分时间在运行高优先级的线程，只留给剩下的线程很少的时间来运行。 请注意这是操作系统使用线程优先级的一个演示。通常你无需使用这种行为编写程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Program&#123; static void Main(string[] args) &#123; // 输出当前线程的优先级 Console.WriteLine(&quot;Current thread priority: &#123;0&#125;&quot;, Thread.CurrentThread.Priority); Console.WriteLine(&quot;Running on all cores available&quot;); // 调用 RunThreads 方法启动线程, 程序将在所有可用核心上运行 RunThreads(); // 主线程休眠 2 秒 Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(&quot;Running on a single core&quot;); // 设置当前进程仅使用一个核心 Process.GetCurrentProcess().ProcessorAffinity = new IntPtr(1); // 启动线程 RunThreads(); &#125; // 启动两个线程并设置不同优先级的方法 static void RunThreads() &#123; var sample = new ThreadSample(); var threadOne = new Thread(sample.CountNumbers); threadOne.Name = &quot;ThreadOne&quot;; // 线程命名 var threadTwo = new Thread(sample.CountNumbers); threadTwo.Name = &quot;ThreadTwo&quot;; // 设置第一个线程的优先级为最高 threadOne.Priority = ThreadPriority.Highest; // 设置第二个线程的优先级为最低 threadTwo.Priority = ThreadPriority.Lowest; threadOne.Start(); threadTwo.Start(); // 主线程休眠 2 秒 Thread.Sleep(TimeSpan.FromSeconds(2)); // 调用 Stop 方法停止线程计数 sample.Stop(); Console.ReadKey(); &#125; class ThreadSample &#123; // 用于控制线程计数循环的标志 private bool _isStopped = false; // 停止线程计数的方法 public void Stop() &#123; _isStopped = true; &#125; // 线程执行的计数方法 public void CountNumbers() &#123; // 初始化计数器 long counter = 0; // 只要未停止，就持续计数 while (!_isStopped) &#123; counter++; &#125; // 输出线程名称、优先级和计数结果 Console.WriteLine(&quot;&#123;0&#125; with &#123;1,11&#125; priority &quot; + &quot;has a count = &#123;2,13&#125;&quot;, Thread.CurrentThread.Name, Thread.CurrentThread.Priority, counter.ToString(&quot;N0&quot;)); &#125; &#125;&#125; 前台线程和后台线程 thread.IsBackground = true 工作原理： 当主程序启动时定义了两个不同的线程。默认情况下，显式创建的线程是前台线程。通过手动的设置 threadTwo 对象的 IsBackground 属性为 ture 来创建一个后台线程(可以在主线程设置其它线程执行完毕的条件)。通过配置来实现第一个线程会比第二个线程先完成。然后运行程序。 第一个线程完成后，程序结束并且后台线程被终结。这是前台线程与后台线程的主要区别：进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结束工作。 一个重要注意事项是：如果程序定义了一个不会完成的前台线程，主程序并不会正常结束。 12345678910111213141516171819202122232425262728293031323334353637class Program&#123; static void Main(string[] args) &#123; var sampleForeground = new ThreadSample(10); var sampleBackground = new ThreadSample(20); var threadOne = new Thread(sampleForeground.CountNumbers); threadOne.Name = &quot;ForegroundThread&quot;; var threadTwo = new Thread(sampleBackground.CountNumbers); threadTwo.Name = &quot;BackgroundThread&quot;; threadTwo.IsBackground = true; threadOne.Start(); threadTwo.Start(); Console.ReadKey(); &#125; class ThreadSample &#123; private readonly int _iterations; public ThreadSample(int iterations) &#123; _iterations = iterations; &#125; public void CountNumbers() &#123; for (int i = 0; i &lt; _iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine(&quot;&#123;0&#125; prints &#123;1&#125;&quot;, Thread.CurrentThread.Name, i); &#125; &#125; &#125;&#125; 向线程传递参数 通过实例字段间接传递参数 Thread.Start 方法传入object类型参数 另一种传递数据的方式是使用 Thread.Start 方法。该方法会接收一个对象，并将该对象传递给线程。为了应用该方法，在线程中启动的方法必须接受 object 类型的单个参数。在创建 threadTwo 线程时演示了该方式。我们将 8 作为一个对象传递给了 Count 方法，然后 Count 方法被转换为整型。 使用 Lambda 表达式捕获变量 接下来的方式是使用 lambda 表达式。lambda 表达式定义了一个不属于任何类的方法。我们创建了一个方法，该方法使用需要的参数调用了另一个方法，并在另一个线程中运行该方法。当启动 threadThree 线程时，打印出了 12 个数字，这正是我们通过 lambda 表达式传递的数字。 使用 lambda 表达式引用另一个 C# 对象的方式被称为csharp的Lambda表达式。当在 lambda 表达式中使用任何局部变量时，C# 会生成一个类，并将该变量作为该类的一个属性。所以实际上该方式与 threadOne 线程中使用的一样，但是我们无须定义该类，C# 编译器会自动帮我们实现。 这可能会导致几个问题。例如，如果在多个 lambda 表达式中使用相同的变量，它们会共享该变量值。在前一个例子中演示了这种情况。当启动 threadFour 和 threadFive 线程时，它们都会打印 20, 因为在这两个线程启动之前变量被修改为 20。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System;using System.Threading;class Program&#123; static void Main(string[] args) &#123; // 指定迭代次数为 10 var sample = new ThreadSample(10); // 创建第一个线程，执行 sample 实例的 CountNumbers 方法 var threadOne = new Thread(sample.CountNumbers); threadOne.Name = &quot;ThreadOne&quot;; threadOne.Start(); // 主线程等待 threadOne 执行完毕 threadOne.Join(); Console.WriteLine(&quot;--------------------------&quot;); // 创建第二个线程，执行静态方法 Count var threadTwo = new Thread(Count); threadTwo.Name = &quot;ThreadTwo&quot;; // 启动线程并传递参数 8 threadTwo.Start(8); // 主线程等待 threadTwo 执行完毕 threadTwo.Join(); Console.WriteLine(&quot;--------------------------&quot;); // 创建第三个线程，使用 Lambda 表达式调用静态方法 CountNumbers var threadThree = new Thread(() =&gt; CountNumbers(12)); threadThree.Name = &quot;ThreadThree&quot;; threadThree.Start(); // 主线程等待 threadThree 执行完毕 threadThree.Join(); Console.WriteLine(&quot;--------------------------&quot;); // 定义一个整数变量 i 并初始化为 10 int i = 10; // 创建第四个线程，使用 Lambda 表达式调用静态方法 PrintNumber var threadFour = new Thread(() =&gt; PrintNumber(i)); // 修改变量 i 的值为 20 i = 20; // 创建第五个线程，使用 Lambda 表达式调用静态方法 PrintNumber var threadFive = new Thread(() =&gt; PrintNumber(i)); threadFour.Start(); threadFive.Start(); &#125; static void Count(object iterations) &#123; CountNumbers((int)iterations); &#125; // 静态方法，用于循环打印线程名称和迭代次数，每次循环间隔 0.5 秒 static void CountNumbers(int iterations) &#123; for (int i = 1; i &lt;= iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine(&quot;&#123;0&#125; prints &#123;1&#125;&quot;, Thread.CurrentThread.Name, i); &#125; &#125; static void PrintNumber(int number) &#123; Console.WriteLine(number); &#125; class ThreadSample &#123; // 迭代次数 private readonly int _iterations; public ThreadSample(int iterations) &#123; _iterations = iterations; &#125; // 循环打印线程名称和迭代次数，每次循环间隔 0.5 秒 public void CountNumbers() &#123; for (int i = 1; i &lt;= _iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine(&quot;&#123;0&#125; prints &#123;1&#125;&quot;, Thread.CurrentThread.Name, i); &#125; &#125; &#125;&#125; 使用 C# 中的 lock 关键字 lock 的作用 线程同步：确保在多线程环境下，同一时间只有一个线程可以访问临界区（被锁保护的代码块）。 解决竞态条件：防止多个线程同时修改共享资源导致数据不一致。 基本语法 123456789private readonly object _lockObj = new object(); // 锁对象必须是引用类型void ThreadSafeMethod()&#123; lock (_lockObj) &#123; // 临界区代码（同一时间仅一个线程可执行） &#125;&#125; 底层原理 基于 Monitor 类：lock 是语法糖，编译后等价于： 1234567891011bool lockTaken = false;try&#123; Monitor.Enter(_lockObj, ref lockTaken); // 临界区代码&#125;finally&#123; if (lockTaken) Monitor.Exit(_lockObj);&#125; 不安全的计数器（Counter 类） 与 安全的计数器（CounterWithLock 类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Program&#123; static void Main(string[] args) &#123; // 不正确的计数器 Console.WriteLine(&quot;Incorrect counter&quot;); var c = new Counter(); var t1 = new Thread(() =&gt; TestCounter(c)); var t2 = new Thread(() =&gt; TestCounter(c)); var t3 = new Thread(() =&gt; TestCounter(c)); t1.Start(); t2.Start(); t3.Start(); t1.Join(); t2.Join(); t3.Join(); Console.WriteLine(&quot;Total count: &#123;0&#125;&quot;,c.Count); Console.WriteLine(&quot;--------------------------&quot;); // 正确的计数器 Console.WriteLine(&quot;Correct counter&quot;); var c1 = new CounterWithLock(); t1 = new Thread(() =&gt; TestCounter(c1)); t2 = new Thread(() =&gt; TestCounter(c1)); t3 = new Thread(() =&gt; TestCounter(c1)); t1.Start(); t2.Start(); t3.Start(); t1.Join(); t2.Join(); t3.Join(); Console.WriteLine(&quot;Total count: &#123;0&#125;&quot;, c1.Count); Console.ReadKey(); &#125; static void TestCounter(CounterBase c) &#123; for (int i = 0; i &lt; 100000; i++) &#123; c.Increment(); c.Decrement(); &#125; &#125; // 没加锁的计数器 class Counter : CounterBase &#123; public int Count &#123; get; private set; &#125; public override void Increment() &#123; Count++; &#125; public override void Decrement() &#123; Count--; &#125; &#125; // 加了锁的计数器 class CounterWithLock : CounterBase &#123; private readonly object _syncRoot = new Object(); public int Count &#123; get; private set; &#125; public override void Increment() &#123; lock (_syncRoot) &#123; Count++; &#125; &#125; public override void Decrement() &#123; lock (_syncRoot) &#123; Count--; &#125; &#125; &#125; abstract class CounterBase &#123; public abstract void Increment(); public abstract void Decrement(); &#125;&#125; lock相关注意： (1) 锁对象的选择 锁对象必须是引用类型：值类型会被装箱，每次装箱生成新对象，导致锁失效。 私有且只读：防止锁对象被修改。推荐模式：private readonly object _lockObj = new object(); // 专用锁对象 (2) 临界区最小化 锁的粒度要细：仅保护真正需要同步的资源，减少锁持有时间 12345678910111213141516// 错误：锁范围过大lock (_lockObj)&#123; ReadData(); ProcessData(); // 长时间计算 WriteData();&#125;// 正确：仅锁共享数据操作var data = ReadData();var result = ProcessData(data); // 无锁计算lock (_lockObj)&#123; WriteData(result);&#125; (3) 避免嵌套锁 死锁风险：若多个锁以不同顺序嵌套获取，可能引发死锁。 1234567891011// 线程1lock (A)&#123; lock (B) &#123; ... &#125;&#125;// 线程2lock (B) // 若线程1已持A等B，线程2持B等A → 死锁&#123; lock (A) &#123; ... &#125;&#125; 使用Monitor类锁定资源* 代码行为分析 第一部分（使用 TryEnter 避免死锁） 线程1执行 LockTooMuch：获取 lock1 → 休眠 1 秒 → 尝试获取 lock2。 主线程：获取 lock2 → 休眠 1 秒 → 尝试通过 TryEnter 获取 lock1（超时 5 秒）。 可能的执行结果： 线程1持有 lock1，等待 lock2；主线程持有 lock2，等待 lock1 → 死锁条件成立。 但由于主线程使用 TryEnter，5 秒后会超时并释放 lock2，随后线程1最终能获取 lock2，继续执行。 输出：Timeout acquiring a resource!。 第二部分（直接死锁） 线程2再次执行 LockTooMuch（同上）。 主线程再次尝试以 lock2 → lock1 顺序获取锁。 结果：主线程持有 lock2，等待 lock1；线程2持有 lock1，等待 lock2 → 死锁，程序永久阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Program&#123; static void Main(string[] args) &#123; // 创建两个锁对象 object lock1 = new object(); object lock2 = new object(); // 启动第一个线程：尝试以 lock1 → lock2 顺序获取锁 new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start(); // 主线程尝试以 lock2 → lock1 顺序获取锁 lock (lock2) // 主线程获取 lock2 &#123; Thread.Sleep(1000); // 等待 1 秒（让第一个线程先获取 lock1） Console.WriteLine(&quot;Monitor.TryEnter 允许不阻塞，在超时后返回 false&quot;); // 尝试在 5 秒内获取 lock1（非阻塞式） if (Monitor.TryEnter(lock1, TimeSpan.FromSeconds(5))) &#123; Console.WriteLine(&quot;成功获取受保护资源！&quot;); Monitor.Exit(lock1); // 释放锁（实际代码中应使用 finally 确保释放） &#125; else &#123; Console.WriteLine(&quot;获取资源超时！&quot;); // 此处未获取到 lock1，但 lock2 会在当前代码块结束后自动释放 &#125; &#125; // 第二次启动线程：再次尝试 lock1 → lock2 顺序 new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start(); Console.WriteLine(&quot;----------------------------------&quot;); // 主线程再次尝试以 lock2 → lock1 顺序获取锁（此次无超时机制） lock (lock2) // 获取 lock2 &#123; Console.WriteLine(&quot;这将引发死锁！&quot;); Thread.Sleep(1000); // 尝试获取 lock1（此时第一个线程可能持有 lock1 并等待 lock2） lock (lock1) // 阻塞在此处，无法继续执行 &#123; Console.WriteLine(&quot;成功获取受保护资源！&quot;); // 永远不会执行 &#125; &#125; Console.ReadKey(); &#125; static void LockTooMuch(object lock1, object lock2) &#123; lock (lock1) // 先获取 lock1 &#123; Thread.Sleep(1000); // 等待 1 秒（让主线程有机会获取 lock2） lock (lock2) // 再尝试获取 lock2（可能导致死锁） &#123; // 临界区代码 &#125; &#125; &#125;&#125; 多线程异常处理 异常作用域规则 线程是独立执行路径：每个线程拥有自己的异常处理上下文。 主线程无法直接捕获子线程的异常：try-catch 在父线程中无法捕获子线程未处理的异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Program&#123; static void Main(string[] args) &#123; // 第一个线程：内部捕获异常 var t = new Thread(FaultyThread); t.Start(); // 启动线程 t.Join(); // 等待线程结束（此时异常已被内部处理，不会传播到主线程） // 第二个线程：未处理异常 try &#123; t = new Thread(BadFaultyThread); t.Start(); // 启动线程（但未调用 Join） // 主线程不会等待此线程结束，try-catch 无法捕获子线程异常！ &#125; catch (Exception ex) &#123; // 此处永远不会执行，因为子线程的异常不会传递到主线程 Console.WriteLine(&quot;We won&#x27;t get here!&quot;); &#125; &#125; // 方法：内部捕获异常 static void FaultyThread() &#123; try &#123; Console.WriteLine(&quot;Starting a faulty thread...&quot;); Thread.Sleep(TimeSpan.FromSeconds(1)); throw new Exception(&quot;Boom!&quot;); // 抛出异常 &#125; catch (Exception ex) &#123; // 异常在此处被捕获并处理 Console.WriteLine(&quot;Exception handled: &#123;0&#125;&quot;, ex.Message); &#125; &#125; // 方法：未处理异常 static void BadFaultyThread() &#123; Console.WriteLine(&quot;Starting a faulty thread...&quot;); Thread.Sleep(TimeSpan.FromSeconds(2)); throw new Exception(&quot;Boom!&quot;); // 抛出未捕获的异常 &#125;&#125; 正确捕获子线程异常的方法 (1) 在线程方法内部处理异常 12345void SafeThreadMethod()&#123; try &#123; /* 代码 */ &#125; catch (Exception ex) &#123; /* 记录或处理异常 */ &#125;&#125; (2) 使用 Task 替代 Thread 优势：通过 Task.Exception 属性聚合所有异常（AggregateException）。 12345678910Task.Run(() =&gt; &#123; // 可能抛异常的代码&#125;).ContinueWith(t =&gt; &#123; if (t.Exception != null) &#123; Console.WriteLine(&quot;捕获异常: &quot; + t.Exception.InnerException.Message); &#125;&#125;, TaskContinuationOptions.OnlyOnFaulted); (3) 全局异常捕获（不推荐） 1234AppDomain.CurrentDomain.UnhandledException += (sender, e) =&gt; &#123; Console.WriteLine(&quot;全局捕获: &quot; + e.ExceptionObject.ToString());&#125;;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"10.协同程序","slug":"游戏引擎/unity/unity基础/10.协同程序","date":"2025-03-02T11:15:55.000Z","updated":"2025-03-04T06:29:05.593Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/10.协同程序/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"简单回顾csharp中的多线程 csharp多线程 Unity是否支持多线程？ Unity是支持多线程的，只是新开线程无法访问Unity相关场景上对象的内容。例如this.transform（必须在主线程调用）。 注意：Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑 在Unity中，不会开启多线程访问Unity相关。当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。 当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//新线程Thread newThread;//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西Queue&lt;Vector3&gt; queue = new Queue&lt;Vector3&gt;();//副线程可能也要拿主线程的数据用来判断做逻辑Queue&lt;Vector3&gt; queue2 = new Queue&lt;Vector3&gt;();void Start()&#123; //首先要明确一点 //Unity是支持多线程的 //只是新开线程无法访问Unity相关对象的内容 //引用System.Threading命名空间 newThread = new Thread(newThreadLogic); newThread.Start(); //注意： //Unity中的多线程 要记住关闭 //不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 //可以在OnDestroy执行关闭线程逻辑&#125;void Update()&#123; //在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用 if (queue.Count &gt; 0) &#123; //取出位置 this.transform.position = queue.Dequeue(); &#125;&#125;//新线程逻辑private void newThreadLogic()&#123; while (true) &#123; Thread.Sleep(1000); print(&quot;新线程逻辑 每隔一秒的打印&quot;); //我们在Unity中，不会开启多线程访问Unity相关 //当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿 //这时就可以开启多线程用于A星寻路算法，网络收发相关 //当算好了结果或者收到了消息过后，放在公共的内存区域 //主线程判断判断公共的内存区域有没有想要的对象，拿来使用 //这句代码会报错 不能在副线程控制Unity相关 //UnityException: get_transform can only be called from the main thread. //this.transform.Translate(Vector3.forward * Time.deltaTime); //相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中 //用Unity的随机数都不能用 用C#里的随机数 System.Random r = new System.Random(); queue.Enqueue(new Vector3(r.Next(-10, 10), r.Next(-10, 10), r.Next(-10, 10))); &#125;&#125;private void OnDestroy()&#123; //关闭线程 newThread.Abort(); //关闭线程后置空 newThread = null;&#125; 什么是协程？ 协程（Coroutine）是Unity中一种特殊的函数，可以分步执行代码并跨越多帧运行。它通过yield关键字暂停执行，并在特定条件（如等待时间结束、帧结束等）满足后继续执行。 它是“假”的多线程，它不是多线程 它的本质是迭代器 C#的迭代器**函数”分步执行”的特点 加上 Unity自己定义的一些协程调度逻辑 实现的一套分时执行函数的规则 协程的主要作用 将代码分时执行，不卡主线程 简单理解，是把可能会让主线程卡顿的耗时的逻辑分时分步执行 处理延时操作：例如等待1秒后执行代码。 分步执行任务：将复杂任务拆分成多个步骤，避免卡顿。 按帧控制逻辑：逐帧处理动画、AI行为等。 异步加载资源：分批加载资源防止主线程阻塞。 异步下载文件 场景异步加载 批量创建时防止卡顿 主要使用场景 角色技能冷却倒计时。 分批次加载大型场景或资源。 实现平滑的动画过渡（如物体渐隐）。 等待网络请求返回后更新UI。 协同程序和线程的区别 新开一个线程是独立的一个管道，与主线程并行执行。 新开一个协程是在原线程之上开启，进行逻辑分时分步执行。 回顾yield return相关知识点 协程的使用方法 基本规则： 协程方法的返回类型必须是 IEnumerator。 使用 yield return 指定暂停条件（如 new WaitForSeconds(2)）。 通过 StartCoroutine() 启动协程。 启动协程： 基本语法： 12345678910111213141516public class CoroutineExample : MonoBehaviour&#123; void Start() &#123; // 启动协程 StartCoroutine(SimpleCoroutine()); &#125; IEnumerator MyCoroutine(string hello) &#123; Debug.Log($&quot;协程开始，say hello\\n&#123;hello&#125;&quot;); yield return new WaitForSeconds(1); // 暂停1秒 Debug.Log(&quot;1秒后执行&quot;); yield return new WaitForSeconds(2); // 再暂停2秒 Debug.Log(&quot;又过了2秒&quot;); &#125;&#125; Unity 提供了多种内置的等待指令，可以直接在协程中使用： 指令 说明 指令满足之后在哪里执行 null 或者 数字 等待到下一帧（等同 yield return null） Update和LateUpdate之间执行 WaitForSeconds 等待指定秒数（受Time.timeScale时间缩放影响） Update和LateUpdate之间执行 WaitForSecondsRealtime 等待指定秒数（不受Time.timeScale时间缩放影响） Update之后 WaitForFixedUpdate 等待到下一个 FixedUpdate 在FixedUpdate和碰撞检测相关函数之后执行 WaitForEndOfFrame 等待到帧结束（截图功能） 等待摄像机和GUI渲染完成后执行，在LateUpdate之后的渲染相关处理完毕后之后 WWW 或 UnityWebRequest 等待网络请求完成 Update之后 停止协程 123456// 停止单个协程Coroutine coroutine = StartCoroutine(MyCoroutine());StopCoroutine(coroutine);// 停止所有协程StopAllCoroutines(); 协程的典型使用场景 场景 1：延迟执行 123456IEnumerator DelayedAction()&#123; yield return new WaitForSeconds(3); Debug.Log(&quot;3秒后执行爆炸效果&quot;); // 触发爆炸动画、音效等&#125; 场景 2：分帧处理大数据 12345678IEnumerator ProcessLargeData(List&lt;Item&gt; data)&#123; foreach (var item in data) &#123; ProcessItem(item); // 处理单个数据 yield return null; // 每帧处理一个，避免卡顿 &#125;&#125; 场景 3：按顺序执行多段逻辑 12345678IEnumerator DialogueSequence()&#123; ShowText(&quot;你好，旅行者！&quot;); yield return new WaitUntil(() =&gt; Input.GetKeyDown(KeyCode.Space)); // 等待玩家按空格 ShowText(&quot;前方有危险...&quot;); yield return new WaitForSeconds(2); ShowText(&quot;准备好了吗？&quot;);&#125; 协程受对象和组件失活销毁的影响 协程开启后： 组件或物体销毁，物体失活，则协程不再执行。 组件失活时，协程仍然执行。 练习 协程实现的计秒器 1234567891011121314151617181920212223242526272829303132using UnityEngine;using UnityEngine.UI;public class Timer : MonoBehaviour&#123; public Text timerText; // 关联UI文本 private float elapsedTime; private bool isRunning; void Start() &#123; StartCoroutine(CountSeconds()); &#125; IEnumerator CountSeconds() &#123; isRunning = true; while (isRunning) &#123; elapsedTime += Time.deltaTime; // 显示格式化为整数秒（或保留1位小数） timerText.text = &quot;Time: &quot; + elapsedTime.ToString(&quot;F1&quot;); yield return null; // 每帧更新 &#125; &#125; // 停止计时（可选） public void StopTimer() &#123; isRunning = false; &#125;&#125; 分帧创建10万立方体（无卡顿） 原本 1帧 创建 10万个 现在 1帧 创建 cubesPerFrame 个 比较蠢的做法 12345for (int i = 0; i &lt; 100000; i++)&#123; GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.transform.position = new Vector3(Random.Range(-100, 100), Random.Range(-100, 100), Random.Range(-100, 100));&#125; 1234567891011121314151617181920212223242526272829303132333435using UnityEngine;public class CubeSpawner : MonoBehaviour&#123; public GameObject cubePrefab; // 立方体预制体 public int totalCubes = 100000; public int cubesPerFrame = 500; // 每帧生成的数量 void Start() &#123; StartCoroutine(SpawnCubes()); &#125; IEnumerator SpawnCubes() &#123; int created = 0; while (created &lt; totalCubes) &#123; for (int i = 0; i &lt; cubesPerFrame; i++) &#123; if (created &gt;= totalCubes) break; // 随机生成位置（范围可调） Vector3 pos = new Vector3( Random.Range(-50f, 50f), Random.Range(-50f, 50f), Random.Range(-50f, 50f) ); Instantiate(cubePrefab, pos, Quaternion.identity); created++; &#125; yield return null; // 每帧分批生成 &#125; Debug.Log(&quot;生成完成&quot;); &#125;&#125; 手动实现协程调度器（不使用Unity自带功能） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class CustomYieldReturn&#123; // 下次执行的时间点 public float Timer; // 每次MoveNext后的返回值 public IEnumerator Coroutine;&#125;public class MyCoroutineMgr : MonoBehaviour&#123; private MyCoroutineMgr() &#123; &#125; private static MyCoroutineMgr _instance; public static MyCoroutineMgr Instance =&gt; _instance; // 迭代器函数对象的 容器 用于 一会继续执行（在Update中不断调用MoveNext） public List&lt;CustomYieldReturn&gt; customYieldReturns = new List&lt;CustomYieldReturn&gt;(); void Awake() &#123; _instance = this; &#125; //开启协程的方法 public void StartCoroutine(IEnumerator coroutine) &#123; if (coroutine.MoveNext()) &#123; CustomYieldReturn tmp = new CustomYieldReturn(); // 记录下次执行的时间点, 用于Update中判断是否执行 tmp.Timer = Time.time + (float)coroutine.Current; // 记录当前的协程位置 tmp.Coroutine = coroutine; customYieldReturns.Add(tmp); &#125; &#125; // Update is called once per frame void Update() &#123; // 每一帧倒着遍历所有的协程，因为有可能会删除 for (int i = customYieldReturns.Count - 1; i &gt;= 0; i--) &#123; CustomYieldReturn tmp = customYieldReturns[i]; // 判断是否到了下次执行 if (Time.time &gt; tmp.Timer) &#123; if (tmp.Coroutine.MoveNext()) &#123; // 更新下一个yield return的条件 tmp.Timer = Time.time + (float)tmp.Coroutine.Current; &#125; else &#123; customYieldReturns.RemoveAt(i); &#125; &#125; &#125; &#125;&#125;// **使用自己的协程管理器** Test.cspublic class Test : MonoBehaviour&#123; // 协程 IEnumerator MyTestFunc() &#123; Debug.Log(&quot;你好&quot;); yield return 1.0f; Debug.Log(1); yield return 2.0f; Debug.Log(2); yield return 3.0f; Debug.Log(3); &#125; private void Start() &#123; // 使用自己的协程管理器 MyCoroutineMgr.Instance.StartCoroutine(MyTestFunc()); &#125;&#125; D老师写的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// 迭代器状态机控制// ----------------------------// yield return 类型 | 对应处理方式// ----------------------------// null | 下一帧继续// WaitForSeconds(秒数) | 计时等待// WaitForEndOfFrame | 帧结束时继续// 其他对象 | 特殊处理（本例暂不实现）using System.Collections;using UnityEngine;public class CustomCoroutineRunner : MonoBehaviour&#123; // 自定义协程数据类 private class CoroutineTask &#123; public IEnumerator Routine; // 迭代器函数 public object CurrentYield; // 当前等待条件 public float Timer; // 计时器 &#125; private List&lt;CoroutineTask&gt; activeCoroutines = new List&lt;CoroutineTask&gt;(); // 启动协程 public void StartCustomCoroutine(IEnumerator routine) &#123; var task = new CoroutineTask &#123; Routine = routine, CurrentYield = null, Timer = 0 &#125;; activeCoroutines.Add(task); &#125; void Update() &#123; // 倒序遍历允许安全移除 for (int i = activeCoroutines.Count - 1; i &gt;= 0; i--) &#123; var task = activeCoroutines[i]; // 处理等待条件 bool canContinue = false; if (task.CurrentYield == null) &#123; canContinue = true; &#125; else if (task.CurrentYield is WaitForSeconds waitForSeconds) &#123; task.Timer += Time.deltaTime; if (task.Timer &gt;= waitForSeconds.m_Seconds) &#123; canContinue = true; task.Timer = 0; &#125; &#125; // 执行迭代器下一步 if (canContinue) &#123; if (task.Routine.MoveNext()) &#123; // 更新下一个yield return的条件 task.CurrentYield = task.Routine.Current; &#125; else &#123; activeCoroutines.RemoveAt(i); &#125; &#125; &#125; &#125;&#125;// 使用示例 TestScript.cspublic class TestScript : MonoBehaviour&#123; void Start() &#123; var runner = gameObject.AddComponent&lt;CustomCoroutineRunner&gt;(); runner.StartCustomCoroutine(MyCustomCoroutine()); &#125; IEnumerator MyCustomCoroutine() &#123; Debug.Log(&quot;步骤1：&quot; + Time.time); yield return new WaitForSeconds(1); // 等待1秒 Debug.Log(&quot;步骤2：&quot; + Time.time); yield return new WaitForSeconds(1); // 再等1秒 Debug.Log(&quot;最终步骤：&quot; + Time.time); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"9.延迟函数","slug":"游戏引擎/unity/unity基础/9.延迟函数","date":"2025-03-02T09:08:38.000Z","updated":"2025-03-02T09:32:59.906Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/9.延迟函数/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/9.%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"什么是延迟函数 延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。 它是MonoBehaviour基类中实现好的方法。 延迟函数的使用 Invoke方法 开启延迟函数 注意: 没法调用有参数的函数 必须是该脚本上申明的函数 可以用DelayedFunction间接调用到其它对象, 或者有参数的函数 只有挂载的脚本对象失活可以继续执行, 其它情况都会无法继续执行 1234// 在time秒后调用methodName方法。 // 参数一：函数名字符串 // 参数二：延迟时间，秒为单位 Invoke(&quot;DelayDoSomething&quot;, 1); InvokeRepeating方法 开启延迟重复执行函数 与Invoke类似，但可以设置重复调用的间隔时间。 参数2：第一次延迟的时间 参数3：以后每次延迟的时间 123456789void Start()&#123; InvokeRepeating(&quot;RepeatedFunction&quot;, 2.0f, 1.0f); // 延时2秒后每隔1秒调用一次RepeatedFunction方法&#125;void RepeatedFunction()&#123; // 在这里写重复延时执行的代码&#125; CancelInvoke 取消延时调用 12CancelInvoke(&quot;Fun&quot;); // 只取消Fun，所有延迟执行Fun的都会没CancelInvoke(); // 无参数取消所有延时函数 IsInvoking方法 判断是否有延迟函数 1234567891011// 是否有任何待处理的methodName调用？// 不传入参数，判断该脚本上是否存在任何延迟函数if (IsInvoking())&#123; print(&quot;存在延迟函数&quot;);&#125;// 传入参数，判断该脚本上是否存在指定延迟函数if (IsInvoking(&quot;DelayDoSomething&quot;))&#123; print(&quot;存在延迟函数DelayDoSomething&quot;);&#125; 延迟函数受对象失活销毁影响 延迟函数在依附对象或者脚本失活时不受影响，但在对象销毁或者移除脚本时无法继续执行。 如果想在失活 或者 激活 的时候来执行延迟函数， 可以在生命周期函数OnEnable和OnDisable中做逻辑 123456789private void OnEnable()&#123; // 对象激活的生命周期函数中，开启延迟（重复执行的延迟）&#125;private void OnDisable()&#123; // 对象失活的生命周期函数中，停止延迟&#125; 练习 利用延时函数实现一个计秒器 12345678910111213141516171819// 使用延迟重复函数，一进来直接调用，然后每隔一秒调用，实现计时器InvokeRepeating(&quot;DelayTimer&quot;, 0, 1);// 直接执行函数 函数里面在写一个普通延迟函数每秒调用自己DelayTimer2();private void DelayTimer()&#123; print(time + &quot;秒&quot;); ++time;&#125;private void DelayTimer2()&#123; print(time + &quot;秒&quot;); ++time; Invoke(&quot;DelayTimer2&quot;, 1);&#125; 请用两种方式延时销毁一个指定对象 一个只能销毁，一个销毁还可以写逻辑 1234567891011// 通过Destroy来进行延迟销毁Destroy(this.gameObject, 5);// 延迟函数销毁，内部使用销毁逻辑，// 包裹一层，相比于Destroy直接销毁，假如想有其他逻辑也可以写在延迟销毁函数中Invoke(&quot;DelayDestroy&quot;, 5);private void DelayDestroy()&#123; Destroy(this.gameObject);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"8.Quaternion四元数计算","slug":"游戏引擎/unity/unity基础/8.Quaternion四元数计算","date":"2025-03-02T07:55:47.000Z","updated":"2025-03-04T08:07:05.852Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/8.Quaternion四元数计算/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/","excerpt":"","text":"四元数相乘 1234567//通过轴角对API传入要转的轴和角度//绕着y轴转20度Quaternion q = Quaternion.AngleAxis(20, Vector3.up);//乘上这个脚本挂载的立方体当前旋转四元数 让这个脚本挂载的立方体绕着y轴转20度this.transform.rotation *= q;//注意1：用四元数旋转完可能和Inspector窗口上的旋转对不上 不用管它//注意2：旋转相对的坐标系 是物体自身坐标系 四元数乘以向量 注意一定是 向量 = 四元数 * 向量 不是 向量 = 向量 * 四元数 123456789101112131415void Start()&#123; // 定义一个向量 Vector3 vector = new Vector3(1, 0, 0); // 定义一个四元数表示45度绕Y轴的旋转 Quaternion rotation = Quaternion.Euler(0, 45, 0); // 使用四元数旋转向量 Vector3 rotatedVector = rotation * vector; // 打印结果 Debug.Log(&quot;Original Vector: &quot; + vector); Debug.Log(&quot;Rotated Vector: &quot; + rotatedVector);&#125; 练习 模拟飞机发射不同类型子弹的方法：单发，双发，扇形，环形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//声明发射类型枚举public enum E_FireType&#123; //单发 One, //双发 Two, //扇形 Three, //环形 Round&#125;public class Airplane : MonoBehaviour&#123; //声明发射类型变量 private E_FireType nowType = E_FireType.One; //子弹 public GameObject bullet; public int roundNum = 4; void Update() &#123; //Update内添加按按键切换发射类型逻辑 if (Input.GetKeyDown(KeyCode.Alpha1)) &#123; nowType = E_FireType.One; &#125; else if (Input.GetKeyDown(KeyCode.Alpha2)) &#123; nowType = E_FireType.Two; &#125; else if (Input.GetKeyDown(KeyCode.Alpha3)) &#123; nowType = E_FireType.Three; &#125; else if (Input.GetKeyDown(KeyCode.Alpha4)) &#123; nowType = E_FireType.Round; &#125; //Update内添加按按键发射子弹逻辑 if (Input.GetKeyDown(KeyCode.Space)) &#123; Fire(); &#125; &#125; //开火方法 private void Fire() &#123; switch (nowType) &#123; case E_FireType.One: Instantiate(bullet, this.transform.position, this.transform.rotation); break; case E_FireType.Two: Instantiate(bullet, this.transform.position - this.transform.right * 0.5f, this.transform.rotation); Instantiate(bullet, this.transform.position + this.transform.right * 0.5f, this.transform.rotation); break; case E_FireType.Three: Instantiate(bullet, this.transform.position, this.transform.rotation); //左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加 Instantiate(bullet, this.transform.position, this.transform.rotation * Quaternion.AngleAxis(-20, Vector3.up)); //右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加 Instantiate(bullet, this.transform.position, this.transform.rotation * Quaternion.AngleAxis(20, Vector3.up)); break; case E_FireType.Round: float angle = 360 / roundNum; for (int i = 0; i &lt; roundNum; i++) //角度是当前偏移度数乘飞机自己的旋转 Instantiate(bullet, this.transform.position, this.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up)); break; &#125; &#125;&#125;#endregion 将此脚本制作成预制体，并拖到飞机的bullet 123456789101112131415//子弹一直往前飞，五秒后销毁public class Bullet : MonoBehaviour&#123; public float moveSpeed = 10; void Start() &#123; Destroy(this.gameObject, 5); &#125; void Update() &#123; this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); &#125;&#125; 摄像机跟随 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//这个脚本要挂载到摄像机上public class CameraMove : MonoBehaviour&#123; //目标对象 public Transform target; //相对头顶的偏移位置 看向头顶多高的位置 public float headOffsetH = 1; //摄像机倾斜的角度 public float offsetAngle = 45; //摄像机离观测点的距离 public float cameraDis = 5; //摄像机离观测点的距离必须是3和10之间 public float minDis = 3; public float maxDis = 10; //鼠标中间滚动控制的移动速度 public float roundSpeed = 1; //看向对象时 四元数 旋转的速度 public float lookAtSpeed = 2; //跟随对象移动的 速度 public float moveSpeed = 2; //当前摄像机应该在的位置 Vector3 nowPos; //头顶一个在的位置 Vector3 headPos; //头顶位置指向摄像机的方向向量 private Vector3 nowDir; void Update() &#123; //实现了鼠标中键 滚动 来改变摄像机远近 cameraDis += Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * roundSpeed; //取最大值和最小值之间的数 cameraDis = Mathf.Clamp(cameraDis, minDis, maxDis); //向头顶偏移位置 headPos = target.position + target.up * headOffsetH; //用要倾斜的角度和轴算出要旋转的四元数 乘上当前向后的向量 就能得到摄像机偏移角度后往后方偏移位置 //通俗理解 nowDir就是头顶位置指向摄像机的方向向量 nowDir = Quaternion.AngleAxis(offsetAngle, target.right) * -target.forward; //用头顶位置加上要偏移的角度乘摄像机离观测点的距离 就是当前摄像机应该在的位置 nowPos = headPos + nowDir * cameraDis; //直接把算出来的位置 进行赋值 //this.transform.position = nowPos; //通过插值运算缓慢移动相机位置 this.transform.position = Vector3.Lerp(this.transform.position, nowPos, Time.deltaTime * moveSpeed); //这里是通过插值运算来缓动看向物体 //摄像机要看的是nowDir的反向向量 所以通过LookRotation算出旋转成的四元数 传入当做插值函数的终点 this.transform.rotation = Quaternion.Slerp(this.transform.rotation, Quaternion.LookRotation(-nowDir), Time.deltaTime * lookAtSpeed); //画出头顶和摄像机的连线 Debug.DrawLine(this.transform.position, headPos); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"3.hexo插件","slug":"hexo/3.hexo插件","date":"2025-03-02T07:07:49.000Z","updated":"2025-03-02T07:36:58.437Z","comments":true,"path":"2025/03/02/hexo/3.hexo插件/","permalink":"http://example.com/2025/03/02/hexo/3.hexo%E6%8F%92%E4%BB%B6/","excerpt":"","text":"思维导图 安装 1npm install hexo-simple-mindmap 使用 使用 Hexo 的 pullquote 将思维导图的内容包裹起来，mindmap 是思维导图渲染的标志 尺寸有三种规格：mindmap-sm、mindmap-md 和 mindmap-lg。 12345678&#123;% pullquote mindmap mindmap-sm %&#125;- [在 Hexo 中使用思维导图](https://hunterx.xyz/use-mindmap-in-hexo.html) - 前言 - 操作指南 - 准备需要的文件 - 为主题添加 CSS/JS 文件 - 使用方法&#123;% endpullquote %&#125; 在 Hexo 中使用思维导图 前言 操作指南 准备需要的文件 为主题添加 CSS/JS 文件 使用方法","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"csharp拓展方法","slug":"编程语言/Csharp/csharp拓展方法","date":"2025-03-02T06:56:36.000Z","updated":"2025-03-02T07:42:37.657Z","comments":true,"path":"2025/03/02/编程语言/Csharp/csharp拓展方法/","permalink":"http://example.com/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/","excerpt":"","text":"拓展方法基本概念 C# 中的扩展方法是 C# 3.0 引入的一项特性，它允许开发者在不修改原始类或对象的情况下，向现有类添加新方法 作用 提升程序拓展性 不需要再对象中重新写方法 不需要继承来添加方法 为别人封装的类型写额外的方法 特点 一定是写在静态类中 一定是个静态函数 第一个参数为拓展目标 第一个参数用this修饰 基本语法 访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名,参数类型 参数名....) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static class Tools&#123; //为int拓展了一个成员方法 //成员方法 是需要 实例化对象后 才 能使用的 //value 代表 使用该方法的 实例化对象 public static void SpeakValue(this int value) &#123; //拓展的方法 的逻辑 Console.WriteLine(&quot;为int拓展的方法&quot; + value); &#125; public static void SpeakStringInfo(this string str, string str2, string str3) &#123; Console.WriteLine(&quot;为string拓展的方法&quot;); Console.WriteLine(&quot;调用方法的对象&quot; + str); Console.WriteLine(&quot;传的参数&quot; + str2 + str3); &#125; public static void Fun3(this Test t) &#123; Console.WriteLine(&quot;为test拓展的方法&quot;); &#125;&#125;// 为自定义的类型拓展方法class Test&#123; public int i = 10; public void Fun1() &#123; Console.WriteLine(&quot;123&quot;); &#125; public void Fun2() &#123; Console.WriteLine(&quot;456&quot;); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;拓展方法&quot;); int i = 10; i.SpeakValue(); string str = &quot;000&quot;; str.SpeakStringInfo(&quot;卧槽&quot;, &quot;nm&quot;); Test t = new Test(); t.Fun2(); &#125;&#125;//总结：//概念：为现有的非静态 变量类型 添加 方法//作用：// 提升程序拓展性// 不需要再在对象中重新写方法// 不需要继承来添加方法// 为别人封装的类型写额外的方法//特点：//静态类中的静态方法//第一个参数 代表拓展的目标//第一个参数前面一定要加 this//注意：//可以有返回值 和 n个参数//根据需求而定","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"7.Quaternion四元数常用方法","slug":"游戏引擎/unity/unity基础/7.Quaternion四元数常用方法","date":"2025-03-02T03:00:47.000Z","updated":"2025-03-02T09:06:50.413Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/7.Quaternion四元数常用方法/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"单位四元数 满足条件：x² + y² + z² + w² = 1 12345// 单位四元数 [1, (0, 0, 0)] Quaternion i = Quaternion.identity; //Object的Instantiate方法有重载 第三个参数可以传入四元数角度 Instantiate(testCube, Vector3.zero, Quaternion.identity); 插值运算 123456// 无限接近，先快后慢A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);// 匀速time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 向量指向转四元数LookRotation 12345678public Transform target;public float rotateSpeed = 2f;void Update() &#123; Vector3 dir = target.position - transform.position; Quaternion targetRot = Quaternion.LookRotation(dir); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime);&#125; 练习 为transform拓展方法实现LookAt 使用拓展方法 ，利用四元数的LookRotation方法，使transform实现LookAt的效果 1234567891011121314151617public static class Tools&#123; //自己写的看向目标的方法 public static void MyLookAt(this Transform obj, Transform target) &#123; //算出目标和自己的向量 Vector3 vec = target.position - obj.position; //用LookRotation得到转向的四元数赋值给自己 obj.transform.rotation = Quaternion.LookRotation(vec); &#125;&#125;void Update() &#123; //调用自己写的拓展方法看向B lookA.MyLookAt(lookB); &#125; 摄像机使用Slerp来缓慢看向玩家 1234567891011121314151617// 当发现目标对象位置改变时if (targetQ != Quaternion.LookRotation(target.position - this.transform.position))&#123; // 重新用目标的位置减去摄像机的位置计算出新的面朝向向量四元数 targetQ = Quaternion.LookRotation(target.position - this.transform.position); // 清空累加时间 不然时间一直大于1 会一直盯着目标看 不能达到匀速旋转看向目标的效果 roundTime = 0; // 重置摄像机开始旋转位置 startQ = this.transform.rotation;&#125;// 累加时间roundTime += Time.deltaTime;// 传入发现目标对象位置改变后定死的摄像机开始旋转位置，目标旋转位置，和累加的时间this.transform.rotation = Quaternion.Slerp(startQ, targetQ, roundTime * roundSpeed);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"6.Quaternion四元数概念","slug":"游戏引擎/unity/unity基础/6.Quaternion四元数概念","date":"2025-03-02T02:26:57.000Z","updated":"2025-03-02T09:05:07.383Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/6.Quaternion四元数概念/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/","excerpt":"","text":"四元数概念 数学定义 四元数由4个分量组成：x, y, z, w，数学表示为 q = xi + yj + zk + w 四元数构成 轴-角对 这里的n是3d向量 Unity中的四元数 Quaternion Unity中的四元数初始化方法 1234567//用四元数的计算原理 绕着(x,y,z)向量旋转β度(弧度)float timeAngle = Mathf.Sin(β / 2 * Mathf.Deg2Rad);Quaternion q = new Quaternion(timeAngle * x, timeAngle * y, timeAngle * z, Mathf.Cos(β / 2 * Mathf.Deg2Rad));//绕着(1,0,0)向量旋转60度 要传入弧度制 角度转弧度Quaternion q1 = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); 123//创建一个围绕 axis 旋转 offsetAngle 度的旋转。//提供的轴角对 初始化 四元数的方法 分别传入度数和向量轴Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right); 四元数和欧拉角相互转换 12345// 欧拉角 转 四元数Quaternion q = Quaternion.Euler(60, 0, 0);// 四元数 转 欧拉角print(q.eulerAngles);//(60.0, 0.0, 0.0) 弥补的欧拉角缺点 注意：四元数转换为欧拉角的范围始终是[-180°, 180°]之间 123//每一帧绕着y轴旋转1度 //四元数绕 y轴转 *****物体坐标系****** 旋转this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"5.Quaternion为什么要使用四元数","slug":"游戏引擎/unity/unity基础/5.Quaternion为什么要使用四元数","date":"2025-03-02T02:10:07.000Z","updated":"2025-03-02T03:01:30.593Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/5.Quaternion为什么要使用四元数/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/","excerpt":"","text":"在unity中将Rotation的x设置为90°，调整y和z都绕同一个轴旋转","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"4.Vector3向量","slug":"游戏引擎/unity/unity基础/4.Vector3向量","date":"2025-03-01T10:14:34.000Z","updated":"2025-03-02T03:01:40.668Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/4.Vector3向量/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/","excerpt":"","text":"Unity中的向量 向量常用的成员和方法 向量在数学和编程中有许多常用的成员和方法，常见的包括： 成员： x、y、z：向量的分量，表示向量在 x、y、z 方向上的值。 magnitude 或 length：向量的长度或模长，表示从原点到向量的终点的距离。 normalized：返回与当前向量方向相同但长度为1的单位向量。也可以 向量 /magnitude sqrMagnitude：向量长度的平方，用于比较向量长度时避免开方计算。 zero：零向量，所有分量均为0的向量。 方法： Vector3.Dot(Vector3 a, Vector3 b)：计算两个向量的点乘结果。返回弧度 Vector3.Cross(Vector3 a, Vector3 b)：计算两个向量的叉乘结果。 Vector3.Distance(Vector3 a, Vector3 b)：计算两个向量之间的距离。 Vector3.Lerp(Vector3 a, Vector3 b, float t)：在两个向量之间进行线性插值。 Vector3.Slerp(Vector3 a, Vector3 b, float t)：在两个向量之间进行球形插值 Vector3.Normalize(Vector3 value)：将向量转化为单位向量。 Vector3.Project(Vector3 vector, Vector3 onNormal)：将一个向量投影到另一个向量上。 Vector3.RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)：将一个向量从当前方向旋转到目标方向。 Vector3.Angle(Vector3 from, Vector3 to)：返回值float, 计算两个向量之间的角度值 例子eg: 利用 A⋅B=∣A∣∗∣B∣cosθA \\cdot B = |A| * |B| cos\\thetaA⋅B=∣A∣∗∣B∣cosθ 或者 Vector.Angle()(角度) 来计算θ\\thetaθ A⋅B&gt;=0A\\cdot B &gt;= 0A⋅B&gt;=0 前方 A×B&lt;0A \\times B &lt; 0A×B&lt;0 则A右B左 线性插值 (匀速) 向量的点积 12345678// Debug类中的DrawLine静态方法 画线段// 参数：前两个参数分别是起点和终点，最后一个参数是划线颜色。Debug.DrawLine(this.transform.position, this.transform.position + this.transform.forward, Color.red);// Debug类中的DrawRay静态方法 画射线// 参数：前两个参数分别是起点和方向，最后一个参数是划线颜色。Debug.DrawRay(this.transform.position, this.transform.up, Color.blue); 两个向量 a=(x1​,y1​) 和 b=(x2​,y2​) 的点积定义为 a⋅b=x1x2​+y1​y2​​，其结果是一个标量，且 a⋅b=∣a∣×∣b∣×cosθ，其中 θ 是 a 和 b 之间的夹角。 θ=Acos(单位向量a⋅单位向量b)\\theta = Acos(单位向量a \\cdot 单位向量b )θ=Acos(单位向量a⋅单位向量b) 点积可用于判断两个向量的前后关系 12345678Vector3 forward = transform.forward;Vector3 toEnemy = enemy.position - transform.position;float dotResult = Vector3.Dot(forward, toEnemy.normalized);// 值&gt;0表示敌人在前方，&lt;0表示在后方if(dotResult &gt; 0.5f) &#123; // 敌人位于前方60度范围内&#125; 向量的叉积 获取垂直向量（右手定则， 常用于计算旋转轴） 可以用叉乘来判断两个向量的左右关系 123456789Vector3 C = Vector3.Cross(A.position, B.position);if (C.y &gt; 0)&#123; Debug.Log(&quot;A在B的右侧&quot;);&#125;else&#123; Debug.Log(&quot;B在A的右侧&quot;);&#125; 向量插值运算 插值公式和Mathf的插值运算差不多 线性插值 先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置 123// 可以理解为t不变 每次往方向向量加的值(end - start)一直会变小A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); 匀速 每帧改变时间 当t&gt;=1时 得到结果 123456789101112131415161718192021// 可以理解为t每一帧累加相同值 start和(end - start)不变 所以是匀速运动// 这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 因为t&gt;=1时直接的得到结果public Transform target;private Vector3 startPos;private Vector3 tmpTarget;private float time = 0;void Update()&#123; // 每次终点移动变化, 重置时间, 起点 if (tmpTarget != target.position) &#123; tmpTarget = target.position; time = 0; startPos = transform.position; &#125; time += Time.deltaTime; transform.position = Vector3.Lerp(startPos, target.position, time); 球形插值 从（10， 0， 0） 到 （0， 0， 10） 12time += Time.deltaTime;A.position = Vector3.Slerp(Vector3.right * 10, Vector3.forward * 10, time); 练习 用向量相关知识，实现摄像机跟随 摄像机代码写在LateUpdate中 如果在Update中更新摄像机的位置，可能会出现摄像机位置更新早于目标对象位置更新的情况，导致摄像机出现抖动或延迟跟随的问题。 而在LateUpdate中更新摄像机位置，可以确保在目标对象位置更新完成后再进行摄像机的移动，从而实现平滑的跟随效果。 1234567891011121314151617public float zOffect = 4;public float yOffect = 7;public Transform target;void LateUpdate()&#123; // 摄像机的位置等于目标的位置进行向量偏移 // 先朝目标对象的面朝向的反方向平移4米再朝目标的头顶位置平移7米 // 设置摄像机位置 this.transform.position = target.position - target.forward * zOffect + target.up * yOffect; // 看向目标 this.transform.LookAt(target);&#125; 发现入侵者 当一个物体B在物体A前方45度角范围内，并且离A只有5米距离时，在控制台打印“发现入侵者” 12345678910111213141516171819// 手动算if (Vector3.Distance(this.transform.position, B.transform.position) &lt;= 5)&#123; // 第一步：算出点乘结果（方向向量） float dotResult = Vector3.Dot(this.transform.forward, (B.transform.position - this.transform.position).normalized); // 第二步：通过反余弦函数算出夹角 if (Mathf.Acos(dotResult) * Mathf.Rad2Deg &lt;= 22.5f) &#123; print(&quot;手动算角度 发现入侵者&quot;); &#125;&#125;// Angle直接算角度if (Vector3.Distance(this.transform.position, B.transform.position) &lt;= 5 &amp;&amp; Vector3.Angle(this.transform.forward, B.transform.position - this.transform.position) &lt;= 22.5f)&#123; print(&quot;Angle直接算角度 发现入侵者&quot;);&#125; 左上，左下 ，右上，右下哪个方位? 判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class VectorPositionDetector : MonoBehaviour&#123; public Transform objectA; public Transform objectB; [Header(&quot;阈值&quot;)] public float angleThreshold = 45f; // 方向识别角度范围 void Update() &#123; // 获取A到B的水平方向向量 Vector3 aToB = objectB.position - objectA.position; aToB.y = 0; // 忽略垂直分量 // 获取A的基准方向向量（已水平化） Vector3 aForward = objectA.forward; aForward.y = 0; Vector3 aRight = objectA.right; aRight.y = 0; // 计算方向点积（自动处理向量长度） float forwardDot = Vector3.Dot(aToB.normalized, aForward.normalized); float rightDot = Vector3.Dot(aToB.normalized, aRight.normalized); // 精确角度计算版本 float angle = Vector3.Angle(aForward, aToB); // 基本方位判断 bool isFront = forwardDot &gt; 0; bool isBack = forwardDot &lt; 0; bool isRight = rightDot &gt; 0; bool isLeft = rightDot &lt; 0; // 精确方位判断（45度扇形区） bool inFrontSector = angle &lt;= angleThreshold; bool inRightSector = Vector3.Angle(aRight, aToB) &lt;= angleThreshold; Debug.Log($&quot;前方: &#123;isFront&#125; | 后方: &#123;isBack&#125;\\n&quot; + $&quot;右侧: &#123;isRight&#125; | 左侧: &#123;isLeft&#125;\\n&quot; + $&quot;前扇形区: &#123;inFrontSector&#125; | 右扇形区: &#123;inRightSector&#125;&quot;); // 计算八个方向识别 bool isFrontRight = forwardDot &gt; 0 &amp;&amp; rightDot &gt; 0; bool isFrontLeft = forwardDot &gt; 0 &amp;&amp; rightDot &lt; 0; // 距离综合判断 float distance = aToB.magnitude; bool inRange = distance &lt; 5f; // 5米范围内 // 运动方向预测（需记录上一帧位置） Vector3 velocity = (objectB.position - lastPosition) / Time.deltaTime; lastPosition = objectB.position; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System.Collections;using System.Collections.Generic;using UnityEngine;public class Lesson08_练习题 : MonoBehaviour&#123; //拖拽得到AB位置变量 public Transform A; public Transform B; //点乘接过和叉乘结果变量 private float dotResult; private Vector3 crossResult; void Update() &#123; #region 练习题一 //判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位 //计算 A位置向量和AB方向差向量 点乘和叉乘结果 dotResult = Vector3.Dot(A.forward, B.position - A.position); crossResult = Vector3.Cross(A.forward, B.position - A.position); //根据点乘和叉乘的值判断前后左右 if (dotResult &gt;= 0) &#123; //右侧 if (crossResult.y &gt;= 0) &#123; print(&quot;右前&quot;); &#125; //左侧 else &#123; print(&quot;左前&quot;); &#125; &#125; else &#123; //右侧 if (crossResult.y &gt;= 0) &#123; print(&quot;右后&quot;); &#125; //左侧 else &#123; print(&quot;左后&quot;); &#125; &#125; // 练习题二 //当一个物体B在物体A左前方20度角或右前方30度范围内，并且离A只有5米距离时，在控制台打印“发现入侵者” //计算叉乘 用于判断左边还是右边 crossResult = Vector3.Cross(A.forward, B.position - A.position); //判断距离 if (Vector3.Distance(A.position, B.position) &lt;= 5) &#123; //A左前方20度角或右前方30度范围内 if (crossResult.y &gt;= 0 &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= 30 || crossResult.y &lt; 0 &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= 20) &#123; print(&quot;发现入侵者&quot;); &#125; &#125; &#125;&#125; 插值实现摄像机跟随 123456789// 如果当前摄像机的目标位置不是目标对象的后方4米，向上偏7米 就设置目标位置 记录摄像机当前开始位置 重置时间if (cameraTargetPos != target.position + -target.forward * zOffect + target.up * yOffect)&#123; cameraTargetPos = target.position + -target.forward * zOffect + target.up * yOffect; startPos = this.transform.position; time = 0;&#125;time += Time.deltaTime;this.transform.position = Vector3.Lerp(startPos, cameraTargetPos, time * moveSpeed); 球形插值模拟太阳轨迹 123456private void Update()&#123; time2 += Time.deltaTime; // sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10, time2 * 0.1f);//假如直接写最终值会不知道从哪里转 可能会平这转 sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up * 0.1f, time2 * 0.1f);//要给最终值加一点向上的向量 才会往上转&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"3.坐标系","slug":"游戏引擎/unity/unity基础/3.坐标系","date":"2025-03-01T07:57:07.000Z","updated":"2025-03-02T03:01:44.817Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/3.坐标系/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/","excerpt":"","text":"世界坐标系 this.transform.position-返回物体在世界坐标系中的位置 this.transform.rotation-返回物体在世界坐标系中的旋转四元数 this.transform.eulerAngles-返回物体在世界坐标系中的欧拉角 this.transform.lossyScale-返回物体在世界坐标系中的缩放 修改它们将导致相对于世界坐标系的变化 物体坐标系 this.transform.localPosition-返回物体在其父对象坐标系中的位置 this.transform.localEulerAngles-返回物体在其父对象坐标系中的旋转四元数 this.transform.localRotation-返回物体在其父对象坐标系中的欧拉角 this.transform.localScale-返回物体在其父对象坐标系中的缩放 修改它们将导致相对于父对象物体坐标系的变化 屏幕坐标系 Input.mousePosition-返回鼠标在屏幕坐标系中的位置 Screen.width-返回屏幕坐标系的宽度 Screen.height-返回屏幕坐标系的高度 currentResolution当前屏幕的分辨率为 视口坐标系 坐标转换 点与向量在本地与世界之间的来回转换 世界转本地 this.transform.InverseTransformDirection 将世界空间中的方向向量转换为本地空间中的方向向量。 12Vector3 worldDirection = new Vector3(1, 0, 0);Vector3 localDirection = this.transform.InverseTransformDirection(worldDirection); // (不受缩放影响 this.transform.InverseTransformPoint 将世界空间中的点转换为本地空间中的点。 12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 localPoint = this.transform.InverseTransformPoint(worldPoint); this.transform.InverseTransformVector 将世界空间中的向量转换为本地空间中的向量。 12Vector3 worldVector = new Vector3(2, 1, 0);Vector3 localVector = this.transform.InverseTransformVector(worldVector); // (受缩放影响 本地转世界 this.transform.TransformDirection 将本地空间中的方向向量转换为世界空间中的方向向量。 12Vector3 localDirection = new Vector3(0, 1, 0);Vector3 worldDirection = this.transform.TransformDirection(localDirection);// (不受缩放影响 this.transform.TransformPoint 将本地空间中的点转换为世界空间中的点。 12Vector3 localPoint = new Vector3(2, 3, 1);Vector3 worldPoint = this.transform.TransformPoint(localPoint); this.transform.TransformVector 将本地空间中的向量转换为世界空间中的向量。 12Vector3 localVector = new Vector3(1, 0, 0);Vector3 worldVector = this.transform.TransformVector(localVector); // (受缩放影响 世界转屏幕 Camera.main.WorldToScreenPoint 将世界空间中的点转换为屏幕空间中的点。 12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 screenPoint = Camera.main.WorldToScreenPoint(worldPoint); 屏幕转世界 Camera.main.ScreenToWorldPoint 将屏幕空间中的点转换为世界空间中的点。 12Vector3 screenPoint = new Vector3(100, 200, 0);Vector3 worldPoint = Camera.main.ScreenToWorldPoint(screenPoint); 世界转视口 Camera.main.WorldToViewportPoint 将世界空间中的点转换为视口空间中的点。 12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 viewportPoint = Camera.main.WorldToViewportPoint(worldPoint); 视口转世界 Camera.main.ViewportToWorldPoint 将视口空间中的点转换为世界空间中的点。 12Vector3 viewportPoint = new Vector3(0.5f, 0.5f, 0);Vector3 worldPoint = Camera.main.ViewportToWorldPoint(viewportPoint); 视口转屏幕 Camera.main.ViewportToScreenPoint 将视口空间中的点转换为屏幕空间中的点。 12Vector3 viewportPoint = new Vector3(0.5f, 0.5f, 0);Vector3 screenPoint = Camera.main.ViewportToScreenPoint(viewportPoint); 屏幕转视口 Camera.main.ScreenToViewportPoint 将屏幕空间中的点转换为视口空间中的点。 12Vector3 screenPoint = new Vector3(100, 200, 0);Vector3 viewportPoint = Camera.main.ScreenToViewportPoint(screenPoint);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"2.Mathf数学计算结构体常用方法","slug":"游戏引擎/unity/unity基础/2.Mathf数学计算结构体常用方法","date":"2025-03-01T06:51:42.000Z","updated":"2025-03-02T03:01:47.531Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/2.Mathf数学计算结构体常用方法/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Mathf和Math Math是C#中封装好的用于数学计算的工具类，位于System命名空间中。 Mathf是Unity中封装好的用于数学计算的工具结构体，位于UnityEngine命名空间中。 他们都是提供来用于进行数学相关计算的。 Mathf和Math的区别 Mathf 和 Math中的相关方法几乎一样。 Math - C#自带数学库，提供基本的数学计算方法。 Mathf - Unity专门针对游戏开发增强的数学库，包含了Math中的方法，并添加了一些适用于游戏开发的方法。 Mathf中的常用方法 PI常量 获取圆周率π 12// 众所周知的“3.14159265358979...”值（只读）。print(Mathf.PI);//3.141593 Abs静态方法 取绝对值 1234// 返回 f 的绝对值。print(Mathf.Abs(-10));//10print(Mathf.Abs(-20));//20print(Mathf.Abs(1));//1 CeilToInt静态方法 向上取整 123456// 返回大于或等于 f 的最小整数。float f = 1.3f;int i = (int)f;print(i);//1print(Mathf.CeilToInt(f));//2print(Mathf.CeilToInt(1.00001f));//2 FloorToInt静态方法 向下取整 12// 返回小于或等于 f 的最大整数。print(Mathf.FloorToInt(9.6f));//9 Clamp静态方法 钳制函数 12345// 在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值。// 比最小还小，就取最小，比最大还大，就取最大，两者之间，就取本身print(Mathf.Clamp(10, 11, 20));//11print(Mathf.Clamp(21, 11, 20));//20print(Mathf.Clamp(15, 11, 20));//15 Max静态方法 获取最大值 1234// 返回两个或更多值中的最大值。// 内部有一个可变长的参数print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8));//8print(Mathf.Max(1, 2));//2 Min静态方法 获取最小值 1234// 返回两个或更多值中的最小值。// 内部有一个可变长的参数print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));//1print(Mathf.Min(1.1f, 0.4f));//0.4 Pow静态方法 一个数的n次幂 123// 返回 f 的 p 次幂。print(&quot;一个数的n次方&quot; + Mathf.Pow(4, 2));//16print(&quot;一个数的n次方&quot; + Mathf.Pow(2, 3));//8 RoundToInt静态方法 四舍五入 123// 返回舍入为最近整数的 / f /。print(&quot;四舍五入&quot; + Mathf.RoundToInt(1.3f));//1print(&quot;四舍五入&quot; + Mathf.RoundToInt(1.5f));//2 Sqrt静态方法 返回一个数的平方根 1234// 返回 f 的平方根。print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(4));//2print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(16));//4print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(64));//8 IsPowerOfTwo静态方法 判断一个数是否是2的n次方 12345// 如果值是 2 的幂，则返回 true。print(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(4));//trueprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(8));//trueprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(3));//falseprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(1));//true Sign静态方法 判断正负数 1234567// 返回 f 的符号。// 正数和0就返回1，负数就返回-1print(&quot;判断正负数&quot; + Mathf.Sign(0));//1print(&quot;判断正负数&quot; + Mathf.Sign(10));//1print(&quot;判断正负数&quot; + Mathf.Sign(-10));//-1print(&quot;判断正负数&quot; + Mathf.Sign(3));//1print(&quot;判断正负数&quot; + Mathf.Sign(-2));//-1 插值运算 Lerp : result = Mathf.Lerp(start, end, t); t为插值系数 取值范围[0, 1] result = start + (end - start) * t; 123456789101112// t不变，起点不断变化// 用法1 先快后慢, 无限趋近10float start = 1;start = Mathf.Lerp(start, 10, Time.deltaTime);// 起点不变，时间t匀速变化// 用法2 匀速变化float start = 1; float time = 0, result = 0;time += Time.deltaTime;result = Mathf.Lerp(start, 10, time); Rad2Deg常量 弧度转角度的常量 1234// 弧度到度换算常量（只读）。float rad = 1;float anger = rad * Mathf.Rad2Deg;print(anger);//57.29578f; Deg2Rad常量 角度转弧度的常量 1234// 度到弧度换算常量（只读）。anger = 1;rad = anger * Mathf.Deg2Rad;print(rad);//0.01745329 Unity中的三角函数 注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 Sin静态方法 计算正弦函数 12// 返回角度 f 的正弦。print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 Cos静态方法 计算余弦函数 12// 返回角度 f 的余弦。print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 Asin静态方法 反正弦函数 123// 返回 f 的反正弦 - 其正弦为 f 的角度（以弧度为单位）。rad = Mathf.Asin(0.5f);print(rad * Mathf.Rad2Deg);//30 Acos静态方法 反余弦函数 123// 返回 f 的反余弦 - 其余弦为 f 的角度（以弧度为单位）。rad = Mathf.Acos(0.5f);print(rad * Mathf.Rad2Deg);//60 练习 使用插值实现一个方块跟随另一个方块移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这个脚本将要挂载到方块A上 实现方块A跟随着方块Bpublic class Lesson02_练习题 : MonoBehaviour&#123; //要跟随的对象B public Transform B; //移动速度 public float moveSpeed; //位置中介 private Vector3 pos; //B当前的位置 private Vector3 bNowPos; //开始位置 private Vector3 startPos; //匀速运动累加的时间 private float time; //模式 public int mode = 1; void Update() &#123; if(mode == 1) &#123; //第一种 就是 先快后慢的形式 //记录当前这一帧A的位置 pos = this.transform.position; //传入这一帧A的位置算出下一帧A的位置 pos.x = Mathf.Lerp(pos.x, B.position.x, Time.deltaTime * moveSpeed); pos.y = Mathf.Lerp(pos.y, B.position.y, Time.deltaTime * moveSpeed); pos.z = Mathf.Lerp(pos.z, B.position.z, Time.deltaTime * moveSpeed); //算出下一帧A的位置赋值给A this.transform.position = pos; &#125; else if(mode == 2) &#123; //第二种 就是 匀速运动 //发现存储的B的位置不等于当前B的位置 if (bNowPos != B.transform.position) &#123; //清空时间 重写设置B的位置 开始位置是A当前的位置 time = 0; bNowPos = B.transform.position; startPos = this.transform.position; &#125; //时间每一帧运算累加 time += Time.deltaTime; //startPos和bNowPos其实定死了 只有time在变化 传入算出下一帧A的位置 pos.x = Mathf.Lerp(startPos.x, bNowPos.x, time * moveSpeed); pos.y = Mathf.Lerp(startPos.y, bNowPos.y, time * moveSpeed); pos.z = Mathf.Lerp(startPos.z, bNowPos.z, time * moveSpeed); //算出下一帧A的位置赋值给A this.transform.position = pos; &#125; &#125; private void OnGUI() &#123; if(GUI.Button(new Rect(0, 0, 200, 200), &quot;切换模式&quot;)) &#123; mode = 3 - mode; &#125; &#125;&#125; 实现一个物体按照曲线移动（正弦或余弦） 1234567891011121314151617181920public class MathfTest : MonoBehaviour&#123; // 向前移动速度 public float moveSpeed = 5; // 振幅 public float changeSize = 10; // 频率 public float changeSpeed = 5; // 时间 public float time = 0; private void Update() &#123; this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); time += Time.deltaTime; this.transform.Translate(Vector3.right * Mathf.Sin(time * changeSpeed) * changeSize * Time.deltaTime); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"1.unity基础概述","slug":"游戏引擎/unity/unity基础/1.unity基础概述","date":"2025-03-01T06:43:09.000Z","updated":"2025-03-01T06:47:12.464Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/1.unity基础概述/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"4.模型自资源的导入","slug":"游戏引擎/unity/unity入门/unity入门实践项目/4.模型自资源的导入","date":"2025-03-01T06:37:18.000Z","updated":"2025-03-01T06:40:34.472Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity入门/unity入门实践项目/4.模型自资源的导入/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"泛型委托和泛型接口の协变和逆变","slug":"编程语言/Csharp/泛型委托和泛型接口の协变和逆变","date":"2025-03-01T02:26:27.000Z","updated":"2025-03-01T06:36:44.841Z","comments":true,"path":"2025/03/01/编程语言/Csharp/泛型委托和泛型接口の协变和逆变/","permalink":"http://example.com/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/","excerpt":"","text":"逆变与协变详解 - zhangweiwen - 博客园 (cnblogs.com) 协变和逆变是用来修饰泛型类型参数T的 协变：out 表明修饰的T只能作为返回值来使用 逆变：in 表明修饰的T只能作为参数来使j用 只有泛型接口和泛型委托能使用 协变（Foo&lt;父类&gt; = Foo&lt;子类&gt; ） 典型场景：生产者（输出数据），如返回值、只读集合。 12345678910111213141516171819202122232425262728293031//泛型委托：public delegate T MyFuncA&lt;T&gt;();//不支持逆变与协变public delegate T MyFuncB&lt;out T&gt;();//支持协变 MyFuncA&lt;object&gt; funcAObject = null;MyFuncA&lt;string&gt; funcAString = null;MyFuncB&lt;object&gt; funcBObject = null;MyFuncB&lt;string&gt; funcBString = null;MyFuncB&lt;int&gt; funcBInt = null; funcAObject = funcAString;//编译失败，MyFuncA不支持逆变与协变funcBObject = funcBString;//变了，协变funcBObject = funcBInt;//编译失败，值类型不参与协变或逆变 //泛型接口public interface IFlyA&lt;T&gt; &#123; &#125;//不支持逆变与协变public interface IFlyB&lt;out T&gt; &#123; &#125;//支持协变 IFlyA&lt;object&gt; flyAObject = null;IFlyA&lt;string&gt; flyAString = null;IFlyB&lt;object&gt; flyBObject = null;IFlyB&lt;string&gt; flyBString = null;IFlyB&lt;int&gt; flyBInt = null; flyAObject = flyAString;//编译失败，IFlyA不支持逆变与协变flyBObject = flyBString;//变了，协变flyBObject = flyBInt;//编译失败，值类型不参与协变或逆变 //数组：string[] strings = new string[] &#123; &quot;string&quot; &#125;;object[] objects = strings; 逆变（Foo&lt;子类&gt; = Foo&lt;父类&gt;） 典型场景：消费者（输入数据），如函数参数、写入操作。 12345678910111213141516171819public delegate void MyActionA&lt;T&gt;(T param);//不支持逆变与协变public delegate void MyActionB&lt;in T&gt;(T param);//支持逆变 public interface IPlayA&lt;T&gt; &#123; &#125;//不支持逆变与协变public interface IPlayB&lt;in T&gt; &#123; &#125;//支持逆变 MyActionA&lt;object&gt; actionAObject = null;MyActionA&lt;string&gt; actionAString = null;MyActionB&lt;object&gt; actionBObject = null;MyActionB&lt;string&gt; actionBString = null;actionAString = actionAObject;//MyActionA不支持逆变与协变,编译失败actionBString = actionBObject;//变了，逆变 IPlayA&lt;object&gt; playAObject = null;IPlayA&lt;string&gt; playAString = null;IPlayB&lt;object&gt; playBObject = null;IPlayB&lt;string&gt; playBString = null;playAString = playAObject;//IPlayA不支持逆变与协变,编译失败playBString = playBObject;//变了，逆变 注意: 当前仅支持接口和委托的逆变与协变 ，不支持类和方法。但数组也有协变性。 值类型不参与逆变与协变。 12345678910public interface Base&lt;T&gt;&#123; T Test(T param);&#125;public class Sub&lt;T&gt; : Base&lt;T&gt;&#123; public T Test(T param) &#123; return default(T); &#125;&#125;Base&lt;string&gt; b = new Sub&lt;string&gt;();b.Test(&quot;你好&quot;); 在上面的例子中，b里面的实例是Sub&lt;string&gt; b.Test(&quot;你好&quot;)会把参数 “你好” 传入到Sub里面执行方法 即调用父类的方法，其实实际是调用子类的方法。 可以看到，这个方法能够安全的调用，需要两个条件： 变式（父）的方法参数能安全转为原式（子）的参数； 原式（子）的返回值能安全的转为变式的返回值。 1234Base&lt;object&gt; BaseObject = null;Base&lt;string&gt; BaseString = null;BaseObject = BaseString;//编译失败BaseObject.Test(&quot;&quot;); 这里的“实际流程”如下，可以看到，参数那里是object是不能安全转换为string，所以编译失败： 看到这里如果都明白的话，我们不难得到逆变与协变的”实际流程图”（记住，它们是有in/out限制的）: 稍微难一点的问题 下面哪个正确？ 12345678910111213public interface IBar&lt;in T&gt; &#123; &#125;//应该是inpublic interface IFoo&lt;in T&gt;&#123; void Test(IBar&lt;T&gt; bar);&#125;//还是outpublic interface IFoo&lt;out T&gt;&#123; void Test(IBar&lt;T&gt; bar);&#125; 答案是，如果是in的话，会编译失败，out才正确（当然不要泛型修饰符也能通过编译，但IFoo就没有协变能力了）。 这里的意思就是说，一个有协变（逆变）能力的泛型（IBar），作为另一个泛型（IFoo）的参数时，影响到了它（IFoo）的泛型的定义。乍一看以为是in的其中一个陷阱是T是在Test方法的参数里的，所以以为是in。但这里Test的参数根本不是T，而是IBar&lt;T&gt;。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp事件","slug":"编程语言/Csharp/csharp事件","date":"2025-02-28T11:31:10.000Z","updated":"2025-03-01T03:26:04.293Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp事件/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"什么是事件？ 事件的核心是：当某件事发生时，自动通知所有关心它的人。 在 C# 中，事件是一种机制，允许一个对象（发布者）在特定动作发生时，通知其他对象（订阅者）执行某些代码。 事件的核心三要素 发布者（Publisher）：定义事件并触发它 订阅者（Subscriber）：注册事件处理方法 事件处理方法（Handler）：当事件发生时执行的代码 游戏开发高频场景 场景 事件用法 代码灵魂示例 角色受伤 触发UI血条更新、音效、伤害数字 player.OnHurt += UpdateHealthBar; 敌人死亡 触发掉落物品、任务进度更新、成就解锁 enemy.OnDeath += DropLoot; 技能释放 触发特效、冷却计时、连击计数 skill.OnCast += PlayVFX; 游戏状态切换 暂停/继续、关卡加载完成、游戏结束 GameManager.OnPause += FreezeEnemies; UI交互 按钮点击、菜单打开/关闭、道具拖动 button.OnClick += OpenInventory; 代码示例 角色受伤触发UI血条更新、音效、伤害数字 第一步：定义事件参数类（传递伤害值） 为什么事件参数要继承 EventArgs？ 这是一个约定，保持代码统一性。 如果需要传递数据，推荐使用自定义的 EventArgs 子类。 EventArgs 作用： 通过自定义参数类，把伤害值传递给所有监听者，避免每个系统单独查询角色状态 123456789public class DamageEventArgs : EventArgs&#123; public int Damage &#123; get; &#125; // 需要传递的伤害值 public DamageEventArgs(int damage) &#123; Damage = damage; &#125;&#125; 第二步：创建角色类（事件发布者） EventHandler&lt;T&gt; 委托 是 .NET 内置的泛型委托，无需自己定义。 签名：void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e)。 sender：触发事件的对象（通常是发布者自己）。 e：事件参数（传递额外数据）。 事件名称以 On 开头（如 OnClick）。 1234567891011121314151617public class Character&#123; // 声明事件（使用自定义的EventArgs） public event EventHandler&lt;DamageEventArgs&gt; Damaged; public void TakeDamage(int damage) &#123; // 触发事件的通用写法 OnDamaged(new DamageEventArgs(damage)); &#125; // 触发事件 protected virtual void OnDamaged(DamageEventArgs e) &#123; Damaged?.Invoke(this, e); &#125;&#125; 第三步：创建各种事件订阅者 12345678910111213141516171819202122232425262728293031323334353637// UI血条控制器public class UIHealthBar&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 更新血条 public void OnCharacterDamaged(object sender, DamageEventArgs e) &#123; UpdateHealthBar(e.Damage); Debug.Log($&quot;血条更新：减少&#123;e.Damage&#125;HP&quot;); &#125; private void UpdateHealthBar(int damage) &#123; /* 实际血条逻辑 */ &#125;&#125;// 音效系统public class SoundSystem&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 播放受伤音效 public void PlayHurtSound(object sender, DamageEventArgs e) &#123; Audio.Play(&quot;受伤音效&quot;); Debug.Log(&quot;播放受伤音效&quot;); &#125;&#125;// 伤害数字系统public class DamageNumbers&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 显示上海数字 public void ShowDamagePopup(object sender, DamageEventArgs e) &#123; CreateFloatingText(e.Damage); Debug.Log($&quot;显示伤害数字：&#123;e.Damage&#125;&quot;); &#125; private void CreateFloatingText(int damage) &#123; /* 数字弹窗逻辑 */ &#125;&#125; 第四步：连接事件订阅 12345678910// 初始化所有对象Character player = new Character();UIHealthBar ui = new UIHealthBar();SoundSystem sound = new SoundSystem();DamageNumbers numbers = new DamageNumbers();// 订阅事件（+= 添加监听）player.Damaged += ui.OnCharacterDamaged;player.Damaged += sound.PlayHurtSound;player.Damaged += numbers.ShowDamagePopup; 第五步：触发事件 1234567// 当玩家受到伤害时player.TakeDamage(50);// 输出结果：// 血条更新：减少50HP// 播放受伤音效// 显示伤害数字：50 事件与委托的区别 特性 委托（Delegate） 事件（Event） 访问权限 可直接调用或赋值（=） 只能在类内部触发（Invoke） 多播（Multicast） 支持（+=/-=） 支持（本质是委托的封装） 封装性 低（外部可任意修改委托链） 高（外部只能订阅/取消订阅） 典型用途 通用回调机制 发布-订阅模式的通知机制","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp表达式体","slug":"编程语言/Csharp/csharp表达式体","date":"2025-02-28T10:17:19.000Z","updated":"2025-02-28T10:32:37.134Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp表达式体/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93/","excerpt":"","text":"表达式体（Expression-bodied members）是 C# 6.0 及更高版本引入的特性，它允许用简洁的 =&gt; 语法替代传统代码块，适用于方法、属性、构造函数等成员。 注意： csharp的Lambda表达式（核心是创建匿名函数） 表达式体成员（核心是简写方法体） 综合示例 123456789101112131415161718public class Calculator &#123; // 只读属性 public string Model =&gt; &quot;Scientific-Calculator-3000&quot;; // 方法 public double Square(double x) =&gt; x * x; // 索引器 private double[] _history = new double[10]; public double this[int index] =&gt; _history[index]; // 构造函数 public Calculator(string model) =&gt; Model = model; // 运算符重载 public static Calculator operator +(Calculator a, Calculator b) =&gt; new Calculator($&quot;&#123;a.Model&#125;+&#123;b.Model&#125;&quot;);&#125; 方法（Methods） 用 =&gt; 替代 &#123;&#125;，适用于单行返回值的方法。 1234567// 传统写法public int Add(int a, int b) &#123; return a + b;&#125;// 表达式体写法public int Add(int a, int b) =&gt; a + b; 只读属性（Read-Only Properties） 直接返回计算结果的属性（仅有 get 访问器）。 1234567// 传统写法public string FullName &#123; get &#123; return $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; &#125;&#125;// 表达式体写法public string FullName =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; 构造函数/析构函数（C# 7.0+） 单行初始化或清理逻辑。 12345678910// 构造函数public class Person &#123; public string Name &#123; get; &#125; public Person(string name) =&gt; Name = name; // 初始化&#125;// 析构函数public class Resource &#123; ~Resource() =&gt; Console.WriteLine(&quot;资源已释放&quot;); // 清理逻辑&#125; 索引器（Indexers） 简化索引器的 get 访问器。 123456789private string[] _data = new string[10];// 传统写法public string this[int index] &#123; get &#123; return _data[index]; &#125;&#125;// 表达式体写法public string this[int index] =&gt; _data[index]; 属性访问器（C# 7.0+） 对 get 和 set 访问器分别使用表达式体。 12345678910111213private string _name;// 传统写法public string Name &#123; get &#123; return _name; &#125; set &#123; _name = value; &#125;&#125;// 表达式体写法public string Name &#123; get =&gt; _name; set =&gt; _name = value ?? throw new ArgumentNullException();&#125; 事件访问器（C# 7.0+） 简化事件的 add 和 remove 逻辑。 12345678910111213private EventHandler _myEvent;// 传统写法public event EventHandler MyEvent &#123; add &#123; _myEvent += value; &#125; remove &#123; _myEvent -= value; &#125;&#125;// 表达式体写法public event EventHandler MyEvent &#123; add =&gt; _myEvent += value; remove =&gt; _myEvent -= value;&#125; 运算符重载（Operator Overloading） 简化运算符的实现。 1234567891011121314public class Vector &#123; public int X &#123; get; &#125; public int Y &#123; get; &#125; public Vector(int x, int y) =&gt; (X, Y) = (x, y); // 传统运算符重载 public static Vector operator +(Vector a, Vector b) &#123; return new Vector(a.X + b.X, a.Y + b.Y); &#125; // 表达式体写法 public static Vector operator +(Vector a, Vector b) =&gt; new(a.X + b.X, a.Y + b.Y);&#125; throw 表达式（C# 7.0+） 直接在表达式中抛出异常。 1234567891011// 参数校验public string GetName(string input) =&gt; input ?? throw new ArgumentNullException(nameof(input));// 替代传统写法：public string GetName(string input) &#123; if (input == null) &#123; throw new ArgumentNullException(nameof(input)); &#125; return input;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp的Lambda表达式","slug":"编程语言/Csharp/csharp的Lambda表达式","date":"2025-02-28T02:38:33.000Z","updated":"2025-02-28T10:33:14.120Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp的Lambda表达式/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"在C#中，Lambda表达式是一种简洁的匿名函数，用于创建委托或表达式树类型。 Lambda表达式的基本形式 Lambda表达式分为两种形式： 表达式Lambda 仅包含单个表达式，无需大括号，自动返回结果。 1234(参数列表) =&gt; 表达式Func&lt;int, int&gt; square = x =&gt; x * x;Console.WriteLine(square(5)); // 输出 25 语句块Lambda 包含多行语句，需用大括号包裹，显式使用return（若有返回值）。 12345678910(参数列表) =&gt; &#123; 语句块; return 结果; &#125;Action&lt;string&gt; greet = name =&gt; &#123; string message = $&quot;Hello, &#123;name&#125;!&quot;; Console.WriteLine(message);&#125;;greet(&quot;Alice&quot;); // 输出 &quot;Hello, Alice!&quot; Lambda表达式的简写 注意和csharp表达式体的区别 简化1：自动类型推断 当委托类型明确时，参数类型可省略： (int x) =&gt; ... → x =&gt; ... 123Func&lt;int, int&gt; doubler = (x) =&gt; &#123; return x * 2; &#125;; 简化2：单参数可省略括号 若只有一个参数，()可省略： (x) =&gt; ... → x =&gt; ... 123Func&lt;int, int&gt; doubler = x =&gt; &#123; return x * 2; &#125;; 简化3：单行表达式自动返回 若主体是单行表达式，可省略&#123;&#125;和return： x =&gt; &#123; return x*2; &#125; → x =&gt; x*2 1Func&lt;int, int&gt; doubler = x =&gt; x * 2; 注意事项 12345678910111213// 多参数必须保留括号：Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b; // 正确Func&lt;int, int, int&gt; add = a, b =&gt; a + b; // 错误！ // 无参数时需空括号:Action printHello = () =&gt; Console.WriteLine(&quot;Hello&quot;);// 复杂逻辑仍需代码块：Action log = () =&gt; &#123; Console.WriteLine(&quot;Start&quot;); // 多行逻辑 Console.WriteLine(&quot;End&quot;);&#125;; Lambda的常见用途 委托实例化 和 事件处理 123Func&lt;int, int, int&gt; sum = (a, b) =&gt; a + b;Action&lt;string&gt; log = msg =&gt; Console.WriteLine(msg);button.Click += (sender, e) =&gt; MessageBox.Show(&quot;Clicked!&quot;); LINQ查询 与LINQ方法结合，实现数据筛选、转换等操作： 123var numbers = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5 &#125;;var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); // 筛选偶数var squares = numbers.Select(x =&gt; x * x); // 计算平方 表达式树（Expression Trees） 将Lambda编译为表达式树，供其他框架（如EF Core）解析： 1Expression&lt;Func&lt;int, bool&gt;&gt; expr = x =&gt; x &gt; 5; 闭包与变量捕获 当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。 示例 1：基本闭包 123456789Func&lt;int&gt; CreateCounter()&#123; int count = 0; return () =&gt; ++count; // 闭包捕获了外部变量 count&#125;var counter = CreateCounter();Console.WriteLine(counter()); // 输出 1Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态） 现象：count 本应在 CreateCounter 方法执行完毕后被销毁，但闭包保留了它的状态。 原理：编译器生成一个类，将 count 作为该类的字段存储，闭包通过这个类的实例访问 count。 示例 2：循环中的闭包陷阱 123456789var actions = new List&lt;Action&gt;();for (int i = 0; i &lt; 3; i++)&#123; actions.Add(() =&gt; Console.WriteLine(i));&#125;foreach (var action in actions)&#123; action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）&#125; 问题原因：所有闭包共享同一个变量 i（在循环结束后，i 的值为 3）。 解决方案：在循环内部创建临时变量，让闭包捕获独立的值： 12345for (int i = 0; i &lt; 3; i++)&#123; int current = i; // 每次循环新建一个临时变量 actions.Add(() =&gt; Console.WriteLine(current)); // 输出 0, 1, 2&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp委托","slug":"编程语言/Csharp/csharp委托","date":"2025-02-27T14:37:01.000Z","updated":"2025-03-01T03:21:55.888Z","comments":true,"path":"2025/02/27/编程语言/Csharp/csharp委托/","permalink":"http://example.com/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/","excerpt":"","text":"委托基本概念 定义：委托是类型安全的函数指针，通过 delegate 关键字声明。（ 委托就是一个用来装函数的类的类型） 作用：允许将方法作为参数传递、动态调用多个方法。 核心特点： 类型安全（编译时检查参数和返回值）。 支持多播（组合多个方法）。 可用于异步编程。 委托的声明与使用 写在哪里？ 可以申明在namespace和class语句块中 更多的写在namespace中 委托常用在： 作为类的成员 作为函数的参数 声明委托类型： 123// 定义委托类型，指定方法签名// MathOperation是一个委托类型，只能引用接受两个 int 参数并返回 string 的方法。public delegate string MathOperation(int a, int b); 实例化委托： eg1： 123456// 绑定到具体方法MathOperation add = (a, b) =&gt; a + b;MathOperation multiply = (a, b) =&gt; a * b;// 调用委托int result = add(3, 5); // 输出 8 eg2： 12345678public delegate int Fun(int a);static int MyFun1(int a) ...static int MyFun2(int a) ...Fun f = MyFun1;int tmp = f.Invoke(666);int tmp = f(666); 多播委托（Multicast Delegate） 功能：一个委托实例可绑定多个方法，按顺序执行。 操作符： += 添加方法。 -= 移除方法。 1234567MathOperation add = (a, b) =&gt; a + b;MathOperation multiply = (a, b) =&gt; a * b;MathOperation operations = add;operations += multiply;// 调用时会依次执行 add 和 multiplyint finalResult = operations(3, 5); // 返回 multiply 的结果 15（最后一个方法的返回值） 注意：返回值通常只保留最后一个方法的返回值，中间结果可能被覆盖。 以下是一个示例，演示了如何获取多播委托每一个函数的返回值： 12345678910111213141516171819202122232425262728293031323334using System;public delegate int MyDelegate();class Program&#123; static void Main() &#123; MyDelegate myDelegate = Method1; myDelegate += Method2; myDelegate += Method3; // 获取每一个函数的返回值 Delegate[] delegates = myDelegate.GetInvocationList(); foreach (var del in delegates) &#123; MyDelegate singleDelegate = (MyDelegate)del; int result = singleDelegate(); Console.WriteLine($&quot;Method returned: &#123;result&#125;&quot;); &#125; &#125; static int Method1() &#123; Console.WriteLine(&quot;Method1&quot;); return 1; &#125; static int Method2() &#123; Console.WriteLine(&quot;Method2&quot;); return 2; &#125; static int Method3() &#123; Console.WriteLine(&quot;Method3&quot;); return 3; &#125;&#125; 内置泛型委托 Action：无返回值的方法，最多支持 16 个参数。 12Action&lt;string&gt; log = message =&gt; Console.WriteLine(message);log(&quot;Hello, Action!&quot;); Func：有返回值的方法，最后一个类型参数为返回类型。 12Func&lt;int, int, string&gt; formatSum = (a, b) =&gt; $&quot;&#123;a + b&#125;&quot;;Console.WriteLine(formatSum(3, 5)); // 输出 &quot;8&quot; 匿名方法 匿名函数的使用主要是配合委托和事件进行使用 何时使用？ 函数中传递委托参数时 委托或事件赋值时 缺点? 不能删的具体只能无脑null eg： 12345678910111213141516171819202122232425262728293031323334 class Test&#123; public void Fun1(Action action) &#123; Console.WriteLine(&quot;需要委托作为参数的函数,使用函数更加方便&quot;); action(); &#125; public Action GetFun() &#123; return delegate () &#123; Console.WriteLine(&quot;匿名函数常用作返回值&quot;); &#125;; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; // 匿名函数给委托赋值 Action a = delegate () &#123; Console.WriteLine(&quot;匿名函数逻辑&quot;); &#125;; Test t = new Test(); t.Fun1(a); t.GetFun()(); Func&lt;int, int&gt; b = delegate (int a) &#123; Console.WriteLine(&quot;匿名函数的返回值直接返回就行&quot;); return a; &#125;; &#125;&#125; csharp事件 csharp的Lambda表达式 泛型委托和泛型接口の协变和逆变","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"3.Unity随机数和UnityAction委托","slug":"游戏引擎/unity/unity入门/unity入门实践项目/3.Unity随机数和UnityAction委托","date":"2025-02-27T13:44:46.000Z","updated":"2025-02-28T10:39:30.253Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/3.Unity随机数和UnityAction委托/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.Unity%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8CUnityAction%E5%A7%94%E6%89%98/","excerpt":"","text":"unity当中的随机数用法 1234int randomNum = Random.Range(0, 100); // [0, 100)// float重载，规则是左右都包含float randomNumF = Random.Range(1.1f, 99.9f); // [1.1~99.9f] CSharp中的随机数 123// 左包含，右不包含System.Random random = new System.Random();random.Next(0, 100); // [0, 100) unity的委托 要引用using UnityEngine.Events;命名空间 无参无返回的委托 123UnityAction uac = () =&gt;&#123;&#125;; string作为参数无返回值的委托 123UnityAction&lt;string&gt; uac1 = (s) =&gt;&#123;&#125;; csharp委托 无参无返回的委托 123System.Action ac = () =&gt;&#123;&#125;; int和float作为参数无返回值的委托 123System.Action&lt;int, float&gt; ac2 = (i, f) =&gt;&#123;&#125;; 无参int返回值的委托 1234System.Func&lt;int&gt; fun1 = () =&gt;&#123; return 1;&#125;; int作为参数string作为返回值的委托 1234System.Func&lt;int, string&gt; fun2 = (i) =&gt;&#123; return &quot;123&quot;;&#125;;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.鼠标的隐藏锁定图片","slug":"游戏引擎/unity/unity入门/unity入门实践项目/2.Cursor鼠标的隐藏锁定图片","date":"2025-02-27T13:35:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/2.Cursor鼠标的隐藏锁定图片/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.Cursor%E9%BC%A0%E6%A0%87%E7%9A%84%E9%9A%90%E8%97%8F%E9%94%81%E5%AE%9A%E5%9B%BE%E7%89%87/","excerpt":"","text":"Cursor.visible静态变量 设置鼠标显隐 12// 隐藏鼠标Cursor.visible = false; Cursor.lockState静态变量 设置鼠标锁定状态 确定硬件指针是否锁定到视图的中心、受限于窗口或者根本不受限制。 None: 不锁定鼠标 Locked: 锁定鼠标。鼠标会被限制在屏幕的中心点，不仅会被锁定，还会被隐藏。可以通过按下ESC键摆脱编辑模式下的锁定。要是回到Game窗口点击鼠标会被再次锁定隐藏。 Confined: 限制鼠标在Game窗口范围内。可以通过按下ESC键摆脱编辑模式下的限制。要是回到Game窗口点击鼠标会被再次限制。 1Cursor.lockState = CursorLockMode.Confined; Cursor.SetCursor静态方法 设置鼠标图片 将鼠标光标设置为给定纹理。 参数一：光标图片 参数二：偏移位置，相对图片左上角 参数三：平台支持的光标模式（硬件或软件）（一般选CursorMode.Auto） 123public Texture2D cursorTexture2D;Cursor.SetCursor(cursorTexture2D, Vector2.zero, CursorMode.Auto);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.场景切换和游戏退出","slug":"游戏引擎/unity/unity入门/unity入门实践项目/1.场景切换和游戏退出","date":"2025-02-27T13:28:07.000Z","updated":"2025-03-04T11:16:54.502Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/1.场景切换和游戏退出/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E9%80%80%E5%87%BA/","excerpt":"","text":"场景切换 按照 Build Settings 中的名称或索引加载场景。要引入using UnityEngine.SceneManagement;命名空间。 直接写代码切换场景可能会报错。注意: 切换必须要将场景拖到Unity 中的file-BuildSetting的Scene列表中 然后可用用代码来切换 1ScenneManager.Load(&quot;BeginScene&quot;); 退出游戏 退出播放器应用程序。执行这句代码就会退出游戏。但是在编辑模式下没有作用，一定是发布游戏过后才有用。 12// 退出游戏Application.Quit(); 场景同步切换的缺点 在切换场景时，Unity会删除当前场景上所有对象，并且去加载下一个场景的相关信息。 如果当前场景对象过多或者下一个场景对象过多，这个过程会非常耗时，会让玩家感受到卡顿。 所以异步切换就是来解决该问题的。 异步加载","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.自定义控件拼面板","slug":"UI系统/GUI/GUI实践项目/12.自定义控件拼面板","date":"2025-02-27T09:11:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/12.自定义控件拼面板/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/12.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%8B%BC%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"先拼面板 TestBeginPanel.cs 1234567891011121314151617181920212223public class BeginPanel : MonoBehaviour&#123; public CustomGUIButton btnBegin; public CustomGUIButton btnEnd; public CustomGUIButton btnQuit; void Start() &#123; btnBegin.clickEvent += () =&gt; &#123; Debug.Log(&quot;Begin&quot;); &#125;; btnEnd.clickEvent += () =&gt; &#123; Debug.Log(&quot;End&quot;); &#125;; btnQuit.clickEvent += () =&gt; &#123; this.gameObject.SetActive(false); &#125;; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.自定义图片绘制","slug":"UI系统/GUI/GUI实践项目/11.自定义图片绘制","date":"2025-02-27T09:01:50.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/11.自定义图片绘制/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/11.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6/","excerpt":"","text":"CustomGUITexture.cs 12345678910111213public class CustomGUITexture : CustomGUIControl&#123; // 方便外部缩放模式调整 public ScaleMode mode = ScaleMode.StretchToFill; protected override void DrawIsOff() &#123; GUI.DrawTexture(guiPos.Pos, guiContent.image, mode); &#125; protected override void DrawIsOn() &#123; GUI.DrawTexture(guiPos.Pos, guiContent.image, mode); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"10.自定义输入框和拖动条","slug":"UI系统/GUI/GUI实践项目/10.自定义输入框和拖动条","date":"2025-02-27T08:49:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/10.自定义输入框和拖动条/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/10.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"CustomGUIInput.cs 12345678910111213141516171819202122232425public class CustomGUIInput : CustomGUIControl&#123; // 当输入框变化时的事件 public event UnityAction&lt;string&gt; changeText; private string oldStr = &quot;&quot;; protected override void DrawIsOff() &#123; guiContent.text = GUI.TextField(guiPos.Pos, guiContent.text); // 当输入框变化时调用的委托函数 if (oldStr != guiContent.text) &#123; changeText?.Invoke(guiContent.text); oldStr = guiContent.text; &#125; &#125; protected override void DrawIsOn() &#123; guiContent.text = GUI.TextField(guiPos.Pos, guiContent.text, style); if (oldStr != guiContent.text) &#123; changeText?.Invoke(guiContent.text); oldStr = guiContent.text; &#125; &#125;&#125; CustomGUISlide.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public enum E_Slider_Type&#123; Horizontal, Vertical,&#125;public class CustomGUISlide : CustomGUIControl&#123; public float minValue = 0; public float maxValue = 1; public float nowValue = 0; public E_Slider_Type sliderType = E_Slider_Type.Horizontal; // 默认的style是条的, 这里还需要滑块的style public GUIStyle styleThumb; public event UnityAction&lt;float&gt; changeValue; private float oldValu e; protected override void DrawIsOff() &#123; switch (sliderType) &#123; case E_Slider_Type.Horizontal: nowValue = GUI.HorizontalSlider(guiPos.Pos, nowValue, minValue, maxValue); break; case E_Slider_Type.Vertical: nowValue = GUI.VerticalSlider(guiPos.Pos, nowValue, minValue, maxValue); break; &#125; if (oldValue != nowValue) &#123; changeValue?.Invoke(nowValue); oldValue = nowValue; &#125; &#125; protected override void DrawIsOn() &#123; switch (sliderType) &#123; case E_Slider_Type.Horizontal: nowValue = GUI.HorizontalSlider(guiPos.Pos, nowValue, minValue, maxValue, style, styleThumb); break; case E_Slider_Type.Vertical: nowValue = GUI.VerticalSlider(guiPos.Pos, nowValue, minValue, maxValue, style, styleThumb); break; &#125; if (oldValue != nowValue) &#123; changeValue?.Invoke(nowValue); oldValue = nowValue; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"9.自定义单选框","slug":"UI系统/GUI/GUI实践项目/9.自定义单选框","date":"2025-02-27T07:47:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/9.自定义单选框/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/9.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E9%80%89%E6%A1%86/","excerpt":"","text":"回顾闭包 当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。 示例 1：基本闭包 123456789Func&lt;int&gt; CreateCounter()&#123; int count = 0; return () =&gt; ++count; // 闭包捕获了外部变量 count&#125;var counter = CreateCounter();Console.WriteLine(counter()); // 输出 1Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态） 现象：count 本应在 CreateCounter 方法执行完毕后被销毁，但闭包保留了它的状态。 原理：编译器生成一个类，将 count 作为该类的字段存储，闭包通过这个类的实例访问 count。 示例 2：循环中的闭包陷阱 123456789var actions = new List&lt;Action&gt;();for (int i = 0; i &lt; 3; i++)&#123; actions.Add(() =&gt; Console.WriteLine(i));&#125;foreach (var action in actions)&#123; action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）&#125; 问题原因：所有闭包共享同一个变量 i（在循环结束后，i 的值为 3）。 解决方案：在循环内部创建临时变量，让闭包捕获独立的值： 12345for (int i = 0; i &lt; 3; i++)&#123; int current = i; // 每次循环新建一个临时变量 actions.Add(() =&gt; Console.WriteLine(current)); // 输出 0, 1, 2&#125; CustomGUIToggleGroup.cs 创建自定义单选框，添加多选框数组，通过管理多选框实现单选框，在添加一个记录上一次为true的toggle 123456789101112131415161718192021222324252627282930313233343536public class CustomGUIToggleGroup : MonoBehaviour&#123; [SerializeField] private CustomGUIToggle[] _toggles; private CustomGUIToggle _frontTrueToggle； // 上一次为true的toggle // 注意只有游戏运行才能用 void Start() &#123; for (int i = 0; i &lt; _toggles.Length; i++) &#123; CustomGUIToggle tmp = _toggles[i]; // 为每个Toggle添加一个一旦其值为true时, 其它Toggle变为false的委托 // Lambda函数捕获了外部变量（tmp）!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! tmp.changeEvent += (value) =&gt; &#123; if (value) &#123; for (int j = 0; j &lt; _toggles.Length; j++) &#123; if (tmp != _toggles[j]) // 只要不是自己 &#123; _toggles[j].isSel = false; &#125; &#125; // 这里可以记录上一次为true的toggle _frontTrueToggle = tmp; &#125; else if (_frontTrueToggle == tmp) // 如果是上一次为true的toggle &#123; tmp.isSel = true; // 永远保持选中的状态 &#125; &#125;; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"8.自定义多选框","slug":"UI系统/GUI/GUI实践项目/8.自定义多选框","date":"2025-02-27T07:42:31.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/8.自定义多选框/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/8.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E9%80%89%E6%A1%86/","excerpt":"","text":"CustomGUIToggle.cs 12345678910111213141516171819202122232425262728public class CustomGUIToggle : CustomGUIControl&#123; // 单选的那个bool public bool isSel; private bool oldSel; // 当选中时所要执行的事件 public event UnityAction&lt;bool&gt; changeEvent; protected override void DrawIsOff() &#123; isSel = GUI.Toggle(guiPos.Pos, isSel, guiContent); // 防止一直true true true一直调用事件执行 // 只有当 true 和 false 发生变化的时候才去处理 if (isSel != oldSel) &#123; changeEvent?.Invoke(isSel); oldSel = isSel; &#125; &#125; protected override void DrawIsOn() &#123; isSel = GUI.Toggle(guiPos.Pos, isSel, guiContent, style); if (isSel != oldSel) &#123; changeEvent?.Invoke(isSel); oldSel = isSel; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"7.自定义文本和按钮","slug":"UI系统/GUI/GUI实践项目/7.自定义文本和按钮","date":"2025-02-27T07:19:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/7.自定义文本和按钮/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/7.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E5%92%8C%E6%8C%89%E9%92%AE/","excerpt":"","text":"创建自定义文本和按钮，将其脚本拖入到空物体上做成预制体 CustomGUILabel.cs 1234567891011public class CustomGUILabel : CustomGUIControl&#123; protected override void DrawIsOff() &#123; GUI.Label(guiPos.Pos, guiContent); &#125; protected override void DrawIsOn() &#123; GUI.Label(guiPos.Pos, guiContent, style); &#125;&#125; CustomGUIButton.cs 1234567891011121314151617181920public class CustomGUIButton : CustomGUIControl&#123; // 提供给外部的按钮点击事件, 想要按钮点击后做啥往里加函数就行, Unity自带的事件 public event UnityAction clickEvent; protected override void DrawIsOff() &#123; if (GUI.Button(guiPos.Pos, guiContent)) &#123; clickEvent?.Invoke(); &#125; &#125; protected override void DrawIsOn() &#123; if (GUI.Button(guiPos.Pos, guiContent, style)) &#123; clickEvent?.Invoke(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"6.控件根对象","slug":"UI系统/GUI/GUI实践项目/6.控件根对象","date":"2025-02-27T07:06:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/6.控件根对象/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/6.%E6%8E%A7%E4%BB%B6%E6%A0%B9%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"解决两个问题 所见即所得（编辑模式下能看到GUI） 可以控制控件的绘制顺序 创建所有自定义GUI的根部类,添加ExecuteAlways特性 在类名添加ExecuteAlways特性，可以让编辑模式下指定代码运行。 12345[ExecuteAlways]//所有自定义GUI的根部类public class CustomGUIRoot : MonoBehaviour&#123;&#125; 在Start方法中获取所有子对象的控件父类脚本 12345void Start()&#123; //通过每一次绘制之前 得到所有子对象控件的 父类脚本 allControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;();&#125; 在OnGUI方法中按照得到的顺序来绘制每个控件，用控件父类中定义好的绘制方法 1234567891011121314151617181920//在这同一绘制子对象控件的内容private void OnGUI()&#123; //编辑状态下 才会一直执行 //if (!Application.isPlaying) //&#123; //这句代码 浪费性能 因为每次 gui都会来获取所有的 控件对应的脚本 所以要在编辑状态下才会一直执行 //在编辑状态下运行是因为想一直看到控件的移动 //最后没开启是因为只得了一次子对象的CustomGUIControl 就算子对象被隐藏了也不会重写得CustomGUIControl 会有问题 allControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); //&#125; //遍历每一个控件 让其 执行绘制 for (int i = 0; i &lt; allControls.Length; i++) &#123; allControls[i].GUIDraw(); &#125;&#125; CustomGUIRoot.cs 12345678910111213141516171819202122[ExecuteAlways]public class CustomGUIRoot : MonoBehaviour&#123; private CustomGUIControl[] _customGUIControls; private void Start() &#123; _customGUIControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); &#125; // 统一控制所有子对象挂载的控件的 绘制 private void OnGUI() &#123; if (!Application.isPlaying) // 这里的条件判断主要是为了性能, 实际运行可能会出错 &#123; _customGUIControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); &#125; for (int i = 0; i &lt; _customGUIControls.Length; i++) &#123; _customGUIControls[i].GUIDraw(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"5.控件父类","slug":"UI系统/GUI/GUI实践项目/5.控件父类","date":"2025-02-27T02:19:18.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/5.控件父类/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/5.%E6%8E%A7%E4%BB%B6%E7%88%B6%E7%B1%BB/","excerpt":"","text":"这是所有控件的公共基类 自定义样式是否启用的开关枚举 定义了一个枚举类型 E_Style_onoff 用于表示自定义样式是否启用。 12345public enum E_Style_onoff&#123; On, Off,&#125; 自定义控件父类是一个抽象类，继承自MonoBehaviour。 123public abstract class CustomGUIControl : MonoBehaviour&#123;&#125; 提取控件的共同表现 位置信息 显示内容信息 自定义样式以及自定义样式是否启用的开关。 123456789101112// 位置信息public CustomGUIPos guiPos;// 显示内容信息public GUIContent content;// 自定义样式public GUIStyle style;// 自定义样式是否启用的开关public E_Style_OnOff styleOnOrOff = E_Style_OnOff.Off; 根据是否使用style写两个抽象方法 1234567891011121314151617181920212223public void DrawGUI()&#123; switch (styleOnOrOff) &#123; case E_Style_OnOff.On: StyleOnDraw(); break; case E_Style_OnOff.Off: StyleOffDraw(); break; &#125;&#125;/// &lt;summary&gt;/// 自定义样式开启时的绘制抽象方法/// &lt;/summary&gt;protected abstract void StyleOnDraw();/// &lt;summary&gt;/// 自定义样式关闭时的绘制抽象方法/// &lt;/summary&gt;protected abstract void StyleOffDraw(); CustomGUIControl.cs 12345678910111213141516171819202122232425262728293031323334public enum E_Style_onoff&#123; On, Off,&#125;public abstract class CustomGUIControl : MonoBehaviour&#123; // GUI控件公共部分 !!!!!! // 位置信息 public CustomGUIPos guiPos; // 显示内容信息 public GUIContent guiContent; // 自定义样式 public GUIStyle style; // 自定义样式开关 public E_Style_onoff styleIsOn = E_Style_onoff.Off; // 提供公共的控件绘制 public void GUIDraw() &#123; switch (styleIsOn) &#123; case E_Style_onoff.On: // 样式开启时使用的绘制函数 DrawIsOn(); break; case E_Style_onoff.Off: DrawIsOff(); break; &#125; &#125; protected abstract void DrawIsOn(); protected abstract void DrawIsOff();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"4.控件位置信息类","slug":"UI系统/GUI/GUI实践项目/4.控件位置信息类","date":"2025-02-27T01:54:24.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/4.控件位置信息类/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%8E%A7%E4%BB%B6%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%B1%BB/","excerpt":"","text":"CustomGUIPos.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//对齐方式九宫格枚举定义public enum E_Alignment_Type&#123; Up, Down, Left, Right, Center, Left_Up, Left_Down, Right_Up, Right_Down,&#125;// 自定义类需要再Inspector面板显示[System.Serializable]public class CustomGUIPos&#123; // 控件位置 private Rect _pos = new Rect(0, 0, 101, 100); // 屏幕九宫格对齐方式 public E_Alignment_Type Screen_Alignment_Type = E_Alignment_Type.Center; // 控件中心点对齐方式 public E_Alignment_Type Constrol_Center_Alignment_Type = E_Alignment_Type.Center; // 偏移位置 public Vector2 dPos; // 控件宽高 public float Width = 100; public float Height = 50; // 计算后的控件位置 public Rect Pos &#123; get &#123; CalcCenterPos(); CalcPos(); _pos.width = Width; _pos.height = Height; return _pos; &#125; &#125; // 计算最后的位置 private void CalcPos() &#123; switch (Screen_Alignment_Type) &#123; case E_Alignment_Type.Up: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Down: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Center: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left_Up: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left_Down: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right_Up: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right_Down: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; &#125; &#125; // 控件中心点位置 private Vector2 _centerPos; private void CalcCenterPos() &#123; switch (Constrol_Center_Alignment_Type) &#123; case E_Alignment_Type.Up: _centerPos.x = -Width / 2; _centerPos.y = 0; break; case E_Alignment_Type.Down: _centerPos.x = -Width / 2; _centerPos.y = -Height; break; case E_Alignment_Type.Left: _centerPos.x = 0; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Right: _centerPos.x = -Width; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Center: _centerPos.x = -Width / 2; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Left_Up: _centerPos.x = 0; _centerPos.y = 0; break; case E_Alignment_Type.Left_Down: _centerPos.x = 0; _centerPos.y = -Height; break; case E_Alignment_Type.Right_Up: _centerPos.x = -Width; _centerPos.y = 0; break; case E_Alignment_Type.Right_Down: _centerPos.x = -Width; _centerPos.y = -Height; break; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"3.九宫格概念","slug":"UI系统/GUI/GUI实践项目/3.九宫格概念","date":"2025-02-27T01:41:15.000Z","updated":"2025-02-28T11:54:17.740Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/3.九宫格概念/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"相对屏幕位置：红点的位置 中心点偏移位置：控件的九个点的位置","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.需求分析","slug":"UI系统/GUI/GUI实践项目/2.需求分析","date":"2025-02-27T01:35:44.000Z","updated":"2025-02-28T11:48:54.741Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/2.需求分析/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"使用GUI制作出控件预制体，不需要运行时在OnGUI写逻辑才能看到UI","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.hexo源码上传到GitHub","slug":"hexo/2.hexo源码上传到GitHub","date":"2025-02-26T13:54:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/hexo/2.hexo源码上传到GitHub/","permalink":"http://example.com/2025/02/26/hexo/2.hexo%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub/","excerpt":"","text":"在你的github中创建一个新的分支用来保存源码 名字随便，这里我的是hexo git clone 你的仓库 复制.git文件夹到你的博客目录 123git add .git commit -m &quot;Update&quot;git push origin hexo 参考链接： hexo源码上传到GitHub - choco莉特 - 博客园","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"1.编辑模式下让指定代码运行","slug":"UI系统/GUI/GUI实践项目/1.编辑模式下让指定代码运行","date":"2025-02-26T13:42:40.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI实践项目/1.编辑模式下让指定代码运行/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%AE%A9%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C/","excerpt":"","text":"在类名上添加 [ExecuteAlways] 特性可以让指定代码在编辑模式下运行 编辑模式下，缩放Game窗口大小每一帧相关也会执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//在类名添加ExecuteAlways特性 可以让编辑模式下让指定代码运行[ExecuteAlways]public class Lesson01_必备知识点_编辑模式下让指定代码运行 : MonoBehaviour&#123; private void Awake() &#123; Debug.Log(&quot;对象初始化时调用（即使脚本未启用）。&quot;); &#125; private void OnEnable() &#123; Debug.Log(&quot;脚本启用或对象激活时调用（在Awake之后，若对象初始启用）。&quot;); &#125; void Start() &#123; Debug.Log(&quot;在首次Update前调用（仅一次，需脚本启用）。&quot;); &#125; private void FixedUpdate() &#123; Debug.Log(&quot;按固定时间间隔调用（物理计算阶段，可能一帧多次）。&quot;); &#125; private void OnTriggerEnter(Collider other) &#123; Debug.Log(&quot;物理触发事件，在FixedUpdate之后、Update之前处理。&quot;); &#125; void Update() &#123; Debug.Log(&quot;每帧调用一次。&quot;); &#125; private void LateUpdate() &#123; Debug.Log(&quot;所有Update完成后调用。&quot;); &#125; private void OnGUI() &#123; Debug.Log(&quot;渲染GUI时调用，每帧可能多次（在LateUpdate之后）。&quot;); &#125; private void OnDisable() &#123; Debug.Log(&quot;脚本禁用或对象失活时调用。&quot;); &#125; private void OnDestroy() &#123; Debug.Log(&quot;对象销毁前调用。&quot;); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.GUI总结","slug":"UI系统/GUI/GUI基础知识/12.GUI总结","date":"2025-02-26T12:22:28.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/12.GUI总结/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GUI%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"11.GUILayout自动布局","slug":"UI系统/GUI/GUI基础知识/11.GUILayout自动布局","date":"2025-02-26T12:13:57.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/11.GUILayout自动布局/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.GUILayout%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546// GUILayout是一个类似GUI的类，里面的API和GUI类似，只是可以帮我们自动布局，不用手动调整位置，方便一点。// GUILayout 类是 Unity GUI 的接口，并且具有自动布局功能。// 主要用于进行编辑器开发，如果用它来做游戏UI不太合适。// GUILayout和GUI可以相互配合着使用GUI.BeginGroup(new Rect(100, 100, 500, 300));GUILayout.BeginArea(new Rect(10, 10, 400, 300)); // 在一个固定的屏幕区域中开始 GUI 控件的 GUILayout 块。GUILayout.BeginVertical(); // 开始一个垂直控件组。GUILayout.Button(&quot;竖直123&quot;, GUILayout.Width(200)); // 控件的固定宽高GUILayout.Button(&quot;竖直245666656565&quot;);GUILayout.Button(&quot;竖直235&quot;, GUILayout.ExpandWidth(false)); // 允许或禁止水平拓展GUILayout.EndVertical(); // 闭合以 BeginVertical 开始的组。GUILayout.BeginHorizontal(); // 开始一个水平控件组。GUILayout.Button(&quot;水平123&quot;, GUILayout.Height(300)); // 控件的固定宽高GUILayout.Button(&quot;水平245666656565&quot;);GUILayout.Button(&quot;水平235&quot;, GUILayout.ExpandWidth(false)); // 允许或禁止水平拓展GUILayout.EndHorizontal(); // 闭合以 BeginHorizontal 开始的组。GUILayout.EndArea(); // 闭合以 BeginArea 开始的 GUILayout 块。GUI.EndGroup();GUILayoutOption 布局选项 //控件的固定宽高 GUILayout.Width(300); GUILayout.Height(200); //允许控件的最小宽高 GUILayout.MinWidth(50); GUILayout.MinHeight(50); //允许控件的最大宽高 GUILayout.MaxWidth(100); GUILayout.MaxHeight(100); //允许或禁止水平拓展 GUILayout.ExpandWidth(true);//允许 GUILayout.ExpandHeight(false);//禁止 GUILayout.ExpandHeight(true);//允许 GUILayout.ExpandHeight(false);//禁止","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"10.自定义皮肤样式","slug":"UI系统/GUI/GUI基础知识/10.自定义皮肤样式","date":"2025-02-26T12:00:57.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/10.自定义皮肤样式/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%AE%E8%82%A4%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"颜色* color静态变量 全局的着色颜色 123456// GUI 的全局着色颜色。GUI.color = Color.red;GUI.Label(new Rect(0, 50, 150, 30), &quot;全局着色颜色标签红&quot;);GUI.Button(new Rect(0, 100, 150, 30), &quot;全局着色颜色按钮红&quot;);GUI.color = Color.white;GUI.Button(new Rect(0, 150, 150, 30), &quot;全局着色颜色按钮白&quot;, style); contentColor静态变量 文本着色颜色 1234// 文本着色颜色，会和全局颜色相乘。// 为 GUI 渲染的所有文本着色。GUI.contentColor = Color.yellow;GUI.Button(new Rect(0, 200, 150, 30), &quot;文本着色颜色&quot;); backgroundColor静态变量 背景元素着色颜色 1234// 用于 GUI 渲染的所有背景元素的全局着色颜色。// 背景元素着色颜色会和全局颜色相乘。GUI.backgroundColor = Color.green;GUI.Button(new Rect(0, 250, 150, 30), &quot;背景元素着色颜色&quot;, style); 整体皮肤样式 在Project窗口可以右键创建GUI皮肤 skin静态变量 全局皮肤 123456public GUISkin mySkin;private void OnGUI()&#123; GUI.skin = mySkin; // 为null就是默认的样式，单个Style会覆盖&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"9.窗口","slug":"UI系统/GUI/GUI基础知识/9.窗口","date":"2025-02-26T11:35:31.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/9.窗口/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%AA%97%E5%8F%A3/","excerpt":"","text":"窗口 1234567891011121314// 第一个参数是窗口唯一id// 第三个参数是一个 要一个int作为参数的无返回值的委托, 用来处理窗口内容的GUI.Window(1, new Rect(0, 0, 500, 500), (a) =&gt;&#123; // 一个函数处理不同的窗口 switch (a) &#123; case 1: GUI.Button(new Rect(0, 0, 100, 30), &quot;第一个窗口逻辑&quot;); break; case 2: break; &#125;&#125;, &quot;测试窗口&quot;); 模态窗口 1234567// 显示一个模态窗口。// 模态窗口可以让其它控件不再有用。// 你可以理解该窗口在最上层，其它按钮都点击不到了，只能点击该窗口上控件。// 只有把模态窗口处理后, 才可以点击其它窗口GUI.ModalWindow(3, new Rect(300, 100, 200, 150), (a) =&gt; &#123;&#125;, &quot;模态窗口&quot;);// 可能应用于警告弹窗，必须先处理的弹出 拖动窗口 12345678public Rect winRect = new Rect(100, 100, 200, 200);winRect = GUI.Window(3, winRect, (a) =&gt;&#123; // 无参默认窗口所有位置都可以拖动 // 参数指定窗口的哪一部分可以被鼠标拖动 GUI.DragWindow(); // 必须要调用这个才能拖动&#125;, &quot;拖动窗口测试&quot;); 练习 在之前制作的开始界面中，点击退出游戏按钮，弹出一个模态窗口，让玩家确定是否退出（退出，取消），点击取消后关闭窗口，点击退出后 退出游戏 QuitTipPanel.cs 1234567891011121314151617181920212223private void OnGUI()&#123; // 绘制模态窗口 GUI.ModalWindow(1, winPos, DrawWindow, &quot;提示&quot;);&#125;private void DrawWindow(int id)&#123; // 标签 GUI.Label(labPos, &quot;是否退出&quot;); // 两个按钮 if(GUI.Button(btnPos1, &quot;退出&quot;)) &#123; Application.Quit(); &#125; if(GUI.Button(btnPos2, &quot;取消&quot;)) &#123; HideMe(); BeginPanel.ShowMe(); &#125;&#125; BeginPanel.cs 12345if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle))&#123; QuitTipPanel.ShowMe(); HideMe();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"8.滚动列表和分组","slug":"UI系统/GUI/GUI基础知识/8.滚动列表和分组","date":"2025-02-26T11:04:59.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/8.滚动列表和分组/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%E5%92%8C%E5%88%86%E7%BB%84/","excerpt":"","text":"分组 BeginGroup 1234567891011121314//BeginGroup静态方法 开始分组//开始一个组。必须与 EndGroup 调用配对使用。//用于批量控制控件位置 //可以理解为 包裹着的控件加了一个父对象 //可以通过控制分组来控制包裹控件的位置GUI.BeginGroup(groupRect); // 必须搭配EndGroup来使用//组内的组件GUI.Button(new Rect(0, 0, 100, 50), &quot;测试按钮&quot;);GUI.Label(new Rect(0, 60, 100, 20), &quot;Label信息&quot;);//EndGroup静态方法 结束分组//结束组。GUI.EndGroup(); 滚动列表 BeginScrollView 在Unity中，GUI.BeginScrollView函数用于创建一个可以滚动的视图区域，允许在较小的矩形区域内显示较大的内容。该函数的参数如下所示： position (Rect)：指定 滚动视图 的矩形区域，使用Rect类型来表示，包含了左上角的位置坐标和宽度、高度。 scrollPosition (Vector2)：指定当前滚动位置的二维向量，表示在滚动视图中内容的偏移量。 viewRect (Rect)：指定 具体内容 的矩形区域大小，使用Rect类型来表示，包含了左上角的位置坐标和宽度、高度。 12345678910111213public Rect scrollPos;public Rect showView;public Vector2 nowPos;nowPos = GUI.BeginScrollView(scrollPos, nowPos, showView);// 中间填想要放在滚动列表里面的UI eg:GUI.Toolbar(new Rect(0, 0, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 60, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 120, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 180, 300, 50), 0, strs);GUI.EndScrollView(); 练习 制作一个滚动视图，外部有一个字符串数组，通过在Inspector修改这个字符串数组数量，会在滚动视图内部动态的创建label依次显示内容 想让滚动视图的真实内容大小 随内容(这里是strings)大小变化而变化 1234567891011121314151617181920public string[] strs;public Rect scrollPos;public Rect showView;public Vector2 nowPos;private void OnGUI()&#123; // 想让滚动视图的真实内容大小 随内容(这里是strings)大小变化而变化 // 在绘制滚动视图之前把变化的数据计算好 showView.height = strs.Length * 30; // 计算你要生成的内容的高度 nowPos = GUI.BeginScrollView(scrollPos, nowPos, showView); for (int i = 0; i &lt; strs.Length; i++) &#123; GUI.Label(new Rect(0, i * 30, 100, 30), strs[i]); &#125; GUI.EndScrollView();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"7.工具栏和选择网格","slug":"UI系统/GUI/GUI基础知识/7.工具栏和选择网格","date":"2025-02-26T09:41:39.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/7.工具栏和选择网格/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E9%80%89%E6%8B%A9%E7%BD%91%E6%A0%BC/","excerpt":"","text":"工具栏Toolbar 1234567891011121314151617181920// 创建一个工具栏。// 需要声明一个 int 变量用于选择 和一个 string 数组用于显示当前选择的工具栏的内容。public int toolbarIndex = 0;public string toolbarInfos = new string[] &#123; &quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot; &#125;;// Toolbar静态方法会返回一个 int 值，也需要重新赋值个给选择的 int 变量。toolbarIndex = GUI.Toolbar(new Rect(0, 0, 200, 30), toolbarIndex, toolbarInfos);// 工具栏可以帮助我们根据不同的返回索引 来处理不同的逻辑switch (toolbarIndex)&#123; case 0: // 处理索引为0的逻辑 break; case 1: // 处理索引为1的逻辑 break; case 2: // 处理索引为2的逻辑 break;&#125; 选择网格SelectionGrid 1234// 创建一个按钮网格。// 也需要声明一个 int 变量用于选择 和一个 string 数组用于显示当前选择的工具栏的内容。// 相对 toolbar 多了一个参数 xCount 代表 水平方向最多显示的按钮数量 比如有三个按钮 这参数天了填了2 那么一行最多只要两个按钮。selGridIndex = GUI.SelectionGrid(new Rect(0, 50, 200, 60), selGridIndex, toolbarInfos, 2); 练习 12345678910111213141516171819202122232425262728293031public class TestPanel : MonoBehaviour&#123; public Rect toolbarPos; public Rect selGridPos; public string[] strs = new string[] &#123; &quot;装备&quot;, &quot;进阶&quot;, &quot;幻化&quot; &#125;; private int nowSelIndex = 0; public Rect labelPos; private void OnGUI() &#123; nowSelIndex = GUI.Toolbar(toolbarPos, nowSelIndex, strs); nowSelIndex = GUI.SelectionGrid(selGridPos, nowSelIndex, strs, 1); switch (nowSelIndex) &#123; case 0: GUI.Label(labelPos, &quot;装备信息&quot;); break; case 1: GUI.Label(labelPos, &quot;进阶信息&quot;); break; case 2: GUI.Label(labelPos, &quot;幻化信息&quot;); break; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"6.图片绘制和框","slug":"UI系统/GUI/GUI基础知识/6.图片绘制和框","date":"2025-02-26T09:26:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/6.图片绘制和框/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E5%92%8C%E6%A1%86/","excerpt":"","text":"DrawTexture DrawTexture静态方法重载中的参数 12345//DrawTexture静态方法所有重载public static void DrawTexture(Rect position, Texture image);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect); ScaleMode: 当图像的宽高比不适合要绘制的宽高比时，如何缩放图像。 ScaleAndCrop: 也会通过宽高比来计算图片 但是会进行裁剪。 ScaleToFit: 会自动根据宽高比进行计算 不会拉变形 会一直保持图片全部显示的状态。 StretchToFill: 始终填充满你传入的 Rect 范围。 alphaBlend: 绘制图像时是否应用 Alpha 混合（默认启用）。 用来控制图片是否开启透明通道。 imageAspect: 用于源图像的宽高比。如果为 0（默认值），则使用图像的宽高比。传入 w/h 来指定所需的宽高比。这让您能够在不改变像素宽度和高度的情况下调整源图像的宽高比。 基本使用 12345678public Rect texPos;public Texture tex;public ScaleMode mode = ScaleMode.StretchToFillpublic bool alpha = true;public float wh = 0;// 在一个矩形内绘制纹理。GUI.DrawTexture(texPos, tex, mode, alpha, wh); 框 12// 在 GUI 层上创建一个框。GUI.Box(texPos, &quot;123&quot;); 练习 为各个面板加上背景图片 123456789101112131415// 开始面板脚本public class BeginPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125; 123456789101112131415// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125; 123456789101112131415// 登陆面板脚本public class LoginPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"5.输入框和拖动条","slug":"UI系统/GUI/GUI基础知识/5.输入框和拖动条","date":"2025-02-26T09:04:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/5.输入框和拖动条/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"输入 普通输入TextField 输入框 重要参数： 显示内容 string 最大输入字符串的长度 和多选框类似 要不停得到自己输入的内容 1234public string inputStr = &quot;hello&quot;;// 创建一个可供用户编辑字符串的单行文本字段。inputStr = GUI.TextField(new Rect(0, 0, 100, 30), inputStr, 5);//最多显示5个字符 超过了不会在打出来了 密码输入框PasswordField 1234public string inputPW = &quot;&quot;;// 创建一个可让用户输入密码的文本字段。inputPW = GUI.PasswordField(new Rect(0, 50, 100, 30), inputPW, &#x27;★&#x27;);//密码文本是★ 拖动条 水平拖动条 拖动条重要参数 当前的值 最小值 left 最大值 right 也是要不停得到自己输入的内容 12345public float nowValue = 0;// 用户可以拖动的水平滑动条，用于在最小值和最大值之间更改某值。nowValue = GUI.HorizontalSlider(new Rect(0, 100, 100, 50), nowValue, 0, 1);Debug.Log(nowValue); 竖直拖动条 12 // 用户可以拖动的垂直滑动条，用于在最小值和最大值之间更改某值。nowValue = GUI.VerticalSlider(new Rect(0, 150, 50, 100), nowValue, 0, 1); 练习 在设置面板中加入拖动条控制音乐大小 12345678910111213141516// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 拖动条控制音乐大小 private float musicValue = 1; public Rect musicPos; private float soundValue = 1; public Rect soundPos; private void OnGUI() &#123; // 拖动条 musicValue = GUI.HorizontalSlider(musicPos, musicValue, 0, 1); soundValue = GUI.HorizontalSlider(soundPos, soundValue, 0, 1); &#125;&#125; 制作一个登陆面板 请在之前的基础上,制作一个登陆面板,有用户名输入和密码输入,有进入游戏和返回上一级按钮,点击开始界面中的开始游戏后 进入登陆面板,输入的用户名为admin密码为8888才能切换场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class LoginPanel : MonoBehaviour&#123; //面板的显示隐藏 所有地方都能够快速使用的 //静态 方法 和静态变量 就可以直接通过类名就用了 private static LoginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; //两个 按钮 public Rect btn1Pos; public Rect btn2Pos; //两个 label public Rect lab1Pos; public Rect lab2Pos; //两个 输入框 public Rect input1Pos; public Rect input2Pos; //用户名和密码 private string userName = &quot;&quot;; private string passWord = &quot;&quot;; private void Awake() &#123; instance = this; HideMe(); &#125; private void OnGUI() &#123; //登录按钮 if ( GUI.Button(btn1Pos, &quot;登录游戏&quot;) ) &#123; if(userName == &quot;admin&quot; &amp;&amp; passWord == &quot;8888&quot;) &#123; SceneManager.LoadScene(&quot;GameScene&quot;); &#125; else &#123; Debug.Log(&quot;用户名或者密码错误&quot;); &#125; &#125; //返回按钮 if( GUI.Button(btn2Pos, &quot;返回&quot;) ) &#123; BeginPanel.ShowMe(); HideMe(); &#125; //文本 GUI.Label(lab1Pos, &quot;用户名&quot;); GUI.Label(lab2Pos, &quot;密码&quot;); //输入框 userName = GUI.TextField(input1Pos, userName); passWord = GUI.PasswordField(input2Pos, passWord, &#x27;*&#x27;); &#125;&#125;#endregion","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"4.多选框和单选框","slug":"UI系统/GUI/GUI基础知识/4.多选框和单选框","date":"2025-02-26T08:10:32.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/4.多选框和单选框/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.%E5%A4%9A%E9%80%89%E6%A1%86%E5%92%8C%E5%8D%95%E9%80%89%E6%A1%86/","excerpt":"","text":"多选框 GUI.Toggle的返回值是该Toggle被点击后是否选中 Toggle静态方法 创建多选框 123456789// 创建一个打开 / 关闭的开关按钮。// 要传入一个布尔值，true为选中，false为不选中// Toggle静态方法会返回一个布尔值，返回的布尔值是, 上次鼠标改变Toggle后是否选中// 普通样式isSel = GUI.Toggle(new Rect(0, 0, 100, 30), isSel, &quot;效果开关&quot;);// GUI.Toggle的点击范围是用的Rect中的宽高// 用fixedWidth和fixedHeight 改变图片的大小，但是不改变点击范围// 修改从GUIStyle边缘到内容起始处的空间 paddingisSel2 = GUI.Toggle(new Rect(0, 40, 100, 30), isSel2, &quot;音效开关&quot;, style); 修改多选框样式 单选框 单选框通过多选框来实现的 123456789// 单选框 (一般通过一个int来控制所有的flag, 可通过点击来改变是否选中)if (GUI.Toggle(rect, selIndex == 1, &quot;选项1&quot;))&#123; selIndex = 1;&#125;if (GUI.Toggle(rect, selIndex == 2, &quot;选项2&quot;))&#123; selIndex = 2;&#125; 练习 控制一个面板（比如设置面板的UI）的显隐，通常是将显示面板的脚本挂载到一个Pannel的游戏对象上，在控制这个游戏对象的失活与激活来是否显示面板和隐藏面板 要完成面板之间相互控制显示有3种方法： 第一种：都写在一个 OnGUI 中，通过 bool 标识去控制显影。 第二种：挂载在同一个对象上，通过控制脚本的 gameObject.SetActive(true/false) 去控制面板的显影。 第三种：挂载在不同对象上，通过控制对象的 gameObject.SetActive(true/false) 来达到面板的显影。 关键的是如何在多个面板之间相互调用显隐。我们是通过静态变量和静态方法的形式，在 Awake 方法中初始化静态变量。如果要用该方法，一开始这个对象不能失活。 制作一个游戏设置面板，上面有背景音乐的开关和音效的开关，并且点击开始界面的设置面板可以打开设置面板 单例模式，控制各个面板的显隐 1234567891011121314151617181920212223242526272829303132333435// 开始面板脚本public class BeginPanel : MonoBehaviour&#123; // 开始面板的显示隐藏 private static BeginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; private void Awake() &#123; instance = this; HideMe(); &#125; // 其他代码... private void OnGUI() &#123; // 其他代码... &#125;&#125; 设置面板脚本SettingPanel.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 音乐开关和音效开关 public Rect toggleMusicPos; // **API: Rect** public Rect toggleSoundPos; // **API: Rect** private bool isSelMusic = true; private bool isSelSound = true; private static SettingPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; private void Awake() &#123; instance = this; HideMe(); &#125; private void OnGUI() &#123; // 音乐开关和音效开关 isSelMusic = GUI.Toggle(toggleMusicPos, isSelMusic, &quot;音乐开关&quot;); isSelSound = GUI.Toggle(toggleSoundPos, isSelSound, &quot;音效开关&quot;); // 关闭按钮 设置面板 if (GUI.Button(btnPos, &quot;&quot;, btnStyle)) &#123; // 关闭自己这个面板的功能 HideMe(); // 显示开始界面 BeginPanel.ShowMe(); &#125; &#125;&#125; 开始面板BeginPanel.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//开始面板public class BeginPanel : MonoBehaviour&#123; //面板的显示隐藏 所有地方都能够快速使用的 //静态 方法 和静态变量 就可以直接通过类名就用了 private static BeginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; //游戏标题 public Rect labPos; public GUIContent labContent; public GUIStyle labStyle; //3个游戏按钮 public Rect btn1Pos; public Rect btn2Pos; public Rect btn3Pos; public GUIStyle btnStyle; private void Awake() &#123; instance = this; &#125; private void OnGUI() &#123; //游戏标题 GUI.Label(labPos, labContent, labStyle); //3个游戏按钮 if (GUI.Button(btn1Pos, &quot;开始游戏&quot;, btnStyle)) &#123; //SceneManager.LoadScene(&quot;GameScene&quot;); LoginPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn2Pos, &quot;设置游戏&quot;, btnStyle)) &#123; //显示设置界面 SettingPanel.ShowMe(); //隐藏自己 HideMe(); &#125; if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle)) &#123; QuitTipPanel.ShowMe(); HideMe(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.文本和按钮控件","slug":"UI系统/GUI/GUI基础知识/3.文本和按钮控件","date":"2025-02-26T07:18:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/3.文本和按钮控件/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E6%96%87%E6%9C%AC%E5%92%8C%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"GUI控件绘制的共同点 他们都是GUI公共类中提供的静态函数，直接调用即可。 他们的参数都大同小异： 位置参数：Rect参数（x、y位置，w、h尺寸），左上角为坐标系原点 显示文本：string参数 图片信息：Texture参数 综合信息：GUIContent参数 （综合显示 文本，图片，tooltip） 自定义样式：GUIStyle参数 每一种控件都有多种重载，都是各个参数的排列组合。 注意： 必备的参数内容是位置信息和显示信息 GUI的原点（0,0）Rect在左上角，x向右，y向下 为正 文本控件 Label静态方法所有重载 12345678// 在屏幕上创建一个文本或纹理标签。// Label静态方法所有重载public static void Label(Rect position, string text);public static void Label(Rect position, Texture image);public static void Label(Rect position, GUIContent guiContent);public static void Label(Rect position, string text, GUIStyle style);public static void Label(Rect position, Texture image, GUIStyle style);public static void Label(Rect position, GUIContent guiContent, GUIStyle style); string参数 和 Texture参数 1234// 基本使用 传入位置信息和显示信息 显示信息可以是显示文本和图片信息GUI.Label(new Rect(100, 20, 100, 20), &quot;666666欢迎你&quot;);// public static void Label(Rect position, Texture image);GUI.Label(labelRect1, image); GUIContent 1234567// 综合使用 传入位置信息和综合信息// 综合信息GUIContent类里包括显示文本和图片信息// public static void Label(Rect position, GUIContent labelGuiContent);GUI.Label(labelRect2, guiContent);// tooltip静态变量 可以获取当前鼠标或者键盘选中的GUI控件 对应的 tooltip信息// 鼠标指针当前悬停在其上或具有键盘焦点的控件的工具提示。（只读）Debug.Log(GUI.tooltip); GUIStyle参数 字体在：C:\\Windows\\Fonts 下面 按钮控件 参数和使用方式与文本控件一毛一样 12// 按钮控件 (在按钮范围内 按下鼠标再抬起鼠标 才算一次点击 才会返回trueGUI.Button(btnRect, btnContent, btnStyle); 12345// 长按按钮控件 (只要在长按按钮范围内 按下鼠标 就会一直返回trueif (GUI.RepeatButton(btnRect, btnContent))&#123; Debug.Log(&quot;只要在长按按钮范围内 按下鼠标 就会一直返回true&quot;);&#125; 练习 请用GUI制作一个游戏开始界面，上面有开始游戏，退出游戏，设置等等按钮选项，点击开始游戏可以切换到游戏场景 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using UnityEngine;public class StartMenu : MonoBehaviour&#123; // 游戏标题 public Rect labPos; public GUIContent labContent; public GUIStyle labStyle; // 三个按钮位置和样式 public Rect btn1Pos; public Rect btn2Pos; public Rect btn3Pos; public GUIStyle btnStyle; void OnGUI() &#123; // 渲染游戏标题 GUI.Label(labPos, labContent, labStyle); // 渲染三个按钮 if (GUI.Button(btn1Pos, &quot;开始游戏&quot;, btnStyle)) &#123; // 点击开始游戏按钮事件处理 // SceneManager.LoadScene(&quot;GameScene&quot;); LoginPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn2Pos, &quot;设置游戏&quot;, btnStyle)) &#123; // 点击设置游戏按钮事件处理 SettingPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle)) &#123; // 点击退出游戏按钮事件处理 QuitTipPanel.ShowMe(); HideMe(); &#125; &#125; // 隐藏当前界面 void HideMe() &#123; gameObject.SetActive(false); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.GUI工作原理与主要作用","slug":"UI系统/GUI/GUI基础知识/2.GUI工作原理与主要作用","date":"2025-02-26T07:09:04.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/2.GUI工作原理与主要作用/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.GUI%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/","excerpt":"","text":"GUI是什么 GUI，即即时模式游戏用户交互界面（IMGUI），在Unity中一般简称为GUI。它是一个代码驱动的UI系统。 GUI的主要作用 作为程序员的调试工具，创建游戏内调试工具。 为脚本组件创建自定义检视面板。 创建新的编辑器窗口和工具以拓展Unity本身（一般用作内置游戏工具）。 注意： 不要用它为玩家制作UI功能。 GUI的工作原理 在继承MonoBehaviour的脚本中的特殊函数OnGUI里调用GUI提供的方法，类似生命周期函数。 1234private void OnGUI()&#123; //在其中书写 GUI相关代码 即可显示GUI内容&#125; OnGUI函数注意事项 它每帧执行，相当于是用于专门绘制GUI界面的函数。 一般只在其中执行GUI相关界面绘制和操作逻辑。 该函数在OnDisable之前，LateUpdate之后执行。 生命周期函数 只要是继承Mono的脚本，都可以在OnGUI中绘制GUI。","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.GUI概述","slug":"UI系统/GUI/GUI基础知识/1.GUI概述","date":"2025-02-26T07:05:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/1.GUI概述/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.GUI%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"13.打包PlayerPrefsDataMgr","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/13.打包PlayerPrefsDataMgr","date":"2025-02-24T03:14:19.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/13.打包PlayerPrefsDataMgr/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/13.%E6%89%93%E5%8C%85PlayerPrefsDataMgr/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; else &#123; // 如果value的类型是自定义类型 Save(value, key); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; object v = Activator.CreateInstance(type); // 填充数据 FieldInfo[] fieldInfos = type.GetFields(); string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;type.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; // 和存储的一样 fieldInfo.SetValue(v, LoadValue(fieldInfo.FieldType, keyName)); &#125; return v; &#125; private object LoadValue(Type fieldType, string key) &#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return Load(fieldType, key); &#125; &#125;&#125; 右键PlayerPrefsDataMgr文件，导出包","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.加密思路","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/12.加密思路","date":"2025-02-24T03:07:58.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/12.加密思路/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/12.%E5%8A%A0%E5%AF%86%E6%80%9D%E8%B7%AF/","excerpt":"","text":"找不到 把存在硬盘上的内容放在一个不容易找到的地方多层文件夹包裹 名字辨识度低 但是对于PlayerPrefs不太适用因为位置已经固定了 我们改不了 看不懂 让数据的Key和Value让别人看不懂俗称加密 为Key和Value加密 解不出 不让别人获取到你加密的规则就解不出来了 注意 单机游戏加密只是提高别人修改你数据的门槛只要别人获取到你的源代码 知道你的加密规则 一切都没有任何意义 但是对于一般玩家来说几乎是不可能的事情 eg: 存的时候按照一定规则来存储 123456789if (fieldType == typeof(int))&#123; Log(&quot;存储int:&quot; + keyName + &quot;值 = &quot; + (int)value); //为int数据加密 int rValue = (int)value; rValue += 10; PlayerPrefs.SetInt(keyName, rValue);&#125; 读取的时候按一定规则来读 123456if( fieldType == typeof(int) )&#123; Log(&quot;读取int:&quot; + keyName + &quot;值 = &quot; + (PlayerPrefs.GetInt(keyName, 0) - 10)); //解密 减10 return PlayerPrefs.GetInt(keyName, 0) - 10;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.反射读取自定义类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/11.反射读取自定义类型","date":"2025-02-24T02:56:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/11.反射读取自定义类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/11.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return Load(fieldType, key); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"10.反射读取Dictionary数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/10.反射读取Dictionary数据类型","date":"2025-02-24T02:52:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/10.反射读取Dictionary数据类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/10.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96Dictionary%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"9.反射读取List数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/9.反射读取List数据类型","date":"2025-02-24T02:45:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/9.反射读取List数据类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/9.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"8.反射读取常用成员数据","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/8.反射读取常用成员数据","date":"2025-02-24T02:40:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/8.反射读取常用成员数据/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/8.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1234567891011121314public object Load(Type type, string key) &#123; object v = Activator.CreateInstance(type); FieldInfo[] fieldInfos = type.GetFields(); string loadKey = null; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; FieldInfo tmp = fieldInfos[i]; loadKey = $&quot;&#123;key&#125;_&#123;type.Name&#125;_&#123;tmp.FieldType.Name&#125;_&#123;tmp.Name&#125;&quot;; // 给v对象的字段赋值 tmp.SetValue(v, LoadValue(tmp.FieldType, loadKey)); &#125; return v; &#125; 1234567891011121314151617181920212223242526// 得单个数据private object LoadValue(Type fieldType, string key)&#123; //object v = Activator.CreateInstance(fieldType); // 根据字段类型调用不同API if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, null); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key) == 1; &#125; else &#123; return null; &#125;&#125; 12// 测试代码Player p = PlayerPrefsDataMgr.Instance.Load(typeof(Player), &quot;player&quot;) as Player;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"7.反射存储自定义类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/7.反射存储自定义类型","date":"2025-02-22T02:58:33.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/7.反射存储自定义类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/7.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"SaveData本来就是存储自定义类 12345else&#123; // 如果value的类型是自定义类型 Save(value, key);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); Debug.Log(key + &quot;_key_&quot; + index.ToString()); Debug.Log(key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; else &#123; // 如果value的类型是自定义类型 Save(value, key); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"6.反射存储Dictionary数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/6.反射存储Dictionary数据类型","date":"2025-02-22T02:46:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/6.反射存储Dictionary数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/6.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8Dictionary%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"类似反射存储List数据类型 123456789101112else if (typeof(IDictionary).IsAssignableFrom(value.GetType()))&#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"5.反射存储List数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/5.反射存储List数据类型","date":"2025-02-22T02:38:46.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/5.反射存储List数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/5.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"普通数据存储画风 1234if (value is int)&#123; PlayerPrefs.SetInt(key, (int)value);&#125; List数据存储画风 12345678910if (typeof(IList).IsAssignableFrom(value.GetType()))&#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"4.反射存储常用数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/4.反射存储常用数据类型","date":"2025-02-22T02:23:22.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/4.反射存储常用数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;keyName_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; Debug.Log(keyN ame); &#125; &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"3.数据管理类的创建","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/3.数据管理类的创建","date":"2025-02-22T01:48:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/3.数据管理类的创建/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"123456789101112131415161718192021public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.需求分析","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/2.需求分析","date":"2025-02-22T01:05:48.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/2.需求分析/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.反射知识补充","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/1.反射知识补充","date":"2025-02-22T00:43:30.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/1.反射知识补充/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%8F%8D%E5%B0%84%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"","text":"反射知识回顾 反射3剑客—— 1T 两 A Type —— 用于获取类的所有信息，包括字段、属性、方法等等 Assembly —— 用于获取程序集，通过程序集获取Type Activator —— 用于快速实例化对象 csharp反射 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom 12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments 12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"csharp反射","slug":"编程语言/Csharp/csharp反射","date":"2025-02-21T12:55:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/编程语言/Csharp/csharp反射/","permalink":"http://example.com/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Csharp源代码到运行时主要阶段 在 C# 中，从源代码到运行时的整个过程可以分为以下主要阶段： 1源代码(.cs) → 编译 → IL/程序集(.exe/.dll) → CLR加载 → JIT编译 → 本机代码 → 执行 源代码阶段： 编写源代码： 开发者编写 C# 源代码文件（.cs）。 编译阶段： 编译： 使用 C# 编译器（csc.exe）将源代码编译为中间语言（IL，Intermediate Language）代码。生成的文件通常是一个扩展名为 .exe（可执行文件）或 .dll（动态链接库）的程序集。 生成[[元数据]]： 编译过程中，生成包含程序集信息的[[元数据]]，包括类型、成员、版本等信息。 JIT 编译阶段： JIT 编译： 在运行时，Common Language Runtime（CLR）的 JIT 编译器负责将 IL 代码编译为本地机器代码。这一步是在程序加载到内存时进行的，即时（Just-In-Time）编译。 执行阶段： 加载程序集： CLR 加载编译好的程序集，包括 IL 代码和[[元数据]]。 执行程序： 程序在 CLR 中执行，JIT 编译器将 IL 代码转换为本地机器代码。执行过程中，CLR 负责内存管理、类型检查、垃圾回收等任务。 总结： 开发者阶段： 编写源代码。 编译阶段： 编译源代码生成 IL 代码和[[元数据]]。 JIT 编译阶段： 在运行时将 IL 代码编译为本地机器代码。 执行阶段： 加载程序集，执行程序，CLR 负责管理运行时环境。 编译 vs 运行 编译期 运行时 发生时间 发生在构建过程中，源代码被翻译为目标代码或中间代码。 发生在程序实际运行时，加载到内存并执行。 可能出现的错误 静态检查错误，如语法错误、类型错误等。 动态运行时错误，如空指针引用、除零错误等。 排查难度 错误信息清晰，易于定位和修复。 错误可能更难以排查，需要使用调试工具进行追踪。 无运行时 有运行时 内存管理 程序员需要手动管理内存分配和释放。 运行时环境负责内存管理，可能包括自动内存分配和垃圾回收。 线程模型 通常依赖操作系统提供的线程机制。 可能提供自己的线程管理机制，与操作系统的线程模型有一定差异。 系统调用 直接使用操作系统提供的系统调用接口。 通过运行时环境提供的接口进行系统调用，可能会屏蔽一些底层细节。 运行效率 对于底层硬件和操作系统有更直接的控制。 需要运行时环境的支持，可能引入一些开销。 动态库 vs. 静态库 - 编译和链接阶段： 阶段 静态库 动态库 定义 静态库是在编译时被链接到程序的库，代码在程序编译阶段就被静态地合并。 态库是在运行时加载到内存的库，它的代码在程序执行时被动态地链接。 文件格式 .lib（Windows）或 .a（Unix/Linux） .dll（Windows）或 .so（Unix/Linux） 编译和链接阶段 静态库的代码在编译时被整合到程序中 编译时不包含库的代码，只在链接时引用库的符号 作用 提供独立的代码副本，每个程序有自己的库的实例，适用于没有外部库的环境 节省内存，允许在运行时替换库的版本，减小程序的可执行文件大小 动态库 vs. 静态库 - 区别和使用场景： 特点 静态库 动态库 链接方式 链接在编译时 链接在运行时 内存占用 每个程序有自己的库的实例，可能占用更多内存 共享内存，多个程序可以共享同一个动态库的实例 更新和维护 需要重新编译整个程序，更新较为繁琐 可在运行时替换库的版本，更容易更新 可执行文件大小 可执行文件较大，因为库的代码在编译时合并到可执行文件中 可执行文件较小，因为库的代码在运行时加载 反射 程序正在运行时，可以查看其它[[程序集]]或者自身的[[元数据]]。 一个运行的程序查看本身或者其它程序的[[元数据]]的行为就叫做反射 在程序运行时，通过反射可以得到其它[[程序集]]或者自己[[程序集]]代码的各种信息 类，函数，变量，对象等等，实例化它们，执行它们，操作它们 exe/dll(主要区别是exe有入口) metadata: 描述dll/exe文件的一个 数据清单 反射: 用来操作获取[[元数据]] 就是一个操作metadata的一个类库, 用来操作[[元数据]]中的**类, 方法, 属性, [[csharp特性]], ** 为什么通过反射去间接操作? 我们需要动态 (这些 “动态” 操作都是在运行时期根据运行时的信息来进行的，而不是在编译时期就确定好的。这使得程序更加灵活，能够处理一些在编译时难以确定的情况。) 读取私有的对象 Type（类的信息类） 它是反射功能的基础！ 它是访问[[元数据]]的主要方式。 使用 Type 的成员获取有关类型声明的信息 有关类型的成员（如构造函数、方法、字段、属性和类的[[事件]]） 1234567int a = 32;Type t1 = a.GetType();Type t2 = typeof(int);// 必须要包含命名空间.类名Type t3 = Type.GetType(&quot;System.Int32&quot;);// 每一个类只有一份元数据, 所以上面的t1, t2, t3 指向的是同一个堆空间 获取所有公共成员 （GetMembers 成员包括：成员变量，成员函数等等 1234567891011121314151617181920212223class Test&#123; private int i = 0; public int j = 1; public string str = &quot;hello world&quot;; public Test() &#123; &#125; public Test(int i) &#123; this.i = i; &#125; public Test(int i, string s) : this(i) &#123; this.str = s; &#125; public void Fun() &#123; Console.WriteLine(str); &#125;&#125;Type t = typeof(Test);MemberInfo[] memberInfos = t.GetMembers();for (int i = 0; i &lt; memberInfos.Length; i++) Console.WriteLine(memberInfos[i]); 获取类所有的公共构造函数并调用 （GetConstructors 1234567891011121314151617// 所有公共构造函数ConstructorInfo[] ctors = t.GetConstructors();// 得构造函数传入 Type数组 数组中内容按顺序是参数类型// 执行构造函数传入 object数组 表示按顺序传入的参数// 无参构造获取Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[0]);Test test = constructorInfo.Invoke(null) as Test;// 有参构造获取 获取一个参数为int的构造函数Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[1] &#123; typeof(int) &#125;);Test test = constructorInfo.Invoke(new object[1] &#123; 666 &#125;) as Test; 获取类所有公共成员变量 （GetFields FieldInfo 类是 .NET 反射中的一个类，用于表示和操作类或结构体的字段信息。字段是类或结构体中的成员变量，通常用于存储对象的状态。FieldInfo 类提供了访问字段的[[元数据]]和运行时值的方法。 以下是一些 FieldInfo 类的常用属性和方法： 属性： Name: 获取字段的名称。 FieldType: 获取字段的类型。 IsPublic, IsPrivate, IsStatic, IsInitOnly: 判断字段的访问修饰符和其他属性。 DeclaringType: 获取定义该字段的类的 Type 对象。 方法： GetValue(object obj): 获取指定对象上的字段值。需要传递目标对象的实例作为参数。 SetValue(object obj, object value): 设置指定对象上的字段值。需要传递目标对象的实例和要设置的值作为参数。 以下是一个简单的示例，演示如何使用 FieldInfo 获取和操作字段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 得到所有公共成员变量Type t = typeof(Test);FieldInfo[] fieldInfos = t.GetFields();// 得到指定名称的公共成员Type t = typeof(Test);FieldInfo fieldInfo = t.GetField(&quot;str&quot;);// 通过反射 获取其它程序集的对象的某个成员变量的值// 假设下面的Test是其他程序集new出来的, Test.str = &quot;wocao&quot;Test test = new Test(999, &quot;wocao&quot;);Console.WriteLine(fieldInfo.GetValue(test)); // 获取到test.str // 通过反射 设置其它程序集的对象的某个成员变量的值 第一个参数是想要通过反射操作的对象!fieldInfo.SetValue(test, &quot;hello world&quot;);Console.WriteLine(fieldInfo.GetValue(test));using System;using System.Reflection;public class MyClass&#123; public int PublicField; private string PrivateField; public MyClass(int value) &#123; PublicField = value; PrivateField = &quot;PrivateFieldValue&quot;; &#125;&#125;class Program&#123; static void Main() &#123; Type myClassType = typeof(MyClass); // 获取字段信息 FieldInfo publicFieldInfo = myClassType.GetField(&quot;PublicField&quot;); FieldInfo privateFieldInfo = myClassType.GetField(&quot;PrivateField&quot;, BindingFlags.NonPublic | BindingFlags.Instance); // 创建 MyClass 实例 MyClass myObject = new MyClass(42); // 读取和修改字段的值 int publicFieldValue = (int)publicFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PublicField value: &#123;publicFieldValue&#125;&quot;); privateFieldInfo.SetValue(myObject, &quot;NewPrivateFieldValue&quot;); string privateFieldValue = (string)privateFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PrivateField value: &#123;privateFieldValue&#125;&quot;); &#125;&#125; 获取了所有公共成员函数 （GetMethods 1234567891011121314151617181920212223242526272829303132333435363738394041// 获取所有公共成员函数并执行Type t = typeof(string);MethodInfo[] methodInfos = t.GetMethods();for (int i = 0; i &lt; methodInfos.Length; i++) Console.WriteLine(methodInfos[i]);// 获取特定名称的公共成员函数MethodInfo methodInfo = t.GetMethod(&quot;Substring&quot;, new Type[] &#123; typeof(int), typeof(int) &#125;);// 执行该方法string str = &quot;hello world&quot;;// 第一个参数是想要通过反射操作的对象 相当于 对象.XX 如果是静态就传 null str = methodInfo.Invoke(str, new object[] &#123; 0, 5 &#125;) as string;Console.WriteLine(str);Type myClassType = typeof(MyClass);// 获取所有公共方法MethodInfo[] publicMethods = myClassType.GetMethods();// 输出方法信息foreach (MethodInfo methodInfo in publicMethods)&#123; Console.WriteLine($&quot;Method Name: &#123;methodInfo.Name&#125;&quot;); Console.WriteLine($&quot;Return Type: &#123;methodInfo.ReturnType&#125;&quot;); // 获取方法的参数信息 ParameterInfo[] parameters = methodInfo.GetParameters(); Console.Write(&quot;Parameters: &quot;); foreach (ParameterInfo parameter in parameters) &#123; Console.Write($&quot;&#123;parameter.ParameterType&#125; &#123;parameter.Name&#125; &quot;); &#125; Console.WriteLine(); Console.WriteLine();&#125; 其它 type.GetXXX 1234567891011121314151617//得枚举GetEnumNameGetEnumNames//得事件GetEventGetEvents//得接口GetInterfaceGetInterfaces//得属性GetPropertyGetPropertys//等等 快速通过反射实例化对象 Activator 使用 Activator 类的主要优势在于在运行时创建对象，尤其是当不知道具体类型的情况下。然而，需要注意的是，使用 Activator 可能会导致性能损失，因为它依赖于反射机制。在已知类型的情况下，直接使用 new 操作符通常是更好的选择。 12345// 快速将Type实例化为对象 无参构造Type t = typeof(Test);Test test = Activator.CreateInstance(t) as Test;// 有参构造 后面参数如果不对会报错test = Activator.CreateInstance(t, 666, &quot;wocao&quot;) as Test; Assembly [[程序集]]类Assembly: 主要用来加载其它[[程序集]]，加载后 才能用Type来使用其它[[程序集]]中的信息 如果想要使用不是自己[[程序集]]中的内容 需要先加载[[程序集]] 比如 dll文件(库文件) 简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类 三种加载[[程序集]]的函数: 一般用来加载在同一文件下的其它[[程序集]] Assembly asembly2 = Assembly.Load(“[[程序集]]名称”); 一般用来加载不在同一文件下的其它[[程序集]] Assembly asembly = Assembly.LoadFrom(“包含[[程序集]]清单的文件的名称或路径”); Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”); 12345Assembly assembly = Assembly.LoadFrom(@&quot;D:\\\\Myproject VS\\\\静态\\\\bin\\\\Debug\\\\net8.0\\\\test.dll&quot;);Type[] types = assembly.GetTypes();Type t = assembly.GetType(&quot;test.Icon&quot;);t.XXX 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom 12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments 12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"4.PlayerPrefs总结","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结","date":"2025-02-21T12:27:02.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/","excerpt":"","text":"练习 要在游戏中做一个排行榜功能，排行榜主要记录玩家名（可重复）,玩家得分，玩家通关时间，请用PlayerPrefs存储读取排行榜相关信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/// &lt;summary&gt;/// 排行榜多条具体信息/// &lt;/summary&gt;public class RankListInfo&#123; //排行榜单条信息列表 public List&lt;RankInfo&gt; rankList; //初始化的时候就是读取数据 public RankListInfo() &#123; Load(); &#125; /// &lt;summary&gt; /// 新加排行榜信息 /// &lt;/summary&gt; public void Add(string name, int score, int time) &#123; rankList.Add(new RankInfo(name, score, time)); &#125; //存储数据 public void Save() &#123; //存储有多少条数据 PlayerPrefs.SetInt(&quot;rankListCount&quot;, rankList.Count); for (int i = 0; i &lt; rankList.Count; i++) &#123; RankInfo info = rankList[i]; PlayerPrefs.SetString(&quot;rankInfo&quot; + i, info.playerName); PlayerPrefs.SetInt(&quot;rankScore&quot; + i, info.playerScore); PlayerPrefs.SetInt(&quot;rankTime&quot; + i, info.playerTime); &#125; &#125; //读取数据 private void Load() &#123; int rankListCount = PlayerPrefs.GetInt(&quot;rankListCount&quot;, 0); rankList = new List&lt;RankInfo&gt;(); for (int i = 0; i &lt; rankListCount; i++) &#123; RankInfo info = new RankInfo( PlayerPrefs.GetString(&quot;rankInfo&quot; + i), PlayerPrefs.GetInt(&quot;rankScore&quot; + i), PlayerPrefs.GetInt(&quot;rankTime&quot; + i)); rankList.Add(info); &#125; &#125;&#125;/// &lt;summary&gt;/// 排行榜单条信息/// &lt;/summary&gt;public class RankInfo&#123; public string playerName; public int playerScore; public int playerTime; public RankInfo(string name, int score, int time) &#123; playerName = name; playerScore = score; playerTime = time; &#125;&#125;#endregionpublic class Lesson03_练习题 : MonoBehaviour&#123; void Start() &#123; //初始化一个排行榜 RankListInfo rankListInfo = new RankListInfo(); print(rankListInfo.rankList.Count); //打印排行榜所有信息 for (int i = 0; i &lt; rankListInfo.rankList.Count; i++) &#123; print(&quot;姓名&quot; + rankListInfo.rankList[i].playerName); print(&quot;分数&quot; + rankListInfo.rankList[i].playerScore); print(&quot;时间&quot; + rankListInfo.rankList[i].playerTime); &#125; //添加排行榜单条信息保存 rankListInfo.Add(&quot;nihao&quot;, 100, 66); rankListInfo.Save(); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.PlayerPrefs不同平台的存储位置","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置","date":"2025-02-21T12:09:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.PlayerPrefs%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"PlayerPrefs存储的数据存在哪里？ 在不同平台上，PlayerPrefs存储的位置会有所不同： PlayerPrefs的存储位置 Windows： PlayerPrefs 存储在注册表（regedit）中。具体位置为： 32位系统：HKEY_CURRENT_USER\\Software\\[公司名]\\[产品名] 64位系统：HKEY_CURRENT_USER\\Software\\WOW6432Node\\[公司名]\\[产品名] Android： 在Android上，PlayerPrefs 存储在应用的持久数据目录中。具体路径为：/data/data/[包名]/shared_prefs/unity.[公司名].[产品名]_prefs.xml。 Linux： 在Linux上，PlayerPrefs 存储在用户主目录的 .config/unity3d/[公司名]/[产品名]/prefs 目录中。 iOS： 在iOS上，PlayerPrefs 存储在应用的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。 macOS： 在macOS上，PlayerPrefs 存储在用户主目录的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.PlayerPrefs基本方法","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法","date":"2025-02-21T11:49:40.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.PlayerPrefs%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/","excerpt":"","text":"PlayerPrefs是什么 PlayerPrefs是Unity提供的可以用于存储读取玩家数据的公共类。 PlayerPrefs，你可以轻松地存储和获取一些简单的数据，例如玩家的分数、游戏设置、解锁的关卡等。这些数据将在应用程序关闭后仍然保留，可以在下次启动应用程序时继续使用。 PlayerPrefs的数据存储 PlayerPrefs的数据存储类似于键值对存储，一个键对应一个值。 提供了存储3种数据的方法 int float string。 键: string类型。 值：int float string 对应3种API。 SetInt方法 SetFloat方法 SetString方法 存储数据 1234//设置由 key 标识的偏好的值。PlayerPrefs.SetInt(&quot;第几帅&quot;, 1);PlayerPrefs.SetFloat(&quot;存个浮点数&quot;, 1.1f);PlayerPrefs.SetString(&quot;黄&quot;, &quot;先生&quot;); Save方法 马上存储数据到硬盘中 直接调用Set相关方法只会把数据存到内存里。 当游戏结束时 Unity会自动把数据存到硬盘中。 如果游戏不是正常结束的而是崩溃 数据是不会存到硬盘中的。 调用该方法马上存到硬盘(各个平台默认位置) 1PlayerPrefs.Save(); PlayerPrefs局限性 1234//PlayerPrefs是有局限性的 它只能存3种类型的数据。//如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储。bool sex = true;PlayerPrefs.SetInt(&quot;sex&quot;, sex ? 1 : 0); 如果不同类型用同一键名进行存储 会进行覆盖 12PlayerPrefs.SetInt(&quot;myAge&quot;, 18);PlayerPrefs.SetFloat(&quot;myAge&quot;, 20.2f);//覆盖上一行存储的myAge数据 读取相关 12// 如果填了第二个参数代表没找到就返回后的默认值, 可用来进行基础数据的初始化string test = PlayerPrefs.GetString(&quot;黄&quot;); 注意： 运行时只要你Set了对应键值对 即使你没有马上存储Save在本地 也能够读取出信息 如果存的是SetInt(&quot;myAge&quot;， 18); 读取的是GetFloat(&quot;myAge&quot;);则会使用Float默认值0 键的存在与删除 12345678if (PlayerPrefs.HasKey(&quot;测试&quot;))&#123; // 删除 // 根据键来删除 PlayerPrefs.DeleteKey(&quot;测试&quot;); // 删除所有键值对 PlayerPrefs.DeleteAll();&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.PlayerPrefs概述","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述","date":"2025-02-21T11:42:51.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"34.unity入门基础知识总结","slug":"游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结","date":"2025-02-21T08:54:06.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"33.Microphone麦克风","slug":"游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风","date":"2025-02-21T08:21:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.Microphone%E9%BA%A6%E5%85%8B%E9%A3%8E/","excerpt":"","text":"Unity提供了Microphone类 获取设备信息 1234// 获取设备Microphone信息string[] strs = Microphone.devices;for (int i = 0; i &lt; strs.Length; i++) print(strs[i]); 开始, 结束录制并存储 12345678910111213141516171819202122232425// 开始录制 (1. 设备名 传null使用默认设备, 2. 超过录制长度是否重新录制// (3. 录制时长, 4. 采样率if (Input.GetKeyDown(KeyCode.Space))&#123; _audioClip = Microphone.Start(null, false, 10, 44100);&#125;// 结束录制if (Input.GetKeyUp(KeyCode.Space))&#123; // 为null表示默认设备 Microphone.End(null); // 播放录制音频 AudioSource audio = GetComponent&lt;AudioSource&gt;() ?? gameObject.AddComponent&lt;AudioSource&gt;(); audio.clip = _audioClip; audio.Play(); //AudioClip类的channels变量和samples变量 //channels变量 音频剪辑中的声道数。（只读） //samples变量 样本中音频剪辑的长度。（只读） //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[_audioClip.channels * _audioClip.samples]; // 把数据存储到浮点数数组里 第二个参数是偏离的位置, 默认填0 _audioClip.GetData(f, 0);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"32.AudioSource音频源代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制","date":"2025-02-21T07:58:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"代码控制播放停止 12345678910111213141516171819202122232425_audioSource = GetComponent&lt;AudioSource&gt;();// 按下p键播放if (Input.GetKeyDown(KeyCode.P))&#123; _audioSource.Play(); //_audioSource.PlayDelayed(4); // 4秒后播放&#125;// 音频停止if (Input.GetKeyDown(KeyCode.S))&#123; _audioSource.Stop();&#125;// 音频暂停 if (Input.GetKeyDown(KeyCode.Space))&#123; _audioSource.Pause(); //_audioSource.UnPause();再次播放可恢复 (或者使用停止暂停&#125;// 音量大小audioSource.volume = floatValue;// 是否静音audioSource.mute = true 检测播放是否完毕 AudioSource没有提供相关 12345// 检测音频是否播放完 if (!_audioSource.isPlaying)&#123; print($&quot;在Update中不断检测该属性可以判断是否播放完毕&quot;);&#125; 控制音频播放几种方式 直接在要播放音频的对象上挂载脚本来控制 自己创建一个挂载了音频脚本的GameObject(放在prefab预设体里) 用得少 在其他脚本中实例化(如果playOnAwake实例化时播放) 这个对象 用一个AudioSource来控制不同的音效 _audioSource.clip = XXX（AudioClip) ps: 注意: 一个GameObject可以挂载多个音频源脚本AudioSource, 但一定要自己管理好, 不然谁是谁都不知道","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"31.AudioSource音频源组件和AudioListener音频监听组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件","date":"2025-02-21T07:31:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/","excerpt":"","text":"添加AudioSource 音频源脚本 AudioClip 声音剪辑文件（音频文件） 可以拖拽音频文件到这个变量上 Output 输出* 默认不设置的话将直接输出到场景中的音频监听器 可以更改为输出到混音器 混音器是高级功能，以后再讲解 Mute 静音开关 Bypass Effect 开关滤波器效果* Bypass Listener Effects 快速开关所有监听器* Bypass Reverb Zones 快速开关所有混响区* Play On Awake 唤醒时播放 对象创建时就播放音乐 开启的话启动游戏默认就播放 关闭的话启动游戏默认就不播放 Loop 循环 循环播放音乐，一般背景音乐才用 Priority 优先级 优先级越高，越不容易被别的音效覆盖 Volume 音量大小 Pitch 音调 可以理解为音乐快放满房 Stereo Pan 立体声效 2D声音立体声位置 相当于左右声道 Spatial Blend 空间混合 音频受3D空间的影响程度，默认是2D音效，拖满为1变成3D音效 Reverb Zone Mix 混响区混音* 到混响区的输出信号量 3D Sound Settings 3D声音设置 和Spatial Blend参数成正比应用 Doppler Level 多普勒效果等级 Spread 扩张 扩散角度设置为3D立体声还是多声道 Volume Rolloff 音量衰减 声音衰减速度，蓝线横轴可以理解为离耳朵的远近，红线纵轴可以理解为声音大小，耳朵可以理解为AudioListener音频监听脚本 Logarithmic Rolloff 对数衰减 靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff 线性衰减 与音频源的距离越远，听到的声音越小。 Custom Rolloff 自定义衰减 音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance 最大最小距离 最小距离内，声音保持最大响度 最大距离外，声音开始减弱 AudioListener 音频监听脚本 默认挂载到场景的主摄像机上，可以理解为是我们的耳朵 有且只有一个，两个把另外一个要移除","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"30.音频文件导入","slug":"游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入","date":"2025-02-20T15:03:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/","excerpt":"","text":"音频文件常用格式 wav mp3 ogg aiff （不常用） 导入音频文件 导入音频文件直接从外部拖拽音频文件到Project窗口即可 Force To Mono 强制变为单声道 多声道转单声道 Normalize 归一化 强制为单声道时，混合过程中被标准化 Load In Background 后台加载 在后台加载，不阻塞主线程 Ambisonic 全景声音* 立体混响声 非常适合 360 度视频和 XR 应用程序 如果音频文件包含立体混响声编码的音频，请启用此选项 LoadType 加载类型 Decompress On Load 加载时压缩 不压缩形式存在内存，加载块，但是内存占用高 适用于小音效 Compress in memory 压缩内存 压缩形式存在内存，加载慢，内存小 仅适用于较大音效文件 Streaming 流式处理 以流形式存在，使用时解码。内存占用最小，cpu消耗高 性能换内存 Preload Audio Data 预加载音频数据 预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format 压缩格式 PCM 音频以最高质量存储 Vorbis 相对PCM压缩的更小，根据质量决定 ADPCM 包含噪音，会被多次播放的声音，如碰撞声 Quality 音频质量* 确定要应用于压缩剪辑的压缩量。 不适用于 PCM/ADPCM/HEVAG 格式 Sample Rate Setting 采样率设置* PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率 Preserve Sample Rate 保持采样率 此设置可保持采样率不变（默认值） Optimize Sample Rate 优化采样率 此设置根据分析的最高频率内容自动优化采样率 Override Sample Rate 覆盖采样率 此设置允许手动覆盖采样率 因此可有效地将其用于丢弃频率内容。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"29.刚体加力","slug":"游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力","date":"2025-02-20T12:09:49.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/","excerpt":"","text":"刚体加力 12345678910111213141516171819202122// 获取刚体组件对象rigidbody = this.GetComponent&lt;Rigidbody&gt;();// 添加力// (相对世界坐标系rigidbody.AddForce(Vector3.forward * 10);// (相对本地坐标系rigidbody.AddRelativeForce(Vector3.forward * 10);// 添加扭矩力// (世界坐标系 // 没有扭矩阻力会一直动rigidbody.AddTorque(Vector3.up * 10);// (本地坐标系rigidbody.AddRelativeTorque(Vector3.forward * 10);// 改变刚体速度 用的少, 位移一般用translate或者给力// 世界坐标系rigidbody.velocity = Vector3.forward;// 模拟爆炸 在中心产生半径 20m 40的力// 如果想要所有刚体都产生同样的爆炸效果就必须所有的刚体组件都要调用AddExplosionForce方法rigidbody.AddExplosionForce(40, Vector3.zero, 20); AddForce方法第二个参数力的模式 1. ForceMode.Force（默认模式） 公式：F * t = m * v 说明： 力会持续作用，受物体质量（mass）影响，质量越大加速度越小。 需要乘以 Time.fixedDeltaTime 才能与物理时间步长匹配（Unity 已自动处理）。 示例： 123// 推动质量为2kg的物体，每帧施加10N的力rb.AddForce(Vector3.forward * 10, ForceMode.Force);// 最终加速度 = 10N / 2kg = 5m/s² 2. ForceMode.Acceleration 公式：F * t = v （m 为 1） 说明： 直接施加加速度，忽略物体质量。 适合需要固定加速度的场景（如模拟重力）。 示例： 12// 无论质量如何，物体以5m/s²的加速度运动rb.AddForce(Vector3.forward * 5, ForceMode.Acceleration); 3. ForceMode.Impulse 公式：F = m * v （t 为 1） 说明： 瞬间施加一个冲量，效果类似“一次性爆发力”。 受质量影响，质量越大效果越弱。 123// 施加一个冲量为100N·s的力（相当于100N的力作用1秒）rb.AddForce(Vector3.up * 100, ForceMode.Impulse);// 质量为2kg时，速度增量 = 100 / 2 = 50m/s 4. ForceMode.VelocityChange 公式：F = v （m 为 1， t 为 1） 说明： 直接修改速度，忽略质量和时间步长。 效果类似“瞬间设置速度”。 示例： 12// 直接将物体的Y轴速度增加10m/s（无视质量）rb.AddForce(Vector3.up * 10, ForceMode.VelocityChange); 恒力场组件 刚体的休眠 Unity为了节约性能，可能会让刚体休眠。 比如让一个有刚体的Cube，受重力影响掉落一个平面上。 当他们静止时，斜向下旋转刚体，这个时候Cube可能不会往下落，因为Cube休眠了。 假如这个时候移动一下平面的位置，Cube可能又会往下落，因为移动平面唤醒了刚体。 12345678910// IsSleeping方法 获取刚体是否处于休眠状态if (rigidBody.IsSleeping())&#123;&#125;// 唤醒休眠if (rigidBody.IsSleeping())&#123; rigidBody.WakeUp();&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"28.碰撞检测之碰撞检测函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数","date":"2025-02-20T11:22:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/","excerpt":"","text":"注意:碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用 ps： 只要挂载的对象能和其它物体产生碰撞检测才会响应下面的函数 如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的，必须挂载到这个刚体父对象上才行。 物理碰撞检测响应函数 12345678910111213141516171819202122232425262728293031private void OnCollisionEnter(Collision collision)&#123; // Collision类 (碰撞信息类 // 碰撞到的对象碰撞器的信息 Collider collider1 = collision.collider; // 碰撞到的对象的所依附的对象 (GameObject) GameObject gameObject1 = collision.gameObject; // 碰撞到的对象的transform组件信息 Transform transform1 = collision.transform; // 触碰点数相关 接触点具体坐标 ContactPoint[] contacts = collision.contacts; print($&quot;我被&#123;collision.gameObject.name&#125;碰撞到了&quot;);&#125;// 碰撞结束分离时, 自动执行private void OnCollisionExit(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;碰撞分离了&quot;);&#125;// 两个物体相互摩擦时会不停调用该函数private void OnCollisionStay(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;一直在产生摩擦&quot;);&#125; 触发器检测响应函数 1234567891011121314151617// 触发开始时会自动调用该函数 (传入的是Collider脚本对象)private void OnTriggerEnter(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;触发了&quot;);&#125;// 当Stay结束时调用private void OnTriggerExit(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;结束触发了&quot;);&#125;// 当两触发器相交会不停调用private void OnTriggerStay(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;水乳相融&quot;);&#125; 碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑 一般会把想要重写的碰撞和触发检测函数写成protected保护类型的，加上virtual变成虚函数。 没有必要写成public，因为不会自己手动调用碰撞和触发检测函数，都是Unity通过反射帮助我们自动调用的。 小练习 在之前Input和Screen中的练习题基础上，加入一个点击鼠标左键可以发射一颗子弹飞出的功能 给坦克添加一个炮口空物体当做子弹飞出来的位置 添加点击飞出子弹代码，创建子弹预设体，拖拽赋值炮口空物体和子弹预设体 12345678910//Update内 if (Input.GetMouseButtonDown(0)) &#123; //实例化一个子弹对象 GameObject obj = Instantiate(bulletObj); //设置对象的位置 obj.transform.position = bulletPos.position; //设置对象的角度 obj.transform.eulerAngles = bulletPos.eulerAngles; &#125; 子弹一直飞 12//Update内 //子弹一直往前飞 this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); 加入子弹触碰到地面会自动消失的功能 123456789101112131415private void OnTriggerEnter(Collider other)&#123; //问题一：如果发射子弹时 和坦克自身的碰撞和重合了 可能一开始 就会被移除 //解决方案：判断自己碰撞到的对象 是什么 一定是特定对象 才移除自己 if (other.gameObject.CompareTag(&quot;Ground&quot;) || other.gameObject.CompareTag(&quot;Monster&quot;)) &#123; //碰撞到别的东西 就让子弹小时 //一定是移除自己依附的GameObject对象 而不是脚本自己 Destroy(this.gameObject); &#125; //问题二：坦克本身就带有碰撞盒 当子弹和坦克自身的碰撞盒碰撞可能会产生力的作用 出现一些意想不到的效果 //解决方案：把子弹做成触发器 这样就没有了力的作用&#125; 123456789101112131415public int HP = 3;//当子弹碰到我时 就减血 血量为0了 就移除private void OnTriggerEnter(Collider other)&#123; //由于场景上 只有子弹时触发器 所以我们可以不用进行任何判断 就可以完成这个功能 //减血 HP -= 1; //为0就移除自己 if (HP &lt;= 0) &#123; Destroy(this.gameObject); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"27.碰撞检测之物理材质","slug":"游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质","date":"2025-02-20T11:15:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/","excerpt":"","text":"创建物理材质 在Project窗口加号创建或者右键创建 把物理材质拖拽到两个碰撞器上才能相互作用 物理材质参数 Dynamic Friction 动摩擦力 已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。 Static Friction 静摩擦力 当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness 弹性 表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine 摩擦力组合 两个碰撞对象的摩擦力的组合方式。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。 Bounce Combine 反弹组合 两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"26.碰撞检测之碰撞器","slug":"游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器","date":"2025-02-20T10:39:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/","excerpt":"","text":"知识回顾 两个物体都有碰撞器，至少一个物体有刚体 碰撞器表示物体的体积（形状） 刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用 3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 共同参数 Edit Collider 编辑碰撞器 改变碰撞体大小 Is Trigger 是否是触发器 如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略 主要用于进行没有物理效果的碰撞检测 Material 物理材质* 可以确定碰撞体和其它对象碰撞时的交互（表现）方式。 Center 碰撞器中心 碰撞体在对象局部空间中的中心点位置 常用碰撞器 BoxCollider 盒状碰撞器 Size 大小：碰撞体在X、Y、Z方向上的大小 Sphere Collider 球状碰撞器 Radius 半径：球形碰撞体的半径大小 Capsule Collider 胶囊碰撞器 Radius 半径：胶囊体的半径 Height 高度：胶囊体的高度 Direction 轴向：胶囊体在对象局部空间中的轴向 异形物体使用多种碰撞器组合 刚体对象的子对象碰撞器信息参与碰撞检测 比如金字塔预设体，只在金字塔最高层级对象添加刚体，子对象的所有Cube都会参与碰撞检测 再比如一个Cube添加刚体，再给他添加两个空物体，两个空物体分别添加斜着的盒型碰撞器当做支架，这样这个Cube下落时就会被支架撑起来，即便两个空物体连模型都没有只有碰撞器 不常用碰撞器* Mesh Collider 网格碰撞器* 不常用的原因是性能消耗较高 默认不会显示绿色的碰撞器边框，开启Convex 才会显示绿色的碰撞器边框 Convex Mesh Collider 最多 255 个三角形。 Wheel Collider 轮胎碰撞器* 可以通过给车的父对象加刚体（注意刚体质量一定要大），子对象加车轮碰撞器模拟汽车 Terrain Collider 地形碰撞器* 不常用的原因是性能消耗很高","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"25.碰撞检测之刚体","slug":"游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体","date":"2025-02-20T09:28:06.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/","excerpt":"","text":"碰撞产生的必要条件：两个物体都有碰撞器，至少一个物体有刚体 RigidBody组件信息如下 Mass 质量 默认为千克 质量越大惯性越大 Drag 空气阻力 根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力 Angular Drag 角阻力（扭矩阻力） 通俗理解就是阻碍对象旋转的阻力，角阻力越大越不容易旋转 0 表示没有空气阻力。 Use Gravity 重力开关 是否受重力影响 Is Kinematic 控制物理是否影响刚体。 可以理解为开启后不受力的影响，只能通过Transform移动 如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用。 Interpolate 插值运算 让刚体物体移动更平滑 可以更改FixTime，改成一秒，这样对象会很突兀的一秒移动一次，这时开启插值运算就可以让刚体对象平滑移动 None 无插值运算模式 不应用插值运算 Interpolate 插值模式 插值将始终滞后一点，但比外推更流畅。 根据前一帧的变换来平滑变换。 Extrapolate 外推模式 外推将根据当前速度预测刚体的位置。 根据下一帧的估计变换来平滑变换。 Collision Detection 碰撞检测模式 Continuous Dynamic 连续动态检测 &gt; Continuous Speculative 连续推测检测 &gt; Continuous 连续检测 &gt; Discrete 离散检测 用于防止快速移动的对象穿过其它对象而不检测碰撞 Discrete 离散检测 默认的碰撞检测模式。 在每一帧中进行一次碰撞检测，适用于大多数普通物体。 最省性能，但可能会错过高速物体的碰撞。 适合一般速度移动的物体，不适合高速移动的小物体。 对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值） Continuous 连续检测 提高了碰撞检测的精度，特别适合高速移动的物体。 在每一帧中进行多次碰撞检测，避免高速物体穿过其他物体。 比 Discrete 消耗更多的性能，但减少了穿透问题。 适用于高速移动的物体，如子弹或快速飞行的物体。 对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用连续碰撞检测。 设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置） 其他刚体将使用离散碰撞检测。 Continuous Dynamic 连续动态检测 针对快速移动的物体和其他静止或缓慢移动的物体之间的碰撞检测。 结合 Continuous 和 Discrete 的优点，对高速物体进行多次检测，对慢速或静止物体进行一次检测。 在保证精度的同时比 Continuous 更省性能。 适用于快速移动的物体与静止或缓慢移动的物体之间的碰撞检测，如快速移动的角色或车辆。 性能消耗高 对设置为连续 (Continuous)和连续动态 (Continuous Dynamic)碰撞的游戏对象使用连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。 对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。 Continuous Speculative 连续推测检测 使用预测的方式进行碰撞检测。 预测物体的未来位置，并在物体穿过其他物体前进行检测和处理。 性能较高，精度也不错，但有时可能会出现误判。 适合大多数需要高精度且有较高速度的物体。 对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 Constraints 刚体约束 对刚体运动的限制 Freeze Position 冻结位置 有选择地停止刚体沿世界 X、Y 和 Z 轴的移动。 Freeze Rotation 冻结旋转 有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"24.光面板","slug":"游戏引擎/unity/unity入门/unity入门基础知识/24.光面板","date":"2025-02-20T09:07:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/24.光面板/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"Skybox Material 天空盒材质 可以改变天空盒 可以在project窗口右键创建材质，材质选择成天空盒着色器 Sun Source 太阳来源* 不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting 环境光设置* Source 环境光光源颜色* Skybox 天空盒：天空和材质作为环境光颜色 Gradient 渐变：可以为天空、地平线、地面单独选择颜色和他们之间混合 Color颜色 Intensity Multiplier 环境光亮度* Ambient Mode 环境模式* 全局光照模式，只有启用了实时全局和全局烘焙时才有用 Realtime 实时（已弃用） Baked 烘焙 OtherSettings 其它设置* Fog 雾开关* Color 雾颜色 Mode 雾计算模式 Linear 线性模式 随距离线性增加 Start 开始距离 离摄像机多远开始有雾 End 结束距离 离摄像机多远完全遮挡 Exponential 指数模式 随距离指数增加 Density 密度 雾强度 Exponential Qquare 指数平方模式 随距离比指数更快的增加 Density 密度 雾强度 Halo Texture 光晕材质* 光源周围挥着光环的纹理 Halo Strength 光晕强度* 光环可见性 Flare Fade Speed 炫光交叉淡化速度* 耀斑淡出时间，最初出现之后淡出的时间 Flare Strength 炫光强度* 耀斑可见性 Spot Cookie 聚光灯剪影* 聚光灯剪影纹理","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"23.Light光源组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件","date":"2025-02-20T08:10:23.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/","excerpt":"","text":"Type光源类型 Spot聚光灯 Spot Angle光锥角度 Range发光范围距离 Directional方向光(环境光) Point点光源 Area面光源 Mode 光源模式 Realtime 实时光源：每帧实时计算，效果好，性能消耗大 Baked 烘焙光源：事先计算好，无法动态变化 Mixed 混合光源：预先计算+实时运算 Intensity 光源强度 Indirect Multiplier 间接系数 * 改变间接光的强度 低于1，每次反弹会使光更暗 大于1，每次反弹会使光更亮 Shadow Type 阴影类型 NoShadows 关闭阴影 HardShadows 生硬阴影 SoftShadows 柔和阴影 Realtime Shadows 实时阴影* Strength 强度: 阴影暗度 0~1之间，越大越黑 Resolution 分辨率: 阴影贴图渲染分辨率，越高越逼真，消耗越高 （Project Setting中的Quallty的设置） Bias 偏离: 阴影推离光源的距离 Normal Bias 法线偏离: 阴影投射面沿法线收缩距离 Near Panel 近平面: 渲染阴影的近裁剪面 Cookie 剪影 投影遮罩: 一般用于聚光灯，显示图案 Draw Halo 绘制光晕 球形光环开关 可以用于蜡烛等效果 Flare 眩光 耀斑 有点类似于太阳耀斑效果 想要在Game窗口看到耀斑要在摄像机Camera上加FlareLayer脚本 Render Mode 渲染模式* Auto 自动: 运行时确定 Important 重要: 以像素质量为单位进行渲染，效果逼真，消耗大 Not Important 非重要: 以快速模式进行渲染 Culling Mask 剔除遮罩 剔除遮罩层，决定哪些层的对象受到该光源影响 ps：所有参数都可都可以在代码中设置","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"22.Camera代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制","date":"2025-02-20T06:40:08.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"重要静态成员 1234567891011121314151617181920// 获取主摄像机 只能是有MainCamera tag的print(Camera.main?.name); **************// 所有摄像机数量print(Camera.allCamerasCount);// 所有摄像机Camera[] allCameras = Camera.allCameras;// 渲染相关委托// 摄像机剔除前处理的委托函 数Camera.onPreCull += (c) =&gt;&#123;&#125;;// 摄像机渲染前处理的委托Camera.onPreRender += (c) =&gt;&#123;&#125;;// 摄像机渲染后处理的委托Camera.onPostRender += (c) =&gt;&#123;&#125;; 重要成员 Inspector窗口的所有值都能用代码得到并修改 比如：Camera.main.depth = 10; 下面非常常用 12345// 世界坐标 转 屏幕坐标// 转换后的x, y就是屏幕坐标, z则为 Camera.main 离 这个物体position有多远 (纵深// 用这个来做 头顶血条 ****************Vector3 vector3 = Camera.main.WorldToScreenPoint(this.transform.position);print(vector3); 设置z之后，屏幕坐标就会转换到世界坐标的距离摄像机的z距离的平面上 12345// 屏幕坐标 转 世界坐标// 转换要自己设定z轴的距离, 否则为0, 一直在视口点上坐标不变Vector3 v = Input.mousePosition; ***********v.z = 10;Vector3 vector31 = Camera.main.ScreenToWorldPoint(v);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"21.Camera","slug":"游戏引擎/unity/unity入门/unity入门基础知识/21.Camera","date":"2025-02-20T05:43:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/21.Camera/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/","excerpt":"","text":"Camera可编辑参数 Clear Flags清楚标志 skybox天空盒 （做3d游戏） Solid Color颜色填充 （做2d游戏） Depth only 只画该层，背景透明 （一般多个摄像机叠加渲染的时候使用，一般与下面的Depth配合使用） Don’t Clear 不移除，覆盖渲染 （不常用，会保留每一帧的渲染内容，就像黄金体验镇魂曲） Culling Mask剔除遮罩 选择渲染部分层级（Layer） Projection FOV Axis Fov轴：视野轴，决定了光学仪器的视野范围。 Perspective 透视模式 Field of view 视野：摄像机视角（以沿着 FOV Axis__ 下拉选单中指定轴的度数为单位）。0-180度之间，一般保持默认60就行。 orthographic 正交摄像机（一般用于2D游戏制作） Size：摄制范围 Clipping Planes裁剪平面 Near：近平面 Far：远平面 Depth深度 渲染顺序上的深度 （数字越小，越先渲染） 数字小的照片会先放， 数字大的照片会叠在上面，天空盒有背景是不透明，depth only透明 Target Texture目标纹理 可以把摄像机画面渲染到一张图上， 主要用于制作小地图 在Project右键创建 Render Texture，将创建的Render Texture拖到摄像机，就会把摄像机看到的画面渲染到一张图上 Occlusion Culling剔除遮挡 勾选时一些游戏物体被大一点的物体挡住可以不用渲染 不常用的参数 Viewport Rect视口范围 屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏，0~1 相当于宽高百分比 Redering path渲染路径","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"20.Screen屏幕相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关","date":"2025-02-20T02:50:13.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.Screen%E5%B1%8F%E5%B9%95%E7%9B%B8%E5%85%B3/","excerpt":"","text":"常用 1234567891011// 当前屏幕分辨率 (设备的分辨率Resolution currentResolution = Screen.currentResolution;print($&quot;当前分辨率宽:&#123;currentResolution.width&#125;, 高:&#123;currentResolution.height&#125;&quot;);// 当前游戏窗口分辨率 print($&quot;当前窗口分辨率为:&#123;Screen.width&#125; * &#123;Screen.height&#125;&quot;);// 屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; 不常用 123456789101112131415161718192021// 运行时是否全屏Screen.fullScreen = true;// 窗口模式 (以后在发布的时候在设置, 一般不用代码去设置)// 独占全屏 FullScreenMode.ExclusiveFullScreen// 全屏窗口 FullScreenMode.FullScreenWindow;// 最大化窗口 FullScreenMode.MaximizedWindow// 窗口模式 FullScreenMode.Windowed;Screen.fullScreenMode = FullScreenMode.FullScreenWindow;// 移动设备转向相关...Screen.autorotateToLandscapeLeft = true;// 指定屏幕显示方向Screen.orientation = ScreenOrientation.LandscapeLeft;// 设置分辨率 第三个参数是否为全屏 (移动设备不用, Screen.SetResolution(1920, 1080, false);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"19.Input输入相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关","date":"2025-02-20T02:39:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.Input%E8%BE%93%E5%85%A5%E7%9B%B8%E5%85%B3/","excerpt":"","text":"输入内容一定是写在Update当中的 鼠标位置 屏幕坐标的原点是在左下角，右是x轴正向，上是y轴正向 123// 鼠标位置// 返回一个Vector3, 但只有x, y有值print(Input.mousePosition); 检测鼠标输入 1234567891011// 检测鼠标输入 (0左键, 1右键, 2滚轮if (Input.GetMouseButtonDown(0)) print(&quot;你按了一次 鼠标左键&quot;);if (Input.GetMouseButtonUp(1)) print(&quot;你抬起了一次 鼠标右键&quot;);if (Input.GetMouseButton(0)) print(&quot;你是一直在按着 鼠标左键&quot;);// 返回一个Vector2, 而滚动会改变其中的y值// y值 -1 往下棍, 0 没滚, 1 往上滚Vector2 mouseScrollDelta = Input.mouseScrollDelta;print(mouseScrollDelta); 检测键盘输入 123// 键盘按下 up抬起, 无长按...if (Input.GetKeyDown(KeyCode.W)) print(&quot;你按下了W键&quot;); 检测默认轴 记不住单词可以在Project Setting中的Input Manager查看 1234567891011121314// 默认轴输入// 当键盘A,D键按下时, 返回-1 到 1之间的变换 // 即一直按A的话, 返回值会慢慢从0变到 -1// Input.GetAxisRaw是只会有 -1, 0, 1三个数字之间的突变float v = Input.GetAxis(&quot;Horizontal&quot;);print(v);// W, S 返回-1, 到 1float v1 = Input.GetAxis(&quot;Vertical&quot;);print(v1);// 鼠标横向移动 纵向 Mouse Yfloat v2 = Input.GetAxis(&quot;Mouse X&quot;);print(v2); 其它 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 是否有任意键或鼠标长按bool anyKey = Input.anyKey;if (Input.anyKeyDown)&#123; print($&quot;有一个键按下了按下的是&#123;Input.inputString&#125;&quot;);&#125;// 得到连接的手柄的所有按钮名字string[] strings = Input.GetJoystickNames();for (int i = 0; i &lt; strings.Length; i++)&#123; print(&quot;你连接的所有按钮有&quot;); print(strings[i]);&#125;// 某一手柄键按下, 抬起, 长按...bool v3 = Input.GetButtonDown(strings[0]);// 移动设备触摸if (Input.touchCount &gt; 0)&#123; Touch touch = Input.touches[0]; // 位置 print(touch.position); // 相对上次位置的变化 print(touch.deltaPosition);&#125;// 是否启用多点触控Input.multiTouchEnabled = true;// 陀螺仪 (重力感应)// 是否开启陀螺仪Input.gyro.enabled = true;// 重力加速度 Vector3 gravity = Input.gyro.gravity;// 旋转速度Vector3 rotationRate = Input.gyro.rotationRate;// 陀螺仪 当前旋转的四元数// 比如用这个角度信息 来控制场景上的一个3D物体收到重力影响// 手机怎么动, 他就怎么动Quaternion attitude = Input.gyro.attitude; 练习 用WASD键控制前进后退，左右转向 123//ws键 控制位移 // 这公式 是 ： 前进方向 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime * Input.GetAxis(&quot;Vertical&quot;)); //ad键 控制 左右转向 // 这公式 是 ： 转动的轴 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Horizontal&quot;)); 鼠标左右移动控制炮口的转向 1head.Rotate(Vector3.up * headRotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Mouse X&quot;));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"18.坐标转换","slug":"游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换","date":"2025-02-19T13:07:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"世界 -&gt; 本地 世界坐标系的点 -&gt; 本地坐标系的点 123// 世界坐标 转换为 本地坐标 (会受到缩放影响// 即 在世界坐标系下的 (0, 0, 1) 在本地坐标系下表示为 transform.InverseTransformPoint(Vector3.forward)print(this.transform.InverseTransformPoint(Vector3.forward)); 世界坐标系的向量 -&gt; 本地坐标系的向量 1234// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (不受缩放影响print(this.transform.InverseTransformDirection(Vector3.forward));// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (受缩放影响print(this.transform.InverseTransformVector(Vector3.forward)); 本地 -&gt; 世界 本地坐标系的点 -&gt; 世界坐标系的点 （最重要的***） 1234567// 本地坐标 转换为 世界坐标 (会受到缩放影响// 即 在本地坐标系下的 (0, 0, 1) 在世界坐标系下表示为 transform.TransformPoint(Vector3.forward)print(this.transform.TransformPoint(Vector3.forward));// eg:GameObject obj = new GameObject(&quot;左前方物体&quot;);obj.transform.position = this.transform.TransformPoint(new Vector3(-1, 0, 1)); // 在本地坐标的左前方（-1,0,1）处创建物体 本地坐标系的向量 -&gt; 世界坐标系的向量 1234// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (不受缩放影响print(this.transform.TransformDirection(Vector3.forward));// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (受缩放影响print(this.transform.TransformVector(Vector3.forward));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"17.父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系","date":"2025-02-19T08:56:46.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"获取和设置父对象 1234567891011121314151617// 获取父对象print(this.transform.parent);// 断绝父子关系this.transform.parent = null; // 认父亲 // 也会顺带把孙子的爷爷也换了this.transform.parent = GameObject.Find(&quot;obj&quot;).transform;// 下面这种认父亲的方法 特殊一些// 第二个参数为true 则不会改掉物体本来的世界坐标位置,大小什么的// 为false, 则会把原来Inspector面板上的数字原封不动的赋值到新的Inspector窗口上，则会用自己的transform中的数值// 子对象世界坐标 = 父对象世界坐标 × 子对象局部坐标（当 worldPositionStays = false 时）。// 动态创建ui时常用this.transform.SetParent(GameObject.Find(&quot;obj&quot;).transform, false); 抛妻弃子 12// 和自己所有儿子断绝关系, 不会断掉儿子和孙子的this.transform.DetachChildren(); 获取子对象及其操作 12345678910111213141516171819// 根据名字查找儿子对象 (不可以查找孙子, 可以找到失活的儿子，GameObject的find不能查找失活的对象 )print(this.transform.Find(&quot;Capsule&quot;));// 查找Father的儿子Sonprint(this.transform.Find(&quot;Father/Son&quot;));// 儿子数量print(this.transform.childCount);// 遍历for (int i = 0; i &lt; this.transform.childCount; i++) print(this.transform.GetChild(i)); // 判断是不是自己是不是另一个对象的儿子bool v = this.transform.IsChildOf(transform.parent);// 设置自己作为儿子编号this.transform.SetSiblingIndex(0);// 得到自己作为儿子的编号print(this.transform.GetSiblingIndex()); 练习 请为Transform写一个拓展方法，可以将它的子对象按名字的长短进行排序改变他们的顺序，名字短的在前面，名字长的在后面 1234567891011121314151617181920212223242526272829public static class TransformExtensions&#123; public static void SortChildrenByNameLength(this Transform obj) &#123; //var children = obj.Cast&lt;Transform&gt;().ToList(); //children = children.OrderBy(child =&gt; child.name.Length).ToList(); //for (int i = 0; i &lt; children.Count; i++) //&#123; // children[i].SetSiblingIndex(i); //&#125; List&lt;Transform&gt; list = new List&lt;Transform&gt;(); for (int i = 0; i &lt; obj.childCount; i++) &#123; list.Add(obj.GetChild(i)); &#125; //这是根据 名字长短进行排序 利用的 是list的排序 传个函数进去 list.Sort((a, b) =&gt; a.transform.name.Length - b.transform.name.Length); //根据 list中的排序结果 重新设置每一个对象的 索引编号 for (int i = 0; i &lt; list.Count; i++) &#123; list[i].SetSiblingIndex(i); &#125; &#125;&#125; 请为Transform写一个拓展方法，传入一个名字查找子对象，即使是子对象的子对象也能查找到 123456789101112131415161718public static class TransformExtensions&#123; public static Transform CustomFind(this Transform obj, string name) &#123; Transform res = null; res = obj.Find(name); if (res != null) return res; for (int i = 0; i &lt; obj.childCount; i++) &#123; res = obj.GetChild(i).CustomFind(name); if (res != null) return res; &#125; return res; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"16.缩放和看向","slug":"游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向","date":"2025-02-19T08:23:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/16.%E7%BC%A9%E6%94%BE%E5%92%8C%E7%9C%8B%E5%90%91/","excerpt":"","text":"缩放 12345678// 相对于世界坐标系 // 不能改print(this.transform.lossyScale);// 相对于父对象 // 可以改print(this.transform.localScale);// unity 没有提供缩放相关的API, 只能自己手动来搞 eg: this.transform.localScale += Vector3.one * Time.deltaTime; 看向 12// 将自己的面朝向源点，相对于世界坐标系this.transform.LookAt(Vector3.zero);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"15.角度和旋转","slug":"游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转","date":"2025-02-19T07:30:32.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/15.%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC/","excerpt":"","text":"角度相关 123456789// 相对于世界坐标角度print(this.transform.eulerAngles);// 相对于父对象角度// Inspector中显示的是相对父对象的角度，localEulerAngles的角度只能是0~360，但Inspector面板是可以负数的print(this.transform.localEulerAngles);// 不能单个x, y, z赋值this.transform.localEulerAngles = new Vector3(10, 10, 10); 旋转相关 123456789101112// 自转API 第二个参数默认不写的话，绕着自己坐标转this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime * 100, Space.World); // 每帧绕y轴增加100 * （0，10，0）//相对于某个轴 转多少度//参数一:是相对哪个轴进行转动//参数二:是转动的 角度 是多少//参数三:默认不填 就是相对于自己的坐标系 进行旋转transform.Rotate(Vector3.up, Time.deltaTime * 100); // 在自己的坐标系的y轴旋转// 绕着某个点旋转 绕着源点, y轴, 转的多少度this.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime); 代码 原理 效率 可读性 Rotate(new Vector3(0,1,0) * dt * 100) 欧拉角增量 较低（需创建Vector3） 一般 Rotate(Vector3.up, dt * 100) 轴-角度 较高 更佳","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"14.位置位移坐标系相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关","date":"2025-02-19T06:59:04.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/14.%E4%BD%8D%E7%BD%AE%E4%BD%8D%E7%A7%BB%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3/","excerpt":"","text":"Vector常用 用的是世界坐标 123456789Vector3.forward 001Vector3.up 010Vector3.down 0-10Vector3.left -100Vector3.right 100Vector3.back 00-1// 两点之间的距离Vector3.Distance(v1, v2); 位置 1234567891011// 相对世界坐标原点的值print($&quot;距离世界源点 &#123;this.transform.position&#125;&quot;);// 相对父对象 没父对象就相对于源点print($&quot;距离父对象坐标点 &#123;this.transform.localPosition&#125;&quot;);// 位置的赋值不能单独改x, y, z 只能整体来赋值this.transform.position = new Vector(5, this.transform.position.y, ...);// 或者Vector3 tmp = this.transform.position; tmp.y = 666;this.transfomr.position = tmp; 朝向 本地坐标系，游戏对象当前的朝向 123print(this.transform.forward); // 游戏对象当前的面朝向print(this.transform.up); // 对象当前的头顶朝向Vector3 right = this.transform.right; // 右手边 位移 123456789101112131415// 1 位移 = 方向 * 速度 * 时间 (手动写, 世界坐标系的话用Vector3.XX)最终位置 = 当前的位置 + 我要变化的位置的路程//this.transform.position += this.transform.forward * 1 * Time.deltaTime;// 2 位移API// 参数1 表示位移多少 位移 = 方向 * 速度 * 时间// 参数2 移动所采用的坐标系, 即(1, 0, 0)是哪个坐标系的(1, 0, 0) (不填的话，默认本地相对坐标系Space.Self)this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); // 沿着世界坐标系的001去动this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.World); // 世界坐标系中沿着自己的面朝向去动this.transform.Translate（Vector3.forward * 1 * Time.deltaTime, Space.Self); // 沿着自己坐标系的001去动// 不会这样移动, 自己相对于世界坐标系的歪曲的数据 再应用于自己的坐标系this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.Self); // 傻逼","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"13.时间相关Time","slug":"游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time","date":"2025-02-19T06:00:25.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13.%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3Time/","excerpt":"","text":"时间缩放比例 12// 时间停止 // 恢复正常 // 2倍速Time.timeScale = 0; Time.timeScale = 1; Time.timeScale = 2; 帧间隔时间 即 两帧之间的时间 作用: 计算位移 每帧移动的距离由speed * Time.deltaTime确定，确保了在不同帧率下物体移动的速度一致 典型应用：transform.Translate(Vector3.forward * speed * Time.deltaTime); 通过乘以 deltaTime，物体每秒移动的距离为 speed 单位，无论帧率如何变化。 123// 帧间隔时间print(&quot;受timeScale影响的 &quot; + Time.deltaTime);print(&quot;不受timeScale影响的&quot; + Time.unscaledDeltaTime); 游戏开始到现在时间 一般都单机游戏用，网游一般用服务器时间 123// 游戏开始到现在的时间print(&quot;受timeScale影响的&quot; + Time.time);print(&quot;不受影响的&quot; + Time.unscaledTime); 物理帧间隔时间 123456void FixedUpdate()&#123; // 物理帧间隔时间 print(&quot;受影响的 &quot; + Time.fixedDeltaTime); print(&quot;不受影响的 &quot; + Time.fixedUnscaledDeltaTime);&#125; 总帧数 (帧同步) 从开始到现在游戏跑了多少帧（即多少次循环） 1print(Time.frameCount);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"12.GameObject","slug":"游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject","date":"2025-02-19T02:07:20.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GameObject/","excerpt":"","text":"成员变量 12345678910// 名字this.gameObject.name = &quot;改名desu&quot;;// 是否激活bool activeSelf = this.gameObject.activeSelf;// 是否静态bool isStatic = this.gameObject.isStatic;// 层级int layer = this.gameObject.layer;// 给游戏对象分的标签string tag1 = this.gameObject.tag; 静态方法 创建自带几何体 123// 创建自带几何体GameObject gameObject1 = GameObject.CreatePrimitive(PrimitiveType.Cube);gameObject1.name = &quot;自己起的名字&quot;; 在场景中查找对象 只能找到激活对象，无法找到失活对象 使用单个查找的api，如果场景有满足调教的多个对象，无法指定找到的是谁 1234567891011121314151617// 在场景中查找对象 // 1.1 单个查找 名字(同名不行)// 查找效率低 会查询所有场景中所有的对象GameObject gameObject2 = GameObject.Find(&quot;自己起的名字&quot;);print(gameObject2?.name);// 1.2 单个查找 tagGameObject gameObject3 = GameObject.FindWithTag(&quot;MainCamera&quot;);print(gameObject3?.name);// 1.3 通过Inspector面板去拖到本地的public// 2 多对象查找 tagGameObject[] gameObjects = GameObject.FindGameObjectsWithTag(&quot;Player&quot;);print(gameObjects?.Length);// FindObjectOfTypes 效率低 克隆对象 根据一个GameObject对象, 创建一个一模一样的对象 1GameObject obj = GameObject.Instantiate(MyObj); 删除 删除一个指定游戏对象 删除一个指定脚本对象 注意: Destroy方法不会马上移除对象, 只是加了一个移除标识 一般情况下, 会在下一帧时把这个对象从内存中移除 1234567// 删除对象GameObject.Destroy(gameObject4, 5); // 第二个参数是延时几秒// 删除脚本对象GameObject.Destroy(this);// 一定要马上移除 // 没特殊需求不用GameObject.DestroyImmediate(gameObject4); 切场景不移除 默认情况下, 切场景会删除该场景的所有对象 一般写自己依附的对象不被删除 1GameObject.DontDestroyOnLoad(this.gameObject); // 不移除该脚本依附的游戏对象 成员方法 创建空物体 顺带加上Test2脚本 1GameObject gameObject5 = new GameObject(&quot;创建的空物体名字&quot;, typeof(Test2)); 动态给GameObject对象添加脚本 12// 给gameObject5加上Test2脚本Test2 test2 = gameObject5.AddComponent&lt;Test2&gt;(); 获取脚本对象 和[[Mono中的重要内容#^155e67 | 继承Mono的类]]获取脚本对象的方法一毛一样 标签比较 12345678if (gameObject5.CompareTag(&quot;Player&quot;))&#123; print(&quot;对象标签是Player&quot;);&#125;if (gameObject5.tag == &quot;Player&quot;)&#123; print(&quot;这和上面是一样的&quot;);&#125; 设置 失活 和 激活 1gameObject5.SetActive(false); // 失活 不建议使用的成员方法 通过广播或者发送消息的形式, 让自己或者别人 执行某些行为和方法 123456789// 让自己去执行TestFun这个函数, 会在自己对象上挂着的所有脚本去找这个名字的函数, 有一个执行一个// 涉及到反射 比较影响性能this.gameObject.SendMessage(&quot;TestFun&quot;);// 广播行为 让自己及其子对象发送消息并执行，让自己及其子对象 执行相同的名字的方法this.gameObject.BroadcastMessage(&quot;TestFun&quot;);// 让自己及其父对象发送消息并执行this.gameObject.SendMessageUpwards(&quot;函数名&quot;); 继承自Object自然可以用Object.xxx的方式来调用静态函数","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"11.MonoBehavior中的重要内容","slug":"游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容","date":"2025-02-18T10:13:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.MonoBehavior%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/","excerpt":"","text":"8.脚本基本规则 重要成员 获取依附的GameObject 1print(this.gameObject.name); 获取依附的GameObject的位置信息 1234567//得到对象位置信息print(this.transform.position);//位置print(this.transform.eulerAngles);//角度print(this.transform.lossyScale);//缩放大小//这种写法和上面是一样的效果 都是得到依附的对象的位置信息this.gameObject.transform 设置脚本是否激活 1234//this.enabled = true;print($&quot;这是其它脚本对象 otherTest, 可以使用本脚本的其它脚本对象来获取gameObject &#123;otherTest.gameObject.name&#125;&quot;); 重要方法 获取依附对象上挂载的其它脚本 三个重载获取 1234567891011// 通过挂载脚本名Component component = this.GetComponent(&quot;Test2&quot;);Test2 t = component as Test2;print(t);// 通过typet = this.GetComponent(typeof(Test2)) as Test2;// 通过 *************用最多*************t = this.GetComponent&lt;Test2&gt;(); 获取多个脚本 123456Test2[] test2s = this.GetComponents&lt;Test2&gt;();List&lt;Test2&gt; list = new List&lt;Test2&gt;();this.GetComponents&lt;Test2&gt;(list); 找自己及其子对象的所挂载的脚本 123// 这里可以不传参数, 默认传false表示不找失活状态的脚本// 找自己及其父对象的同理this.GetComponentsInChildren&lt;Test2&gt;(false); 注意 要想操作其它GameObject对象, 必须获取其它的脚本对象, 而且得用Inspector来赋值","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"csharp特性","slug":"编程语言/Csharp/csharp特性","date":"2025-02-18T09:18:38.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/编程语言/Csharp/csharp特性/","permalink":"http://example.com/2025/02/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%89%B9%E6%80%A7/","excerpt":"","text":"特性 特性是一种允许我们向程序的[[程序集]]添加[[元数据]]的语言结构 它是用于保存程序结构信息的某种特殊类型的类 特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。 特性与程序实体关联后，即可在运行时使用[[csharp反射]]查询特性信息 特性的目的是告诉编译器把程序结构的某组[[元数据]]嵌入[[程序集]]中 它可以放置在几乎所有的声明中（类、变量、函数等等申明） 说人话： 特性本质是个类 我们可以利用特性类为[[元数据]]添加额外信息 比如一个类、成员变量、成员方法等等为他们添加更多的额外信息 之后可以通过[[csharp反射]]来获取这些额外信息 自定义特性 12345678910111213class MyCustomAttribute : Attribute&#123; //特性中的成员 一般根据需求来写 public string info; public MyCustomAttribute(string info) &#123; this.info = info; &#125; public void TestFun() &#123; Console.WriteLine(&quot;特性的方法&quot;); &#125;&#125; 特性的使用 基本语法: [特性名(参数列表)] 本质上 就是在调用特性类的构造函数 写在哪里？ 类、函数、变量上一行，表示他们具有该特性信息 1234567891011121314151617181920212223[MyCustom(&quot;这是我自己的类&quot;)]class MyClass&#123; [MyCustom(&quot;这是一个int型的成员变量&quot;)] public int Value; [MyCustom(&quot;这是用来测试的成员函数&quot;)] public void TestFun([MyCustom(&quot;这是用来测试的函数参数&quot;)] int a) &#123; Console.WriteLine(a); &#125;&#125;Type t = typeof(MyClass);if (t.IsDefined(typeof(MyCustomAttribute), false))&#123; Console.WriteLine(&quot;判断一个类型是否使用了某个特性&quot;);&#125;// 获取Type元数据中的所有特性object[] objects = t.GetCustomAttributes(true);for (int i = 0; i &lt; objects.Length; i++) Console.WriteLine((objects[i] as MyCustomAttribute).Info); 为特性类加特性 限制其使用范围 12345[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]//参数一：AttributeTargets —— 特性能够用在哪些地方//参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上//参数三：Inherited —— 特性是否能被派生类和重写成员继承public class MyCustom2Attribute : Attribute &#123; &#125; 系统自带特性——过时特性 Obsolete 用于提示用户 使用的方法等成员已经过时 建议使用新方法 123456//一般加在函数前的特性[Obsolete(&quot;这个是旧方法&quot;, false)]// 第一个参数是提示信息, 第二个参数 true直接报错, false警告public void OldFun() &#123; &#125; 系统自带特性——调用者信息特性 (快速查出哪里的错误) 12345678910111213141516171819202122232425//哪个文件调用？//CallerFilePath特性//哪一行调用？//CallerLineNumber特性//哪个函数调用？//CallerMemberName特性class TestClass&#123; [Obsolete(&quot;这个是旧方法&quot;, false)] // 第一个参数是提示信息, 第二个参数 true直接报错, false警告 public void OldFun() &#123; &#125; public void NewFun(string str, [CallerFilePath] string fileName = &quot;&quot;, [CallerLineNumber] int line = 0, [CallerMemberName] string memberName = &quot;&quot;) &#123; Console.WriteLine(&quot;这些使用的CallerXXX特性会在, 其它调用者调用时自动将调用者的额外信息填入参数中&quot;); Console.WriteLine(&quot;调用者的文件名 fileName = &quot; + fileName); Console.WriteLine(&quot;调用者的所在的行数 line = &quot; + line); Console.WriteLine(&quot;调用者的所处的调用函数名 memberName = &quot; + memberName); &#125;&#125; 系统自带特性——条件编译特性 Conditional 它会和[[预处理指令]] #define配合使用 123456[Conditional(&quot;Fun&quot;)] // 如果 #define 下面就会编译static void Fun()&#123; Console.WriteLine(&quot;如果有#define 我就会执行&quot;);&#125; 系统自带特性——外部Dll包函数特性 DllImport 用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。 一般用来调用 C或者C++的Dll包写好的方法 需要引用[[命名空间]] using System.Runtime.InteropServices 123[DllImport(&quot;Test.dll&quot;)] // 下面这个函数一定在dll中有一模一样的public static extern int Add(int a, int b);//需要引用命名空间 using System.Runtime.CompilerServices;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"10.inspector 窗口可编辑变量","slug":"游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量","date":"2025-02-18T08:47:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.inspector%20%E7%AA%97%E5%8F%A3%E5%8F%AF%E7%BC%96%E8%BE%91%E5%8F%98%E9%87%8F/","excerpt":"","text":"知识点一 私有和保护无法显示编辑 12private int i1;protected string str1; 知识点二 让私有的和保护的也可以被显示SerializeField 加上强制序列化字段csharp特性 [SerializeField] 所谓序列化就是把一个对象保存到一个文件或数据库字段中去 1234[SerializeField]private int privateInt;[SerializeField]protected string protectedStr; 知识点三 公共的可以显示编辑 12public int publicInt = 10;public bool publicBool = false; 知识点四 公共的也不让其显示编辑HideInInspector 在变量前加上csharp特性 [HideInInspector] 12[HideInInspector]public int publicInt2 = 50; 知识点五 大部分类型都能显示编辑 12345678910public int[] array;public List&lt;int&gt; list;public E_TestEnum type;public GameObject gameObj;//字典不能被Inspector窗口显示public Dictionary&lt;int, string&gt; dic;//自定义类型变量public MyStruct myStruct;public MyClass myClass; 知识点六 让自定义类型可以被访问 加上序列化csharp特性[System.Serializable] 字典怎样都不行 12345678910111213[System.Serializable]public struct MyStruct&#123; public int age; public bool sex;&#125;[System.Serializable]public class MyClass&#123; public int age; public bool sex;&#125; 知识点七 一些辅助csharp特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//1.分组说明特性Header **************有用**************//为成员分组//Header特性//[Header(&quot;分组说明&quot;)][Header(&quot;基础属性&quot;)]public int age;public bool sex;[Header(&quot;战斗属性&quot;)]public int atk;public int def;//2.悬停注释Tooltip//为变量添加说明//[Tooltip(&quot;说明内容&quot;)][Tooltip(&quot;闪避&quot;)]public int miss;//3.间隔特性 Space()//让两个字段间出现间隔//[Space()][Space()]public int crit;//4.修饰数值的滑条范围Range **************有用**************//[Range(最小值, 最大值)][Range(0,10)]public float luck;//5.多行显示字符串 默认不写参数显示3行//写参数就是对应行//[Multiline(4)][Multiline(5)]public string tips;//6.滚动条显示字符串 //默认不写参数就是超过3行显示滚动条//[TextArea(3, 4)]//最少显示3行，最多4行，超过4行就显示滚动条[TextArea(3,4)]public string myLife;//7.为变量添加快捷方法 ContextMenuItem **************有用**************//参数1 显示按钮名//参数2 方法名 不能有参数//[ContextMenuItem(&quot;显示按钮名&quot;, &quot;方法名&quot;)][ContextMenuItem(&quot;重置钱&quot;, &quot;Test&quot;)]public int money;private void Test()&#123; money = 99;&#125;//8.为方法添加特性能够在Inspector中执行//[ContextMenu(&quot;测试函数&quot;)][ContextMenu(&quot;哈哈哈哈&quot;)]private void TestFun()&#123; print(&quot;测试方法&quot;);&#125; 注意 Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变 要么老老实实的在Inspector窗口改默认值 要么重新挂载脚本 运行中修改的信息不会保存","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"9.生命周期函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数","date":"2025-02-18T07:39:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"碰撞检测函数 知识点一 了解帧的概念 Unity 底层已经帮助我们做好了死循环 我们需要学习Unity的生命周期函数 利用它做好的规则来执行我们的游戏逻辑就行了 知识点二 生命周期函数的概念 所有继承MonoBehavior的脚本 最终都会挂载到GameObject游戏对象上 生命周期函数 就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中 会通过反射自动调用的一些特殊函数 注意： 生命周期函数的访问修饰符一般为private和protected 因为不需要再外部自己调用生命周期函数 都是Unity自己帮助我们调用的 当对象（自己这个类脚本对象）被创建时 才会调用该生命周期函数 生命周期函数支持多态 如果GameObject一开始失活就不会调用生命周期函数 awake，onenable,start, fixedUpdate,update, laterupdate, ondisenable,ondestroy Awake： 类似构造函数的存在 我们可以在一个类对象 该创建 进行一些初始化操作 OnEnable： 对于我们来说 想要当一个对象被激活时 进行一些逻辑处理 就可以写在这个函数 Start： 主要作用还是用于初始化信息的 但是它相对Awake来说 要晚一点 如果我们在update中动态的创建对象，这个对象马上会执行Awake，但不会立即执行Start，要等到在下一帧的第一次 Update() 之前执行才会执行Start FixedUpdate： 它主要是用于 进行物理更新 它是每一帧的执行的 但是 这里的帧 和游戏帧 有点不同 它的时间间隔 是可以在 project setting中的 Time里去设置的 Update： 主要用于处理游戏核心逻辑更新的函数 LateUpdate： 一般这个更新是用来处理 摄像机位置更新相关内容的 Update和LateUpdate之间 Unity进了一些处理 处理我们动画相关的更新 OnDisable： 如果我们希望在一个对象失活时做一些处理 就可以在该函数中写逻辑 失活后不参与游戏循环了，激活后又可以循环 OnDestroy： 当对象销毁后调用 问题：不同对象的生命周期函数是在同一个线程中执行吗？","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"8.脚本基本规则","slug":"游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则","date":"2025-02-18T07:10:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/","excerpt":"","text":"MonoBehavior基类 创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 继承了MonoBehavior的脚本可以在一个对象上挂多个（如果没有加DisallowMultipleComponent特性） 继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 不继承MonoBehavior的类 不继承Mono的类 不能挂载在GameObject上 不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 不继承Mono的类 一般是单例模式的类（用于管理模块） 或者数据结构类（用于存储数据） 不继承Mono的类 不用保留默认出现的几个函数 设置挂载脚本的执行顺序，默认时间前是系统必须执行的，可以设置自己添加的脚本的执行顺序，数字越小脚本越先执行 打开 当前unity版本下的Editor\\Data\\Resources\\ScriptTemplates目录可以更改默认的脚本模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"7.预制体和资源包的导入导出","slug":"游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出","date":"2025-02-18T07:01:18.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E9%A2%84%E5%88%B6%E4%BD%93%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"预设体是 Unity 中非常重要的概念，可以理解为一个游戏对象及其组件的集合。其目的是使游戏对象及其资源能够重复使用。当修改预设体时，实例也会同步修改。 创建预设体 将其拖到asset文件夹下 右键可以取消预设体 资源包导出直接右键，导入直接拖","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"6.反射机制和游戏场景","slug":"游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景","date":"2025-02-18T03:33:39.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF/","excerpt":"","text":"Unity中的反射机制 Unity引擎本质是一个软件使用它时是处于运行中的我们是在一个运行中的软件里制作游戏的 Unity开发的本质就是 在Unity引擎的基础上利用反射和引擎提供的各种功能进行的拓展开发 回忆一下反射的概念 程序正在运行时，可以查看其它程序集或者自身的元数据（元数据就是程序当中的类，对象，函数，变量之类的东西） 一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射 在程序运行时，通过反射可以得到其它程序集或者自己程序集中 代码的各种信息，比如类，函数，变量，对象等等 我们可以实例化它们，执行它们，操作它们 Unity 反射机制的完整工作流 假设你写了一个 PlayerController.cs 脚本 12345678public class PlayerController : MonoBehaviour &#123; [SerializeField] private float _moveSpeed = 5.0f; void Update() &#123; // 移动逻辑 &#125;&#125; 脚本编译阶段： Unity 会通过 Mono/C# 编译器 将你的脚本编译到 Assembly-CSharp.dll 中，同时生成 元数据表 编辑器反射阶段： Unity Editor 通过反射扫描所有 MonoBehaviour 子类 解析 [SerializeField] 等特性 生成 Inspector 面板的 UI 元素 运行时反射阶段： 当场景加载时，Unity 通过反射： 实例化 PlayerController 对象 将序列化数据（如 _moveSpeed）注入到对应字段 构建消息系统的方法表（用于 SendMessage()） 游戏场景","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"5.工具栏与对象的父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系","date":"2025-02-18T03:27:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E5%B7%A5%E5%85%B7%E6%A0%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"4.Inspector和Console窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口","date":"2025-02-18T02:08:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.Inspector%E5%92%8CConsole%E7%AA%97%E5%8F%A3/","excerpt":"","text":"选择对象进行标记 选择是否激活对象 修改对象名 设置对象为静态对象 标签 层级","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"3.Game和Project窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口","date":"2025-02-18T01:56:51.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"2.Scene和Hierarchy窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口","date":"2025-02-16T02:24:38.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/","excerpt":"","text":"主要内容 窗口布局 左上角Layout选项 Scene和Hierarchy 场景窗口和层级窗口是息息相关的 层级窗口中看到的内容就是场景窗口中的显示对象","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"1.unity入门概述","slug":"游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述","date":"2025-02-16T01:27:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.unity%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/","excerpt":"","text":"主要学习内容 学习建议 以前做游戏 vs 现在做游戏 如何学习游戏引擎","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.使用obsidian来写hexo博客","slug":"hexo/1.使用obsidian来写hexo博客","date":"2025-02-09T12:59:52.000Z","updated":"2025-03-04T06:32:33.499Z","comments":true,"path":"2025/02/09/hexo/1.使用obsidian来写hexo博客/","permalink":"http://example.com/2025/02/09/hexo/1.%E4%BD%BF%E7%94%A8obsidian%E6%9D%A5%E5%86%99hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Front-Matter obsidian安装Template插件，设置目录后在该目录下创建HexoPost.md文件 HexoPost.md内容如下 123456789101112131415161718---title: &lt;% tp.file.title %&gt;date: &lt;% tp.date.now(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;toc: truecategories:&lt;%*// 自动生成分类（兼容Windows路径）let folders = await tp.file.folder(true).split(/[\\\\/]/); folders = folders.slice(2); // 移除 &quot;_posts&quot; 父级目录for (let category of folders) &#123; tR += ` - $&#123;category&#125;`;&#125;if (folders.length === 0) &#123; tR += &quot; - 未分类&quot;;&#125;%&gt;tags:--- 这样就可以在新建md文件后点击obsidian侧边来自动填充categories 图片管理 站点配置文件_config.yml 1post_asset_folder: true # 启用文章资源文件夹 obsidian安装 Custom Attachment Location插件并进行如下设置 其它小优化 设置新建笔记位置 关闭wiki链接 文章内跳转使用md语法 [显示文本](#锚点) md标题自动生成锚点（全小写，空格换-）或者自定义锚点（&lt;a id=&quot;nihao&quot;&gt;&lt;/a&gt;） 忽略文件夹 参考 使用 Hexo 搭建博客 | OHLIA’s Wiki Hexo和Obsidian：让个人博客写作更加优雅、高效 - ＊tree_fly 's Blog 给博客上Live2d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"你好呀","slug":"你好呀","date":"1999-12-31T16:00:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2000/01/01/你好呀/","permalink":"http://example.com/2000/01/01/%E4%BD%A0%E5%A5%BD%E5%91%80/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity核心","slug":"游戏引擎/unity/unity核心","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E6%A0%B8%E5%BF%83/"},{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"UI系统/NGUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"},{"name":"NGUI基础知识","slug":"UI系统/NGUI/NGUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"数据/数据持久化/XML","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/"},{"name":"XML实践项目","slug":"数据/数据持久化/XML/XML实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"XML基础知识","slug":"数据/数据持久化/XML/XML基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/XML/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"unity核心","slug":"unity核心","permalink":"http://example.com/tags/unity%E6%A0%B8%E5%BF%83/"},{"name":"动画系统","slug":"动画系统","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"2d动画","slug":"2d动画","permalink":"http://example.com/tags/2d%E5%8A%A8%E7%94%BB/"},{"name":"2d骨骼动画","slug":"2d骨骼动画","permalink":"http://example.com/tags/2d%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/"},{"name":"Spine","slug":"Spine","permalink":"http://example.com/tags/Spine/"},{"name":"2d Animation","slug":"2d-Animation","permalink":"http://example.com/tags/2d-Animation/"},{"name":"2d序列帧动画","slug":"2d序列帧动画","permalink":"http://example.com/tags/2d%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB/"},{"name":"2d相关","slug":"2d相关","permalink":"http://example.com/tags/2d%E7%9B%B8%E5%85%B3/"},{"name":"Tilemap","slug":"Tilemap","permalink":"http://example.com/tags/Tilemap/"},{"name":"Sprite","slug":"Sprite","permalink":"http://example.com/tags/Sprite/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"2d物理系统","slug":"2d物理系统","permalink":"http://example.com/tags/2d%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"图片导入相关设置","slug":"图片导入相关设置","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/"},{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"NGUI","slug":"NGUI","permalink":"http://example.com/tags/NGUI/"},{"name":"NGUI基础知识","slug":"NGUI基础知识","permalink":"http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"XML","slug":"XML","permalink":"http://example.com/tags/XML/"},{"name":"XML实践项目","slug":"XML实践项目","permalink":"http://example.com/tags/XML%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"XML基础知识","slug":"XML基础知识","permalink":"http://example.com/tags/XML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]}