{"meta":{"title":"akiraの博客思密达","subtitle":"","description":"","author":"akira23369","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2025-02-06T20:57:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2025-02-06T20:57:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-02-06T20:57:28.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-02-06T20:57:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"csharp迭代器","slug":"编程语言/Csharp/csharp迭代器","date":"2025-03-03T12:31:58.000Z","updated":"2025-03-03T13:09:41.419Z","comments":true,"path":"2025/03/03/编程语言/Csharp/csharp迭代器/","permalink":"http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"迭代器是什么 在 C# 中，迭代器（Iterator） 是一种用于遍历集合（如数组、列表等）元素的机制，它允许你按顺序访问集合中的每个元素而不必暴露集合的内部结构。迭代器的核心是通过 IEnumerable 和 IEnumerator 接口实现的，但 C# 提供了更简洁的语法（yield 关键字）来简化迭代器的创建。 在表现效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口。设计人员无需关心容器对象的内存分配的实现细节，可以用foreach遍历的类，都是实现了迭代器的。 迭代器的基本概念 IEnumerable 接口：表示一个集合可以被迭代，包含一个 GetEnumerator 方法。 IEnumerator 接口：提供了遍历集合的能力，包含 MoveNext()、Reset() 和 Current 属性。 标准迭代器实现（手动版） 接口定义： 1234567891011public interface IEnumerable&#123; IEnumerator GetEnumerator();&#125;public interface IEnumerator&#123; bool MoveNext(); object Current &#123; get; &#125; void Reset(); // 实际开发中通常不实现&#125; 完整实现示例： 123456789101112131415161718192021222324252627282930public class MyCollection : IEnumerable&#123; private int[] data = &#123; 1, 2, 3 &#125;; public IEnumerator GetEnumerator() =&gt; new MyEnumerator(data); // 自定义枚举器 private class MyEnumerator : IEnumerator &#123; private int[] data; private int index = -1; public MyEnumerator(int[] data) =&gt; this.data = data; public bool MoveNext() &#123; index++; return index &lt; data.Length; &#125; public object Current =&gt; data[index]; public void Reset() =&gt; index = -1; &#125;&#125;// 使用：foreach (int num in new MyCollection())&#123; Console.WriteLine(num); // 输出 1 2 3&#125; foreach本质 foreach本质: 先获取in后面这个对象的 IEnumerator 会调用对象其中的GetEnumerator方法 执行得到这个IEnumerator对象中的 MoveNext方法 只要MoveNext()方法的返回值时true 就会去得到Current然后复制给 item 123456789101112131415161718192021foreach (var item in collection) &#123; // code&#125;// 等价于：IEnumerator enumerator = collection.GetEnumerator();try &#123; while (enumerator.MoveNext()) &#123; var item = enumerator.Current; // code &#125;&#125;finally &#123; IDisposable disposable = enumerator as IDisposable; disposable?.Dispose();&#125; yield return 语法糖 C# 的 yield return 关键字可以快速定义迭代器，无需手动实现 IEnumerator 基本作用：简化迭代器 yield return 的作用是告诉编译器：“帮我自动生成一个迭代器，按我写的顺序逐个返回这些值”。例如： 123456IEnumerable&lt;int&gt; GetNumbers()&#123; yield return 10; yield return 20; yield return 30;&#125; 当调用 GetNumbers() 时，它不会一次性返回所有值，而是返回一个“待执行的迭代器”。只有当你用 foreach 遍历时，才会按顺序取出每个值。 关键特性：延迟执行（Lazy） yield return 的代码不会一次性全部执行，而是按需执行。看这个例子： 12345678910111213141516IEnumerable&lt;string&gt; GetMessages()&#123; Console.WriteLine(&quot;开始迭代&quot;); yield return &quot;第一步&quot;; Console.WriteLine(&quot;执行到中间&quot;); yield return &quot;第二步&quot;; Console.WriteLine(&quot;结束迭代&quot;);&#125;// 测试代码：var messages = GetMessages(); // 这里不会输出任何内容！Console.WriteLine(&quot;准备遍历&quot;);foreach (var msg in messages) // 此时才开始真正执行&#123; Console.WriteLine(msg);&#125; 关键点： 调用 GetMessages() 时，代码不会运行，只是返回一个“迭代器对象”。 当 foreach 开始遍历时，代码才从头执行，每次遇到 yield return 时： 返回一个值， 暂停当前方法，记录当前位置（状态）。 下次循环时，从暂停的位置继续执行。 底层原理：状态机 编译器会将 yield return 代码转换为一个隐藏的“状态机”类。例如，上述 GetMessages() 会被编译成一个类似如下的类： 12345678910111213141516171819202122232425262728class GeneratedStateMachine : IEnumerator&lt;string&gt;&#123; private int _state = 0; public string Current &#123; get; private set; &#125; public bool MoveNext() &#123; switch (_state) &#123; case 0: Console.WriteLine(&quot;开始迭代&quot;); Current = &quot;第一步&quot;; _state = 1; return true; case 1: Console.WriteLine(&quot;执行到中间&quot;); Current = &quot;第二步&quot;; _state = 2; return true; case 2: Console.WriteLine(&quot;结束迭代&quot;); return false; // 结束 default: return false; &#125; &#125; // 其他接口方法（略）&#125; yield break yield break 的基本作用 功能：在迭代器方法中，yield break 会立即终止迭代，不再生成后续的值。 1234567891011121314IEnumerable&lt;int&gt; GetNumbers()&#123; yield return 1; yield return 2; yield break; // 这里终止，后续的 yield return 不会执行 yield return 3; // 永远不会执行&#125;// 使用foreach (var num in GetNumbers())&#123; Console.WriteLine(num);&#125;// 输出：1, 2 实际应用案例 分页加载数据 1234567891011121314IEnumerable&lt;int&gt; LoadBigData()&#123; int pageSize = 1000; for (int page = 0; ; page++) &#123; var data = QueryDatabase(page, pageSize); if (data.Count == 0) yield break; foreach (var item in data) &#123; yield return item; &#125; &#125;&#125; 游戏技能连招系统： 123456789101112IEnumerator ComboAttack()&#123; yield return PlayAnimation(&quot;Attack1&quot;); if (Input.GetButton(&quot;Attack&quot;)) &#123; yield return PlayAnimation(&quot;Attack2&quot;); if (Input.GetButton(&quot;Attack&quot;)) &#123; yield return PlayAnimation(&quot;FinalBlow&quot;); &#125; &#125;&#125; 树形结构遍历： 1234567891011public IEnumerable&lt;Node&gt; Traverse(Node root)&#123; yield return root; foreach (var child in root.Children) &#123; foreach (var node in Traverse(child)) &#123; yield return node; &#125; &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp多线程","slug":"编程语言/Csharp/csharp多线程","date":"2025-03-03T12:20:16.000Z","updated":"2025-03-03T12:20:30.543Z","comments":true,"path":"2025/03/03/编程语言/Csharp/csharp多线程/","permalink":"http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园 线程基础 创建线程 Thread t = new Thread(PrintNumbers) 12345678910111213141516static void Main(string[] args)&#123; Thread t = new Thread(PrintNumbers); t.Start();//线程开始执行 PrintNumbers(); Console.ReadKey();&#125;static void PrintNumbers()&#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Console.WriteLine(i); &#125;&#125; 暂停线程 Thread.Sleep 工作原理： 当线程处于休眠状态时，它会占用尽可能少的 CPU 时间。结果我们会发现通常后运行的 PrintNumbers 方法中的代码会比独立线程中的 PrintNumbersWithDelay暂停2S 方法中的代码先执行。 1234567891011121314151617181920212223242526272829class Program&#123; static void Main(string[] args) &#123; Thread t = new Thread(PrintNumbersWithDelay); t.Start(); PrintNumbers(); Console.ReadKey(); &#125; static void PrintNumbers() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Console.WriteLine(i); &#125; &#125; static void PrintNumbersWithDelay() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2));//暂停2S Console.WriteLine(i); &#125; &#125;&#125; 线程等待 t.Join() 工作原理： 但我们在主程序中调用了 t.Join 方法，该方法允许我们等待直到线程 t 完成。当线程 t 完成时，主程序会继续运行。 借助该技术可以实现在两个线程间同步执行步骤。第一个线程会等待另一个线程完成后再继续执行。第一个线程等待时是处于阻塞状态 (正如暂停线程中调用 Thread.Sleep 方法一样)。 123456789101112131415161718192021class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Starting program...&quot;); Thread t = new Thread(PrintNumbersWithDelay); t.Start(); t.Join(); Console.WriteLine(&quot;Thread completed&quot;); &#125; static void PrintNumbersWithDelay() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(i); &#125; &#125;&#125; 终止线程 t.Abort() 弃用了 工作原理： 当主程序和单独的数字打印线程运行时，我们等待 6 秒后对线程调用了 t.Abort 方法。 这给线程注入了 ThreadAbortException 方法，导致线程被终结。这非常危险，因为该异常可以在任何时刻发生并可能彻底摧毁应用程序。 另外，使用该技术也不一定总能终止线程。目标线程可以通过处理该异常并调用 Thread.ResetAbort 方法来拒绝被终止。因此并不推荐使用 Abort 方法来关闭线程。 可优先使用一些其他方法，比如提供一个 CancellationToken 方法来取消线程的执行。 12345678910111213141516171819202122class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Starting program...&quot;); Thread t = new Thread(PrintNumbersWithDelay); t.Start(); Thread.Sleep(TimeSpan.FromSeconds(6)); t.Abort(); Console.WriteLine(&quot;A thread has been aborted&quot;); &#125; static void PrintNumbersWithDelay() &#123; Console.WriteLine(&quot;Starting...&quot;); for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(i); &#125; &#125;&#125; 监测线程状态 Thread 对象的 ThreadState: Unstarted：线程已被创建，但尚未调用 Start 方法启动。 Running ：线程正在执行。当调用 Start 方法后，线程进入此状态并开始执行其关联的方法。 WaitSleepJoin：线程正在等待、休眠或被阻塞。当线程调用 Sleep、Wait 或 Join 方法时，会进入此状态。 Suspended（不推荐使用）：线程已被挂起。可以使用 Suspend 方法将线程挂起，但该方法已被弃用，因为它可能会导致死锁等问题。 Stopped：线程已完成执行或被终止，处于停止状态。 Aborted：线程已被调用 Abort 方法终止，但尚未完全停止执行。 。。。。。。。。。 工作原理： 当主程序启动时定义了两个不同的线程。一个将被终止，另一个则会成功完成运行。 线程状态位于 Thread 对象的 ThreadState 属性中。ThreadState 属性是一个 C# 枚举对象。 刚开始线程状态为 ThreadState.Unstarted, 然后我们启动线程，并估计在一个周期为 30 次迭代的区间中，线程状态会从 ThreadState.Running 变为 ThreadState.WaitSleepJoin。 请注意始终可以通过 Thread.CurrentThread 静态属性获得当前 Thread 对象。 如果实际情况与以上不符，请增加迭代次数。终止第一个线程后，会看到现在该线程状态为 ThreadState.Aborted, 程序也有可能会打印出 ThreadState.AbortRequested 状态。这充分说明了同步两个线程的复杂性。请记住不要在程序中使用线程终止。我在这里使用它只是为了展示相应的线程状态。 最后可以看到第二个线程 t2 成功完成并且状态为 ThreadState.Stopped。另外还有一些其他的线程状态，但是要么已经被弃用，要么没有我们实验过的几种状态有用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;Starting program...&quot;); Thread t = new Thread(PrintNumbersWithStatus); Thread t2 = new Thread(DoNothing); // 线程 t 的初始状态 Console.WriteLine(t.ThreadState.ToString()); t2.Start(); t.Start(); // 循环 29 次，输出线程 t 的状态 for (int i = 1; i &lt; 30; i++) &#123; Console.WriteLine(t.ThreadState.ToString()); &#125; // 主线程休眠 6 秒 Thread.Sleep(TimeSpan.FromSeconds(6)); // 终止线程 t t.Abort(); Console.WriteLine(&quot;A thread has been aborted&quot;); // 线程 t 终止后的状态 Console.WriteLine(t.ThreadState.ToString()); // 线程 t2 的状态 Console.WriteLine(t2.ThreadState.ToString()); Console.ReadKey(); &#125; static void DoNothing() &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); &#125; static void PrintNumbersWithStatus() &#123; Console.WriteLine(&quot;Starting...&quot;); // 输出当前线程的状态 Console.WriteLine(Thread.CurrentThread.ThreadState.ToString()); // 循环 9 次，每次打印一个数字，每次循环间隔 2 秒 for (int i = 1; i &lt; 10; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(i); &#125; &#125;&#125; 线程优先级 Thread.CurrentThread.Priority 工作原理： 当主程序启动时定义了两个不同的线程。 第一个线程优先级为 ThreadPriority.Highest, 即具有最高优先级。 第二个线程优先级为 ThreadPriority.Lowest, 即具有最低优先级。 我们先打印出主线程的优先级值，然后在所有可用的 CPU 核心上启动这两个线程。如果拥有一个 1 以上的计算核心，将在两秒钟内得到初步结果。最高优先级的线程通常会计算更多的迭代，但是两个值应该很接近。然而，如果有其他程序占用了所有的 CPU 核心运行负载，结果则会截然不同。 为了模拟该情形，我们设置了 ProcessorAffinity 选项，让操作系统将所有的线程运行在单个 CPU 核心 (第一个核心) 上。现在结果完全不同，并且计算耗时将超过 2 秒钟。这是因为 CPU 核心大部分时间在运行高优先级的线程，只留给剩下的线程很少的时间来运行。 请注意这是操作系统使用线程优先级的一个演示。通常你无需使用这种行为编写程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Program&#123; static void Main(string[] args) &#123; // 输出当前线程的优先级 Console.WriteLine(&quot;Current thread priority: &#123;0&#125;&quot;, Thread.CurrentThread.Priority); Console.WriteLine(&quot;Running on all cores available&quot;); // 调用 RunThreads 方法启动线程, 程序将在所有可用核心上运行 RunThreads(); // 主线程休眠 2 秒 Thread.Sleep(TimeSpan.FromSeconds(2)); Console.WriteLine(&quot;Running on a single core&quot;); // 设置当前进程仅使用一个核心 Process.GetCurrentProcess().ProcessorAffinity = new IntPtr(1); // 启动线程 RunThreads(); &#125; // 启动两个线程并设置不同优先级的方法 static void RunThreads() &#123; var sample = new ThreadSample(); var threadOne = new Thread(sample.CountNumbers); threadOne.Name = &quot;ThreadOne&quot;; // 线程命名 var threadTwo = new Thread(sample.CountNumbers); threadTwo.Name = &quot;ThreadTwo&quot;; // 设置第一个线程的优先级为最高 threadOne.Priority = ThreadPriority.Highest; // 设置第二个线程的优先级为最低 threadTwo.Priority = ThreadPriority.Lowest; threadOne.Start(); threadTwo.Start(); // 主线程休眠 2 秒 Thread.Sleep(TimeSpan.FromSeconds(2)); // 调用 Stop 方法停止线程计数 sample.Stop(); Console.ReadKey(); &#125; class ThreadSample &#123; // 用于控制线程计数循环的标志 private bool _isStopped = false; // 停止线程计数的方法 public void Stop() &#123; _isStopped = true; &#125; // 线程执行的计数方法 public void CountNumbers() &#123; // 初始化计数器 long counter = 0; // 只要未停止，就持续计数 while (!_isStopped) &#123; counter++; &#125; // 输出线程名称、优先级和计数结果 Console.WriteLine(&quot;&#123;0&#125; with &#123;1,11&#125; priority &quot; + &quot;has a count = &#123;2,13&#125;&quot;, Thread.CurrentThread.Name, Thread.CurrentThread.Priority, counter.ToString(&quot;N0&quot;)); &#125; &#125;&#125; 前台线程和后台线程 thread.IsBackground = true 工作原理： 当主程序启动时定义了两个不同的线程。默认情况下，显式创建的线程是前台线程。通过手动的设置 threadTwo 对象的 IsBackground 属性为 ture 来创建一个后台线程(可以在主线程设置其它线程执行完毕的条件)。通过配置来实现第一个线程会比第二个线程先完成。然后运行程序。 第一个线程完成后，程序结束并且后台线程被终结。这是前台线程与后台线程的主要区别：进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结束工作。 一个重要注意事项是：如果程序定义了一个不会完成的前台线程，主程序并不会正常结束。 12345678910111213141516171819202122232425262728293031323334353637class Program&#123; static void Main(string[] args) &#123; var sampleForeground = new ThreadSample(10); var sampleBackground = new ThreadSample(20); var threadOne = new Thread(sampleForeground.CountNumbers); threadOne.Name = &quot;ForegroundThread&quot;; var threadTwo = new Thread(sampleBackground.CountNumbers); threadTwo.Name = &quot;BackgroundThread&quot;; threadTwo.IsBackground = true; threadOne.Start(); threadTwo.Start(); Console.ReadKey(); &#125; class ThreadSample &#123; private readonly int _iterations; public ThreadSample(int iterations) &#123; _iterations = iterations; &#125; public void CountNumbers() &#123; for (int i = 0; i &lt; _iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine(&quot;&#123;0&#125; prints &#123;1&#125;&quot;, Thread.CurrentThread.Name, i); &#125; &#125; &#125;&#125; 向线程传递参数 通过实例字段间接传递参数 Thread.Start 方法传入object类型参数 另一种传递数据的方式是使用 Thread.Start 方法。该方法会接收一个对象，并将该对象传递给线程。为了应用该方法，在线程中启动的方法必须接受 object 类型的单个参数。在创建 threadTwo 线程时演示了该方式。我们将 8 作为一个对象传递给了 Count 方法，然后 Count 方法被转换为整型。 使用 Lambda 表达式捕获变量 接下来的方式是使用 lambda 表达式。lambda 表达式定义了一个不属于任何类的方法。我们创建了一个方法，该方法使用需要的参数调用了另一个方法，并在另一个线程中运行该方法。当启动 threadThree 线程时，打印出了 12 个数字，这正是我们通过 lambda 表达式传递的数字。 使用 lambda 表达式引用另一个 C# 对象的方式被称为csharp的Lambda表达式。当在 lambda 表达式中使用任何局部变量时，C# 会生成一个类，并将该变量作为该类的一个属性。所以实际上该方式与 threadOne 线程中使用的一样，但是我们无须定义该类，C# 编译器会自动帮我们实现。 这可能会导致几个问题。例如，如果在多个 lambda 表达式中使用相同的变量，它们会共享该变量值。在前一个例子中演示了这种情况。当启动 threadFour 和 threadFive 线程时，它们都会打印 20, 因为在这两个线程启动之前变量被修改为 20。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990using System;using System.Threading;class Program&#123; static void Main(string[] args) &#123; // 指定迭代次数为 10 var sample = new ThreadSample(10); // 创建第一个线程，执行 sample 实例的 CountNumbers 方法 var threadOne = new Thread(sample.CountNumbers); threadOne.Name = &quot;ThreadOne&quot;; threadOne.Start(); // 主线程等待 threadOne 执行完毕 threadOne.Join(); Console.WriteLine(&quot;--------------------------&quot;); // 创建第二个线程，执行静态方法 Count var threadTwo = new Thread(Count); threadTwo.Name = &quot;ThreadTwo&quot;; // 启动线程并传递参数 8 threadTwo.Start(8); // 主线程等待 threadTwo 执行完毕 threadTwo.Join(); Console.WriteLine(&quot;--------------------------&quot;); // 创建第三个线程，使用 Lambda 表达式调用静态方法 CountNumbers var threadThree = new Thread(() =&gt; CountNumbers(12)); threadThree.Name = &quot;ThreadThree&quot;; threadThree.Start(); // 主线程等待 threadThree 执行完毕 threadThree.Join(); Console.WriteLine(&quot;--------------------------&quot;); // 定义一个整数变量 i 并初始化为 10 int i = 10; // 创建第四个线程，使用 Lambda 表达式调用静态方法 PrintNumber var threadFour = new Thread(() =&gt; PrintNumber(i)); // 修改变量 i 的值为 20 i = 20; // 创建第五个线程，使用 Lambda 表达式调用静态方法 PrintNumber var threadFive = new Thread(() =&gt; PrintNumber(i)); threadFour.Start(); threadFive.Start(); &#125; static void Count(object iterations) &#123; CountNumbers((int)iterations); &#125; // 静态方法，用于循环打印线程名称和迭代次数，每次循环间隔 0.5 秒 static void CountNumbers(int iterations) &#123; for (int i = 1; i &lt;= iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine(&quot;&#123;0&#125; prints &#123;1&#125;&quot;, Thread.CurrentThread.Name, i); &#125; &#125; static void PrintNumber(int number) &#123; Console.WriteLine(number); &#125; class ThreadSample &#123; // 迭代次数 private readonly int _iterations; public ThreadSample(int iterations) &#123; _iterations = iterations; &#125; // 循环打印线程名称和迭代次数，每次循环间隔 0.5 秒 public void CountNumbers() &#123; for (int i = 1; i &lt;= _iterations; i++) &#123; Thread.Sleep(TimeSpan.FromSeconds(0.5)); Console.WriteLine(&quot;&#123;0&#125; prints &#123;1&#125;&quot;, Thread.CurrentThread.Name, i); &#125; &#125; &#125;&#125; 使用 C# 中的 lock 关键字 lock 的作用 线程同步：确保在多线程环境下，同一时间只有一个线程可以访问临界区（被锁保护的代码块）。 解决竞态条件：防止多个线程同时修改共享资源导致数据不一致。 基本语法 123456789private readonly object _lockObj = new object(); // 锁对象必须是引用类型void ThreadSafeMethod()&#123; lock (_lockObj) &#123; // 临界区代码（同一时间仅一个线程可执行） &#125;&#125; 底层原理 基于 Monitor 类：lock 是语法糖，编译后等价于： 1234567891011bool lockTaken = false;try&#123; Monitor.Enter(_lockObj, ref lockTaken); // 临界区代码&#125;finally&#123; if (lockTaken) Monitor.Exit(_lockObj);&#125; 不安全的计数器（Counter 类） 与 安全的计数器（CounterWithLock 类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Program&#123; static void Main(string[] args) &#123; // 不正确的计数器 Console.WriteLine(&quot;Incorrect counter&quot;); var c = new Counter(); var t1 = new Thread(() =&gt; TestCounter(c)); var t2 = new Thread(() =&gt; TestCounter(c)); var t3 = new Thread(() =&gt; TestCounter(c)); t1.Start(); t2.Start(); t3.Start(); t1.Join(); t2.Join(); t3.Join(); Console.WriteLine(&quot;Total count: &#123;0&#125;&quot;,c.Count); Console.WriteLine(&quot;--------------------------&quot;); // 正确的计数器 Console.WriteLine(&quot;Correct counter&quot;); var c1 = new CounterWithLock(); t1 = new Thread(() =&gt; TestCounter(c1)); t2 = new Thread(() =&gt; TestCounter(c1)); t3 = new Thread(() =&gt; TestCounter(c1)); t1.Start(); t2.Start(); t3.Start(); t1.Join(); t2.Join(); t3.Join(); Console.WriteLine(&quot;Total count: &#123;0&#125;&quot;, c1.Count); Console.ReadKey(); &#125; static void TestCounter(CounterBase c) &#123; for (int i = 0; i &lt; 100000; i++) &#123; c.Increment(); c.Decrement(); &#125; &#125; // 没加锁的计数器 class Counter : CounterBase &#123; public int Count &#123; get; private set; &#125; public override void Increment() &#123; Count++; &#125; public override void Decrement() &#123; Count--; &#125; &#125; // 加了锁的计数器 class CounterWithLock : CounterBase &#123; private readonly object _syncRoot = new Object(); public int Count &#123; get; private set; &#125; public override void Increment() &#123; lock (_syncRoot) &#123; Count++; &#125; &#125; public override void Decrement() &#123; lock (_syncRoot) &#123; Count--; &#125; &#125; &#125; abstract class CounterBase &#123; public abstract void Increment(); public abstract void Decrement(); &#125;&#125; lock相关注意： (1) 锁对象的选择 锁对象必须是引用类型：值类型会被装箱，每次装箱生成新对象，导致锁失效。 私有且只读：防止锁对象被修改。推荐模式：private readonly object _lockObj = new object(); // 专用锁对象 (2) 临界区最小化 锁的粒度要细：仅保护真正需要同步的资源，减少锁持有时间 12345678910111213141516// 错误：锁范围过大lock (_lockObj)&#123; ReadData(); ProcessData(); // 长时间计算 WriteData();&#125;// 正确：仅锁共享数据操作var data = ReadData();var result = ProcessData(data); // 无锁计算lock (_lockObj)&#123; WriteData(result);&#125; (3) 避免嵌套锁 死锁风险：若多个锁以不同顺序嵌套获取，可能引发死锁。 1234567891011// 线程1lock (A)&#123; lock (B) &#123; ... &#125;&#125;// 线程2lock (B) // 若线程1已持A等B，线程2持B等A → 死锁&#123; lock (A) &#123; ... &#125;&#125; 使用Monitor类锁定资源* 代码行为分析 第一部分（使用 TryEnter 避免死锁） 线程1执行 LockTooMuch：获取 lock1 → 休眠 1 秒 → 尝试获取 lock2。 主线程：获取 lock2 → 休眠 1 秒 → 尝试通过 TryEnter 获取 lock1（超时 5 秒）。 可能的执行结果： 线程1持有 lock1，等待 lock2；主线程持有 lock2，等待 lock1 → 死锁条件成立。 但由于主线程使用 TryEnter，5 秒后会超时并释放 lock2，随后线程1最终能获取 lock2，继续执行。 输出：Timeout acquiring a resource!。 第二部分（直接死锁） 线程2再次执行 LockTooMuch（同上）。 主线程再次尝试以 lock2 → lock1 顺序获取锁。 结果：主线程持有 lock2，等待 lock1；线程2持有 lock1，等待 lock2 → 死锁，程序永久阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Program&#123; static void Main(string[] args) &#123; // 创建两个锁对象 object lock1 = new object(); object lock2 = new object(); // 启动第一个线程：尝试以 lock1 → lock2 顺序获取锁 new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start(); // 主线程尝试以 lock2 → lock1 顺序获取锁 lock (lock2) // 主线程获取 lock2 &#123; Thread.Sleep(1000); // 等待 1 秒（让第一个线程先获取 lock1） Console.WriteLine(&quot;Monitor.TryEnter 允许不阻塞，在超时后返回 false&quot;); // 尝试在 5 秒内获取 lock1（非阻塞式） if (Monitor.TryEnter(lock1, TimeSpan.FromSeconds(5))) &#123; Console.WriteLine(&quot;成功获取受保护资源！&quot;); Monitor.Exit(lock1); // 释放锁（实际代码中应使用 finally 确保释放） &#125; else &#123; Console.WriteLine(&quot;获取资源超时！&quot;); // 此处未获取到 lock1，但 lock2 会在当前代码块结束后自动释放 &#125; &#125; // 第二次启动线程：再次尝试 lock1 → lock2 顺序 new Thread(() =&gt; LockTooMuch(lock1, lock2)).Start(); Console.WriteLine(&quot;----------------------------------&quot;); // 主线程再次尝试以 lock2 → lock1 顺序获取锁（此次无超时机制） lock (lock2) // 获取 lock2 &#123; Console.WriteLine(&quot;这将引发死锁！&quot;); Thread.Sleep(1000); // 尝试获取 lock1（此时第一个线程可能持有 lock1 并等待 lock2） lock (lock1) // 阻塞在此处，无法继续执行 &#123; Console.WriteLine(&quot;成功获取受保护资源！&quot;); // 永远不会执行 &#125; &#125; Console.ReadKey(); &#125; static void LockTooMuch(object lock1, object lock2) &#123; lock (lock1) // 先获取 lock1 &#123; Thread.Sleep(1000); // 等待 1 秒（让主线程有机会获取 lock2） lock (lock2) // 再尝试获取 lock2（可能导致死锁） &#123; // 临界区代码 &#125; &#125; &#125;&#125; 多线程异常处理 异常作用域规则 线程是独立执行路径：每个线程拥有自己的异常处理上下文。 主线程无法直接捕获子线程的异常：try-catch 在父线程中无法捕获子线程未处理的异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Program&#123; static void Main(string[] args) &#123; // 第一个线程：内部捕获异常 var t = new Thread(FaultyThread); t.Start(); // 启动线程 t.Join(); // 等待线程结束（此时异常已被内部处理，不会传播到主线程） // 第二个线程：未处理异常 try &#123; t = new Thread(BadFaultyThread); t.Start(); // 启动线程（但未调用 Join） // 主线程不会等待此线程结束，try-catch 无法捕获子线程异常！ &#125; catch (Exception ex) &#123; // 此处永远不会执行，因为子线程的异常不会传递到主线程 Console.WriteLine(&quot;We won&#x27;t get here!&quot;); &#125; &#125; // 方法：内部捕获异常 static void FaultyThread() &#123; try &#123; Console.WriteLine(&quot;Starting a faulty thread...&quot;); Thread.Sleep(TimeSpan.FromSeconds(1)); throw new Exception(&quot;Boom!&quot;); // 抛出异常 &#125; catch (Exception ex) &#123; // 异常在此处被捕获并处理 Console.WriteLine(&quot;Exception handled: &#123;0&#125;&quot;, ex.Message); &#125; &#125; // 方法：未处理异常 static void BadFaultyThread() &#123; Console.WriteLine(&quot;Starting a faulty thread...&quot;); Thread.Sleep(TimeSpan.FromSeconds(2)); throw new Exception(&quot;Boom!&quot;); // 抛出未捕获的异常 &#125;&#125; 正确捕获子线程异常的方法 (1) 在线程方法内部处理异常 12345void SafeThreadMethod()&#123; try &#123; /* 代码 */ &#125; catch (Exception ex) &#123; /* 记录或处理异常 */ &#125;&#125; (2) 使用 Task 替代 Thread 优势：通过 Task.Exception 属性聚合所有异常（AggregateException）。 12345678910Task.Run(() =&gt; &#123; // 可能抛异常的代码&#125;).ContinueWith(t =&gt; &#123; if (t.Exception != null) &#123; Console.WriteLine(&quot;捕获异常: &quot; + t.Exception.InnerException.Message); &#125;&#125;, TaskContinuationOptions.OnlyOnFaulted); (3) 全局异常捕获（不推荐） 1234AppDomain.CurrentDomain.UnhandledException += (sender, e) =&gt; &#123; Console.WriteLine(&quot;全局捕获: &quot; + e.ExceptionObject.ToString());&#125;;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"10.协同程序","slug":"游戏引擎/unity/unity基础/10.协同程序","date":"2025-03-02T11:15:55.000Z","updated":"2025-03-03T14:46:22.500Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/10.协同程序/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"简单回顾csharp中的多线程 csharp多线程 Unity是否支持多线程？ Unity是支持多线程的，只是新开线程无法访问Unity相关场景上对象的内容。例如this.transform（必须在主线程调用）。 注意：Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑 在Unity中，不会开启多线程访问Unity相关。当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。 当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//新线程Thread newThread;//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西Queue&lt;Vector3&gt; queue = new Queue&lt;Vector3&gt;();//副线程可能也要拿主线程的数据用来判断做逻辑Queue&lt;Vector3&gt; queue2 = new Queue&lt;Vector3&gt;();void Start()&#123; //首先要明确一点 //Unity是支持多线程的 //只是新开线程无法访问Unity相关对象的内容 //引用System.Threading命名空间 newThread = new Thread(newThreadLogic); newThread.Start(); //注意： //Unity中的多线程 要记住关闭 //不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 //可以在OnDestroy执行关闭线程逻辑&#125;void Update()&#123; //在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用 if (queue.Count &gt; 0) &#123; //取出位置 this.transform.position = queue.Dequeue(); &#125;&#125;//新线程逻辑private void newThreadLogic()&#123; while (true) &#123; Thread.Sleep(1000); print(&quot;新线程逻辑 每隔一秒的打印&quot;); //我们在Unity中，不会开启多线程访问Unity相关 //当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿 //这时就可以开启多线程用于A星寻路算法，网络收发相关 //当算好了结果或者收到了消息过后，放在公共的内存区域 //主线程判断判断公共的内存区域有没有想要的对象，拿来使用 //这句代码会报错 不能在副线程控制Unity相关 //UnityException: get_transform can only be called from the main thread. //this.transform.Translate(Vector3.forward * Time.deltaTime); //相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中 //用Unity的随机数都不能用 用C#里的随机数 System.Random r = new System.Random(); queue.Enqueue(new Vector3(r.Next(-10, 10), r.Next(-10, 10), r.Next(-10, 10))); &#125;&#125;private void OnDestroy()&#123; //关闭线程 newThread.Abort(); //关闭线程后置空 newThread = null;&#125; 什么是协程？ 协程（Coroutine）是Unity中一种特殊的函数，可以分步执行代码并跨越多帧运行。它通过yield关键字暂停执行，并在特定条件（如等待时间结束、帧结束等）满足后继续执行。 它是“假”的多线程，它不是多线程 它的本质是迭代器 C#的迭代器**函数”分步执行”的特点 加上 Unity自己定义的一些协程调度逻辑 实现的一套分时执行函数的规则 协程的主要作用 将代码分时执行，不卡主线程 简单理解，是把可能会让主线程卡顿的耗时的逻辑分时分步执行 处理延时操作：例如等待1秒后执行代码。 分步执行任务：将复杂任务拆分成多个步骤，避免卡顿。 按帧控制逻辑：逐帧处理动画、AI行为等。 异步加载资源：分批加载资源防止主线程阻塞。 异步下载文件 场景异步加载 批量创建时防止卡顿 主要使用场景 角色技能冷却倒计时。 分批次加载大型场景或资源。 实现平滑的动画过渡（如物体渐隐）。 等待网络请求返回后更新UI。 协同程序和线程的区别 新开一个线程是独立的一个管道，与主线程并行执行。 新开一个协程是在原线程之上开启，进行逻辑分时分步执行。 回顾yield return相关知识点 协程的使用方法 基本规则： 协程方法的返回类型必须是 IEnumerator。 使用 yield return 指定暂停条件（如 new WaitForSeconds(2)）。 通过 StartCoroutine() 启动协程。 启动协程： 基本语法： 12345678910111213141516public class CoroutineExample : MonoBehaviour&#123; void Start() &#123; // 启动协程 StartCoroutine(SimpleCoroutine()); &#125; IEnumerator MyCoroutine(string hello) &#123; Debug.Log($&quot;协程开始，say hello\\n&#123;hello&#125;&quot;); yield return new WaitForSeconds(1); // 暂停1秒 Debug.Log(&quot;1秒后执行&quot;); yield return new WaitForSeconds(2); // 再暂停2秒 Debug.Log(&quot;又过了2秒&quot;); &#125;&#125; Unity 提供了多种内置的等待指令，可以直接在协程中使用： 指令 说明 指令满足之后在哪里执行 null 或者 数字 等待到下一帧（等同 yield return null） Update和LateUpdate之间执行 WaitForSeconds 等待指定秒数（受Time.timeScale时间缩放影响） Update和LateUpdate之间执行 WaitForSecondsRealtime 等待指定秒数（不受Time.timeScale时间缩放影响） Update之后 WaitForFixedUpdate 等待到下一个 FixedUpdate 在FixedUpdate和碰撞检测相关函数之后执行 WaitForEndOfFrame 等待到帧结束（截图功能） 等待摄像机和GUI渲染完成后执行，在LateUpdate之后的渲染相关处理完毕后之后 WWW 或 UnityWebRequest 等待网络请求完成 Update之后 停止协程 123456// 停止单个协程Coroutine coroutine = StartCoroutine(MyCoroutine());StopCoroutine(coroutine);// 停止所有协程StopAllCoroutines(); 协程的典型使用场景 场景 1：延迟执行 123456IEnumerator DelayedAction()&#123; yield return new WaitForSeconds(3); Debug.Log(&quot;3秒后执行爆炸效果&quot;); // 触发爆炸动画、音效等&#125; 场景 2：分帧处理大数据 12345678IEnumerator ProcessLargeData(List&lt;Item&gt; data)&#123; foreach (var item in data) &#123; ProcessItem(item); // 处理单个数据 yield return null; // 每帧处理一个，避免卡顿 &#125;&#125; 场景 3：按顺序执行多段逻辑 12345678IEnumerator DialogueSequence()&#123; ShowText(&quot;你好，旅行者！&quot;); yield return new WaitUntil(() =&gt; Input.GetKeyDown(KeyCode.Space)); // 等待玩家按空格 ShowText(&quot;前方有危险...&quot;); yield return new WaitForSeconds(2); ShowText(&quot;准备好了吗？&quot;);&#125; 协程受对象和组件失活销毁的影响 协程开启后： 组件或物体销毁，物体失活，则协程不再执行。 组件失活时，协程仍然执行。 练习 协程实现的计秒器 1234567891011121314151617181920212223242526272829303132using UnityEngine;using UnityEngine.UI;public class Timer : MonoBehaviour&#123; public Text timerText; // 关联UI文本 private float elapsedTime; private bool isRunning; void Start() &#123; StartCoroutine(CountSeconds()); &#125; IEnumerator CountSeconds() &#123; isRunning = true; while (isRunning) &#123; elapsedTime += Time.deltaTime; // 显示格式化为整数秒（或保留1位小数） timerText.text = &quot;Time: &quot; + elapsedTime.ToString(&quot;F1&quot;); yield return null; // 每帧更新 &#125; &#125; // 停止计时（可选） public void StopTimer() &#123; isRunning = false; &#125;&#125; 分帧创建10万立方体（无卡顿） 原本 1帧 创建 10万个 现在 1帧 创建 cubesPerFrame 个 比较蠢的做法 12345for (int i = 0; i &lt; 100000; i++)&#123; GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube); obj.transform.position = new Vector3(Random.Range(-100, 100), Random.Range(-100, 100), Random.Range(-100, 100));&#125; 1234567891011121314151617181920212223242526272829303132333435using UnityEngine;public class CubeSpawner : MonoBehaviour&#123; public GameObject cubePrefab; // 立方体预制体 public int totalCubes = 100000; public int cubesPerFrame = 500; // 每帧生成的数量 void Start() &#123; StartCoroutine(SpawnCubes()); &#125; IEnumerator SpawnCubes() &#123; int created = 0; while (created &lt; totalCubes) &#123; for (int i = 0; i &lt; cubesPerFrame; i++) &#123; if (created &gt;= totalCubes) break; // 随机生成位置（范围可调） Vector3 pos = new Vector3( Random.Range(-50f, 50f), Random.Range(-50f, 50f), Random.Range(-50f, 50f) ); Instantiate(cubePrefab, pos, Quaternion.identity); created++; &#125; yield return null; // 每帧分批生成 &#125; Debug.Log(&quot;生成完成&quot;); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"9.延迟函数","slug":"游戏引擎/unity/unity基础/9.延迟函数","date":"2025-03-02T09:08:38.000Z","updated":"2025-03-02T09:32:59.906Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/9.延迟函数/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/9.%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"什么是延迟函数 延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。 它是MonoBehaviour基类中实现好的方法。 延迟函数的使用 Invoke方法 开启延迟函数 注意: 没法调用有参数的函数 必须是该脚本上申明的函数 可以用DelayedFunction间接调用到其它对象, 或者有参数的函数 只有挂载的脚本对象失活可以继续执行, 其它情况都会无法继续执行 1234// 在time秒后调用methodName方法。 // 参数一：函数名字符串 // 参数二：延迟时间，秒为单位 Invoke(&quot;DelayDoSomething&quot;, 1); InvokeRepeating方法 开启延迟重复执行函数 与Invoke类似，但可以设置重复调用的间隔时间。 参数2：第一次延迟的时间 参数3：以后每次延迟的时间 123456789void Start()&#123; InvokeRepeating(&quot;RepeatedFunction&quot;, 2.0f, 1.0f); // 延时2秒后每隔1秒调用一次RepeatedFunction方法&#125;void RepeatedFunction()&#123; // 在这里写重复延时执行的代码&#125; CancelInvoke 取消延时调用 12CancelInvoke(&quot;Fun&quot;); // 只取消Fun，所有延迟执行Fun的都会没CancelInvoke(); // 无参数取消所有延时函数 IsInvoking方法 判断是否有延迟函数 1234567891011// 是否有任何待处理的methodName调用？// 不传入参数，判断该脚本上是否存在任何延迟函数if (IsInvoking())&#123; print(&quot;存在延迟函数&quot;);&#125;// 传入参数，判断该脚本上是否存在指定延迟函数if (IsInvoking(&quot;DelayDoSomething&quot;))&#123; print(&quot;存在延迟函数DelayDoSomething&quot;);&#125; 延迟函数受对象失活销毁影响 延迟函数在依附对象或者脚本失活时不受影响，但在对象销毁或者移除脚本时无法继续执行。 如果想在失活 或者 激活 的时候来执行延迟函数， 可以在生命周期函数OnEnable和OnDisable中做逻辑 123456789private void OnEnable()&#123; // 对象激活的生命周期函数中，开启延迟（重复执行的延迟）&#125;private void OnDisable()&#123; // 对象失活的生命周期函数中，停止延迟&#125; 练习 利用延时函数实现一个计秒器 12345678910111213141516171819// 使用延迟重复函数，一进来直接调用，然后每隔一秒调用，实现计时器InvokeRepeating(&quot;DelayTimer&quot;, 0, 1);// 直接执行函数 函数里面在写一个普通延迟函数每秒调用自己DelayTimer2();private void DelayTimer()&#123; print(time + &quot;秒&quot;); ++time;&#125;private void DelayTimer2()&#123; print(time + &quot;秒&quot;); ++time; Invoke(&quot;DelayTimer2&quot;, 1);&#125; 请用两种方式延时销毁一个指定对象 一个只能销毁，一个销毁还可以写逻辑 1234567891011// 通过Destroy来进行延迟销毁Destroy(this.gameObject, 5);// 延迟函数销毁，内部使用销毁逻辑，// 包裹一层，相比于Destroy直接销毁，假如想有其他逻辑也可以写在延迟销毁函数中Invoke(&quot;DelayDestroy&quot;, 5);private void DelayDestroy()&#123; Destroy(this.gameObject);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"8.Quaternion四元数计算","slug":"游戏引擎/unity/unity基础/8.Quaternion四元数计算","date":"2025-03-02T07:55:47.000Z","updated":"2025-03-02T09:02:57.869Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/8.Quaternion四元数计算/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/","excerpt":"","text":"四元数相乘 1234567//通过轴角对API传入要转的轴和角度//绕着y轴转20度Quaternion q = Quaternion.AngleAxis(20, Vector3.up);//乘上这个脚本挂载的立方体当前旋转四元数 让这个脚本挂载的立方体绕着y轴转20度this.transform.rotation *= q;//注意1：用四元数旋转完可能和Inspector窗口上的旋转对不上 不用管它//注意2：旋转相对的坐标系 是物体自身坐标系 四元数乘以向量 注意一定是 向量 = 四元数 * 向量 不是 向量 = 向量 * 四元数 123456789101112131415void Start()&#123; // 定义一个向量 Vector3 vector = new Vector3(1, 0, 0); // 定义一个四元数表示45度绕Y轴的旋转 Quaternion rotation = Quaternion.Euler(0, 45, 0); // 使用四元数旋转向量 Vector3 rotatedVector = rotation * vector; // 打印结果 Debug.Log(&quot;Original Vector: &quot; + vector); Debug.Log(&quot;Rotated Vector: &quot; + rotatedVector);&#125; 练习 模拟飞机发射不同类型子弹的方法：单发，双发，扇形，环形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//声明发射类型枚举public enum E_FireType&#123; //单发 One, //双发 Two, //扇形 Three, //环形 Round&#125;public class Airplane : MonoBehaviour&#123; //声明发射类型变量 private E_FireType nowType = E_FireType.One; //子弹 public GameObject bullet; public int roundNum = 4; void Update() &#123; //Update内添加按按键切换发射类型逻辑 if (Input.GetKeyDown(KeyCode.Alpha1)) &#123; nowType = E_FireType.One; &#125; else if (Input.GetKeyDown(KeyCode.Alpha2)) &#123; nowType = E_FireType.Two; &#125; else if (Input.GetKeyDown(KeyCode.Alpha3)) &#123; nowType = E_FireType.Three; &#125; else if (Input.GetKeyDown(KeyCode.Alpha4)) &#123; nowType = E_FireType.Round; &#125; //Update内添加按按键发射子弹逻辑 if (Input.GetKeyDown(KeyCode.Space)) &#123; Fire(); &#125; &#125; //开火方法 private void Fire() &#123; switch (nowType) &#123; case E_FireType.One: Instantiate(bullet, this.transform.position, this.transform.rotation); break; case E_FireType.Two: Instantiate(bullet, this.transform.position - this.transform.right * 0.5f, this.transform.rotation); Instantiate(bullet, this.transform.position + this.transform.right * 0.5f, this.transform.rotation); break; case E_FireType.Three: Instantiate(bullet, this.transform.position, this.transform.rotation); //左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加 Instantiate(bullet, this.transform.position, this.transform.rotation * Quaternion.AngleAxis(-20, Vector3.up)); //右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加 Instantiate(bullet, this.transform.position, this.transform.rotation * Quaternion.AngleAxis(20, Vector3.up)); break; case E_FireType.Round: float angle = 360 / roundNum; for (int i = 0; i &lt; roundNum; i++) //角度是当前偏移度数乘飞机自己的旋转 Instantiate(bullet, this.transform.position, this.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up)); break; &#125; &#125;&#125;#endregion 将此脚本制作成预制体，并拖到飞机的bullet 123456789101112131415//子弹一直往前飞，五秒后销毁public class Bullet : MonoBehaviour&#123; public float moveSpeed = 10; void Start() &#123; Destroy(this.gameObject, 5); &#125; void Update() &#123; this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); &#125;&#125; 摄像机跟随 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//这个脚本要挂载到摄像机上public class CameraMove : MonoBehaviour&#123; //目标对象 public Transform target; //相对头顶的偏移位置 看向头顶多高的位置 public float headOffsetH = 1; //摄像机倾斜的角度 public float offsetAngle = 45; //摄像机离观测点的距离 public float cameraDis = 5; //摄像机离观测点的距离必须是3和10之间 public float minDis = 3; public float maxDis = 10; //鼠标中间滚动控制的移动速度 public float roundSpeed = 1; //看向对象时 四元数 旋转的速度 public float lookAtSpeed = 2; //跟随对象移动的 速度 public float moveSpeed = 2; //当前摄像机应该在的位置 Vector3 nowPos; //头顶一个在的位置 Vector3 headPos; //头顶位置指向摄像机的方向向量 private Vector3 nowDir; void Update() &#123; //实现了鼠标中键 滚动 来改变摄像机远近 cameraDis += Input.GetAxis(&quot;Mouse ScrollWheel&quot;) * roundSpeed; //取最大值和最小值之间的数 cameraDis = Mathf.Clamp(cameraDis, minDis, maxDis); //向头顶偏移位置 headPos = target.position + target.up * headOffsetH; //用要倾斜的角度和轴算出要旋转的四元数 乘上当前向后的向量 就能得到摄像机偏移角度后往后方偏移位置 //通俗理解 nowDir就是头顶位置指向摄像机的方向向量 nowDir = Quaternion.AngleAxis(offsetAngle, target.right) * -target.forward; //用头顶位置加上要偏移的角度乘摄像机离观测点的距离 就是当前摄像机应该在的位置 nowPos = headPos + nowDir * cameraDis; //直接把算出来的位置 进行赋值 //this.transform.position = nowPos; //通过插值运算缓慢移动相机位置 this.transform.position = Vector3.Lerp(this.transform.position, nowPos, Time.deltaTime * moveSpeed); //这里是通过插值运算来缓动看向物体 //摄像机要看的是nowDir的反向向量 所以通过LookRotation算出旋转成的四元数 传入当做插值函数的终点 this.transform.rotation = Quaternion.Slerp(this.transform.rotation, Quaternion.LookRotation(-nowDir), Time.deltaTime * lookAtSpeed); //画出头顶和摄像机的连线 Debug.DrawLine(this.transform.position, headPos); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"3.hexo插件","slug":"hexo/3.hexo插件","date":"2025-03-02T07:07:49.000Z","updated":"2025-03-02T07:36:58.437Z","comments":true,"path":"2025/03/02/hexo/3.hexo插件/","permalink":"http://example.com/2025/03/02/hexo/3.hexo%E6%8F%92%E4%BB%B6/","excerpt":"","text":"思维导图 安装 1npm install hexo-simple-mindmap 使用 使用 Hexo 的 pullquote 将思维导图的内容包裹起来，mindmap 是思维导图渲染的标志 尺寸有三种规格：mindmap-sm、mindmap-md 和 mindmap-lg。 12345678&#123;% pullquote mindmap mindmap-sm %&#125;- [在 Hexo 中使用思维导图](https://hunterx.xyz/use-mindmap-in-hexo.html) - 前言 - 操作指南 - 准备需要的文件 - 为主题添加 CSS/JS 文件 - 使用方法&#123;% endpullquote %&#125; 在 Hexo 中使用思维导图 前言 操作指南 准备需要的文件 为主题添加 CSS/JS 文件 使用方法","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"csharp拓展方法","slug":"编程语言/Csharp/csharp拓展方法","date":"2025-03-02T06:56:36.000Z","updated":"2025-03-02T07:42:37.657Z","comments":true,"path":"2025/03/02/编程语言/Csharp/csharp拓展方法/","permalink":"http://example.com/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/","excerpt":"","text":"拓展方法基本概念 C# 中的扩展方法是 C# 3.0 引入的一项特性，它允许开发者在不修改原始类或对象的情况下，向现有类添加新方法 作用 提升程序拓展性 不需要再对象中重新写方法 不需要继承来添加方法 为别人封装的类型写额外的方法 特点 一定是写在静态类中 一定是个静态函数 第一个参数为拓展目标 第一个参数用this修饰 基本语法 访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名,参数类型 参数名....) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static class Tools&#123; //为int拓展了一个成员方法 //成员方法 是需要 实例化对象后 才 能使用的 //value 代表 使用该方法的 实例化对象 public static void SpeakValue(this int value) &#123; //拓展的方法 的逻辑 Console.WriteLine(&quot;为int拓展的方法&quot; + value); &#125; public static void SpeakStringInfo(this string str, string str2, string str3) &#123; Console.WriteLine(&quot;为string拓展的方法&quot;); Console.WriteLine(&quot;调用方法的对象&quot; + str); Console.WriteLine(&quot;传的参数&quot; + str2 + str3); &#125; public static void Fun3(this Test t) &#123; Console.WriteLine(&quot;为test拓展的方法&quot;); &#125;&#125;// 为自定义的类型拓展方法class Test&#123; public int i = 10; public void Fun1() &#123; Console.WriteLine(&quot;123&quot;); &#125; public void Fun2() &#123; Console.WriteLine(&quot;456&quot;); &#125;&#125;class Program&#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;拓展方法&quot;); int i = 10; i.SpeakValue(); string str = &quot;000&quot;; str.SpeakStringInfo(&quot;卧槽&quot;, &quot;nm&quot;); Test t = new Test(); t.Fun2(); &#125;&#125;//总结：//概念：为现有的非静态 变量类型 添加 方法//作用：// 提升程序拓展性// 不需要再在对象中重新写方法// 不需要继承来添加方法// 为别人封装的类型写额外的方法//特点：//静态类中的静态方法//第一个参数 代表拓展的目标//第一个参数前面一定要加 this//注意：//可以有返回值 和 n个参数//根据需求而定","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"7.Quaternion四元数常用方法","slug":"游戏引擎/unity/unity基础/7.Quaternion四元数常用方法","date":"2025-03-02T03:00:47.000Z","updated":"2025-03-02T09:06:50.413Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/7.Quaternion四元数常用方法/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"单位四元数 满足条件：x² + y² + z² + w² = 1 12345// 单位四元数 [1, (0, 0, 0)] Quaternion i = Quaternion.identity; //Object的Instantiate方法有重载 第三个参数可以传入四元数角度 Instantiate(testCube, Vector3.zero, Quaternion.identity); 插值运算 123456// 无限接近，先快后慢A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);// 匀速time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 向量指向转四元数LookRotation 12345678public Transform target;public float rotateSpeed = 2f;void Update() &#123; Vector3 dir = target.position - transform.position; Quaternion targetRot = Quaternion.LookRotation(dir); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime);&#125; 练习 为transform拓展方法实现LookAt 使用拓展方法 ，利用四元数的LookRotation方法，使transform实现LookAt的效果 1234567891011121314151617public static class Tools&#123; //自己写的看向目标的方法 public static void MyLookAt(this Transform obj, Transform target) &#123; //算出目标和自己的向量 Vector3 vec = target.position - obj.position; //用LookRotation得到转向的四元数赋值给自己 obj.transform.rotation = Quaternion.LookRotation(vec); &#125;&#125;void Update() &#123; //调用自己写的拓展方法看向B lookA.MyLookAt(lookB); &#125; 摄像机使用Slerp来缓慢看向玩家 1234567891011121314151617// 当发现目标对象位置改变时if (targetQ != Quaternion.LookRotation(target.position - this.transform.position))&#123; // 重新用目标的位置减去摄像机的位置计算出新的面朝向向量四元数 targetQ = Quaternion.LookRotation(target.position - this.transform.position); // 清空累加时间 不然时间一直大于1 会一直盯着目标看 不能达到匀速旋转看向目标的效果 roundTime = 0; // 重置摄像机开始旋转位置 startQ = this.transform.rotation;&#125;// 累加时间roundTime += Time.deltaTime;// 传入发现目标对象位置改变后定死的摄像机开始旋转位置，目标旋转位置，和累加的时间this.transform.rotation = Quaternion.Slerp(startQ, targetQ, roundTime * roundSpeed);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"6.Quaternion四元数概念","slug":"游戏引擎/unity/unity基础/6.Quaternion四元数概念","date":"2025-03-02T02:26:57.000Z","updated":"2025-03-02T09:05:07.383Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/6.Quaternion四元数概念/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/","excerpt":"","text":"四元数概念 数学定义 四元数由4个分量组成：x, y, z, w，数学表示为 q = xi + yj + zk + w 四元数构成 轴-角对 这里的n是3d向量 Unity中的四元数 Quaternion Unity中的四元数初始化方法 1234567//用四元数的计算原理 绕着(x,y,z)向量旋转β度(弧度)float timeAngle = Mathf.Sin(β / 2 * Mathf.Deg2Rad);Quaternion q = new Quaternion(timeAngle * x, timeAngle * y, timeAngle * z, Mathf.Cos(β / 2 * Mathf.Deg2Rad));//绕着(1,0,0)向量旋转60度 要传入弧度制 角度转弧度Quaternion q1 = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); 123//创建一个围绕 axis 旋转 offsetAngle 度的旋转。//提供的轴角对 初始化 四元数的方法 分别传入度数和向量轴Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right); 四元数和欧拉角相互转换 12345// 欧拉角 转 四元数Quaternion q = Quaternion.Euler(60, 0, 0);// 四元数 转 欧拉角print(q.eulerAngles);//(60.0, 0.0, 0.0) 弥补的欧拉角缺点 注意：四元数转换为欧拉角的范围始终是[-180°, 180°]之间 123//每一帧绕着y轴旋转1度 //四元数绕 y轴转 *****物体坐标系****** 旋转this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"5.Quaternion为什么要使用四元数","slug":"游戏引擎/unity/unity基础/5.Quaternion为什么要使用四元数","date":"2025-03-02T02:10:07.000Z","updated":"2025-03-02T03:01:30.593Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/5.Quaternion为什么要使用四元数/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/","excerpt":"","text":"在unity中将Rotation的x设置为90°，调整y和z都绕同一个轴旋转","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"4.Vector3向量","slug":"游戏引擎/unity/unity基础/4.Vector3向量","date":"2025-03-01T10:14:34.000Z","updated":"2025-03-02T03:01:40.668Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/4.Vector3向量/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/","excerpt":"","text":"Unity中的向量 向量常用的成员和方法 向量在数学和编程中有许多常用的成员和方法，常见的包括： 成员： x、y、z：向量的分量，表示向量在 x、y、z 方向上的值。 magnitude 或 length：向量的长度或模长，表示从原点到向量的终点的距离。 normalized：返回与当前向量方向相同但长度为1的单位向量。也可以 向量 /magnitude sqrMagnitude：向量长度的平方，用于比较向量长度时避免开方计算。 zero：零向量，所有分量均为0的向量。 方法： Vector3.Dot(Vector3 a, Vector3 b)：计算两个向量的点乘结果。返回弧度 Vector3.Cross(Vector3 a, Vector3 b)：计算两个向量的叉乘结果。 Vector3.Distance(Vector3 a, Vector3 b)：计算两个向量之间的距离。 Vector3.Lerp(Vector3 a, Vector3 b, float t)：在两个向量之间进行线性插值。 Vector3.Slerp(Vector3 a, Vector3 b, float t)：在两个向量之间进行球形插值 Vector3.Normalize(Vector3 value)：将向量转化为单位向量。 Vector3.Project(Vector3 vector, Vector3 onNormal)：将一个向量投影到另一个向量上。 Vector3.RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)：将一个向量从当前方向旋转到目标方向。 Vector3.Angle(Vector3 from, Vector3 to)：返回值float, 计算两个向量之间的角度值 例子eg: 利用 A⋅B=∣A∣∗∣B∣cosθA \\cdot B = |A| * |B| cos\\thetaA⋅B=∣A∣∗∣B∣cosθ 或者 Vector.Angle()(角度) 来计算θ\\thetaθ A⋅B&gt;=0A\\cdot B &gt;= 0A⋅B&gt;=0 前方 A×B&lt;0A \\times B &lt; 0A×B&lt;0 则A右B左 线性插值 (匀速) 向量的点积 12345678// Debug类中的DrawLine静态方法 画线段// 参数：前两个参数分别是起点和终点，最后一个参数是划线颜色。Debug.DrawLine(this.transform.position, this.transform.position + this.transform.forward, Color.red);// Debug类中的DrawRay静态方法 画射线// 参数：前两个参数分别是起点和方向，最后一个参数是划线颜色。Debug.DrawRay(this.transform.position, this.transform.up, Color.blue); 两个向量 a=(x1​,y1​) 和 b=(x2​,y2​) 的点积定义为 a⋅b=x1x2​+y1​y2​​，其结果是一个标量，且 a⋅b=∣a∣×∣b∣×cosθ，其中 θ 是 a 和 b 之间的夹角。 θ=Acos(单位向量a⋅单位向量b)\\theta = Acos(单位向量a \\cdot 单位向量b )θ=Acos(单位向量a⋅单位向量b) 点积可用于判断两个向量的前后关系 12345678Vector3 forward = transform.forward;Vector3 toEnemy = enemy.position - transform.position;float dotResult = Vector3.Dot(forward, toEnemy.normalized);// 值&gt;0表示敌人在前方，&lt;0表示在后方if(dotResult &gt; 0.5f) &#123; // 敌人位于前方60度范围内&#125; 向量的叉积 获取垂直向量（右手定则， 常用于计算旋转轴） 可以用叉乘来判断两个向量的左右关系 123456789Vector3 C = Vector3.Cross(A.position, B.position);if (C.y &gt; 0)&#123; Debug.Log(&quot;A在B的右侧&quot;);&#125;else&#123; Debug.Log(&quot;B在A的右侧&quot;);&#125; 向量插值运算 插值公式和Mathf的插值运算差不多 线性插值 先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置 123// 可以理解为t不变 每次往方向向量加的值(end - start)一直会变小A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); 匀速 每帧改变时间 当t&gt;=1时 得到结果 123456789101112131415161718192021// 可以理解为t每一帧累加相同值 start和(end - start)不变 所以是匀速运动// 这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 因为t&gt;=1时直接的得到结果public Transform target;private Vector3 startPos;private Vector3 tmpTarget;private float time = 0;void Update()&#123; // 每次终点移动变化, 重置时间, 起点 if (tmpTarget != target.position) &#123; tmpTarget = target.position; time = 0; startPos = transform.position; &#125; time += Time.deltaTime; transform.position = Vector3.Lerp(startPos, target.position, time); 球形插值 从（10， 0， 0） 到 （0， 0， 10） 12time += Time.deltaTime;A.position = Vector3.Slerp(Vector3.right * 10, Vector3.forward * 10, time); 练习 用向量相关知识，实现摄像机跟随 摄像机代码写在LateUpdate中 如果在Update中更新摄像机的位置，可能会出现摄像机位置更新早于目标对象位置更新的情况，导致摄像机出现抖动或延迟跟随的问题。 而在LateUpdate中更新摄像机位置，可以确保在目标对象位置更新完成后再进行摄像机的移动，从而实现平滑的跟随效果。 1234567891011121314151617public float zOffect = 4;public float yOffect = 7;public Transform target;void LateUpdate()&#123; // 摄像机的位置等于目标的位置进行向量偏移 // 先朝目标对象的面朝向的反方向平移4米再朝目标的头顶位置平移7米 // 设置摄像机位置 this.transform.position = target.position - target.forward * zOffect + target.up * yOffect; // 看向目标 this.transform.LookAt(target);&#125; 发现入侵者 当一个物体B在物体A前方45度角范围内，并且离A只有5米距离时，在控制台打印“发现入侵者” 12345678910111213141516171819// 手动算if (Vector3.Distance(this.transform.position, B.transform.position) &lt;= 5)&#123; // 第一步：算出点乘结果（方向向量） float dotResult = Vector3.Dot(this.transform.forward, (B.transform.position - this.transform.position).normalized); // 第二步：通过反余弦函数算出夹角 if (Mathf.Acos(dotResult) * Mathf.Rad2Deg &lt;= 22.5f) &#123; print(&quot;手动算角度 发现入侵者&quot;); &#125;&#125;// Angle直接算角度if (Vector3.Distance(this.transform.position, B.transform.position) &lt;= 5 &amp;&amp; Vector3.Angle(this.transform.forward, B.transform.position - this.transform.position) &lt;= 22.5f)&#123; print(&quot;Angle直接算角度 发现入侵者&quot;);&#125; 左上，左下 ，右上，右下哪个方位? 判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class VectorPositionDetector : MonoBehaviour&#123; public Transform objectA; public Transform objectB; [Header(&quot;阈值&quot;)] public float angleThreshold = 45f; // 方向识别角度范围 void Update() &#123; // 获取A到B的水平方向向量 Vector3 aToB = objectB.position - objectA.position; aToB.y = 0; // 忽略垂直分量 // 获取A的基准方向向量（已水平化） Vector3 aForward = objectA.forward; aForward.y = 0; Vector3 aRight = objectA.right; aRight.y = 0; // 计算方向点积（自动处理向量长度） float forwardDot = Vector3.Dot(aToB.normalized, aForward.normalized); float rightDot = Vector3.Dot(aToB.normalized, aRight.normalized); // 精确角度计算版本 float angle = Vector3.Angle(aForward, aToB); // 基本方位判断 bool isFront = forwardDot &gt; 0; bool isBack = forwardDot &lt; 0; bool isRight = rightDot &gt; 0; bool isLeft = rightDot &lt; 0; // 精确方位判断（45度扇形区） bool inFrontSector = angle &lt;= angleThreshold; bool inRightSector = Vector3.Angle(aRight, aToB) &lt;= angleThreshold; Debug.Log($&quot;前方: &#123;isFront&#125; | 后方: &#123;isBack&#125;\\n&quot; + $&quot;右侧: &#123;isRight&#125; | 左侧: &#123;isLeft&#125;\\n&quot; + $&quot;前扇形区: &#123;inFrontSector&#125; | 右扇形区: &#123;inRightSector&#125;&quot;); // 计算八个方向识别 bool isFrontRight = forwardDot &gt; 0 &amp;&amp; rightDot &gt; 0; bool isFrontLeft = forwardDot &gt; 0 &amp;&amp; rightDot &lt; 0; // 距离综合判断 float distance = aToB.magnitude; bool inRange = distance &lt; 5f; // 5米范围内 // 运动方向预测（需记录上一帧位置） Vector3 velocity = (objectB.position - lastPosition) / Time.deltaTime; lastPosition = objectB.position; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System.Collections;using System.Collections.Generic;using UnityEngine;public class Lesson08_练习题 : MonoBehaviour&#123; //拖拽得到AB位置变量 public Transform A; public Transform B; //点乘接过和叉乘结果变量 private float dotResult; private Vector3 crossResult; void Update() &#123; #region 练习题一 //判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位 //计算 A位置向量和AB方向差向量 点乘和叉乘结果 dotResult = Vector3.Dot(A.forward, B.position - A.position); crossResult = Vector3.Cross(A.forward, B.position - A.position); //根据点乘和叉乘的值判断前后左右 if (dotResult &gt;= 0) &#123; //右侧 if (crossResult.y &gt;= 0) &#123; print(&quot;右前&quot;); &#125; //左侧 else &#123; print(&quot;左前&quot;); &#125; &#125; else &#123; //右侧 if (crossResult.y &gt;= 0) &#123; print(&quot;右后&quot;); &#125; //左侧 else &#123; print(&quot;左后&quot;); &#125; &#125; // 练习题二 //当一个物体B在物体A左前方20度角或右前方30度范围内，并且离A只有5米距离时，在控制台打印“发现入侵者” //计算叉乘 用于判断左边还是右边 crossResult = Vector3.Cross(A.forward, B.position - A.position); //判断距离 if (Vector3.Distance(A.position, B.position) &lt;= 5) &#123; //A左前方20度角或右前方30度范围内 if (crossResult.y &gt;= 0 &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= 30 || crossResult.y &lt; 0 &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= 20) &#123; print(&quot;发现入侵者&quot;); &#125; &#125; &#125;&#125; 插值实现摄像机跟随 123456789// 如果当前摄像机的目标位置不是目标对象的后方4米，向上偏7米 就设置目标位置 记录摄像机当前开始位置 重置时间if (cameraTargetPos != target.position + -target.forward * zOffect + target.up * yOffect)&#123; cameraTargetPos = target.position + -target.forward * zOffect + target.up * yOffect; startPos = this.transform.position; time = 0;&#125;time += Time.deltaTime;this.transform.position = Vector3.Lerp(startPos, cameraTargetPos, time * moveSpeed); 球形插值模拟太阳轨迹 123456private void Update()&#123; time2 += Time.deltaTime; // sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10, time2 * 0.1f);//假如直接写最终值会不知道从哪里转 可能会平这转 sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up * 0.1f, time2 * 0.1f);//要给最终值加一点向上的向量 才会往上转&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"3.坐标系","slug":"游戏引擎/unity/unity基础/3.坐标系","date":"2025-03-01T07:57:07.000Z","updated":"2025-03-02T03:01:44.817Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/3.坐标系/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/","excerpt":"","text":"世界坐标系 this.transform.position-返回物体在世界坐标系中的位置 this.transform.rotation-返回物体在世界坐标系中的旋转四元数 this.transform.eulerAngles-返回物体在世界坐标系中的欧拉角 this.transform.lossyScale-返回物体在世界坐标系中的缩放 修改它们将导致相对于世界坐标系的变化 物体坐标系 this.transform.localPosition-返回物体在其父对象坐标系中的位置 this.transform.localEulerAngles-返回物体在其父对象坐标系中的旋转四元数 this.transform.localRotation-返回物体在其父对象坐标系中的欧拉角 this.transform.localScale-返回物体在其父对象坐标系中的缩放 修改它们将导致相对于父对象物体坐标系的变化 屏幕坐标系 Input.mousePosition-返回鼠标在屏幕坐标系中的位置 Screen.width-返回屏幕坐标系的宽度 Screen.height-返回屏幕坐标系的高度 currentResolution当前屏幕的分辨率为 视口坐标系 坐标转换 点与向量在本地与世界之间的来回转换 世界转本地 this.transform.InverseTransformDirection 将世界空间中的方向向量转换为本地空间中的方向向量。 12Vector3 worldDirection = new Vector3(1, 0, 0);Vector3 localDirection = this.transform.InverseTransformDirection(worldDirection); // (不受缩放影响 this.transform.InverseTransformPoint 将世界空间中的点转换为本地空间中的点。 12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 localPoint = this.transform.InverseTransformPoint(worldPoint); this.transform.InverseTransformVector 将世界空间中的向量转换为本地空间中的向量。 12Vector3 worldVector = new Vector3(2, 1, 0);Vector3 localVector = this.transform.InverseTransformVector(worldVector); // (受缩放影响 本地转世界 this.transform.TransformDirection 将本地空间中的方向向量转换为世界空间中的方向向量。 12Vector3 localDirection = new Vector3(0, 1, 0);Vector3 worldDirection = this.transform.TransformDirection(localDirection);// (不受缩放影响 this.transform.TransformPoint 将本地空间中的点转换为世界空间中的点。 12Vector3 localPoint = new Vector3(2, 3, 1);Vector3 worldPoint = this.transform.TransformPoint(localPoint); this.transform.TransformVector 将本地空间中的向量转换为世界空间中的向量。 12Vector3 localVector = new Vector3(1, 0, 0);Vector3 worldVector = this.transform.TransformVector(localVector); // (受缩放影响 世界转屏幕 Camera.main.WorldToScreenPoint 将世界空间中的点转换为屏幕空间中的点。 12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 screenPoint = Camera.main.WorldToScreenPoint(worldPoint); 屏幕转世界 Camera.main.ScreenToWorldPoint 将屏幕空间中的点转换为世界空间中的点。 12Vector3 screenPoint = new Vector3(100, 200, 0);Vector3 worldPoint = Camera.main.ScreenToWorldPoint(screenPoint); 世界转视口 Camera.main.WorldToViewportPoint 将世界空间中的点转换为视口空间中的点。 12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 viewportPoint = Camera.main.WorldToViewportPoint(worldPoint); 视口转世界 Camera.main.ViewportToWorldPoint 将视口空间中的点转换为世界空间中的点。 12Vector3 viewportPoint = new Vector3(0.5f, 0.5f, 0);Vector3 worldPoint = Camera.main.ViewportToWorldPoint(viewportPoint); 视口转屏幕 Camera.main.ViewportToScreenPoint 将视口空间中的点转换为屏幕空间中的点。 12Vector3 viewportPoint = new Vector3(0.5f, 0.5f, 0);Vector3 screenPoint = Camera.main.ViewportToScreenPoint(viewportPoint); 屏幕转视口 Camera.main.ScreenToViewportPoint 将屏幕空间中的点转换为视口空间中的点。 12Vector3 screenPoint = new Vector3(100, 200, 0);Vector3 viewportPoint = Camera.main.ScreenToViewportPoint(screenPoint);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"2.Mathf数学计算结构体常用方法","slug":"游戏引擎/unity/unity基础/2.Mathf数学计算结构体常用方法","date":"2025-03-01T06:51:42.000Z","updated":"2025-03-02T03:01:47.531Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/2.Mathf数学计算结构体常用方法/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Mathf和Math Math是C#中封装好的用于数学计算的工具类，位于System命名空间中。 Mathf是Unity中封装好的用于数学计算的工具结构体，位于UnityEngine命名空间中。 他们都是提供来用于进行数学相关计算的。 Mathf和Math的区别 Mathf 和 Math中的相关方法几乎一样。 Math - C#自带数学库，提供基本的数学计算方法。 Mathf - Unity专门针对游戏开发增强的数学库，包含了Math中的方法，并添加了一些适用于游戏开发的方法。 Mathf中的常用方法 PI常量 获取圆周率π 12// 众所周知的“3.14159265358979...”值（只读）。print(Mathf.PI);//3.141593 Abs静态方法 取绝对值 1234// 返回 f 的绝对值。print(Mathf.Abs(-10));//10print(Mathf.Abs(-20));//20print(Mathf.Abs(1));//1 CeilToInt静态方法 向上取整 123456// 返回大于或等于 f 的最小整数。float f = 1.3f;int i = (int)f;print(i);//1print(Mathf.CeilToInt(f));//2print(Mathf.CeilToInt(1.00001f));//2 FloorToInt静态方法 向下取整 12// 返回小于或等于 f 的最大整数。print(Mathf.FloorToInt(9.6f));//9 Clamp静态方法 钳制函数 12345// 在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值。// 比最小还小，就取最小，比最大还大，就取最大，两者之间，就取本身print(Mathf.Clamp(10, 11, 20));//11print(Mathf.Clamp(21, 11, 20));//20print(Mathf.Clamp(15, 11, 20));//15 Max静态方法 获取最大值 1234// 返回两个或更多值中的最大值。// 内部有一个可变长的参数print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8));//8print(Mathf.Max(1, 2));//2 Min静态方法 获取最小值 1234// 返回两个或更多值中的最小值。// 内部有一个可变长的参数print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));//1print(Mathf.Min(1.1f, 0.4f));//0.4 Pow静态方法 一个数的n次幂 123// 返回 f 的 p 次幂。print(&quot;一个数的n次方&quot; + Mathf.Pow(4, 2));//16print(&quot;一个数的n次方&quot; + Mathf.Pow(2, 3));//8 RoundToInt静态方法 四舍五入 123// 返回舍入为最近整数的 / f /。print(&quot;四舍五入&quot; + Mathf.RoundToInt(1.3f));//1print(&quot;四舍五入&quot; + Mathf.RoundToInt(1.5f));//2 Sqrt静态方法 返回一个数的平方根 1234// 返回 f 的平方根。print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(4));//2print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(16));//4print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(64));//8 IsPowerOfTwo静态方法 判断一个数是否是2的n次方 12345// 如果值是 2 的幂，则返回 true。print(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(4));//trueprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(8));//trueprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(3));//falseprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(1));//true Sign静态方法 判断正负数 1234567// 返回 f 的符号。// 正数和0就返回1，负数就返回-1print(&quot;判断正负数&quot; + Mathf.Sign(0));//1print(&quot;判断正负数&quot; + Mathf.Sign(10));//1print(&quot;判断正负数&quot; + Mathf.Sign(-10));//-1print(&quot;判断正负数&quot; + Mathf.Sign(3));//1print(&quot;判断正负数&quot; + Mathf.Sign(-2));//-1 插值运算 Lerp : result = Mathf.Lerp(start, end, t); t为插值系数 取值范围[0, 1] result = start + (end - start) * t; 123456789101112// t不变，起点不断变化// 用法1 先快后慢, 无限趋近10float start = 1;start = Mathf.Lerp(start, 10, Time.deltaTime);// 起点不变，时间t匀速变化// 用法2 匀速变化float start = 1; float time = 0, result = 0;time += Time.deltaTime;result = Mathf.Lerp(start, 10, time); Rad2Deg常量 弧度转角度的常量 1234// 弧度到度换算常量（只读）。float rad = 1;float anger = rad * Mathf.Rad2Deg;print(anger);//57.29578f; Deg2Rad常量 角度转弧度的常量 1234// 度到弧度换算常量（只读）。anger = 1;rad = anger * Mathf.Deg2Rad;print(rad);//0.01745329 Unity中的三角函数 注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 Sin静态方法 计算正弦函数 12// 返回角度 f 的正弦。print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 Cos静态方法 计算余弦函数 12// 返回角度 f 的余弦。print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 Asin静态方法 反正弦函数 123// 返回 f 的反正弦 - 其正弦为 f 的角度（以弧度为单位）。rad = Mathf.Asin(0.5f);print(rad * Mathf.Rad2Deg);//30 Acos静态方法 反余弦函数 123// 返回 f 的反余弦 - 其余弦为 f 的角度（以弧度为单位）。rad = Mathf.Acos(0.5f);print(rad * Mathf.Rad2Deg);//60 练习 使用插值实现一个方块跟随另一个方块移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这个脚本将要挂载到方块A上 实现方块A跟随着方块Bpublic class Lesson02_练习题 : MonoBehaviour&#123; //要跟随的对象B public Transform B; //移动速度 public float moveSpeed; //位置中介 private Vector3 pos; //B当前的位置 private Vector3 bNowPos; //开始位置 private Vector3 startPos; //匀速运动累加的时间 private float time; //模式 public int mode = 1; void Update() &#123; if(mode == 1) &#123; //第一种 就是 先快后慢的形式 //记录当前这一帧A的位置 pos = this.transform.position; //传入这一帧A的位置算出下一帧A的位置 pos.x = Mathf.Lerp(pos.x, B.position.x, Time.deltaTime * moveSpeed); pos.y = Mathf.Lerp(pos.y, B.position.y, Time.deltaTime * moveSpeed); pos.z = Mathf.Lerp(pos.z, B.position.z, Time.deltaTime * moveSpeed); //算出下一帧A的位置赋值给A this.transform.position = pos; &#125; else if(mode == 2) &#123; //第二种 就是 匀速运动 //发现存储的B的位置不等于当前B的位置 if (bNowPos != B.transform.position) &#123; //清空时间 重写设置B的位置 开始位置是A当前的位置 time = 0; bNowPos = B.transform.position; startPos = this.transform.position; &#125; //时间每一帧运算累加 time += Time.deltaTime; //startPos和bNowPos其实定死了 只有time在变化 传入算出下一帧A的位置 pos.x = Mathf.Lerp(startPos.x, bNowPos.x, time * moveSpeed); pos.y = Mathf.Lerp(startPos.y, bNowPos.y, time * moveSpeed); pos.z = Mathf.Lerp(startPos.z, bNowPos.z, time * moveSpeed); //算出下一帧A的位置赋值给A this.transform.position = pos; &#125; &#125; private void OnGUI() &#123; if(GUI.Button(new Rect(0, 0, 200, 200), &quot;切换模式&quot;)) &#123; mode = 3 - mode; &#125; &#125;&#125; 实现一个物体按照曲线移动（正弦或余弦） 1234567891011121314151617181920public class MathfTest : MonoBehaviour&#123; // 向前移动速度 public float moveSpeed = 5; // 振幅 public float changeSize = 10; // 频率 public float changeSpeed = 5; // 时间 public float time = 0; private void Update() &#123; this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); time += Time.deltaTime; this.transform.Translate(Vector3.right * Mathf.Sin(time * changeSpeed) * changeSize * Time.deltaTime); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"1.unity基础概述","slug":"游戏引擎/unity/unity基础/1.unity基础概述","date":"2025-03-01T06:43:09.000Z","updated":"2025-03-01T06:47:12.464Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/1.unity基础概述/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"4.模型自资源的导入","slug":"游戏引擎/unity/unity入门/unity入门实践项目/4.模型自资源的导入","date":"2025-03-01T06:37:18.000Z","updated":"2025-03-01T06:40:34.472Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity入门/unity入门实践项目/4.模型自资源的导入/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"泛型委托和泛型接口の协变和逆变","slug":"编程语言/Csharp/泛型委托和泛型接口の协变和逆变","date":"2025-03-01T02:26:27.000Z","updated":"2025-03-01T06:36:44.841Z","comments":true,"path":"2025/03/01/编程语言/Csharp/泛型委托和泛型接口の协变和逆变/","permalink":"http://example.com/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/","excerpt":"","text":"逆变与协变详解 - zhangweiwen - 博客园 (cnblogs.com) 协变和逆变是用来修饰泛型类型参数T的 协变：out 表明修饰的T只能作为返回值来使用 逆变：in 表明修饰的T只能作为参数来使j用 只有泛型接口和泛型委托能使用 协变（Foo&lt;父类&gt; = Foo&lt;子类&gt; ） 典型场景：生产者（输出数据），如返回值、只读集合。 12345678910111213141516171819202122232425262728293031//泛型委托：public delegate T MyFuncA&lt;T&gt;();//不支持逆变与协变public delegate T MyFuncB&lt;out T&gt;();//支持协变 MyFuncA&lt;object&gt; funcAObject = null;MyFuncA&lt;string&gt; funcAString = null;MyFuncB&lt;object&gt; funcBObject = null;MyFuncB&lt;string&gt; funcBString = null;MyFuncB&lt;int&gt; funcBInt = null; funcAObject = funcAString;//编译失败，MyFuncA不支持逆变与协变funcBObject = funcBString;//变了，协变funcBObject = funcBInt;//编译失败，值类型不参与协变或逆变 //泛型接口public interface IFlyA&lt;T&gt; &#123; &#125;//不支持逆变与协变public interface IFlyB&lt;out T&gt; &#123; &#125;//支持协变 IFlyA&lt;object&gt; flyAObject = null;IFlyA&lt;string&gt; flyAString = null;IFlyB&lt;object&gt; flyBObject = null;IFlyB&lt;string&gt; flyBString = null;IFlyB&lt;int&gt; flyBInt = null; flyAObject = flyAString;//编译失败，IFlyA不支持逆变与协变flyBObject = flyBString;//变了，协变flyBObject = flyBInt;//编译失败，值类型不参与协变或逆变 //数组：string[] strings = new string[] &#123; &quot;string&quot; &#125;;object[] objects = strings; 逆变（Foo&lt;子类&gt; = Foo&lt;父类&gt;） 典型场景：消费者（输入数据），如函数参数、写入操作。 12345678910111213141516171819public delegate void MyActionA&lt;T&gt;(T param);//不支持逆变与协变public delegate void MyActionB&lt;in T&gt;(T param);//支持逆变 public interface IPlayA&lt;T&gt; &#123; &#125;//不支持逆变与协变public interface IPlayB&lt;in T&gt; &#123; &#125;//支持逆变 MyActionA&lt;object&gt; actionAObject = null;MyActionA&lt;string&gt; actionAString = null;MyActionB&lt;object&gt; actionBObject = null;MyActionB&lt;string&gt; actionBString = null;actionAString = actionAObject;//MyActionA不支持逆变与协变,编译失败actionBString = actionBObject;//变了，逆变 IPlayA&lt;object&gt; playAObject = null;IPlayA&lt;string&gt; playAString = null;IPlayB&lt;object&gt; playBObject = null;IPlayB&lt;string&gt; playBString = null;playAString = playAObject;//IPlayA不支持逆变与协变,编译失败playBString = playBObject;//变了，逆变 注意: 当前仅支持接口和委托的逆变与协变 ，不支持类和方法。但数组也有协变性。 值类型不参与逆变与协变。 12345678910public interface Base&lt;T&gt;&#123; T Test(T param);&#125;public class Sub&lt;T&gt; : Base&lt;T&gt;&#123; public T Test(T param) &#123; return default(T); &#125;&#125;Base&lt;string&gt; b = new Sub&lt;string&gt;();b.Test(&quot;你好&quot;); 在上面的例子中，b里面的实例是Sub&lt;string&gt; b.Test(&quot;你好&quot;)会把参数 “你好” 传入到Sub里面执行方法 即调用父类的方法，其实实际是调用子类的方法。 可以看到，这个方法能够安全的调用，需要两个条件： 变式（父）的方法参数能安全转为原式（子）的参数； 原式（子）的返回值能安全的转为变式的返回值。 1234Base&lt;object&gt; BaseObject = null;Base&lt;string&gt; BaseString = null;BaseObject = BaseString;//编译失败BaseObject.Test(&quot;&quot;); 这里的“实际流程”如下，可以看到，参数那里是object是不能安全转换为string，所以编译失败： 看到这里如果都明白的话，我们不难得到逆变与协变的”实际流程图”（记住，它们是有in/out限制的）: 稍微难一点的问题 下面哪个正确？ 12345678910111213public interface IBar&lt;in T&gt; &#123; &#125;//应该是inpublic interface IFoo&lt;in T&gt;&#123; void Test(IBar&lt;T&gt; bar);&#125;//还是outpublic interface IFoo&lt;out T&gt;&#123; void Test(IBar&lt;T&gt; bar);&#125; 答案是，如果是in的话，会编译失败，out才正确（当然不要泛型修饰符也能通过编译，但IFoo就没有协变能力了）。 这里的意思就是说，一个有协变（逆变）能力的泛型（IBar），作为另一个泛型（IFoo）的参数时，影响到了它（IFoo）的泛型的定义。乍一看以为是in的其中一个陷阱是T是在Test方法的参数里的，所以以为是in。但这里Test的参数根本不是T，而是IBar&lt;T&gt;。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp事件","slug":"编程语言/Csharp/csharp事件","date":"2025-02-28T11:31:10.000Z","updated":"2025-03-01T03:26:04.293Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp事件/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"什么是事件？ 事件的核心是：当某件事发生时，自动通知所有关心它的人。 在 C# 中，事件是一种机制，允许一个对象（发布者）在特定动作发生时，通知其他对象（订阅者）执行某些代码。 事件的核心三要素 发布者（Publisher）：定义事件并触发它 订阅者（Subscriber）：注册事件处理方法 事件处理方法（Handler）：当事件发生时执行的代码 游戏开发高频场景 场景 事件用法 代码灵魂示例 角色受伤 触发UI血条更新、音效、伤害数字 player.OnHurt += UpdateHealthBar; 敌人死亡 触发掉落物品、任务进度更新、成就解锁 enemy.OnDeath += DropLoot; 技能释放 触发特效、冷却计时、连击计数 skill.OnCast += PlayVFX; 游戏状态切换 暂停/继续、关卡加载完成、游戏结束 GameManager.OnPause += FreezeEnemies; UI交互 按钮点击、菜单打开/关闭、道具拖动 button.OnClick += OpenInventory; 代码示例 角色受伤触发UI血条更新、音效、伤害数字 第一步：定义事件参数类（传递伤害值） 为什么事件参数要继承 EventArgs？ 这是一个约定，保持代码统一性。 如果需要传递数据，推荐使用自定义的 EventArgs 子类。 EventArgs 作用： 通过自定义参数类，把伤害值传递给所有监听者，避免每个系统单独查询角色状态 123456789public class DamageEventArgs : EventArgs&#123; public int Damage &#123; get; &#125; // 需要传递的伤害值 public DamageEventArgs(int damage) &#123; Damage = damage; &#125;&#125; 第二步：创建角色类（事件发布者） EventHandler&lt;T&gt; 委托 是 .NET 内置的泛型委托，无需自己定义。 签名：void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e)。 sender：触发事件的对象（通常是发布者自己）。 e：事件参数（传递额外数据）。 事件名称以 On 开头（如 OnClick）。 1234567891011121314151617public class Character&#123; // 声明事件（使用自定义的EventArgs） public event EventHandler&lt;DamageEventArgs&gt; Damaged; public void TakeDamage(int damage) &#123; // 触发事件的通用写法 OnDamaged(new DamageEventArgs(damage)); &#125; // 触发事件 protected virtual void OnDamaged(DamageEventArgs e) &#123; Damaged?.Invoke(this, e); &#125;&#125; 第三步：创建各种事件订阅者 12345678910111213141516171819202122232425262728293031323334353637// UI血条控制器public class UIHealthBar&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 更新血条 public void OnCharacterDamaged(object sender, DamageEventArgs e) &#123; UpdateHealthBar(e.Damage); Debug.Log($&quot;血条更新：减少&#123;e.Damage&#125;HP&quot;); &#125; private void UpdateHealthBar(int damage) &#123; /* 实际血条逻辑 */ &#125;&#125;// 音效系统public class SoundSystem&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 播放受伤音效 public void PlayHurtSound(object sender, DamageEventArgs e) &#123; Audio.Play(&quot;受伤音效&quot;); Debug.Log(&quot;播放受伤音效&quot;); &#125;&#125;// 伤害数字系统public class DamageNumbers&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 显示上海数字 public void ShowDamagePopup(object sender, DamageEventArgs e) &#123; CreateFloatingText(e.Damage); Debug.Log($&quot;显示伤害数字：&#123;e.Damage&#125;&quot;); &#125; private void CreateFloatingText(int damage) &#123; /* 数字弹窗逻辑 */ &#125;&#125; 第四步：连接事件订阅 12345678910// 初始化所有对象Character player = new Character();UIHealthBar ui = new UIHealthBar();SoundSystem sound = new SoundSystem();DamageNumbers numbers = new DamageNumbers();// 订阅事件（+= 添加监听）player.Damaged += ui.OnCharacterDamaged;player.Damaged += sound.PlayHurtSound;player.Damaged += numbers.ShowDamagePopup; 第五步：触发事件 1234567// 当玩家受到伤害时player.TakeDamage(50);// 输出结果：// 血条更新：减少50HP// 播放受伤音效// 显示伤害数字：50 事件与委托的区别 特性 委托（Delegate） 事件（Event） 访问权限 可直接调用或赋值（=） 只能在类内部触发（Invoke） 多播（Multicast） 支持（+=/-=） 支持（本质是委托的封装） 封装性 低（外部可任意修改委托链） 高（外部只能订阅/取消订阅） 典型用途 通用回调机制 发布-订阅模式的通知机制","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp表达式体","slug":"编程语言/Csharp/csharp表达式体","date":"2025-02-28T10:17:19.000Z","updated":"2025-02-28T10:32:37.134Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp表达式体/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93/","excerpt":"","text":"表达式体（Expression-bodied members）是 C# 6.0 及更高版本引入的特性，它允许用简洁的 =&gt; 语法替代传统代码块，适用于方法、属性、构造函数等成员。 注意： csharp的Lambda表达式（核心是创建匿名函数） 表达式体成员（核心是简写方法体） 综合示例 123456789101112131415161718public class Calculator &#123; // 只读属性 public string Model =&gt; &quot;Scientific-Calculator-3000&quot;; // 方法 public double Square(double x) =&gt; x * x; // 索引器 private double[] _history = new double[10]; public double this[int index] =&gt; _history[index]; // 构造函数 public Calculator(string model) =&gt; Model = model; // 运算符重载 public static Calculator operator +(Calculator a, Calculator b) =&gt; new Calculator($&quot;&#123;a.Model&#125;+&#123;b.Model&#125;&quot;);&#125; 方法（Methods） 用 =&gt; 替代 &#123;&#125;，适用于单行返回值的方法。 1234567// 传统写法public int Add(int a, int b) &#123; return a + b;&#125;// 表达式体写法public int Add(int a, int b) =&gt; a + b; 只读属性（Read-Only Properties） 直接返回计算结果的属性（仅有 get 访问器）。 1234567// 传统写法public string FullName &#123; get &#123; return $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; &#125;&#125;// 表达式体写法public string FullName =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; 构造函数/析构函数（C# 7.0+） 单行初始化或清理逻辑。 12345678910// 构造函数public class Person &#123; public string Name &#123; get; &#125; public Person(string name) =&gt; Name = name; // 初始化&#125;// 析构函数public class Resource &#123; ~Resource() =&gt; Console.WriteLine(&quot;资源已释放&quot;); // 清理逻辑&#125; 索引器（Indexers） 简化索引器的 get 访问器。 123456789private string[] _data = new string[10];// 传统写法public string this[int index] &#123; get &#123; return _data[index]; &#125;&#125;// 表达式体写法public string this[int index] =&gt; _data[index]; 属性访问器（C# 7.0+） 对 get 和 set 访问器分别使用表达式体。 12345678910111213private string _name;// 传统写法public string Name &#123; get &#123; return _name; &#125; set &#123; _name = value; &#125;&#125;// 表达式体写法public string Name &#123; get =&gt; _name; set =&gt; _name = value ?? throw new ArgumentNullException();&#125; 事件访问器（C# 7.0+） 简化事件的 add 和 remove 逻辑。 12345678910111213private EventHandler _myEvent;// 传统写法public event EventHandler MyEvent &#123; add &#123; _myEvent += value; &#125; remove &#123; _myEvent -= value; &#125;&#125;// 表达式体写法public event EventHandler MyEvent &#123; add =&gt; _myEvent += value; remove =&gt; _myEvent -= value;&#125; 运算符重载（Operator Overloading） 简化运算符的实现。 1234567891011121314public class Vector &#123; public int X &#123; get; &#125; public int Y &#123; get; &#125; public Vector(int x, int y) =&gt; (X, Y) = (x, y); // 传统运算符重载 public static Vector operator +(Vector a, Vector b) &#123; return new Vector(a.X + b.X, a.Y + b.Y); &#125; // 表达式体写法 public static Vector operator +(Vector a, Vector b) =&gt; new(a.X + b.X, a.Y + b.Y);&#125; throw 表达式（C# 7.0+） 直接在表达式中抛出异常。 1234567891011// 参数校验public string GetName(string input) =&gt; input ?? throw new ArgumentNullException(nameof(input));// 替代传统写法：public string GetName(string input) &#123; if (input == null) &#123; throw new ArgumentNullException(nameof(input)); &#125; return input;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp的Lambda表达式","slug":"编程语言/Csharp/csharp的Lambda表达式","date":"2025-02-28T02:38:33.000Z","updated":"2025-02-28T10:33:14.120Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp的Lambda表达式/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"在C#中，Lambda表达式是一种简洁的匿名函数，用于创建委托或表达式树类型。 Lambda表达式的基本形式 Lambda表达式分为两种形式： 表达式Lambda 仅包含单个表达式，无需大括号，自动返回结果。 1234(参数列表) =&gt; 表达式Func&lt;int, int&gt; square = x =&gt; x * x;Console.WriteLine(square(5)); // 输出 25 语句块Lambda 包含多行语句，需用大括号包裹，显式使用return（若有返回值）。 12345678910(参数列表) =&gt; &#123; 语句块; return 结果; &#125;Action&lt;string&gt; greet = name =&gt; &#123; string message = $&quot;Hello, &#123;name&#125;!&quot;; Console.WriteLine(message);&#125;;greet(&quot;Alice&quot;); // 输出 &quot;Hello, Alice!&quot; Lambda表达式的简写 注意和csharp表达式体的区别 简化1：自动类型推断 当委托类型明确时，参数类型可省略： (int x) =&gt; ... → x =&gt; ... 123Func&lt;int, int&gt; doubler = (x) =&gt; &#123; return x * 2; &#125;; 简化2：单参数可省略括号 若只有一个参数，()可省略： (x) =&gt; ... → x =&gt; ... 123Func&lt;int, int&gt; doubler = x =&gt; &#123; return x * 2; &#125;; 简化3：单行表达式自动返回 若主体是单行表达式，可省略&#123;&#125;和return： x =&gt; &#123; return x*2; &#125; → x =&gt; x*2 1Func&lt;int, int&gt; doubler = x =&gt; x * 2; 注意事项 12345678910111213// 多参数必须保留括号：Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b; // 正确Func&lt;int, int, int&gt; add = a, b =&gt; a + b; // 错误！ // 无参数时需空括号:Action printHello = () =&gt; Console.WriteLine(&quot;Hello&quot;);// 复杂逻辑仍需代码块：Action log = () =&gt; &#123; Console.WriteLine(&quot;Start&quot;); // 多行逻辑 Console.WriteLine(&quot;End&quot;);&#125;; Lambda的常见用途 委托实例化 和 事件处理 123Func&lt;int, int, int&gt; sum = (a, b) =&gt; a + b;Action&lt;string&gt; log = msg =&gt; Console.WriteLine(msg);button.Click += (sender, e) =&gt; MessageBox.Show(&quot;Clicked!&quot;); LINQ查询 与LINQ方法结合，实现数据筛选、转换等操作： 123var numbers = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5 &#125;;var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); // 筛选偶数var squares = numbers.Select(x =&gt; x * x); // 计算平方 表达式树（Expression Trees） 将Lambda编译为表达式树，供其他框架（如EF Core）解析： 1Expression&lt;Func&lt;int, bool&gt;&gt; expr = x =&gt; x &gt; 5; 闭包与变量捕获 当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。 示例 1：基本闭包 123456789Func&lt;int&gt; CreateCounter()&#123; int count = 0; return () =&gt; ++count; // 闭包捕获了外部变量 count&#125;var counter = CreateCounter();Console.WriteLine(counter()); // 输出 1Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态） 现象：count 本应在 CreateCounter 方法执行完毕后被销毁，但闭包保留了它的状态。 原理：编译器生成一个类，将 count 作为该类的字段存储，闭包通过这个类的实例访问 count。 示例 2：循环中的闭包陷阱 123456789var actions = new List&lt;Action&gt;();for (int i = 0; i &lt; 3; i++)&#123; actions.Add(() =&gt; Console.WriteLine(i));&#125;foreach (var action in actions)&#123; action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）&#125; 问题原因：所有闭包共享同一个变量 i（在循环结束后，i 的值为 3）。 解决方案：在循环内部创建临时变量，让闭包捕获独立的值： 12345for (int i = 0; i &lt; 3; i++)&#123; int current = i; // 每次循环新建一个临时变量 actions.Add(() =&gt; Console.WriteLine(current)); // 输出 0, 1, 2&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp委托","slug":"编程语言/Csharp/csharp委托","date":"2025-02-27T14:37:01.000Z","updated":"2025-03-01T03:21:55.888Z","comments":true,"path":"2025/02/27/编程语言/Csharp/csharp委托/","permalink":"http://example.com/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/","excerpt":"","text":"委托基本概念 定义：委托是类型安全的函数指针，通过 delegate 关键字声明。（ 委托就是一个用来装函数的类的类型） 作用：允许将方法作为参数传递、动态调用多个方法。 核心特点： 类型安全（编译时检查参数和返回值）。 支持多播（组合多个方法）。 可用于异步编程。 委托的声明与使用 写在哪里？ 可以申明在namespace和class语句块中 更多的写在namespace中 委托常用在： 作为类的成员 作为函数的参数 声明委托类型： 123// 定义委托类型，指定方法签名// MathOperation是一个委托类型，只能引用接受两个 int 参数并返回 string 的方法。public delegate string MathOperation(int a, int b); 实例化委托： eg1： 123456// 绑定到具体方法MathOperation add = (a, b) =&gt; a + b;MathOperation multiply = (a, b) =&gt; a * b;// 调用委托int result = add(3, 5); // 输出 8 eg2： 12345678public delegate int Fun(int a);static int MyFun1(int a) ...static int MyFun2(int a) ...Fun f = MyFun1;int tmp = f.Invoke(666);int tmp = f(666); 多播委托（Multicast Delegate） 功能：一个委托实例可绑定多个方法，按顺序执行。 操作符： += 添加方法。 -= 移除方法。 1234567MathOperation add = (a, b) =&gt; a + b;MathOperation multiply = (a, b) =&gt; a * b;MathOperation operations = add;operations += multiply;// 调用时会依次执行 add 和 multiplyint finalResult = operations(3, 5); // 返回 multiply 的结果 15（最后一个方法的返回值） 注意：返回值通常只保留最后一个方法的返回值，中间结果可能被覆盖。 以下是一个示例，演示了如何获取多播委托每一个函数的返回值： 12345678910111213141516171819202122232425262728293031323334using System;public delegate int MyDelegate();class Program&#123; static void Main() &#123; MyDelegate myDelegate = Method1; myDelegate += Method2; myDelegate += Method3; // 获取每一个函数的返回值 Delegate[] delegates = myDelegate.GetInvocationList(); foreach (var del in delegates) &#123; MyDelegate singleDelegate = (MyDelegate)del; int result = singleDelegate(); Console.WriteLine($&quot;Method returned: &#123;result&#125;&quot;); &#125; &#125; static int Method1() &#123; Console.WriteLine(&quot;Method1&quot;); return 1; &#125; static int Method2() &#123; Console.WriteLine(&quot;Method2&quot;); return 2; &#125; static int Method3() &#123; Console.WriteLine(&quot;Method3&quot;); return 3; &#125;&#125; 内置泛型委托 Action：无返回值的方法，最多支持 16 个参数。 12Action&lt;string&gt; log = message =&gt; Console.WriteLine(message);log(&quot;Hello, Action!&quot;); Func：有返回值的方法，最后一个类型参数为返回类型。 12Func&lt;int, int, string&gt; formatSum = (a, b) =&gt; $&quot;&#123;a + b&#125;&quot;;Console.WriteLine(formatSum(3, 5)); // 输出 &quot;8&quot; 匿名方法 匿名函数的使用主要是配合委托和事件进行使用 何时使用？ 函数中传递委托参数时 委托或事件赋值时 缺点? 不能删的具体只能无脑null eg： 12345678910111213141516171819202122232425262728293031323334 class Test&#123; public void Fun1(Action action) &#123; Console.WriteLine(&quot;需要委托作为参数的函数,使用函数更加方便&quot;); action(); &#125; public Action GetFun() &#123; return delegate () &#123; Console.WriteLine(&quot;匿名函数常用作返回值&quot;); &#125;; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; // 匿名函数给委托赋值 Action a = delegate () &#123; Console.WriteLine(&quot;匿名函数逻辑&quot;); &#125;; Test t = new Test(); t.Fun1(a); t.GetFun()(); Func&lt;int, int&gt; b = delegate (int a) &#123; Console.WriteLine(&quot;匿名函数的返回值直接返回就行&quot;); return a; &#125;; &#125;&#125; csharp事件 csharp的Lambda表达式 泛型委托和泛型接口の协变和逆变","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"3.Unity随机数和UnityAction委托","slug":"游戏引擎/unity/unity入门/unity入门实践项目/3.Unity随机数和UnityAction委托","date":"2025-02-27T13:44:46.000Z","updated":"2025-02-28T10:39:30.253Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/3.Unity随机数和UnityAction委托/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.Unity%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8CUnityAction%E5%A7%94%E6%89%98/","excerpt":"","text":"unity当中的随机数用法 1234int randomNum = Random.Range(0, 100); // [0, 100)// float重载，规则是左右都包含float randomNumF = Random.Range(1.1f, 99.9f); // [1.1~99.9f] CSharp中的随机数 123// 左包含，右不包含System.Random random = new System.Random();random.Next(0, 100); // [0, 100) unity的委托 要引用using UnityEngine.Events;命名空间 无参无返回的委托 123UnityAction uac = () =&gt;&#123;&#125;; string作为参数无返回值的委托 123UnityAction&lt;string&gt; uac1 = (s) =&gt;&#123;&#125;; csharp委托 无参无返回的委托 123System.Action ac = () =&gt;&#123;&#125;; int和float作为参数无返回值的委托 123System.Action&lt;int, float&gt; ac2 = (i, f) =&gt;&#123;&#125;; 无参int返回值的委托 1234System.Func&lt;int&gt; fun1 = () =&gt;&#123; return 1;&#125;; int作为参数string作为返回值的委托 1234System.Func&lt;int, string&gt; fun2 = (i) =&gt;&#123; return &quot;123&quot;;&#125;;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.鼠标的隐藏锁定图片","slug":"游戏引擎/unity/unity入门/unity入门实践项目/2.Cursor鼠标的隐藏锁定图片","date":"2025-02-27T13:35:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/2.Cursor鼠标的隐藏锁定图片/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.Cursor%E9%BC%A0%E6%A0%87%E7%9A%84%E9%9A%90%E8%97%8F%E9%94%81%E5%AE%9A%E5%9B%BE%E7%89%87/","excerpt":"","text":"Cursor.visible静态变量 设置鼠标显隐 12// 隐藏鼠标Cursor.visible = false; Cursor.lockState静态变量 设置鼠标锁定状态 确定硬件指针是否锁定到视图的中心、受限于窗口或者根本不受限制。 None: 不锁定鼠标 Locked: 锁定鼠标。鼠标会被限制在屏幕的中心点，不仅会被锁定，还会被隐藏。可以通过按下ESC键摆脱编辑模式下的锁定。要是回到Game窗口点击鼠标会被再次锁定隐藏。 Confined: 限制鼠标在Game窗口范围内。可以通过按下ESC键摆脱编辑模式下的限制。要是回到Game窗口点击鼠标会被再次限制。 1Cursor.lockState = CursorLockMode.Confined; Cursor.SetCursor静态方法 设置鼠标图片 将鼠标光标设置为给定纹理。 参数一：光标图片 参数二：偏移位置，相对图片左上角 参数三：平台支持的光标模式（硬件或软件）（一般选CursorMode.Auto） 123public Texture2D cursorTexture2D;Cursor.SetCursor(cursorTexture2D, Vector2.zero, CursorMode.Auto);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.场景切换和游戏退出","slug":"游戏引擎/unity/unity入门/unity入门实践项目/1.场景切换和游戏退出","date":"2025-02-27T13:28:07.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/1.场景切换和游戏退出/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E9%80%80%E5%87%BA/","excerpt":"","text":"场景切换 按照 Build Settings 中的名称或索引加载场景。要引入using UnityEngine.SceneManagement;命名空间。 直接写代码切换场景可能会报错。注意: 切换必须要将场景拖到Unity 中的file-BuildSetting的Scene列表中 然后可用用代码来切换 1ScenneManager.Load(&quot;scenename&quot;); 退出游戏 退出播放器应用程序。执行这句代码就会退出游戏。但是在编辑模式下没有作用，一定是发布游戏过后才有用。 12// 退出游戏Application.Quit();","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.自定义控件拼面板","slug":"UI系统/GUI/GUI实践项目/12.自定义控件拼面板","date":"2025-02-27T09:11:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/12.自定义控件拼面板/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/12.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%8B%BC%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"先拼面板 TestBeginPanel.cs 1234567891011121314151617181920212223public class BeginPanel : MonoBehaviour&#123; public CustomGUIButton btnBegin; public CustomGUIButton btnEnd; public CustomGUIButton btnQuit; void Start() &#123; btnBegin.clickEvent += () =&gt; &#123; Debug.Log(&quot;Begin&quot;); &#125;; btnEnd.clickEvent += () =&gt; &#123; Debug.Log(&quot;End&quot;); &#125;; btnQuit.clickEvent += () =&gt; &#123; this.gameObject.SetActive(false); &#125;; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.自定义图片绘制","slug":"UI系统/GUI/GUI实践项目/11.自定义图片绘制","date":"2025-02-27T09:01:50.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/11.自定义图片绘制/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/11.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6/","excerpt":"","text":"CustomGUITexture.cs 12345678910111213public class CustomGUITexture : CustomGUIControl&#123; // 方便外部缩放模式调整 public ScaleMode mode = ScaleMode.StretchToFill; protected override void DrawIsOff() &#123; GUI.DrawTexture(guiPos.Pos, guiContent.image, mode); &#125; protected override void DrawIsOn() &#123; GUI.DrawTexture(guiPos.Pos, guiContent.image, mode); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"10.自定义输入框和拖动条","slug":"UI系统/GUI/GUI实践项目/10.自定义输入框和拖动条","date":"2025-02-27T08:49:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/10.自定义输入框和拖动条/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/10.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"CustomGUIInput.cs 12345678910111213141516171819202122232425public class CustomGUIInput : CustomGUIControl&#123; // 当输入框变化时的事件 public event UnityAction&lt;string&gt; changeText; private string oldStr = &quot;&quot;; protected override void DrawIsOff() &#123; guiContent.text = GUI.TextField(guiPos.Pos, guiContent.text); // 当输入框变化时调用的委托函数 if (oldStr != guiContent.text) &#123; changeText?.Invoke(guiContent.text); oldStr = guiContent.text; &#125; &#125; protected override void DrawIsOn() &#123; guiContent.text = GUI.TextField(guiPos.Pos, guiContent.text, style); if (oldStr != guiContent.text) &#123; changeText?.Invoke(guiContent.text); oldStr = guiContent.text; &#125; &#125;&#125; CustomGUISlide.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public enum E_Slider_Type&#123; Horizontal, Vertical,&#125;public class CustomGUISlide : CustomGUIControl&#123; public float minValue = 0; public float maxValue = 1; public float nowValue = 0; public E_Slider_Type sliderType = E_Slider_Type.Horizontal; // 默认的style是条的, 这里还需要滑块的style public GUIStyle styleThumb; public event UnityAction&lt;float&gt; changeValue; private float oldValu e; protected override void DrawIsOff() &#123; switch (sliderType) &#123; case E_Slider_Type.Horizontal: nowValue = GUI.HorizontalSlider(guiPos.Pos, nowValue, minValue, maxValue); break; case E_Slider_Type.Vertical: nowValue = GUI.VerticalSlider(guiPos.Pos, nowValue, minValue, maxValue); break; &#125; if (oldValue != nowValue) &#123; changeValue?.Invoke(nowValue); oldValue = nowValue; &#125; &#125; protected override void DrawIsOn() &#123; switch (sliderType) &#123; case E_Slider_Type.Horizontal: nowValue = GUI.HorizontalSlider(guiPos.Pos, nowValue, minValue, maxValue, style, styleThumb); break; case E_Slider_Type.Vertical: nowValue = GUI.VerticalSlider(guiPos.Pos, nowValue, minValue, maxValue, style, styleThumb); break; &#125; if (oldValue != nowValue) &#123; changeValue?.Invoke(nowValue); oldValue = nowValue; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"9.自定义单选框","slug":"UI系统/GUI/GUI实践项目/9.自定义单选框","date":"2025-02-27T07:47:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/9.自定义单选框/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/9.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E9%80%89%E6%A1%86/","excerpt":"","text":"回顾闭包 当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。 示例 1：基本闭包 123456789Func&lt;int&gt; CreateCounter()&#123; int count = 0; return () =&gt; ++count; // 闭包捕获了外部变量 count&#125;var counter = CreateCounter();Console.WriteLine(counter()); // 输出 1Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态） 现象：count 本应在 CreateCounter 方法执行完毕后被销毁，但闭包保留了它的状态。 原理：编译器生成一个类，将 count 作为该类的字段存储，闭包通过这个类的实例访问 count。 示例 2：循环中的闭包陷阱 123456789var actions = new List&lt;Action&gt;();for (int i = 0; i &lt; 3; i++)&#123; actions.Add(() =&gt; Console.WriteLine(i));&#125;foreach (var action in actions)&#123; action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）&#125; 问题原因：所有闭包共享同一个变量 i（在循环结束后，i 的值为 3）。 解决方案：在循环内部创建临时变量，让闭包捕获独立的值： 12345for (int i = 0; i &lt; 3; i++)&#123; int current = i; // 每次循环新建一个临时变量 actions.Add(() =&gt; Console.WriteLine(current)); // 输出 0, 1, 2&#125; CustomGUIToggleGroup.cs 创建自定义单选框，添加多选框数组，通过管理多选框实现单选框，在添加一个记录上一次为true的toggle 123456789101112131415161718192021222324252627282930313233343536public class CustomGUIToggleGroup : MonoBehaviour&#123; [SerializeField] private CustomGUIToggle[] _toggles; private CustomGUIToggle _frontTrueToggle； // 上一次为true的toggle // 注意只有游戏运行才能用 void Start() &#123; for (int i = 0; i &lt; _toggles.Length; i++) &#123; CustomGUIToggle tmp = _toggles[i]; // 为每个Toggle添加一个一旦其值为true时, 其它Toggle变为false的委托 // Lambda函数捕获了外部变量（tmp）!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! tmp.changeEvent += (value) =&gt; &#123; if (value) &#123; for (int j = 0; j &lt; _toggles.Length; j++) &#123; if (tmp != _toggles[j]) // 只要不是自己 &#123; _toggles[j].isSel = false; &#125; &#125; // 这里可以记录上一次为true的toggle _frontTrueToggle = tmp; &#125; else if (_frontTrueToggle == tmp) // 如果是上一次为true的toggle &#123; tmp.isSel = true; // 永远保持选中的状态 &#125; &#125;; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"8.自定义多选框","slug":"UI系统/GUI/GUI实践项目/8.自定义多选框","date":"2025-02-27T07:42:31.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/8.自定义多选框/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/8.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E9%80%89%E6%A1%86/","excerpt":"","text":"CustomGUIToggle.cs 12345678910111213141516171819202122232425262728public class CustomGUIToggle : CustomGUIControl&#123; // 单选的那个bool public bool isSel; private bool oldSel; // 当选中时所要执行的事件 public event UnityAction&lt;bool&gt; changeEvent; protected override void DrawIsOff() &#123; isSel = GUI.Toggle(guiPos.Pos, isSel, guiContent); // 防止一直true true true一直调用事件执行 // 只有当 true 和 false 发生变化的时候才去处理 if (isSel != oldSel) &#123; changeEvent?.Invoke(isSel); oldSel = isSel; &#125; &#125; protected override void DrawIsOn() &#123; isSel = GUI.Toggle(guiPos.Pos, isSel, guiContent, style); if (isSel != oldSel) &#123; changeEvent?.Invoke(isSel); oldSel = isSel; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"7.自定义文本和按钮","slug":"UI系统/GUI/GUI实践项目/7.自定义文本和按钮","date":"2025-02-27T07:19:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/7.自定义文本和按钮/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/7.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E5%92%8C%E6%8C%89%E9%92%AE/","excerpt":"","text":"创建自定义文本和按钮，将其脚本拖入到空物体上做成预制体 CustomGUILabel.cs 1234567891011public class CustomGUILabel : CustomGUIControl&#123; protected override void DrawIsOff() &#123; GUI.Label(guiPos.Pos, guiContent); &#125; protected override void DrawIsOn() &#123; GUI.Label(guiPos.Pos, guiContent, style); &#125;&#125; CustomGUIButton.cs 1234567891011121314151617181920public class CustomGUIButton : CustomGUIControl&#123; // 提供给外部的按钮点击事件, 想要按钮点击后做啥往里加函数就行, Unity自带的事件 public event UnityAction clickEvent; protected override void DrawIsOff() &#123; if (GUI.Button(guiPos.Pos, guiContent)) &#123; clickEvent?.Invoke(); &#125; &#125; protected override void DrawIsOn() &#123; if (GUI.Button(guiPos.Pos, guiContent, style)) &#123; clickEvent?.Invoke(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"6.控件根对象","slug":"UI系统/GUI/GUI实践项目/6.控件根对象","date":"2025-02-27T07:06:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/6.控件根对象/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/6.%E6%8E%A7%E4%BB%B6%E6%A0%B9%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"解决两个问题 所见即所得（编辑模式下能看到GUI） 可以控制控件的绘制顺序 创建所有自定义GUI的根部类,添加ExecuteAlways特性 在类名添加ExecuteAlways特性，可以让编辑模式下指定代码运行。 12345[ExecuteAlways]//所有自定义GUI的根部类public class CustomGUIRoot : MonoBehaviour&#123;&#125; 在Start方法中获取所有子对象的控件父类脚本 12345void Start()&#123; //通过每一次绘制之前 得到所有子对象控件的 父类脚本 allControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;();&#125; 在OnGUI方法中按照得到的顺序来绘制每个控件，用控件父类中定义好的绘制方法 1234567891011121314151617181920//在这同一绘制子对象控件的内容private void OnGUI()&#123; //编辑状态下 才会一直执行 //if (!Application.isPlaying) //&#123; //这句代码 浪费性能 因为每次 gui都会来获取所有的 控件对应的脚本 所以要在编辑状态下才会一直执行 //在编辑状态下运行是因为想一直看到控件的移动 //最后没开启是因为只得了一次子对象的CustomGUIControl 就算子对象被隐藏了也不会重写得CustomGUIControl 会有问题 allControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); //&#125; //遍历每一个控件 让其 执行绘制 for (int i = 0; i &lt; allControls.Length; i++) &#123; allControls[i].GUIDraw(); &#125;&#125; CustomGUIRoot.cs 12345678910111213141516171819202122[ExecuteAlways]public class CustomGUIRoot : MonoBehaviour&#123; private CustomGUIControl[] _customGUIControls; private void Start() &#123; _customGUIControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); &#125; // 统一控制所有子对象挂载的控件的 绘制 private void OnGUI() &#123; if (!Application.isPlaying) // 这里的条件判断主要是为了性能, 实际运行可能会出错 &#123; _customGUIControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); &#125; for (int i = 0; i &lt; _customGUIControls.Length; i++) &#123; _customGUIControls[i].GUIDraw(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"5.控件父类","slug":"UI系统/GUI/GUI实践项目/5.控件父类","date":"2025-02-27T02:19:18.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/5.控件父类/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/5.%E6%8E%A7%E4%BB%B6%E7%88%B6%E7%B1%BB/","excerpt":"","text":"这是所有控件的公共基类 自定义样式是否启用的开关枚举 定义了一个枚举类型 E_Style_onoff 用于表示自定义样式是否启用。 12345public enum E_Style_onoff&#123; On, Off,&#125; 自定义控件父类是一个抽象类，继承自MonoBehaviour。 123public abstract class CustomGUIControl : MonoBehaviour&#123;&#125; 提取控件的共同表现 位置信息 显示内容信息 自定义样式以及自定义样式是否启用的开关。 123456789101112// 位置信息public CustomGUIPos guiPos;// 显示内容信息public GUIContent content;// 自定义样式public GUIStyle style;// 自定义样式是否启用的开关public E_Style_OnOff styleOnOrOff = E_Style_OnOff.Off; 根据是否使用style写两个抽象方法 1234567891011121314151617181920212223public void DrawGUI()&#123; switch (styleOnOrOff) &#123; case E_Style_OnOff.On: StyleOnDraw(); break; case E_Style_OnOff.Off: StyleOffDraw(); break; &#125;&#125;/// &lt;summary&gt;/// 自定义样式开启时的绘制抽象方法/// &lt;/summary&gt;protected abstract void StyleOnDraw();/// &lt;summary&gt;/// 自定义样式关闭时的绘制抽象方法/// &lt;/summary&gt;protected abstract void StyleOffDraw(); CustomGUIControl.cs 12345678910111213141516171819202122232425262728293031323334public enum E_Style_onoff&#123; On, Off,&#125;public abstract class CustomGUIControl : MonoBehaviour&#123; // GUI控件公共部分 !!!!!! // 位置信息 public CustomGUIPos guiPos; // 显示内容信息 public GUIContent guiContent; // 自定义样式 public GUIStyle style; // 自定义样式开关 public E_Style_onoff styleIsOn = E_Style_onoff.Off; // 提供公共的控件绘制 public void GUIDraw() &#123; switch (styleIsOn) &#123; case E_Style_onoff.On: // 样式开启时使用的绘制函数 DrawIsOn(); break; case E_Style_onoff.Off: DrawIsOff(); break; &#125; &#125; protected abstract void DrawIsOn(); protected abstract void DrawIsOff();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"4.控件位置信息类","slug":"UI系统/GUI/GUI实践项目/4.控件位置信息类","date":"2025-02-27T01:54:24.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/4.控件位置信息类/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%8E%A7%E4%BB%B6%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%B1%BB/","excerpt":"","text":"CustomGUIPos.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//对齐方式九宫格枚举定义public enum E_Alignment_Type&#123; Up, Down, Left, Right, Center, Left_Up, Left_Down, Right_Up, Right_Down,&#125;// 自定义类需要再Inspector面板显示[System.Serializable]public class CustomGUIPos&#123; // 控件位置 private Rect _pos = new Rect(0, 0, 101, 100); // 屏幕九宫格对齐方式 public E_Alignment_Type Screen_Alignment_Type = E_Alignment_Type.Center; // 控件中心点对齐方式 public E_Alignment_Type Constrol_Center_Alignment_Type = E_Alignment_Type.Center; // 偏移位置 public Vector2 dPos; // 控件宽高 public float Width = 100; public float Height = 50; // 计算后的控件位置 public Rect Pos &#123; get &#123; CalcCenterPos(); CalcPos(); _pos.width = Width; _pos.height = Height; return _pos; &#125; &#125; // 计算最后的位置 private void CalcPos() &#123; switch (Screen_Alignment_Type) &#123; case E_Alignment_Type.Up: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Down: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Center: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left_Up: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left_Down: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right_Up: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right_Down: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; &#125; &#125; // 控件中心点位置 private Vector2 _centerPos; private void CalcCenterPos() &#123; switch (Constrol_Center_Alignment_Type) &#123; case E_Alignment_Type.Up: _centerPos.x = -Width / 2; _centerPos.y = 0; break; case E_Alignment_Type.Down: _centerPos.x = -Width / 2; _centerPos.y = -Height; break; case E_Alignment_Type.Left: _centerPos.x = 0; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Right: _centerPos.x = -Width; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Center: _centerPos.x = -Width / 2; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Left_Up: _centerPos.x = 0; _centerPos.y = 0; break; case E_Alignment_Type.Left_Down: _centerPos.x = 0; _centerPos.y = -Height; break; case E_Alignment_Type.Right_Up: _centerPos.x = -Width; _centerPos.y = 0; break; case E_Alignment_Type.Right_Down: _centerPos.x = -Width; _centerPos.y = -Height; break; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"3.九宫格概念","slug":"UI系统/GUI/GUI实践项目/3.九宫格概念","date":"2025-02-27T01:41:15.000Z","updated":"2025-02-28T11:54:17.740Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/3.九宫格概念/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"相对屏幕位置：红点的位置 中心点偏移位置：控件的九个点的位置","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.需求分析","slug":"UI系统/GUI/GUI实践项目/2.需求分析","date":"2025-02-27T01:35:44.000Z","updated":"2025-02-28T11:48:54.741Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/2.需求分析/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"使用GUI制作出控件预制体，不需要运行时在OnGUI写逻辑才能看到UI","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.hexo源码上传到GitHub","slug":"hexo/2.hexo源码上传到GitHub","date":"2025-02-26T13:54:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/hexo/2.hexo源码上传到GitHub/","permalink":"http://example.com/2025/02/26/hexo/2.hexo%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub/","excerpt":"","text":"在你的github中创建一个新的分支用来保存源码 名字随便，这里我的是hexo git clone 你的仓库 复制.git文件夹到你的博客目录 123git add .git commit -m &quot;Update&quot;git push origin hexo 参考链接： hexo源码上传到GitHub - choco莉特 - 博客园","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"1.编辑模式下让指定代码运行","slug":"UI系统/GUI/GUI实践项目/1.编辑模式下让指定代码运行","date":"2025-02-26T13:42:40.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI实践项目/1.编辑模式下让指定代码运行/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%AE%A9%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C/","excerpt":"","text":"在类名上添加 [ExecuteAlways] 特性可以让指定代码在编辑模式下运行 编辑模式下，缩放Game窗口大小每一帧相关也会执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//在类名添加ExecuteAlways特性 可以让编辑模式下让指定代码运行[ExecuteAlways]public class Lesson01_必备知识点_编辑模式下让指定代码运行 : MonoBehaviour&#123; private void Awake() &#123; Debug.Log(&quot;对象初始化时调用（即使脚本未启用）。&quot;); &#125; private void OnEnable() &#123; Debug.Log(&quot;脚本启用或对象激活时调用（在Awake之后，若对象初始启用）。&quot;); &#125; void Start() &#123; Debug.Log(&quot;在首次Update前调用（仅一次，需脚本启用）。&quot;); &#125; private void FixedUpdate() &#123; Debug.Log(&quot;按固定时间间隔调用（物理计算阶段，可能一帧多次）。&quot;); &#125; private void OnTriggerEnter(Collider other) &#123; Debug.Log(&quot;物理触发事件，在FixedUpdate之后、Update之前处理。&quot;); &#125; void Update() &#123; Debug.Log(&quot;每帧调用一次。&quot;); &#125; private void LateUpdate() &#123; Debug.Log(&quot;所有Update完成后调用。&quot;); &#125; private void OnGUI() &#123; Debug.Log(&quot;渲染GUI时调用，每帧可能多次（在LateUpdate之后）。&quot;); &#125; private void OnDisable() &#123; Debug.Log(&quot;脚本禁用或对象失活时调用。&quot;); &#125; private void OnDestroy() &#123; Debug.Log(&quot;对象销毁前调用。&quot;); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.GUI总结","slug":"UI系统/GUI/GUI基础知识/12.GUI总结","date":"2025-02-26T12:22:28.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/12.GUI总结/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GUI%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"11.GUILayout自动布局","slug":"UI系统/GUI/GUI基础知识/11.GUILayout自动布局","date":"2025-02-26T12:13:57.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/11.GUILayout自动布局/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.GUILayout%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546// GUILayout是一个类似GUI的类，里面的API和GUI类似，只是可以帮我们自动布局，不用手动调整位置，方便一点。// GUILayout 类是 Unity GUI 的接口，并且具有自动布局功能。// 主要用于进行编辑器开发，如果用它来做游戏UI不太合适。// GUILayout和GUI可以相互配合着使用GUI.BeginGroup(new Rect(100, 100, 500, 300));GUILayout.BeginArea(new Rect(10, 10, 400, 300)); // 在一个固定的屏幕区域中开始 GUI 控件的 GUILayout 块。GUILayout.BeginVertical(); // 开始一个垂直控件组。GUILayout.Button(&quot;竖直123&quot;, GUILayout.Width(200)); // 控件的固定宽高GUILayout.Button(&quot;竖直245666656565&quot;);GUILayout.Button(&quot;竖直235&quot;, GUILayout.ExpandWidth(false)); // 允许或禁止水平拓展GUILayout.EndVertical(); // 闭合以 BeginVertical 开始的组。GUILayout.BeginHorizontal(); // 开始一个水平控件组。GUILayout.Button(&quot;水平123&quot;, GUILayout.Height(300)); // 控件的固定宽高GUILayout.Button(&quot;水平245666656565&quot;);GUILayout.Button(&quot;水平235&quot;, GUILayout.ExpandWidth(false)); // 允许或禁止水平拓展GUILayout.EndHorizontal(); // 闭合以 BeginHorizontal 开始的组。GUILayout.EndArea(); // 闭合以 BeginArea 开始的 GUILayout 块。GUI.EndGroup();GUILayoutOption 布局选项 //控件的固定宽高 GUILayout.Width(300); GUILayout.Height(200); //允许控件的最小宽高 GUILayout.MinWidth(50); GUILayout.MinHeight(50); //允许控件的最大宽高 GUILayout.MaxWidth(100); GUILayout.MaxHeight(100); //允许或禁止水平拓展 GUILayout.ExpandWidth(true);//允许 GUILayout.ExpandHeight(false);//禁止 GUILayout.ExpandHeight(true);//允许 GUILayout.ExpandHeight(false);//禁止","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"10.自定义皮肤样式","slug":"UI系统/GUI/GUI基础知识/10.自定义皮肤样式","date":"2025-02-26T12:00:57.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/10.自定义皮肤样式/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%AE%E8%82%A4%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"颜色* color静态变量 全局的着色颜色 123456// GUI 的全局着色颜色。GUI.color = Color.red;GUI.Label(new Rect(0, 50, 150, 30), &quot;全局着色颜色标签红&quot;);GUI.Button(new Rect(0, 100, 150, 30), &quot;全局着色颜色按钮红&quot;);GUI.color = Color.white;GUI.Button(new Rect(0, 150, 150, 30), &quot;全局着色颜色按钮白&quot;, style); contentColor静态变量 文本着色颜色 1234// 文本着色颜色，会和全局颜色相乘。// 为 GUI 渲染的所有文本着色。GUI.contentColor = Color.yellow;GUI.Button(new Rect(0, 200, 150, 30), &quot;文本着色颜色&quot;); backgroundColor静态变量 背景元素着色颜色 1234// 用于 GUI 渲染的所有背景元素的全局着色颜色。// 背景元素着色颜色会和全局颜色相乘。GUI.backgroundColor = Color.green;GUI.Button(new Rect(0, 250, 150, 30), &quot;背景元素着色颜色&quot;, style); 整体皮肤样式 在Project窗口可以右键创建GUI皮肤 skin静态变量 全局皮肤 123456public GUISkin mySkin;private void OnGUI()&#123; GUI.skin = mySkin; // 为null就是默认的样式，单个Style会覆盖&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"9.窗口","slug":"UI系统/GUI/GUI基础知识/9.窗口","date":"2025-02-26T11:35:31.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/9.窗口/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%AA%97%E5%8F%A3/","excerpt":"","text":"窗口 1234567891011121314// 第一个参数是窗口唯一id// 第三个参数是一个 要一个int作为参数的无返回值的委托, 用来处理窗口内容的GUI.Window(1, new Rect(0, 0, 500, 500), (a) =&gt;&#123; // 一个函数处理不同的窗口 switch (a) &#123; case 1: GUI.Button(new Rect(0, 0, 100, 30), &quot;第一个窗口逻辑&quot;); break; case 2: break; &#125;&#125;, &quot;测试窗口&quot;); 模态窗口 1234567// 显示一个模态窗口。// 模态窗口可以让其它控件不再有用。// 你可以理解该窗口在最上层，其它按钮都点击不到了，只能点击该窗口上控件。// 只有把模态窗口处理后, 才可以点击其它窗口GUI.ModalWindow(3, new Rect(300, 100, 200, 150), (a) =&gt; &#123;&#125;, &quot;模态窗口&quot;);// 可能应用于警告弹窗，必须先处理的弹出 拖动窗口 12345678public Rect winRect = new Rect(100, 100, 200, 200);winRect = GUI.Window(3, winRect, (a) =&gt;&#123; // 无参默认窗口所有位置都可以拖动 // 参数指定窗口的哪一部分可以被鼠标拖动 GUI.DragWindow(); // 必须要调用这个才能拖动&#125;, &quot;拖动窗口测试&quot;); 练习 在之前制作的开始界面中，点击退出游戏按钮，弹出一个模态窗口，让玩家确定是否退出（退出，取消），点击取消后关闭窗口，点击退出后 退出游戏 QuitTipPanel.cs 1234567891011121314151617181920212223private void OnGUI()&#123; // 绘制模态窗口 GUI.ModalWindow(1, winPos, DrawWindow, &quot;提示&quot;);&#125;private void DrawWindow(int id)&#123; // 标签 GUI.Label(labPos, &quot;是否退出&quot;); // 两个按钮 if(GUI.Button(btnPos1, &quot;退出&quot;)) &#123; Application.Quit(); &#125; if(GUI.Button(btnPos2, &quot;取消&quot;)) &#123; HideMe(); BeginPanel.ShowMe(); &#125;&#125; BeginPanel.cs 12345if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle))&#123; QuitTipPanel.ShowMe(); HideMe();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"8.滚动列表和分组","slug":"UI系统/GUI/GUI基础知识/8.滚动列表和分组","date":"2025-02-26T11:04:59.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/8.滚动列表和分组/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%E5%92%8C%E5%88%86%E7%BB%84/","excerpt":"","text":"分组 BeginGroup 1234567891011121314//BeginGroup静态方法 开始分组//开始一个组。必须与 EndGroup 调用配对使用。//用于批量控制控件位置 //可以理解为 包裹着的控件加了一个父对象 //可以通过控制分组来控制包裹控件的位置GUI.BeginGroup(groupRect); // 必须搭配EndGroup来使用//组内的组件GUI.Button(new Rect(0, 0, 100, 50), &quot;测试按钮&quot;);GUI.Label(new Rect(0, 60, 100, 20), &quot;Label信息&quot;);//EndGroup静态方法 结束分组//结束组。GUI.EndGroup(); 滚动列表 BeginScrollView 在Unity中，GUI.BeginScrollView函数用于创建一个可以滚动的视图区域，允许在较小的矩形区域内显示较大的内容。该函数的参数如下所示： position (Rect)：指定 滚动视图 的矩形区域，使用Rect类型来表示，包含了左上角的位置坐标和宽度、高度。 scrollPosition (Vector2)：指定当前滚动位置的二维向量，表示在滚动视图中内容的偏移量。 viewRect (Rect)：指定 具体内容 的矩形区域大小，使用Rect类型来表示，包含了左上角的位置坐标和宽度、高度。 12345678910111213public Rect scrollPos;public Rect showView;public Vector2 nowPos;nowPos = GUI.BeginScrollView(scrollPos, nowPos, showView);// 中间填想要放在滚动列表里面的UI eg:GUI.Toolbar(new Rect(0, 0, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 60, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 120, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 180, 300, 50), 0, strs);GUI.EndScrollView(); 练习 制作一个滚动视图，外部有一个字符串数组，通过在Inspector修改这个字符串数组数量，会在滚动视图内部动态的创建label依次显示内容 想让滚动视图的真实内容大小 随内容(这里是strings)大小变化而变化 1234567891011121314151617181920public string[] strs;public Rect scrollPos;public Rect showView;public Vector2 nowPos;private void OnGUI()&#123; // 想让滚动视图的真实内容大小 随内容(这里是strings)大小变化而变化 // 在绘制滚动视图之前把变化的数据计算好 showView.height = strs.Length * 30; // 计算你要生成的内容的高度 nowPos = GUI.BeginScrollView(scrollPos, nowPos, showView); for (int i = 0; i &lt; strs.Length; i++) &#123; GUI.Label(new Rect(0, i * 30, 100, 30), strs[i]); &#125; GUI.EndScrollView();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"7.工具栏和选择网格","slug":"UI系统/GUI/GUI基础知识/7.工具栏和选择网格","date":"2025-02-26T09:41:39.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/7.工具栏和选择网格/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E9%80%89%E6%8B%A9%E7%BD%91%E6%A0%BC/","excerpt":"","text":"工具栏Toolbar 1234567891011121314151617181920// 创建一个工具栏。// 需要声明一个 int 变量用于选择 和一个 string 数组用于显示当前选择的工具栏的内容。public int toolbarIndex = 0;public string toolbarInfos = new string[] &#123; &quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot; &#125;;// Toolbar静态方法会返回一个 int 值，也需要重新赋值个给选择的 int 变量。toolbarIndex = GUI.Toolbar(new Rect(0, 0, 200, 30), toolbarIndex, toolbarInfos);// 工具栏可以帮助我们根据不同的返回索引 来处理不同的逻辑switch (toolbarIndex)&#123; case 0: // 处理索引为0的逻辑 break; case 1: // 处理索引为1的逻辑 break; case 2: // 处理索引为2的逻辑 break;&#125; 选择网格SelectionGrid 1234// 创建一个按钮网格。// 也需要声明一个 int 变量用于选择 和一个 string 数组用于显示当前选择的工具栏的内容。// 相对 toolbar 多了一个参数 xCount 代表 水平方向最多显示的按钮数量 比如有三个按钮 这参数天了填了2 那么一行最多只要两个按钮。selGridIndex = GUI.SelectionGrid(new Rect(0, 50, 200, 60), selGridIndex, toolbarInfos, 2); 练习 12345678910111213141516171819202122232425262728293031public class TestPanel : MonoBehaviour&#123; public Rect toolbarPos; public Rect selGridPos; public string[] strs = new string[] &#123; &quot;装备&quot;, &quot;进阶&quot;, &quot;幻化&quot; &#125;; private int nowSelIndex = 0; public Rect labelPos; private void OnGUI() &#123; nowSelIndex = GUI.Toolbar(toolbarPos, nowSelIndex, strs); nowSelIndex = GUI.SelectionGrid(selGridPos, nowSelIndex, strs, 1); switch (nowSelIndex) &#123; case 0: GUI.Label(labelPos, &quot;装备信息&quot;); break; case 1: GUI.Label(labelPos, &quot;进阶信息&quot;); break; case 2: GUI.Label(labelPos, &quot;幻化信息&quot;); break; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"6.图片绘制和框","slug":"UI系统/GUI/GUI基础知识/6.图片绘制和框","date":"2025-02-26T09:26:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/6.图片绘制和框/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E5%92%8C%E6%A1%86/","excerpt":"","text":"DrawTexture DrawTexture静态方法重载中的参数 12345//DrawTexture静态方法所有重载public static void DrawTexture(Rect position, Texture image);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect); ScaleMode: 当图像的宽高比不适合要绘制的宽高比时，如何缩放图像。 ScaleAndCrop: 也会通过宽高比来计算图片 但是会进行裁剪。 ScaleToFit: 会自动根据宽高比进行计算 不会拉变形 会一直保持图片全部显示的状态。 StretchToFill: 始终填充满你传入的 Rect 范围。 alphaBlend: 绘制图像时是否应用 Alpha 混合（默认启用）。 用来控制图片是否开启透明通道。 imageAspect: 用于源图像的宽高比。如果为 0（默认值），则使用图像的宽高比。传入 w/h 来指定所需的宽高比。这让您能够在不改变像素宽度和高度的情况下调整源图像的宽高比。 基本使用 12345678public Rect texPos;public Texture tex;public ScaleMode mode = ScaleMode.StretchToFillpublic bool alpha = true;public float wh = 0;// 在一个矩形内绘制纹理。GUI.DrawTexture(texPos, tex, mode, alpha, wh); 框 12// 在 GUI 层上创建一个框。GUI.Box(texPos, &quot;123&quot;); 练习 为各个面板加上背景图片 123456789101112131415// 开始面板脚本public class BeginPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125; 123456789101112131415// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125; 123456789101112131415// 登陆面板脚本public class LoginPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"5.输入框和拖动条","slug":"UI系统/GUI/GUI基础知识/5.输入框和拖动条","date":"2025-02-26T09:04:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/5.输入框和拖动条/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"输入 普通输入TextField 输入框 重要参数： 显示内容 string 最大输入字符串的长度 和多选框类似 要不停得到自己输入的内容 1234public string inputStr = &quot;hello&quot;;// 创建一个可供用户编辑字符串的单行文本字段。inputStr = GUI.TextField(new Rect(0, 0, 100, 30), inputStr, 5);//最多显示5个字符 超过了不会在打出来了 密码输入框PasswordField 1234public string inputPW = &quot;&quot;;// 创建一个可让用户输入密码的文本字段。inputPW = GUI.PasswordField(new Rect(0, 50, 100, 30), inputPW, &#x27;★&#x27;);//密码文本是★ 拖动条 水平拖动条 拖动条重要参数 当前的值 最小值 left 最大值 right 也是要不停得到自己输入的内容 12345public float nowValue = 0;// 用户可以拖动的水平滑动条，用于在最小值和最大值之间更改某值。nowValue = GUI.HorizontalSlider(new Rect(0, 100, 100, 50), nowValue, 0, 1);Debug.Log(nowValue); 竖直拖动条 12 // 用户可以拖动的垂直滑动条，用于在最小值和最大值之间更改某值。nowValue = GUI.VerticalSlider(new Rect(0, 150, 50, 100), nowValue, 0, 1); 练习 在设置面板中加入拖动条控制音乐大小 12345678910111213141516// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 拖动条控制音乐大小 private float musicValue = 1; public Rect musicPos; private float soundValue = 1; public Rect soundPos; private void OnGUI() &#123; // 拖动条 musicValue = GUI.HorizontalSlider(musicPos, musicValue, 0, 1); soundValue = GUI.HorizontalSlider(soundPos, soundValue, 0, 1); &#125;&#125; 制作一个登陆面板 请在之前的基础上,制作一个登陆面板,有用户名输入和密码输入,有进入游戏和返回上一级按钮,点击开始界面中的开始游戏后 进入登陆面板,输入的用户名为admin密码为8888才能切换场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class LoginPanel : MonoBehaviour&#123; //面板的显示隐藏 所有地方都能够快速使用的 //静态 方法 和静态变量 就可以直接通过类名就用了 private static LoginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; //两个 按钮 public Rect btn1Pos; public Rect btn2Pos; //两个 label public Rect lab1Pos; public Rect lab2Pos; //两个 输入框 public Rect input1Pos; public Rect input2Pos; //用户名和密码 private string userName = &quot;&quot;; private string passWord = &quot;&quot;; private void Awake() &#123; instance = this; HideMe(); &#125; private void OnGUI() &#123; //登录按钮 if ( GUI.Button(btn1Pos, &quot;登录游戏&quot;) ) &#123; if(userName == &quot;admin&quot; &amp;&amp; passWord == &quot;8888&quot;) &#123; SceneManager.LoadScene(&quot;GameScene&quot;); &#125; else &#123; Debug.Log(&quot;用户名或者密码错误&quot;); &#125; &#125; //返回按钮 if( GUI.Button(btn2Pos, &quot;返回&quot;) ) &#123; BeginPanel.ShowMe(); HideMe(); &#125; //文本 GUI.Label(lab1Pos, &quot;用户名&quot;); GUI.Label(lab2Pos, &quot;密码&quot;); //输入框 userName = GUI.TextField(input1Pos, userName); passWord = GUI.PasswordField(input2Pos, passWord, &#x27;*&#x27;); &#125;&#125;#endregion","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"4.多选框和单选框","slug":"UI系统/GUI/GUI基础知识/4.多选框和单选框","date":"2025-02-26T08:10:32.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/4.多选框和单选框/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.%E5%A4%9A%E9%80%89%E6%A1%86%E5%92%8C%E5%8D%95%E9%80%89%E6%A1%86/","excerpt":"","text":"多选框 GUI.Toggle的返回值是该Toggle被点击后是否选中 Toggle静态方法 创建多选框 123456789// 创建一个打开 / 关闭的开关按钮。// 要传入一个布尔值，true为选中，false为不选中// Toggle静态方法会返回一个布尔值，返回的布尔值是, 上次鼠标改变Toggle后是否选中// 普通样式isSel = GUI.Toggle(new Rect(0, 0, 100, 30), isSel, &quot;效果开关&quot;);// GUI.Toggle的点击范围是用的Rect中的宽高// 用fixedWidth和fixedHeight 改变图片的大小，但是不改变点击范围// 修改从GUIStyle边缘到内容起始处的空间 paddingisSel2 = GUI.Toggle(new Rect(0, 40, 100, 30), isSel2, &quot;音效开关&quot;, style); 修改多选框样式 单选框 单选框通过多选框来实现的 123456789// 单选框 (一般通过一个int来控制所有的flag, 可通过点击来改变是否选中)if (GUI.Toggle(rect, selIndex == 1, &quot;选项1&quot;))&#123; selIndex = 1;&#125;if (GUI.Toggle(rect, selIndex == 2, &quot;选项2&quot;))&#123; selIndex = 2;&#125; 练习 控制一个面板（比如设置面板的UI）的显隐，通常是将显示面板的脚本挂载到一个Pannel的游戏对象上，在控制这个游戏对象的失活与激活来是否显示面板和隐藏面板 要完成面板之间相互控制显示有3种方法： 第一种：都写在一个 OnGUI 中，通过 bool 标识去控制显影。 第二种：挂载在同一个对象上，通过控制脚本的 gameObject.SetActive(true/false) 去控制面板的显影。 第三种：挂载在不同对象上，通过控制对象的 gameObject.SetActive(true/false) 来达到面板的显影。 关键的是如何在多个面板之间相互调用显隐。我们是通过静态变量和静态方法的形式，在 Awake 方法中初始化静态变量。如果要用该方法，一开始这个对象不能失活。 制作一个游戏设置面板，上面有背景音乐的开关和音效的开关，并且点击开始界面的设置面板可以打开设置面板 单例模式，控制各个面板的显隐 1234567891011121314151617181920212223242526272829303132333435// 开始面板脚本public class BeginPanel : MonoBehaviour&#123; // 开始面板的显示隐藏 private static BeginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; private void Awake() &#123; instance = this; HideMe(); &#125; // 其他代码... private void OnGUI() &#123; // 其他代码... &#125;&#125; 设置面板脚本SettingPanel.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 音乐开关和音效开关 public Rect toggleMusicPos; // **API: Rect** public Rect toggleSoundPos; // **API: Rect** private bool isSelMusic = true; private bool isSelSound = true; private static SettingPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; private void Awake() &#123; instance = this; HideMe(); &#125; private void OnGUI() &#123; // 音乐开关和音效开关 isSelMusic = GUI.Toggle(toggleMusicPos, isSelMusic, &quot;音乐开关&quot;); isSelSound = GUI.Toggle(toggleSoundPos, isSelSound, &quot;音效开关&quot;); // 关闭按钮 设置面板 if (GUI.Button(btnPos, &quot;&quot;, btnStyle)) &#123; // 关闭自己这个面板的功能 HideMe(); // 显示开始界面 BeginPanel.ShowMe(); &#125; &#125;&#125; 开始面板BeginPanel.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//开始面板public class BeginPanel : MonoBehaviour&#123; //面板的显示隐藏 所有地方都能够快速使用的 //静态 方法 和静态变量 就可以直接通过类名就用了 private static BeginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; //游戏标题 public Rect labPos; public GUIContent labContent; public GUIStyle labStyle; //3个游戏按钮 public Rect btn1Pos; public Rect btn2Pos; public Rect btn3Pos; public GUIStyle btnStyle; private void Awake() &#123; instance = this; &#125; private void OnGUI() &#123; //游戏标题 GUI.Label(labPos, labContent, labStyle); //3个游戏按钮 if (GUI.Button(btn1Pos, &quot;开始游戏&quot;, btnStyle)) &#123; //SceneManager.LoadScene(&quot;GameScene&quot;); LoginPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn2Pos, &quot;设置游戏&quot;, btnStyle)) &#123; //显示设置界面 SettingPanel.ShowMe(); //隐藏自己 HideMe(); &#125; if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle)) &#123; QuitTipPanel.ShowMe(); HideMe(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.文本和按钮控件","slug":"UI系统/GUI/GUI基础知识/3.文本和按钮控件","date":"2025-02-26T07:18:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/3.文本和按钮控件/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E6%96%87%E6%9C%AC%E5%92%8C%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"GUI控件绘制的共同点 他们都是GUI公共类中提供的静态函数，直接调用即可。 他们的参数都大同小异： 位置参数：Rect参数（x、y位置，w、h尺寸），左上角为坐标系原点 显示文本：string参数 图片信息：Texture参数 综合信息：GUIContent参数 （综合显示 文本，图片，tooltip） 自定义样式：GUIStyle参数 每一种控件都有多种重载，都是各个参数的排列组合。 注意： 必备的参数内容是位置信息和显示信息 GUI的原点（0,0）Rect在左上角，x向右，y向下 为正 文本控件 Label静态方法所有重载 12345678// 在屏幕上创建一个文本或纹理标签。// Label静态方法所有重载public static void Label(Rect position, string text);public static void Label(Rect position, Texture image);public static void Label(Rect position, GUIContent guiContent);public static void Label(Rect position, string text, GUIStyle style);public static void Label(Rect position, Texture image, GUIStyle style);public static void Label(Rect position, GUIContent guiContent, GUIStyle style); string参数 和 Texture参数 1234// 基本使用 传入位置信息和显示信息 显示信息可以是显示文本和图片信息GUI.Label(new Rect(100, 20, 100, 20), &quot;666666欢迎你&quot;);// public static void Label(Rect position, Texture image);GUI.Label(labelRect1, image); GUIContent 1234567// 综合使用 传入位置信息和综合信息// 综合信息GUIContent类里包括显示文本和图片信息// public static void Label(Rect position, GUIContent labelGuiContent);GUI.Label(labelRect2, guiContent);// tooltip静态变量 可以获取当前鼠标或者键盘选中的GUI控件 对应的 tooltip信息// 鼠标指针当前悬停在其上或具有键盘焦点的控件的工具提示。（只读）Debug.Log(GUI.tooltip); GUIStyle参数 字体在：C:\\Windows\\Fonts 下面 按钮控件 参数和使用方式与文本控件一毛一样 12// 按钮控件 (在按钮范围内 按下鼠标再抬起鼠标 才算一次点击 才会返回trueGUI.Button(btnRect, btnContent, btnStyle); 12345// 长按按钮控件 (只要在长按按钮范围内 按下鼠标 就会一直返回trueif (GUI.RepeatButton(btnRect, btnContent))&#123; Debug.Log(&quot;只要在长按按钮范围内 按下鼠标 就会一直返回true&quot;);&#125; 练习 请用GUI制作一个游戏开始界面，上面有开始游戏，退出游戏，设置等等按钮选项，点击开始游戏可以切换到游戏场景 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using UnityEngine;public class StartMenu : MonoBehaviour&#123; // 游戏标题 public Rect labPos; public GUIContent labContent; public GUIStyle labStyle; // 三个按钮位置和样式 public Rect btn1Pos; public Rect btn2Pos; public Rect btn3Pos; public GUIStyle btnStyle; void OnGUI() &#123; // 渲染游戏标题 GUI.Label(labPos, labContent, labStyle); // 渲染三个按钮 if (GUI.Button(btn1Pos, &quot;开始游戏&quot;, btnStyle)) &#123; // 点击开始游戏按钮事件处理 // SceneManager.LoadScene(&quot;GameScene&quot;); LoginPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn2Pos, &quot;设置游戏&quot;, btnStyle)) &#123; // 点击设置游戏按钮事件处理 SettingPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle)) &#123; // 点击退出游戏按钮事件处理 QuitTipPanel.ShowMe(); HideMe(); &#125; &#125; // 隐藏当前界面 void HideMe() &#123; gameObject.SetActive(false); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.GUI工作原理与主要作用","slug":"UI系统/GUI/GUI基础知识/2.GUI工作原理与主要作用","date":"2025-02-26T07:09:04.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/2.GUI工作原理与主要作用/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.GUI%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/","excerpt":"","text":"GUI是什么 GUI，即即时模式游戏用户交互界面（IMGUI），在Unity中一般简称为GUI。它是一个代码驱动的UI系统。 GUI的主要作用 作为程序员的调试工具，创建游戏内调试工具。 为脚本组件创建自定义检视面板。 创建新的编辑器窗口和工具以拓展Unity本身（一般用作内置游戏工具）。 注意： 不要用它为玩家制作UI功能。 GUI的工作原理 在继承MonoBehaviour的脚本中的特殊函数OnGUI里调用GUI提供的方法，类似生命周期函数。 1234private void OnGUI()&#123; //在其中书写 GUI相关代码 即可显示GUI内容&#125; OnGUI函数注意事项 它每帧执行，相当于是用于专门绘制GUI界面的函数。 一般只在其中执行GUI相关界面绘制和操作逻辑。 该函数在OnDisable之前，LateUpdate之后执行。 生命周期函数 只要是继承Mono的脚本，都可以在OnGUI中绘制GUI。","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.GUI概述","slug":"UI系统/GUI/GUI基础知识/1.GUI概述","date":"2025-02-26T07:05:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/1.GUI概述/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.GUI%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"13.打包PlayerPrefsDataMgr","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/13.打包PlayerPrefsDataMgr","date":"2025-02-24T03:14:19.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/13.打包PlayerPrefsDataMgr/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/13.%E6%89%93%E5%8C%85PlayerPrefsDataMgr/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; else &#123; // 如果value的类型是自定义类型 Save(value, key); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; object v = Activator.CreateInstance(type); // 填充数据 FieldInfo[] fieldInfos = type.GetFields(); string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;type.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; // 和存储的一样 fieldInfo.SetValue(v, LoadValue(fieldInfo.FieldType, keyName)); &#125; return v; &#125; private object LoadValue(Type fieldType, string key) &#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return Load(fieldType, key); &#125; &#125;&#125; 右键PlayerPrefsDataMgr文件，导出包","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.加密思路","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/12.加密思路","date":"2025-02-24T03:07:58.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/12.加密思路/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/12.%E5%8A%A0%E5%AF%86%E6%80%9D%E8%B7%AF/","excerpt":"","text":"找不到 把存在硬盘上的内容放在一个不容易找到的地方多层文件夹包裹 名字辨识度低 但是对于PlayerPrefs不太适用因为位置已经固定了 我们改不了 看不懂 让数据的Key和Value让别人看不懂俗称加密 为Key和Value加密 解不出 不让别人获取到你加密的规则就解不出来了 注意 单机游戏加密只是提高别人修改你数据的门槛只要别人获取到你的源代码 知道你的加密规则 一切都没有任何意义 但是对于一般玩家来说几乎是不可能的事情 eg: 存的时候按照一定规则来存储 123456789if (fieldType == typeof(int))&#123; Log(&quot;存储int:&quot; + keyName + &quot;值 = &quot; + (int)value); //为int数据加密 int rValue = (int)value; rValue += 10; PlayerPrefs.SetInt(keyName, rValue);&#125; 读取的时候按一定规则来读 123456if( fieldType == typeof(int) )&#123; Log(&quot;读取int:&quot; + keyName + &quot;值 = &quot; + (PlayerPrefs.GetInt(keyName, 0) - 10)); //解密 减10 return PlayerPrefs.GetInt(keyName, 0) - 10;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.反射读取自定义类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/11.反射读取自定义类型","date":"2025-02-24T02:56:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/11.反射读取自定义类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/11.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return Load(fieldType, key); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"10.反射读取Dictionary数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/10.反射读取Dictionary数据类型","date":"2025-02-24T02:52:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/10.反射读取Dictionary数据类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/10.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96Dictionary%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"9.反射读取List数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/9.反射读取List数据类型","date":"2025-02-24T02:45:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/9.反射读取List数据类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/9.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"8.反射读取常用成员数据","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/8.反射读取常用成员数据","date":"2025-02-24T02:40:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/8.反射读取常用成员数据/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/8.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1234567891011121314public object Load(Type type, string key) &#123; object v = Activator.CreateInstance(type); FieldInfo[] fieldInfos = type.GetFields(); string loadKey = null; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; FieldInfo tmp = fieldInfos[i]; loadKey = $&quot;&#123;key&#125;_&#123;type.Name&#125;_&#123;tmp.FieldType.Name&#125;_&#123;tmp.Name&#125;&quot;; // 给v对象的字段赋值 tmp.SetValue(v, LoadValue(tmp.FieldType, loadKey)); &#125; return v; &#125; 1234567891011121314151617181920212223242526// 得单个数据private object LoadValue(Type fieldType, string key)&#123; //object v = Activator.CreateInstance(fieldType); // 根据字段类型调用不同API if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, null); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key) == 1; &#125; else &#123; return null; &#125;&#125; 12// 测试代码Player p = PlayerPrefsDataMgr.Instance.Load(typeof(Player), &quot;player&quot;) as Player;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"7.反射存储自定义类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/7.反射存储自定义类型","date":"2025-02-22T02:58:33.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/7.反射存储自定义类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/7.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"SaveData本来就是存储自定义类 12345else&#123; // 如果value的类型是自定义类型 Save(value, key);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); Debug.Log(key + &quot;_key_&quot; + index.ToString()); Debug.Log(key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; else &#123; // 如果value的类型是自定义类型 Save(value, key); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"6.反射存储Dictionary数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/6.反射存储Dictionary数据类型","date":"2025-02-22T02:46:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/6.反射存储Dictionary数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/6.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8Dictionary%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"类似反射存储List数据类型 123456789101112else if (typeof(IDictionary).IsAssignableFrom(value.GetType()))&#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"5.反射存储List数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/5.反射存储List数据类型","date":"2025-02-22T02:38:46.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/5.反射存储List数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/5.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"普通数据存储画风 1234if (value is int)&#123; PlayerPrefs.SetInt(key, (int)value);&#125; List数据存储画风 12345678910if (typeof(IList).IsAssignableFrom(value.GetType()))&#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"4.反射存储常用数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/4.反射存储常用数据类型","date":"2025-02-22T02:23:22.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/4.反射存储常用数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;keyName_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; Debug.Log(keyN ame); &#125; &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"3.数据管理类的创建","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/3.数据管理类的创建","date":"2025-02-22T01:48:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/3.数据管理类的创建/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"123456789101112131415161718192021public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.需求分析","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/2.需求分析","date":"2025-02-22T01:05:48.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/2.需求分析/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.反射知识补充","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/1.反射知识补充","date":"2025-02-22T00:43:30.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/1.反射知识补充/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%8F%8D%E5%B0%84%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"","text":"反射知识回顾 反射3剑客—— 1T 两 A Type —— 用于获取类的所有信息，包括字段、属性、方法等等 Assembly —— 用于获取程序集，通过程序集获取Type Activator —— 用于快速实例化对象 csharp反射 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom 12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments 12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"csharp反射","slug":"编程语言/Csharp/csharp反射","date":"2025-02-21T12:55:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/编程语言/Csharp/csharp反射/","permalink":"http://example.com/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Csharp源代码到运行时主要阶段 在 C# 中，从源代码到运行时的整个过程可以分为以下主要阶段： 1源代码(.cs) → 编译 → IL/程序集(.exe/.dll) → CLR加载 → JIT编译 → 本机代码 → 执行 源代码阶段： 编写源代码： 开发者编写 C# 源代码文件（.cs）。 编译阶段： 编译： 使用 C# 编译器（csc.exe）将源代码编译为中间语言（IL，Intermediate Language）代码。生成的文件通常是一个扩展名为 .exe（可执行文件）或 .dll（动态链接库）的程序集。 生成[[元数据]]： 编译过程中，生成包含程序集信息的[[元数据]]，包括类型、成员、版本等信息。 JIT 编译阶段： JIT 编译： 在运行时，Common Language Runtime（CLR）的 JIT 编译器负责将 IL 代码编译为本地机器代码。这一步是在程序加载到内存时进行的，即时（Just-In-Time）编译。 执行阶段： 加载程序集： CLR 加载编译好的程序集，包括 IL 代码和[[元数据]]。 执行程序： 程序在 CLR 中执行，JIT 编译器将 IL 代码转换为本地机器代码。执行过程中，CLR 负责内存管理、类型检查、垃圾回收等任务。 总结： 开发者阶段： 编写源代码。 编译阶段： 编译源代码生成 IL 代码和[[元数据]]。 JIT 编译阶段： 在运行时将 IL 代码编译为本地机器代码。 执行阶段： 加载程序集，执行程序，CLR 负责管理运行时环境。 编译 vs 运行 编译期 运行时 发生时间 发生在构建过程中，源代码被翻译为目标代码或中间代码。 发生在程序实际运行时，加载到内存并执行。 可能出现的错误 静态检查错误，如语法错误、类型错误等。 动态运行时错误，如空指针引用、除零错误等。 排查难度 错误信息清晰，易于定位和修复。 错误可能更难以排查，需要使用调试工具进行追踪。 无运行时 有运行时 内存管理 程序员需要手动管理内存分配和释放。 运行时环境负责内存管理，可能包括自动内存分配和垃圾回收。 线程模型 通常依赖操作系统提供的线程机制。 可能提供自己的线程管理机制，与操作系统的线程模型有一定差异。 系统调用 直接使用操作系统提供的系统调用接口。 通过运行时环境提供的接口进行系统调用，可能会屏蔽一些底层细节。 运行效率 对于底层硬件和操作系统有更直接的控制。 需要运行时环境的支持，可能引入一些开销。 动态库 vs. 静态库 - 编译和链接阶段： 阶段 静态库 动态库 定义 静态库是在编译时被链接到程序的库，代码在程序编译阶段就被静态地合并。 态库是在运行时加载到内存的库，它的代码在程序执行时被动态地链接。 文件格式 .lib（Windows）或 .a（Unix/Linux） .dll（Windows）或 .so（Unix/Linux） 编译和链接阶段 静态库的代码在编译时被整合到程序中 编译时不包含库的代码，只在链接时引用库的符号 作用 提供独立的代码副本，每个程序有自己的库的实例，适用于没有外部库的环境 节省内存，允许在运行时替换库的版本，减小程序的可执行文件大小 动态库 vs. 静态库 - 区别和使用场景： 特点 静态库 动态库 链接方式 链接在编译时 链接在运行时 内存占用 每个程序有自己的库的实例，可能占用更多内存 共享内存，多个程序可以共享同一个动态库的实例 更新和维护 需要重新编译整个程序，更新较为繁琐 可在运行时替换库的版本，更容易更新 可执行文件大小 可执行文件较大，因为库的代码在编译时合并到可执行文件中 可执行文件较小，因为库的代码在运行时加载 反射 程序正在运行时，可以查看其它[[程序集]]或者自身的[[元数据]]。 一个运行的程序查看本身或者其它程序的[[元数据]]的行为就叫做反射 在程序运行时，通过反射可以得到其它[[程序集]]或者自己[[程序集]]代码的各种信息 类，函数，变量，对象等等，实例化它们，执行它们，操作它们 exe/dll(主要区别是exe有入口) metadata: 描述dll/exe文件的一个 数据清单 反射: 用来操作获取[[元数据]] 就是一个操作metadata的一个类库, 用来操作[[元数据]]中的**类, 方法, 属性, [[csharp特性]], ** 为什么通过反射去间接操作? 我们需要动态 (这些 “动态” 操作都是在运行时期根据运行时的信息来进行的，而不是在编译时期就确定好的。这使得程序更加灵活，能够处理一些在编译时难以确定的情况。) 读取私有的对象 Type（类的信息类） 它是反射功能的基础！ 它是访问[[元数据]]的主要方式。 使用 Type 的成员获取有关类型声明的信息 有关类型的成员（如构造函数、方法、字段、属性和类的[[事件]]） 1234567int a = 32;Type t1 = a.GetType();Type t2 = typeof(int);// 必须要包含命名空间.类名Type t3 = Type.GetType(&quot;System.Int32&quot;);// 每一个类只有一份元数据, 所以上面的t1, t2, t3 指向的是同一个堆空间 获取所有公共成员 （GetMembers 成员包括：成员变量，成员函数等等 1234567891011121314151617181920212223class Test&#123; private int i = 0; public int j = 1; public string str = &quot;hello world&quot;; public Test() &#123; &#125; public Test(int i) &#123; this.i = i; &#125; public Test(int i, string s) : this(i) &#123; this.str = s; &#125; public void Fun() &#123; Console.WriteLine(str); &#125;&#125;Type t = typeof(Test);MemberInfo[] memberInfos = t.GetMembers();for (int i = 0; i &lt; memberInfos.Length; i++) Console.WriteLine(memberInfos[i]); 获取类所有的公共构造函数并调用 （GetConstructors 1234567891011121314151617// 所有公共构造函数ConstructorInfo[] ctors = t.GetConstructors();// 得构造函数传入 Type数组 数组中内容按顺序是参数类型// 执行构造函数传入 object数组 表示按顺序传入的参数// 无参构造获取Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[0]);Test test = constructorInfo.Invoke(null) as Test;// 有参构造获取 获取一个参数为int的构造函数Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[1] &#123; typeof(int) &#125;);Test test = constructorInfo.Invoke(new object[1] &#123; 666 &#125;) as Test; 获取类所有公共成员变量 （GetFields FieldInfo 类是 .NET 反射中的一个类，用于表示和操作类或结构体的字段信息。字段是类或结构体中的成员变量，通常用于存储对象的状态。FieldInfo 类提供了访问字段的[[元数据]]和运行时值的方法。 以下是一些 FieldInfo 类的常用属性和方法： 属性： Name: 获取字段的名称。 FieldType: 获取字段的类型。 IsPublic, IsPrivate, IsStatic, IsInitOnly: 判断字段的访问修饰符和其他属性。 DeclaringType: 获取定义该字段的类的 Type 对象。 方法： GetValue(object obj): 获取指定对象上的字段值。需要传递目标对象的实例作为参数。 SetValue(object obj, object value): 设置指定对象上的字段值。需要传递目标对象的实例和要设置的值作为参数。 以下是一个简单的示例，演示如何使用 FieldInfo 获取和操作字段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 得到所有公共成员变量Type t = typeof(Test);FieldInfo[] fieldInfos = t.GetFields();// 得到指定名称的公共成员Type t = typeof(Test);FieldInfo fieldInfo = t.GetField(&quot;str&quot;);// 通过反射 获取其它程序集的对象的某个成员变量的值// 假设下面的Test是其他程序集new出来的, Test.str = &quot;wocao&quot;Test test = new Test(999, &quot;wocao&quot;);Console.WriteLine(fieldInfo.GetValue(test)); // 获取到test.str // 通过反射 设置其它程序集的对象的某个成员变量的值 第一个参数是想要通过反射操作的对象!fieldInfo.SetValue(test, &quot;hello world&quot;);Console.WriteLine(fieldInfo.GetValue(test));using System;using System.Reflection;public class MyClass&#123; public int PublicField; private string PrivateField; public MyClass(int value) &#123; PublicField = value; PrivateField = &quot;PrivateFieldValue&quot;; &#125;&#125;class Program&#123; static void Main() &#123; Type myClassType = typeof(MyClass); // 获取字段信息 FieldInfo publicFieldInfo = myClassType.GetField(&quot;PublicField&quot;); FieldInfo privateFieldInfo = myClassType.GetField(&quot;PrivateField&quot;, BindingFlags.NonPublic | BindingFlags.Instance); // 创建 MyClass 实例 MyClass myObject = new MyClass(42); // 读取和修改字段的值 int publicFieldValue = (int)publicFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PublicField value: &#123;publicFieldValue&#125;&quot;); privateFieldInfo.SetValue(myObject, &quot;NewPrivateFieldValue&quot;); string privateFieldValue = (string)privateFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PrivateField value: &#123;privateFieldValue&#125;&quot;); &#125;&#125; 获取了所有公共成员函数 （GetMethods 1234567891011121314151617181920212223242526272829303132333435363738394041// 获取所有公共成员函数并执行Type t = typeof(string);MethodInfo[] methodInfos = t.GetMethods();for (int i = 0; i &lt; methodInfos.Length; i++) Console.WriteLine(methodInfos[i]);// 获取特定名称的公共成员函数MethodInfo methodInfo = t.GetMethod(&quot;Substring&quot;, new Type[] &#123; typeof(int), typeof(int) &#125;);// 执行该方法string str = &quot;hello world&quot;;// 第一个参数是想要通过反射操作的对象 相当于 对象.XX 如果是静态就传 null str = methodInfo.Invoke(str, new object[] &#123; 0, 5 &#125;) as string;Console.WriteLine(str);Type myClassType = typeof(MyClass);// 获取所有公共方法MethodInfo[] publicMethods = myClassType.GetMethods();// 输出方法信息foreach (MethodInfo methodInfo in publicMethods)&#123; Console.WriteLine($&quot;Method Name: &#123;methodInfo.Name&#125;&quot;); Console.WriteLine($&quot;Return Type: &#123;methodInfo.ReturnType&#125;&quot;); // 获取方法的参数信息 ParameterInfo[] parameters = methodInfo.GetParameters(); Console.Write(&quot;Parameters: &quot;); foreach (ParameterInfo parameter in parameters) &#123; Console.Write($&quot;&#123;parameter.ParameterType&#125; &#123;parameter.Name&#125; &quot;); &#125; Console.WriteLine(); Console.WriteLine();&#125; 其它 type.GetXXX 1234567891011121314151617//得枚举GetEnumNameGetEnumNames//得事件GetEventGetEvents//得接口GetInterfaceGetInterfaces//得属性GetPropertyGetPropertys//等等 快速通过反射实例化对象 Activator 使用 Activator 类的主要优势在于在运行时创建对象，尤其是当不知道具体类型的情况下。然而，需要注意的是，使用 Activator 可能会导致性能损失，因为它依赖于反射机制。在已知类型的情况下，直接使用 new 操作符通常是更好的选择。 12345// 快速将Type实例化为对象 无参构造Type t = typeof(Test);Test test = Activator.CreateInstance(t) as Test;// 有参构造 后面参数如果不对会报错test = Activator.CreateInstance(t, 666, &quot;wocao&quot;) as Test; Assembly [[程序集]]类Assembly: 主要用来加载其它[[程序集]]，加载后 才能用Type来使用其它[[程序集]]中的信息 如果想要使用不是自己[[程序集]]中的内容 需要先加载[[程序集]] 比如 dll文件(库文件) 简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类 三种加载[[程序集]]的函数: 一般用来加载在同一文件下的其它[[程序集]] Assembly asembly2 = Assembly.Load(“[[程序集]]名称”); 一般用来加载不在同一文件下的其它[[程序集]] Assembly asembly = Assembly.LoadFrom(“包含[[程序集]]清单的文件的名称或路径”); Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”); 12345Assembly assembly = Assembly.LoadFrom(@&quot;D:\\\\Myproject VS\\\\静态\\\\bin\\\\Debug\\\\net8.0\\\\test.dll&quot;);Type[] types = assembly.GetTypes();Type t = assembly.GetType(&quot;test.Icon&quot;);t.XXX 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom 12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments 12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"4.PlayerPrefs总结","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结","date":"2025-02-21T12:27:02.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/","excerpt":"","text":"练习 要在游戏中做一个排行榜功能，排行榜主要记录玩家名（可重复）,玩家得分，玩家通关时间，请用PlayerPrefs存储读取排行榜相关信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/// &lt;summary&gt;/// 排行榜多条具体信息/// &lt;/summary&gt;public class RankListInfo&#123; //排行榜单条信息列表 public List&lt;RankInfo&gt; rankList; //初始化的时候就是读取数据 public RankListInfo() &#123; Load(); &#125; /// &lt;summary&gt; /// 新加排行榜信息 /// &lt;/summary&gt; public void Add(string name, int score, int time) &#123; rankList.Add(new RankInfo(name, score, time)); &#125; //存储数据 public void Save() &#123; //存储有多少条数据 PlayerPrefs.SetInt(&quot;rankListCount&quot;, rankList.Count); for (int i = 0; i &lt; rankList.Count; i++) &#123; RankInfo info = rankList[i]; PlayerPrefs.SetString(&quot;rankInfo&quot; + i, info.playerName); PlayerPrefs.SetInt(&quot;rankScore&quot; + i, info.playerScore); PlayerPrefs.SetInt(&quot;rankTime&quot; + i, info.playerTime); &#125; &#125; //读取数据 private void Load() &#123; int rankListCount = PlayerPrefs.GetInt(&quot;rankListCount&quot;, 0); rankList = new List&lt;RankInfo&gt;(); for (int i = 0; i &lt; rankListCount; i++) &#123; RankInfo info = new RankInfo( PlayerPrefs.GetString(&quot;rankInfo&quot; + i), PlayerPrefs.GetInt(&quot;rankScore&quot; + i), PlayerPrefs.GetInt(&quot;rankTime&quot; + i)); rankList.Add(info); &#125; &#125;&#125;/// &lt;summary&gt;/// 排行榜单条信息/// &lt;/summary&gt;public class RankInfo&#123; public string playerName; public int playerScore; public int playerTime; public RankInfo(string name, int score, int time) &#123; playerName = name; playerScore = score; playerTime = time; &#125;&#125;#endregionpublic class Lesson03_练习题 : MonoBehaviour&#123; void Start() &#123; //初始化一个排行榜 RankListInfo rankListInfo = new RankListInfo(); print(rankListInfo.rankList.Count); //打印排行榜所有信息 for (int i = 0; i &lt; rankListInfo.rankList.Count; i++) &#123; print(&quot;姓名&quot; + rankListInfo.rankList[i].playerName); print(&quot;分数&quot; + rankListInfo.rankList[i].playerScore); print(&quot;时间&quot; + rankListInfo.rankList[i].playerTime); &#125; //添加排行榜单条信息保存 rankListInfo.Add(&quot;nihao&quot;, 100, 66); rankListInfo.Save(); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.PlayerPrefs不同平台的存储位置","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置","date":"2025-02-21T12:09:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.PlayerPrefs%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"PlayerPrefs存储的数据存在哪里？ 在不同平台上，PlayerPrefs存储的位置会有所不同： PlayerPrefs的存储位置 Windows： PlayerPrefs 存储在注册表（regedit）中。具体位置为： 32位系统：HKEY_CURRENT_USER\\Software\\[公司名]\\[产品名] 64位系统：HKEY_CURRENT_USER\\Software\\WOW6432Node\\[公司名]\\[产品名] Android： 在Android上，PlayerPrefs 存储在应用的持久数据目录中。具体路径为：/data/data/[包名]/shared_prefs/unity.[公司名].[产品名]_prefs.xml。 Linux： 在Linux上，PlayerPrefs 存储在用户主目录的 .config/unity3d/[公司名]/[产品名]/prefs 目录中。 iOS： 在iOS上，PlayerPrefs 存储在应用的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。 macOS： 在macOS上，PlayerPrefs 存储在用户主目录的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.PlayerPrefs基本方法","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法","date":"2025-02-21T11:49:40.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.PlayerPrefs%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/","excerpt":"","text":"PlayerPrefs是什么 PlayerPrefs是Unity提供的可以用于存储读取玩家数据的公共类。 PlayerPrefs，你可以轻松地存储和获取一些简单的数据，例如玩家的分数、游戏设置、解锁的关卡等。这些数据将在应用程序关闭后仍然保留，可以在下次启动应用程序时继续使用。 PlayerPrefs的数据存储 PlayerPrefs的数据存储类似于键值对存储，一个键对应一个值。 提供了存储3种数据的方法 int float string。 键: string类型。 值：int float string 对应3种API。 SetInt方法 SetFloat方法 SetString方法 存储数据 1234//设置由 key 标识的偏好的值。PlayerPrefs.SetInt(&quot;第几帅&quot;, 1);PlayerPrefs.SetFloat(&quot;存个浮点数&quot;, 1.1f);PlayerPrefs.SetString(&quot;黄&quot;, &quot;先生&quot;); Save方法 马上存储数据到硬盘中 直接调用Set相关方法只会把数据存到内存里。 当游戏结束时 Unity会自动把数据存到硬盘中。 如果游戏不是正常结束的而是崩溃 数据是不会存到硬盘中的。 调用该方法马上存到硬盘(各个平台默认位置) 1PlayerPrefs.Save(); PlayerPrefs局限性 1234//PlayerPrefs是有局限性的 它只能存3种类型的数据。//如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储。bool sex = true;PlayerPrefs.SetInt(&quot;sex&quot;, sex ? 1 : 0); 如果不同类型用同一键名进行存储 会进行覆盖 12PlayerPrefs.SetInt(&quot;myAge&quot;, 18);PlayerPrefs.SetFloat(&quot;myAge&quot;, 20.2f);//覆盖上一行存储的myAge数据 读取相关 12// 如果填了第二个参数代表没找到就返回后的默认值, 可用来进行基础数据的初始化string test = PlayerPrefs.GetString(&quot;黄&quot;); 注意： 运行时只要你Set了对应键值对 即使你没有马上存储Save在本地 也能够读取出信息 如果存的是SetInt(&quot;myAge&quot;， 18); 读取的是GetFloat(&quot;myAge&quot;);则会使用Float默认值0 键的存在与删除 12345678if (PlayerPrefs.HasKey(&quot;测试&quot;))&#123; // 删除 // 根据键来删除 PlayerPrefs.DeleteKey(&quot;测试&quot;); // 删除所有键值对 PlayerPrefs.DeleteAll();&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.PlayerPrefs概述","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述","date":"2025-02-21T11:42:51.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"34.unity入门基础知识总结","slug":"游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结","date":"2025-02-21T08:54:06.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"33.Microphone麦克风","slug":"游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风","date":"2025-02-21T08:21:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.Microphone%E9%BA%A6%E5%85%8B%E9%A3%8E/","excerpt":"","text":"Unity提供了Microphone类 获取设备信息 1234// 获取设备Microphone信息string[] strs = Microphone.devices;for (int i = 0; i &lt; strs.Length; i++) print(strs[i]); 开始, 结束录制并存储 12345678910111213141516171819202122232425// 开始录制 (1. 设备名 传null使用默认设备, 2. 超过录制长度是否重新录制// (3. 录制时长, 4. 采样率if (Input.GetKeyDown(KeyCode.Space))&#123; _audioClip = Microphone.Start(null, false, 10, 44100);&#125;// 结束录制if (Input.GetKeyUp(KeyCode.Space))&#123; // 为null表示默认设备 Microphone.End(null); // 播放录制音频 AudioSource audio = GetComponent&lt;AudioSource&gt;() ?? gameObject.AddComponent&lt;AudioSource&gt;(); audio.clip = _audioClip; audio.Play(); //AudioClip类的channels变量和samples变量 //channels变量 音频剪辑中的声道数。（只读） //samples变量 样本中音频剪辑的长度。（只读） //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[_audioClip.channels * _audioClip.samples]; // 把数据存储到浮点数数组里 第二个参数是偏离的位置, 默认填0 _audioClip.GetData(f, 0);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"32.AudioSource音频源代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制","date":"2025-02-21T07:58:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"代码控制播放停止 12345678910111213141516171819202122232425_audioSource = GetComponent&lt;AudioSource&gt;();// 按下p键播放if (Input.GetKeyDown(KeyCode.P))&#123; _audioSource.Play(); //_audioSource.PlayDelayed(4); // 4秒后播放&#125;// 音频停止if (Input.GetKeyDown(KeyCode.S))&#123; _audioSource.Stop();&#125;// 音频暂停 if (Input.GetKeyDown(KeyCode.Space))&#123; _audioSource.Pause(); //_audioSource.UnPause();再次播放可恢复 (或者使用停止暂停&#125;// 音量大小audioSource.volume = floatValue;// 是否静音audioSource.mute = true 检测播放是否完毕 AudioSource没有提供相关 12345// 检测音频是否播放完 if (!_audioSource.isPlaying)&#123; print($&quot;在Update中不断检测该属性可以判断是否播放完毕&quot;);&#125; 控制音频播放几种方式 直接在要播放音频的对象上挂载脚本来控制 自己创建一个挂载了音频脚本的GameObject(放在prefab预设体里) 用得少 在其他脚本中实例化(如果playOnAwake实例化时播放) 这个对象 用一个AudioSource来控制不同的音效 _audioSource.clip = XXX（AudioClip) ps: 注意: 一个GameObject可以挂载多个音频源脚本AudioSource, 但一定要自己管理好, 不然谁是谁都不知道","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"31.AudioSource音频源组件和AudioListener音频监听组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件","date":"2025-02-21T07:31:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/","excerpt":"","text":"添加AudioSource 音频源脚本 AudioClip 声音剪辑文件（音频文件） 可以拖拽音频文件到这个变量上 Output 输出* 默认不设置的话将直接输出到场景中的音频监听器 可以更改为输出到混音器 混音器是高级功能，以后再讲解 Mute 静音开关 Bypass Effect 开关滤波器效果* Bypass Listener Effects 快速开关所有监听器* Bypass Reverb Zones 快速开关所有混响区* Play On Awake 唤醒时播放 对象创建时就播放音乐 开启的话启动游戏默认就播放 关闭的话启动游戏默认就不播放 Loop 循环 循环播放音乐，一般背景音乐才用 Priority 优先级 优先级越高，越不容易被别的音效覆盖 Volume 音量大小 Pitch 音调 可以理解为音乐快放满房 Stereo Pan 立体声效 2D声音立体声位置 相当于左右声道 Spatial Blend 空间混合 音频受3D空间的影响程度，默认是2D音效，拖满为1变成3D音效 Reverb Zone Mix 混响区混音* 到混响区的输出信号量 3D Sound Settings 3D声音设置 和Spatial Blend参数成正比应用 Doppler Level 多普勒效果等级 Spread 扩张 扩散角度设置为3D立体声还是多声道 Volume Rolloff 音量衰减 声音衰减速度，蓝线横轴可以理解为离耳朵的远近，红线纵轴可以理解为声音大小，耳朵可以理解为AudioListener音频监听脚本 Logarithmic Rolloff 对数衰减 靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff 线性衰减 与音频源的距离越远，听到的声音越小。 Custom Rolloff 自定义衰减 音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance 最大最小距离 最小距离内，声音保持最大响度 最大距离外，声音开始减弱 AudioListener 音频监听脚本 默认挂载到场景的主摄像机上，可以理解为是我们的耳朵 有且只有一个，两个把另外一个要移除","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"30.音频文件导入","slug":"游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入","date":"2025-02-20T15:03:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/","excerpt":"","text":"音频文件常用格式 wav mp3 ogg aiff （不常用） 导入音频文件 导入音频文件直接从外部拖拽音频文件到Project窗口即可 Force To Mono 强制变为单声道 多声道转单声道 Normalize 归一化 强制为单声道时，混合过程中被标准化 Load In Background 后台加载 在后台加载，不阻塞主线程 Ambisonic 全景声音* 立体混响声 非常适合 360 度视频和 XR 应用程序 如果音频文件包含立体混响声编码的音频，请启用此选项 LoadType 加载类型 Decompress On Load 加载时压缩 不压缩形式存在内存，加载块，但是内存占用高 适用于小音效 Compress in memory 压缩内存 压缩形式存在内存，加载慢，内存小 仅适用于较大音效文件 Streaming 流式处理 以流形式存在，使用时解码。内存占用最小，cpu消耗高 性能换内存 Preload Audio Data 预加载音频数据 预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format 压缩格式 PCM 音频以最高质量存储 Vorbis 相对PCM压缩的更小，根据质量决定 ADPCM 包含噪音，会被多次播放的声音，如碰撞声 Quality 音频质量* 确定要应用于压缩剪辑的压缩量。 不适用于 PCM/ADPCM/HEVAG 格式 Sample Rate Setting 采样率设置* PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率 Preserve Sample Rate 保持采样率 此设置可保持采样率不变（默认值） Optimize Sample Rate 优化采样率 此设置根据分析的最高频率内容自动优化采样率 Override Sample Rate 覆盖采样率 此设置允许手动覆盖采样率 因此可有效地将其用于丢弃频率内容。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"29.刚体加力","slug":"游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力","date":"2025-02-20T12:09:49.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/","excerpt":"","text":"刚体加力 12345678910111213141516171819202122// 获取刚体组件对象rigidbody = this.GetComponent&lt;Rigidbody&gt;();// 添加力// (相对世界坐标系rigidbody.AddForce(Vector3.forward * 10);// (相对本地坐标系rigidbody.AddRelativeForce(Vector3.forward * 10);// 添加扭矩力// (世界坐标系 // 没有扭矩阻力会一直动rigidbody.AddTorque(Vector3.up * 10);// (本地坐标系rigidbody.AddRelativeTorque(Vector3.forward * 10);// 改变刚体速度 用的少, 位移一般用translate或者给力// 世界坐标系rigidbody.velocity = Vector3.forward;// 模拟爆炸 在中心产生半径 20m 40的力// 如果想要所有刚体都产生同样的爆炸效果就必须所有的刚体组件都要调用AddExplosionForce方法rigidbody.AddExplosionForce(40, Vector3.zero, 20); AddForce方法第二个参数力的模式 1. ForceMode.Force（默认模式） 公式：F * t = m * v 说明： 力会持续作用，受物体质量（mass）影响，质量越大加速度越小。 需要乘以 Time.fixedDeltaTime 才能与物理时间步长匹配（Unity 已自动处理）。 示例： 123// 推动质量为2kg的物体，每帧施加10N的力rb.AddForce(Vector3.forward * 10, ForceMode.Force);// 最终加速度 = 10N / 2kg = 5m/s² 2. ForceMode.Acceleration 公式：F * t = v （m 为 1） 说明： 直接施加加速度，忽略物体质量。 适合需要固定加速度的场景（如模拟重力）。 示例： 12// 无论质量如何，物体以5m/s²的加速度运动rb.AddForce(Vector3.forward * 5, ForceMode.Acceleration); 3. ForceMode.Impulse 公式：F = m * v （t 为 1） 说明： 瞬间施加一个冲量，效果类似“一次性爆发力”。 受质量影响，质量越大效果越弱。 123// 施加一个冲量为100N·s的力（相当于100N的力作用1秒）rb.AddForce(Vector3.up * 100, ForceMode.Impulse);// 质量为2kg时，速度增量 = 100 / 2 = 50m/s 4. ForceMode.VelocityChange 公式：F = v （m 为 1， t 为 1） 说明： 直接修改速度，忽略质量和时间步长。 效果类似“瞬间设置速度”。 示例： 12// 直接将物体的Y轴速度增加10m/s（无视质量）rb.AddForce(Vector3.up * 10, ForceMode.VelocityChange); 恒力场组件 刚体的休眠 Unity为了节约性能，可能会让刚体休眠。 比如让一个有刚体的Cube，受重力影响掉落一个平面上。 当他们静止时，斜向下旋转刚体，这个时候Cube可能不会往下落，因为Cube休眠了。 假如这个时候移动一下平面的位置，Cube可能又会往下落，因为移动平面唤醒了刚体。 12345678910// IsSleeping方法 获取刚体是否处于休眠状态if (rigidBody.IsSleeping())&#123;&#125;// 唤醒休眠if (rigidBody.IsSleeping())&#123; rigidBody.WakeUp();&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"28.碰撞检测之碰撞检测函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数","date":"2025-02-20T11:22:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/","excerpt":"","text":"注意:碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用 ps： 只要挂载的对象能和其它物体产生碰撞检测才会响应下面的函数 如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的，必须挂载到这个刚体父对象上才行。 物理碰撞检测响应函数 12345678910111213141516171819202122232425262728293031private void OnCollisionEnter(Collision collision)&#123; // Collision类 (碰撞信息类 // 碰撞到的对象碰撞器的信息 Collider collider1 = collision.collider; // 碰撞到的对象的所依附的对象 (GameObject) GameObject gameObject1 = collision.gameObject; // 碰撞到的对象的transform组件信息 Transform transform1 = collision.transform; // 触碰点数相关 接触点具体坐标 ContactPoint[] contacts = collision.contacts; print($&quot;我被&#123;collision.gameObject.name&#125;碰撞到了&quot;);&#125;// 碰撞结束分离时, 自动执行private void OnCollisionExit(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;碰撞分离了&quot;);&#125;// 两个物体相互摩擦时会不停调用该函数private void OnCollisionStay(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;一直在产生摩擦&quot;);&#125; 触发器检测响应函数 1234567891011121314151617// 触发开始时会自动调用该函数 (传入的是Collider脚本对象)private void OnTriggerEnter(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;触发了&quot;);&#125;// 当Stay结束时调用private void OnTriggerExit(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;结束触发了&quot;);&#125;// 当两触发器相交会不停调用private void OnTriggerStay(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;水乳相融&quot;);&#125; 碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑 一般会把想要重写的碰撞和触发检测函数写成protected保护类型的，加上virtual变成虚函数。 没有必要写成public，因为不会自己手动调用碰撞和触发检测函数，都是Unity通过反射帮助我们自动调用的。 小练习 在之前Input和Screen中的练习题基础上，加入一个点击鼠标左键可以发射一颗子弹飞出的功能 给坦克添加一个炮口空物体当做子弹飞出来的位置 添加点击飞出子弹代码，创建子弹预设体，拖拽赋值炮口空物体和子弹预设体 12345678910//Update内 if (Input.GetMouseButtonDown(0)) &#123; //实例化一个子弹对象 GameObject obj = Instantiate(bulletObj); //设置对象的位置 obj.transform.position = bulletPos.position; //设置对象的角度 obj.transform.eulerAngles = bulletPos.eulerAngles; &#125; 子弹一直飞 12//Update内 //子弹一直往前飞 this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); 加入子弹触碰到地面会自动消失的功能 123456789101112131415private void OnTriggerEnter(Collider other)&#123; //问题一：如果发射子弹时 和坦克自身的碰撞和重合了 可能一开始 就会被移除 //解决方案：判断自己碰撞到的对象 是什么 一定是特定对象 才移除自己 if (other.gameObject.CompareTag(&quot;Ground&quot;) || other.gameObject.CompareTag(&quot;Monster&quot;)) &#123; //碰撞到别的东西 就让子弹小时 //一定是移除自己依附的GameObject对象 而不是脚本自己 Destroy(this.gameObject); &#125; //问题二：坦克本身就带有碰撞盒 当子弹和坦克自身的碰撞盒碰撞可能会产生力的作用 出现一些意想不到的效果 //解决方案：把子弹做成触发器 这样就没有了力的作用&#125; 123456789101112131415public int HP = 3;//当子弹碰到我时 就减血 血量为0了 就移除private void OnTriggerEnter(Collider other)&#123; //由于场景上 只有子弹时触发器 所以我们可以不用进行任何判断 就可以完成这个功能 //减血 HP -= 1; //为0就移除自己 if (HP &lt;= 0) &#123; Destroy(this.gameObject); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"27.碰撞检测之物理材质","slug":"游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质","date":"2025-02-20T11:15:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/","excerpt":"","text":"创建物理材质 在Project窗口加号创建或者右键创建 把物理材质拖拽到两个碰撞器上才能相互作用 物理材质参数 Dynamic Friction 动摩擦力 已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。 Static Friction 静摩擦力 当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness 弹性 表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine 摩擦力组合 两个碰撞对象的摩擦力的组合方式。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。 Bounce Combine 反弹组合 两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"26.碰撞检测之碰撞器","slug":"游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器","date":"2025-02-20T10:39:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/","excerpt":"","text":"知识回顾 两个物体都有碰撞器，至少一个物体有刚体 碰撞器表示物体的体积（形状） 刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用 3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 共同参数 Edit Collider 编辑碰撞器 改变碰撞体大小 Is Trigger 是否是触发器 如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略 主要用于进行没有物理效果的碰撞检测 Material 物理材质* 可以确定碰撞体和其它对象碰撞时的交互（表现）方式。 Center 碰撞器中心 碰撞体在对象局部空间中的中心点位置 常用碰撞器 BoxCollider 盒状碰撞器 Size 大小：碰撞体在X、Y、Z方向上的大小 Sphere Collider 球状碰撞器 Radius 半径：球形碰撞体的半径大小 Capsule Collider 胶囊碰撞器 Radius 半径：胶囊体的半径 Height 高度：胶囊体的高度 Direction 轴向：胶囊体在对象局部空间中的轴向 异形物体使用多种碰撞器组合 刚体对象的子对象碰撞器信息参与碰撞检测 比如金字塔预设体，只在金字塔最高层级对象添加刚体，子对象的所有Cube都会参与碰撞检测 再比如一个Cube添加刚体，再给他添加两个空物体，两个空物体分别添加斜着的盒型碰撞器当做支架，这样这个Cube下落时就会被支架撑起来，即便两个空物体连模型都没有只有碰撞器 不常用碰撞器* Mesh Collider 网格碰撞器* 不常用的原因是性能消耗较高 默认不会显示绿色的碰撞器边框，开启Convex 才会显示绿色的碰撞器边框 Convex Mesh Collider 最多 255 个三角形。 Wheel Collider 轮胎碰撞器* 可以通过给车的父对象加刚体（注意刚体质量一定要大），子对象加车轮碰撞器模拟汽车 Terrain Collider 地形碰撞器* 不常用的原因是性能消耗很高","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"25.碰撞检测之刚体","slug":"游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体","date":"2025-02-20T09:28:06.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/","excerpt":"","text":"碰撞产生的必要条件：两个物体都有碰撞器，至少一个物体有刚体 RigidBody组件信息如下 Mass 质量 默认为千克 质量越大惯性越大 Drag 空气阻力 根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力 Angular Drag 角阻力（扭矩阻力） 通俗理解就是阻碍对象旋转的阻力，角阻力越大越不容易旋转 0 表示没有空气阻力。 Use Gravity 重力开关 是否受重力影响 Is Kinematic 控制物理是否影响刚体。 可以理解为开启后不受力的影响，只能通过Transform移动 如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用。 Interpolate 插值运算 让刚体物体移动更平滑 可以更改FixTime，改成一秒，这样对象会很突兀的一秒移动一次，这时开启插值运算就可以让刚体对象平滑移动 None 无插值运算模式 不应用插值运算 Interpolate 插值模式 插值将始终滞后一点，但比外推更流畅。 根据前一帧的变换来平滑变换。 Extrapolate 外推模式 外推将根据当前速度预测刚体的位置。 根据下一帧的估计变换来平滑变换。 Collision Detection 碰撞检测模式 Continuous Dynamic 连续动态检测 &gt; Continuous Speculative 连续推测检测 &gt; Continuous 连续检测 &gt; Discrete 离散检测 用于防止快速移动的对象穿过其它对象而不检测碰撞 Discrete 离散检测 默认的碰撞检测模式。 在每一帧中进行一次碰撞检测，适用于大多数普通物体。 最省性能，但可能会错过高速物体的碰撞。 适合一般速度移动的物体，不适合高速移动的小物体。 对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值） Continuous 连续检测 提高了碰撞检测的精度，特别适合高速移动的物体。 在每一帧中进行多次碰撞检测，避免高速物体穿过其他物体。 比 Discrete 消耗更多的性能，但减少了穿透问题。 适用于高速移动的物体，如子弹或快速飞行的物体。 对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用连续碰撞检测。 设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置） 其他刚体将使用离散碰撞检测。 Continuous Dynamic 连续动态检测 针对快速移动的物体和其他静止或缓慢移动的物体之间的碰撞检测。 结合 Continuous 和 Discrete 的优点，对高速物体进行多次检测，对慢速或静止物体进行一次检测。 在保证精度的同时比 Continuous 更省性能。 适用于快速移动的物体与静止或缓慢移动的物体之间的碰撞检测，如快速移动的角色或车辆。 性能消耗高 对设置为连续 (Continuous)和连续动态 (Continuous Dynamic)碰撞的游戏对象使用连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。 对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。 Continuous Speculative 连续推测检测 使用预测的方式进行碰撞检测。 预测物体的未来位置，并在物体穿过其他物体前进行检测和处理。 性能较高，精度也不错，但有时可能会出现误判。 适合大多数需要高精度且有较高速度的物体。 对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 Constraints 刚体约束 对刚体运动的限制 Freeze Position 冻结位置 有选择地停止刚体沿世界 X、Y 和 Z 轴的移动。 Freeze Rotation 冻结旋转 有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"24.光面板","slug":"游戏引擎/unity/unity入门/unity入门基础知识/24.光面板","date":"2025-02-20T09:07:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/24.光面板/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"Skybox Material 天空盒材质 可以改变天空盒 可以在project窗口右键创建材质，材质选择成天空盒着色器 Sun Source 太阳来源* 不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting 环境光设置* Source 环境光光源颜色* Skybox 天空盒：天空和材质作为环境光颜色 Gradient 渐变：可以为天空、地平线、地面单独选择颜色和他们之间混合 Color颜色 Intensity Multiplier 环境光亮度* Ambient Mode 环境模式* 全局光照模式，只有启用了实时全局和全局烘焙时才有用 Realtime 实时（已弃用） Baked 烘焙 OtherSettings 其它设置* Fog 雾开关* Color 雾颜色 Mode 雾计算模式 Linear 线性模式 随距离线性增加 Start 开始距离 离摄像机多远开始有雾 End 结束距离 离摄像机多远完全遮挡 Exponential 指数模式 随距离指数增加 Density 密度 雾强度 Exponential Qquare 指数平方模式 随距离比指数更快的增加 Density 密度 雾强度 Halo Texture 光晕材质* 光源周围挥着光环的纹理 Halo Strength 光晕强度* 光环可见性 Flare Fade Speed 炫光交叉淡化速度* 耀斑淡出时间，最初出现之后淡出的时间 Flare Strength 炫光强度* 耀斑可见性 Spot Cookie 聚光灯剪影* 聚光灯剪影纹理","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"23.Light光源组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件","date":"2025-02-20T08:10:23.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/","excerpt":"","text":"Type光源类型 Spot聚光灯 Spot Angle光锥角度 Range发光范围距离 Directional方向光(环境光) Point点光源 Area面光源 Mode 光源模式 Realtime 实时光源：每帧实时计算，效果好，性能消耗大 Baked 烘焙光源：事先计算好，无法动态变化 Mixed 混合光源：预先计算+实时运算 Intensity 光源强度 Indirect Multiplier 间接系数 * 改变间接光的强度 低于1，每次反弹会使光更暗 大于1，每次反弹会使光更亮 Shadow Type 阴影类型 NoShadows 关闭阴影 HardShadows 生硬阴影 SoftShadows 柔和阴影 Realtime Shadows 实时阴影* Strength 强度: 阴影暗度 0~1之间，越大越黑 Resolution 分辨率: 阴影贴图渲染分辨率，越高越逼真，消耗越高 （Project Setting中的Quallty的设置） Bias 偏离: 阴影推离光源的距离 Normal Bias 法线偏离: 阴影投射面沿法线收缩距离 Near Panel 近平面: 渲染阴影的近裁剪面 Cookie 剪影 投影遮罩: 一般用于聚光灯，显示图案 Draw Halo 绘制光晕 球形光环开关 可以用于蜡烛等效果 Flare 眩光 耀斑 有点类似于太阳耀斑效果 想要在Game窗口看到耀斑要在摄像机Camera上加FlareLayer脚本 Render Mode 渲染模式* Auto 自动: 运行时确定 Important 重要: 以像素质量为单位进行渲染，效果逼真，消耗大 Not Important 非重要: 以快速模式进行渲染 Culling Mask 剔除遮罩 剔除遮罩层，决定哪些层的对象受到该光源影响 ps：所有参数都可都可以在代码中设置","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"22.Camera代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制","date":"2025-02-20T06:40:08.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"重要静态成员 1234567891011121314151617181920// 获取主摄像机 只能是有MainCamera tag的print(Camera.main?.name); **************// 所有摄像机数量print(Camera.allCamerasCount);// 所有摄像机Camera[] allCameras = Camera.allCameras;// 渲染相关委托// 摄像机剔除前处理的委托函 数Camera.onPreCull += (c) =&gt;&#123;&#125;;// 摄像机渲染前处理的委托Camera.onPreRender += (c) =&gt;&#123;&#125;;// 摄像机渲染后处理的委托Camera.onPostRender += (c) =&gt;&#123;&#125;; 重要成员 Inspector窗口的所有值都能用代码得到并修改 比如：Camera.main.depth = 10; 下面非常常用 12345// 世界坐标 转 屏幕坐标// 转换后的x, y就是屏幕坐标, z则为 Camera.main 离 这个物体position有多远 (纵深// 用这个来做 头顶血条 ****************Vector3 vector3 = Camera.main.WorldToScreenPoint(this.transform.position);print(vector3); 设置z之后，屏幕坐标就会转换到世界坐标的距离摄像机的z距离的平面上 12345// 屏幕坐标 转 世界坐标// 转换要自己设定z轴的距离, 否则为0, 一直在视口点上坐标不变Vector3 v = Input.mousePosition; ***********v.z = 10;Vector3 vector31 = Camera.main.ScreenToWorldPoint(v);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"21.Camera","slug":"游戏引擎/unity/unity入门/unity入门基础知识/21.Camera","date":"2025-02-20T05:43:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/21.Camera/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/","excerpt":"","text":"Camera可编辑参数 Clear Flags清楚标志 skybox天空盒 （做3d游戏） Solid Color颜色填充 （做2d游戏） Depth only 只画该层，背景透明 （一般多个摄像机叠加渲染的时候使用，一般与下面的Depth配合使用） Don’t Clear 不移除，覆盖渲染 （不常用，会保留每一帧的渲染内容，就像黄金体验镇魂曲） Culling Mask剔除遮罩 选择渲染部分层级（Layer） Projection FOV Axis Fov轴：视野轴，决定了光学仪器的视野范围。 Perspective 透视模式 Field of view 视野：摄像机视角（以沿着 FOV Axis__ 下拉选单中指定轴的度数为单位）。0-180度之间，一般保持默认60就行。 orthographic 正交摄像机（一般用于2D游戏制作） Size：摄制范围 Clipping Planes裁剪平面 Near：近平面 Far：远平面 Depth深度 渲染顺序上的深度 （数字越小，越先渲染） 数字小的照片会先放， 数字大的照片会叠在上面，天空盒有背景是不透明，depth only透明 Target Texture目标纹理 可以把摄像机画面渲染到一张图上， 主要用于制作小地图 在Project右键创建 Render Texture，将创建的Render Texture拖到摄像机，就会把摄像机看到的画面渲染到一张图上 Occlusion Culling剔除遮挡 勾选时一些游戏物体被大一点的物体挡住可以不用渲染 不常用的参数 Viewport Rect视口范围 屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏，0~1 相当于宽高百分比 Redering path渲染路径","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"20.Screen屏幕相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关","date":"2025-02-20T02:50:13.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.Screen%E5%B1%8F%E5%B9%95%E7%9B%B8%E5%85%B3/","excerpt":"","text":"常用 1234567891011// 当前屏幕分辨率 (设备的分辨率Resolution currentResolution = Screen.currentResolution;print($&quot;当前分辨率宽:&#123;currentResolution.width&#125;, 高:&#123;currentResolution.height&#125;&quot;);// 当前游戏窗口分辨率 print($&quot;当前窗口分辨率为:&#123;Screen.width&#125; * &#123;Screen.height&#125;&quot;);// 屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; 不常用 123456789101112131415161718192021// 运行时是否全屏Screen.fullScreen = true;// 窗口模式 (以后在发布的时候在设置, 一般不用代码去设置)// 独占全屏 FullScreenMode.ExclusiveFullScreen// 全屏窗口 FullScreenMode.FullScreenWindow;// 最大化窗口 FullScreenMode.MaximizedWindow// 窗口模式 FullScreenMode.Windowed;Screen.fullScreenMode = FullScreenMode.FullScreenWindow;// 移动设备转向相关...Screen.autorotateToLandscapeLeft = true;// 指定屏幕显示方向Screen.orientation = ScreenOrientation.LandscapeLeft;// 设置分辨率 第三个参数是否为全屏 (移动设备不用, Screen.SetResolution(1920, 1080, false);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"19.Input输入相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关","date":"2025-02-20T02:39:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.Input%E8%BE%93%E5%85%A5%E7%9B%B8%E5%85%B3/","excerpt":"","text":"输入内容一定是写在Update当中的 鼠标位置 屏幕坐标的原点是在左下角，右是x轴正向，上是y轴正向 123// 鼠标位置// 返回一个Vector3, 但只有x, y有值print(Input.mousePosition); 检测鼠标输入 1234567891011// 检测鼠标输入 (0左键, 1右键, 2滚轮if (Input.GetMouseButtonDown(0)) print(&quot;你按了一次 鼠标左键&quot;);if (Input.GetMouseButtonUp(1)) print(&quot;你抬起了一次 鼠标右键&quot;);if (Input.GetMouseButton(0)) print(&quot;你是一直在按着 鼠标左键&quot;);// 返回一个Vector2, 而滚动会改变其中的y值// y值 -1 往下棍, 0 没滚, 1 往上滚Vector2 mouseScrollDelta = Input.mouseScrollDelta;print(mouseScrollDelta); 检测键盘输入 123// 键盘按下 up抬起, 无长按...if (Input.GetKeyDown(KeyCode.W)) print(&quot;你按下了W键&quot;); 检测默认轴 记不住单词可以在Project Setting中的Input Manager查看 1234567891011121314// 默认轴输入// 当键盘A,D键按下时, 返回-1 到 1之间的变换 // 即一直按A的话, 返回值会慢慢从0变到 -1// Input.GetAxisRaw是只会有 -1, 0, 1三个数字之间的突变float v = Input.GetAxis(&quot;Horizontal&quot;);print(v);// W, S 返回-1, 到 1float v1 = Input.GetAxis(&quot;Vertical&quot;);print(v1);// 鼠标横向移动 纵向 Mouse Yfloat v2 = Input.GetAxis(&quot;Mouse X&quot;);print(v2); 其它 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 是否有任意键或鼠标长按bool anyKey = Input.anyKey;if (Input.anyKeyDown)&#123; print($&quot;有一个键按下了按下的是&#123;Input.inputString&#125;&quot;);&#125;// 得到连接的手柄的所有按钮名字string[] strings = Input.GetJoystickNames();for (int i = 0; i &lt; strings.Length; i++)&#123; print(&quot;你连接的所有按钮有&quot;); print(strings[i]);&#125;// 某一手柄键按下, 抬起, 长按...bool v3 = Input.GetButtonDown(strings[0]);// 移动设备触摸if (Input.touchCount &gt; 0)&#123; Touch touch = Input.touches[0]; // 位置 print(touch.position); // 相对上次位置的变化 print(touch.deltaPosition);&#125;// 是否启用多点触控Input.multiTouchEnabled = true;// 陀螺仪 (重力感应)// 是否开启陀螺仪Input.gyro.enabled = true;// 重力加速度 Vector3 gravity = Input.gyro.gravity;// 旋转速度Vector3 rotationRate = Input.gyro.rotationRate;// 陀螺仪 当前旋转的四元数// 比如用这个角度信息 来控制场景上的一个3D物体收到重力影响// 手机怎么动, 他就怎么动Quaternion attitude = Input.gyro.attitude; 练习 用WASD键控制前进后退，左右转向 123//ws键 控制位移 // 这公式 是 ： 前进方向 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime * Input.GetAxis(&quot;Vertical&quot;)); //ad键 控制 左右转向 // 这公式 是 ： 转动的轴 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Horizontal&quot;)); 鼠标左右移动控制炮口的转向 1head.Rotate(Vector3.up * headRotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Mouse X&quot;));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"18.坐标转换","slug":"游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换","date":"2025-02-19T13:07:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"世界 -&gt; 本地 世界坐标系的点 -&gt; 本地坐标系的点 123// 世界坐标 转换为 本地坐标 (会受到缩放影响// 即 在世界坐标系下的 (0, 0, 1) 在本地坐标系下表示为 transform.InverseTransformPoint(Vector3.forward)print(this.transform.InverseTransformPoint(Vector3.forward)); 世界坐标系的向量 -&gt; 本地坐标系的向量 1234// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (不受缩放影响print(this.transform.InverseTransformDirection(Vector3.forward));// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (受缩放影响print(this.transform.InverseTransformVector(Vector3.forward)); 本地 -&gt; 世界 本地坐标系的点 -&gt; 世界坐标系的点 （最重要的***） 1234567// 本地坐标 转换为 世界坐标 (会受到缩放影响// 即 在本地坐标系下的 (0, 0, 1) 在世界坐标系下表示为 transform.TransformPoint(Vector3.forward)print(this.transform.TransformPoint(Vector3.forward));// eg:GameObject obj = new GameObject(&quot;左前方物体&quot;);obj.transform.position = this.transform.TransformPoint(new Vector3(-1, 0, 1)); // 在本地坐标的左前方（-1,0,1）处创建物体 本地坐标系的向量 -&gt; 世界坐标系的向量 1234// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (不受缩放影响print(this.transform.TransformDirection(Vector3.forward));// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (受缩放影响print(this.transform.TransformVector(Vector3.forward));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"17.父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系","date":"2025-02-19T08:56:46.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"获取和设置父对象 1234567891011121314151617// 获取父对象print(this.transform.parent);// 断绝父子关系this.transform.parent = null; // 认父亲 // 也会顺带把孙子的爷爷也换了this.transform.parent = GameObject.Find(&quot;obj&quot;).transform;// 下面这种认父亲的方法 特殊一些// 第二个参数为true 则不会改掉物体本来的世界坐标位置,大小什么的// 为false, 则会把原来Inspector面板上的数字原封不动的赋值到新的Inspector窗口上，则会用自己的transform中的数值// 子对象世界坐标 = 父对象世界坐标 × 子对象局部坐标（当 worldPositionStays = false 时）。// 动态创建ui时常用this.transform.SetParent(GameObject.Find(&quot;obj&quot;).transform, false); 抛妻弃子 12// 和自己所有儿子断绝关系, 不会断掉儿子和孙子的this.transform.DetachChildren(); 获取子对象及其操作 12345678910111213141516171819// 根据名字查找儿子对象 (不可以查找孙子, 可以找到失活的儿子，GameObject的find不能查找失活的对象 )print(this.transform.Find(&quot;Capsule&quot;));// 查找Father的儿子Sonprint(this.transform.Find(&quot;Father/Son&quot;));// 儿子数量print(this.transform.childCount);// 遍历for (int i = 0; i &lt; this.transform.childCount; i++) print(this.transform.GetChild(i)); // 判断是不是自己是不是另一个对象的儿子bool v = this.transform.IsChildOf(transform.parent);// 设置自己作为儿子编号this.transform.SetSiblingIndex(0);// 得到自己作为儿子的编号print(this.transform.GetSiblingIndex()); 练习 请为Transform写一个拓展方法，可以将它的子对象按名字的长短进行排序改变他们的顺序，名字短的在前面，名字长的在后面 1234567891011121314151617181920212223242526272829public static class TransformExtensions&#123; public static void SortChildrenByNameLength(this Transform obj) &#123; //var children = obj.Cast&lt;Transform&gt;().ToList(); //children = children.OrderBy(child =&gt; child.name.Length).ToList(); //for (int i = 0; i &lt; children.Count; i++) //&#123; // children[i].SetSiblingIndex(i); //&#125; List&lt;Transform&gt; list = new List&lt;Transform&gt;(); for (int i = 0; i &lt; obj.childCount; i++) &#123; list.Add(obj.GetChild(i)); &#125; //这是根据 名字长短进行排序 利用的 是list的排序 传个函数进去 list.Sort((a, b) =&gt; a.transform.name.Length - b.transform.name.Length); //根据 list中的排序结果 重新设置每一个对象的 索引编号 for (int i = 0; i &lt; list.Count; i++) &#123; list[i].SetSiblingIndex(i); &#125; &#125;&#125; 请为Transform写一个拓展方法，传入一个名字查找子对象，即使是子对象的子对象也能查找到 123456789101112131415161718public static class TransformExtensions&#123; public static Transform CustomFind(this Transform obj, string name) &#123; Transform res = null; res = obj.Find(name); if (res != null) return res; for (int i = 0; i &lt; obj.childCount; i++) &#123; res = obj.GetChild(i).CustomFind(name); if (res != null) return res; &#125; return res; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"16.缩放和看向","slug":"游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向","date":"2025-02-19T08:23:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/16.%E7%BC%A9%E6%94%BE%E5%92%8C%E7%9C%8B%E5%90%91/","excerpt":"","text":"缩放 12345678// 相对于世界坐标系 // 不能改print(this.transform.lossyScale);// 相对于父对象 // 可以改print(this.transform.localScale);// unity 没有提供缩放相关的API, 只能自己手动来搞 eg: this.transform.localScale += Vector3.one * Time.deltaTime; 看向 12// 将自己的面朝向源点，相对于世界坐标系this.transform.LookAt(Vector3.zero);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"15.角度和旋转","slug":"游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转","date":"2025-02-19T07:30:32.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/15.%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC/","excerpt":"","text":"角度相关 123456789// 相对于世界坐标角度print(this.transform.eulerAngles);// 相对于父对象角度// Inspector中显示的是相对父对象的角度，localEulerAngles的角度只能是0~360，但Inspector面板是可以负数的print(this.transform.localEulerAngles);// 不能单个x, y, z赋值this.transform.localEulerAngles = new Vector3(10, 10, 10); 旋转相关 123456789101112// 自转API 第二个参数默认不写的话，绕着自己坐标转this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime * 100, Space.World); // 每帧绕y轴增加100 * （0，10，0）//相对于某个轴 转多少度//参数一:是相对哪个轴进行转动//参数二:是转动的 角度 是多少//参数三:默认不填 就是相对于自己的坐标系 进行旋转transform.Rotate(Vector3.up, Time.deltaTime * 100); // 在自己的坐标系的y轴旋转// 绕着某个点旋转 绕着源点, y轴, 转的多少度this.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime); 代码 原理 效率 可读性 Rotate(new Vector3(0,1,0) * dt * 100) 欧拉角增量 较低（需创建Vector3） 一般 Rotate(Vector3.up, dt * 100) 轴-角度 较高 更佳","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"14.位置位移坐标系相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关","date":"2025-02-19T06:59:04.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/14.%E4%BD%8D%E7%BD%AE%E4%BD%8D%E7%A7%BB%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3/","excerpt":"","text":"Vector常用 用的是世界坐标 123456789Vector3.forward 001Vector3.up 010Vector3.down 0-10Vector3.left -100Vector3.right 100Vector3.back 00-1// 两点之间的距离Vector3.Distance(v1, v2); 位置 1234567891011// 相对世界坐标原点的值print($&quot;距离世界源点 &#123;this.transform.position&#125;&quot;);// 相对父对象 没父对象就相对于源点print($&quot;距离父对象坐标点 &#123;this.transform.localPosition&#125;&quot;);// 位置的赋值不能单独改x, y, z 只能整体来赋值this.transform.position = new Vector(5, this.transform.position.y, ...);// 或者Vector3 tmp = this.transform.position; tmp.y = 666;this.transfomr.position = tmp; 朝向 本地坐标系，游戏对象当前的朝向 123print(this.transform.forward); // 游戏对象当前的面朝向print(this.transform.up); // 对象当前的头顶朝向Vector3 right = this.transform.right; // 右手边 位移 123456789101112131415// 1 位移 = 方向 * 速度 * 时间 (手动写, 世界坐标系的话用Vector3.XX)最终位置 = 当前的位置 + 我要变化的位置的路程//this.transform.position += this.transform.forward * 1 * Time.deltaTime;// 2 位移API// 参数1 表示位移多少 位移 = 方向 * 速度 * 时间// 参数2 移动所采用的坐标系, 即(1, 0, 0)是哪个坐标系的(1, 0, 0) (不填的话，默认本地相对坐标系Space.Self)this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); // 沿着世界坐标系的001去动this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.World); // 世界坐标系中沿着自己的面朝向去动this.transform.Translate（Vector3.forward * 1 * Time.deltaTime, Space.Self); // 沿着自己坐标系的001去动// 不会这样移动, 自己相对于世界坐标系的歪曲的数据 再应用于自己的坐标系this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.Self); // 傻逼","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"13.时间相关Time","slug":"游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time","date":"2025-02-19T06:00:25.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13.%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3Time/","excerpt":"","text":"时间缩放比例 12// 时间停止 // 恢复正常 // 2倍速Time.timeScale = 0; Time.timeScale = 1; Time.timeScale = 2; 帧间隔时间 即 两帧之间的时间 作用: 计算位移 每帧移动的距离由speed * Time.deltaTime确定，确保了在不同帧率下物体移动的速度一致 典型应用：transform.Translate(Vector3.forward * speed * Time.deltaTime); 通过乘以 deltaTime，物体每秒移动的距离为 speed 单位，无论帧率如何变化。 123// 帧间隔时间print(&quot;受timeScale影响的 &quot; + Time.deltaTime);print(&quot;不受timeScale影响的&quot; + Time.unscaledDeltaTime); 游戏开始到现在时间 一般都单机游戏用，网游一般用服务器时间 123// 游戏开始到现在的时间print(&quot;受timeScale影响的&quot; + Time.time);print(&quot;不受影响的&quot; + Time.unscaledTime); 物理帧间隔时间 123456void FixedUpdate()&#123; // 物理帧间隔时间 print(&quot;受影响的 &quot; + Time.fixedDeltaTime); print(&quot;不受影响的 &quot; + Time.fixedUnscaledDeltaTime);&#125; 总帧数 (帧同步) 从开始到现在游戏跑了多少帧（即多少次循环） 1print(Time.frameCount);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"12.GameObject","slug":"游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject","date":"2025-02-19T02:07:20.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GameObject/","excerpt":"","text":"成员变量 12345678910// 名字this.gameObject.name = &quot;改名desu&quot;;// 是否激活bool activeSelf = this.gameObject.activeSelf;// 是否静态bool isStatic = this.gameObject.isStatic;// 层级int layer = this.gameObject.layer;// 给游戏对象分的标签string tag1 = this.gameObject.tag; 静态方法 创建自带几何体 123// 创建自带几何体GameObject gameObject1 = GameObject.CreatePrimitive(PrimitiveType.Cube);gameObject1.name = &quot;自己起的名字&quot;; 在场景中查找对象 只能找到激活对象，无法找到失活对象 使用单个查找的api，如果场景有满足调教的多个对象，无法指定找到的是谁 1234567891011121314151617// 在场景中查找对象 // 1.1 单个查找 名字(同名不行)// 查找效率低 会查询所有场景中所有的对象GameObject gameObject2 = GameObject.Find(&quot;自己起的名字&quot;);print(gameObject2?.name);// 1.2 单个查找 tagGameObject gameObject3 = GameObject.FindWithTag(&quot;MainCamera&quot;);print(gameObject3?.name);// 1.3 通过Inspector面板去拖到本地的public// 2 多对象查找 tagGameObject[] gameObjects = GameObject.FindGameObjectsWithTag(&quot;Player&quot;);print(gameObjects?.Length);// FindObjectOfTypes 效率低 克隆对象 根据一个GameObject对象, 创建一个一模一样的对象 1GameObject obj = GameObject.Instantiate(MyObj); 删除 删除一个指定游戏对象 删除一个指定脚本对象 注意: Destroy方法不会马上移除对象, 只是加了一个移除标识 一般情况下, 会在下一帧时把这个对象从内存中移除 1234567// 删除对象GameObject.Destroy(gameObject4, 5); // 第二个参数是延时几秒// 删除脚本对象GameObject.Destroy(this);// 一定要马上移除 // 没特殊需求不用GameObject.DestroyImmediate(gameObject4); 切场景不移除 默认情况下, 切场景会删除该场景的所有对象 一般写自己依附的对象不被删除 1GameObject.DontDestroyOnLoad(this.gameObject); // 不移除该脚本依附的游戏对象 成员方法 创建空物体 顺带加上Test2脚本 1GameObject gameObject5 = new GameObject(&quot;创建的空物体名字&quot;, typeof(Test2)); 动态给GameObject对象添加脚本 12// 给gameObject5加上Test2脚本Test2 test2 = gameObject5.AddComponent&lt;Test2&gt;(); 获取脚本对象 和[[Mono中的重要内容#^155e67 | 继承Mono的类]]获取脚本对象的方法一毛一样 标签比较 12345678if (gameObject5.CompareTag(&quot;Player&quot;))&#123; print(&quot;对象标签是Player&quot;);&#125;if (gameObject5.tag == &quot;Player&quot;)&#123; print(&quot;这和上面是一样的&quot;);&#125; 设置 失活 和 激活 1gameObject5.SetActive(false); // 失活 不建议使用的成员方法 通过广播或者发送消息的形式, 让自己或者别人 执行某些行为和方法 123456789// 让自己去执行TestFun这个函数, 会在自己对象上挂着的所有脚本去找这个名字的函数, 有一个执行一个// 涉及到反射 比较影响性能this.gameObject.SendMessage(&quot;TestFun&quot;);// 广播行为 让自己及其子对象发送消息并执行，让自己及其子对象 执行相同的名字的方法this.gameObject.BroadcastMessage(&quot;TestFun&quot;);// 让自己及其父对象发送消息并执行this.gameObject.SendMessageUpwards(&quot;函数名&quot;); 继承自Object自然可以用Object.xxx的方式来调用静态函数","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"11.MonoBehavior中的重要内容","slug":"游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容","date":"2025-02-18T10:13:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.MonoBehavior%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/","excerpt":"","text":"8.脚本基本规则 重要成员 获取依附的GameObject 1print(this.gameObject.name); 获取依附的GameObject的位置信息 1234567//得到对象位置信息print(this.transform.position);//位置print(this.transform.eulerAngles);//角度print(this.transform.lossyScale);//缩放大小//这种写法和上面是一样的效果 都是得到依附的对象的位置信息this.gameObject.transform 设置脚本是否激活 1234//this.enabled = true;print($&quot;这是其它脚本对象 otherTest, 可以使用本脚本的其它脚本对象来获取gameObject &#123;otherTest.gameObject.name&#125;&quot;); 重要方法 获取依附对象上挂载的其它脚本 三个重载获取 1234567891011// 通过挂载脚本名Component component = this.GetComponent(&quot;Test2&quot;);Test2 t = component as Test2;print(t);// 通过typet = this.GetComponent(typeof(Test2)) as Test2;// 通过 *************用最多*************t = this.GetComponent&lt;Test2&gt;(); 获取多个脚本 123456Test2[] test2s = this.GetComponents&lt;Test2&gt;();List&lt;Test2&gt; list = new List&lt;Test2&gt;();this.GetComponents&lt;Test2&gt;(list); 找自己及其子对象的所挂载的脚本 123// 这里可以不传参数, 默认传false表示不找失活状态的脚本// 找自己及其父对象的同理this.GetComponentsInChildren&lt;Test2&gt;(false); 注意 要想操作其它GameObject对象, 必须获取其它的脚本对象, 而且得用Inspector来赋值","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"csharp特性","slug":"编程语言/Csharp/csharp特性","date":"2025-02-18T09:18:38.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/编程语言/Csharp/csharp特性/","permalink":"http://example.com/2025/02/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%89%B9%E6%80%A7/","excerpt":"","text":"特性 特性是一种允许我们向程序的[[程序集]]添加[[元数据]]的语言结构 它是用于保存程序结构信息的某种特殊类型的类 特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。 特性与程序实体关联后，即可在运行时使用[[csharp反射]]查询特性信息 特性的目的是告诉编译器把程序结构的某组[[元数据]]嵌入[[程序集]]中 它可以放置在几乎所有的声明中（类、变量、函数等等申明） 说人话： 特性本质是个类 我们可以利用特性类为[[元数据]]添加额外信息 比如一个类、成员变量、成员方法等等为他们添加更多的额外信息 之后可以通过[[csharp反射]]来获取这些额外信息 自定义特性 12345678910111213class MyCustomAttribute : Attribute&#123; //特性中的成员 一般根据需求来写 public string info; public MyCustomAttribute(string info) &#123; this.info = info; &#125; public void TestFun() &#123; Console.WriteLine(&quot;特性的方法&quot;); &#125;&#125; 特性的使用 基本语法: [特性名(参数列表)] 本质上 就是在调用特性类的构造函数 写在哪里？ 类、函数、变量上一行，表示他们具有该特性信息 1234567891011121314151617181920212223[MyCustom(&quot;这是我自己的类&quot;)]class MyClass&#123; [MyCustom(&quot;这是一个int型的成员变量&quot;)] public int Value; [MyCustom(&quot;这是用来测试的成员函数&quot;)] public void TestFun([MyCustom(&quot;这是用来测试的函数参数&quot;)] int a) &#123; Console.WriteLine(a); &#125;&#125;Type t = typeof(MyClass);if (t.IsDefined(typeof(MyCustomAttribute), false))&#123; Console.WriteLine(&quot;判断一个类型是否使用了某个特性&quot;);&#125;// 获取Type元数据中的所有特性object[] objects = t.GetCustomAttributes(true);for (int i = 0; i &lt; objects.Length; i++) Console.WriteLine((objects[i] as MyCustomAttribute).Info); 为特性类加特性 限制其使用范围 12345[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]//参数一：AttributeTargets —— 特性能够用在哪些地方//参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上//参数三：Inherited —— 特性是否能被派生类和重写成员继承public class MyCustom2Attribute : Attribute &#123; &#125; 系统自带特性——过时特性 Obsolete 用于提示用户 使用的方法等成员已经过时 建议使用新方法 123456//一般加在函数前的特性[Obsolete(&quot;这个是旧方法&quot;, false)]// 第一个参数是提示信息, 第二个参数 true直接报错, false警告public void OldFun() &#123; &#125; 系统自带特性——调用者信息特性 (快速查出哪里的错误) 12345678910111213141516171819202122232425//哪个文件调用？//CallerFilePath特性//哪一行调用？//CallerLineNumber特性//哪个函数调用？//CallerMemberName特性class TestClass&#123; [Obsolete(&quot;这个是旧方法&quot;, false)] // 第一个参数是提示信息, 第二个参数 true直接报错, false警告 public void OldFun() &#123; &#125; public void NewFun(string str, [CallerFilePath] string fileName = &quot;&quot;, [CallerLineNumber] int line = 0, [CallerMemberName] string memberName = &quot;&quot;) &#123; Console.WriteLine(&quot;这些使用的CallerXXX特性会在, 其它调用者调用时自动将调用者的额外信息填入参数中&quot;); Console.WriteLine(&quot;调用者的文件名 fileName = &quot; + fileName); Console.WriteLine(&quot;调用者的所在的行数 line = &quot; + line); Console.WriteLine(&quot;调用者的所处的调用函数名 memberName = &quot; + memberName); &#125;&#125; 系统自带特性——条件编译特性 Conditional 它会和[[预处理指令]] #define配合使用 123456[Conditional(&quot;Fun&quot;)] // 如果 #define 下面就会编译static void Fun()&#123; Console.WriteLine(&quot;如果有#define 我就会执行&quot;);&#125; 系统自带特性——外部Dll包函数特性 DllImport 用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。 一般用来调用 C或者C++的Dll包写好的方法 需要引用[[命名空间]] using System.Runtime.InteropServices 123[DllImport(&quot;Test.dll&quot;)] // 下面这个函数一定在dll中有一模一样的public static extern int Add(int a, int b);//需要引用命名空间 using System.Runtime.CompilerServices;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"10.inspector 窗口可编辑变量","slug":"游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量","date":"2025-02-18T08:47:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.inspector%20%E7%AA%97%E5%8F%A3%E5%8F%AF%E7%BC%96%E8%BE%91%E5%8F%98%E9%87%8F/","excerpt":"","text":"知识点一 私有和保护无法显示编辑 12private int i1;protected string str1; 知识点二 让私有的和保护的也可以被显示SerializeField 加上强制序列化字段csharp特性 [SerializeField] 所谓序列化就是把一个对象保存到一个文件或数据库字段中去 1234[SerializeField]private int privateInt;[SerializeField]protected string protectedStr; 知识点三 公共的可以显示编辑 12public int publicInt = 10;public bool publicBool = false; 知识点四 公共的也不让其显示编辑HideInInspector 在变量前加上csharp特性 [HideInInspector] 12[HideInInspector]public int publicInt2 = 50; 知识点五 大部分类型都能显示编辑 12345678910public int[] array;public List&lt;int&gt; list;public E_TestEnum type;public GameObject gameObj;//字典不能被Inspector窗口显示public Dictionary&lt;int, string&gt; dic;//自定义类型变量public MyStruct myStruct;public MyClass myClass; 知识点六 让自定义类型可以被访问 加上序列化csharp特性[System.Serializable] 字典怎样都不行 12345678910111213[System.Serializable]public struct MyStruct&#123; public int age; public bool sex;&#125;[System.Serializable]public class MyClass&#123; public int age; public bool sex;&#125; 知识点七 一些辅助csharp特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//1.分组说明特性Header **************有用**************//为成员分组//Header特性//[Header(&quot;分组说明&quot;)][Header(&quot;基础属性&quot;)]public int age;public bool sex;[Header(&quot;战斗属性&quot;)]public int atk;public int def;//2.悬停注释Tooltip//为变量添加说明//[Tooltip(&quot;说明内容&quot;)][Tooltip(&quot;闪避&quot;)]public int miss;//3.间隔特性 Space()//让两个字段间出现间隔//[Space()][Space()]public int crit;//4.修饰数值的滑条范围Range **************有用**************//[Range(最小值, 最大值)][Range(0,10)]public float luck;//5.多行显示字符串 默认不写参数显示3行//写参数就是对应行//[Multiline(4)][Multiline(5)]public string tips;//6.滚动条显示字符串 //默认不写参数就是超过3行显示滚动条//[TextArea(3, 4)]//最少显示3行，最多4行，超过4行就显示滚动条[TextArea(3,4)]public string myLife;//7.为变量添加快捷方法 ContextMenuItem **************有用**************//参数1 显示按钮名//参数2 方法名 不能有参数//[ContextMenuItem(&quot;显示按钮名&quot;, &quot;方法名&quot;)][ContextMenuItem(&quot;重置钱&quot;, &quot;Test&quot;)]public int money;private void Test()&#123; money = 99;&#125;//8.为方法添加特性能够在Inspector中执行//[ContextMenu(&quot;测试函数&quot;)][ContextMenu(&quot;哈哈哈哈&quot;)]private void TestFun()&#123; print(&quot;测试方法&quot;);&#125; 注意 Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变 要么老老实实的在Inspector窗口改默认值 要么重新挂载脚本 运行中修改的信息不会保存","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"9.生命周期函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数","date":"2025-02-18T07:39:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"碰撞检测函数 知识点一 了解帧的概念 Unity 底层已经帮助我们做好了死循环 我们需要学习Unity的生命周期函数 利用它做好的规则来执行我们的游戏逻辑就行了 知识点二 生命周期函数的概念 所有继承MonoBehavior的脚本 最终都会挂载到GameObject游戏对象上 生命周期函数 就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中 会通过反射自动调用的一些特殊函数 注意： 生命周期函数的访问修饰符一般为private和protected 因为不需要再外部自己调用生命周期函数 都是Unity自己帮助我们调用的 当对象（自己这个类脚本对象）被创建时 才会调用该生命周期函数 生命周期函数支持多态 如果GameObject一开始失活就不会调用生命周期函数 awake，onenable,start, fixedUpdate,update, laterupdate, ondisenable,ondestroy Awake： 类似构造函数的存在 我们可以在一个类对象 该创建 进行一些初始化操作 OnEnable： 对于我们来说 想要当一个对象被激活时 进行一些逻辑处理 就可以写在这个函数 Start： 主要作用还是用于初始化信息的 但是它相对Awake来说 要晚一点 如果我们在update中动态的创建对象，这个对象马上会执行Awake，但不会立即执行Start，要等到在下一帧的第一次 Update() 之前执行才会执行Start FixedUpdate： 它主要是用于 进行物理更新 它是每一帧的执行的 但是 这里的帧 和游戏帧 有点不同 它的时间间隔 是可以在 project setting中的 Time里去设置的 Update： 主要用于处理游戏核心逻辑更新的函数 LateUpdate： 一般这个更新是用来处理 摄像机位置更新相关内容的 Update和LateUpdate之间 Unity进了一些处理 处理我们动画相关的更新 OnDisable： 如果我们希望在一个对象失活时做一些处理 就可以在该函数中写逻辑 失活后不参与游戏循环了，激活后又可以循环 OnDestroy： 当对象销毁后调用 问题：不同对象的生命周期函数是在同一个线程中执行吗？","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"8.脚本基本规则","slug":"游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则","date":"2025-02-18T07:10:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/","excerpt":"","text":"MonoBehavior基类 创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 继承了MonoBehavior的脚本可以在一个对象上挂多个（如果没有加DisallowMultipleComponent特性） 继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 不继承MonoBehavior的类 不继承Mono的类 不能挂载在GameObject上 不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 不继承Mono的类 一般是单例模式的类（用于管理模块） 或者数据结构类（用于存储数据） 不继承Mono的类 不用保留默认出现的几个函数 设置挂载脚本的执行顺序，默认时间前是系统必须执行的，可以设置自己添加的脚本的执行顺序，数字越小脚本越先执行 打开 当前unity版本下的Editor\\Data\\Resources\\ScriptTemplates目录可以更改默认的脚本模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"7.预制体和资源包的导入导出","slug":"游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出","date":"2025-02-18T07:01:18.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E9%A2%84%E5%88%B6%E4%BD%93%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"预设体是 Unity 中非常重要的概念，可以理解为一个游戏对象及其组件的集合。其目的是使游戏对象及其资源能够重复使用。当修改预设体时，实例也会同步修改。 创建预设体 将其拖到asset文件夹下 右键可以取消预设体 资源包导出直接右键，导入直接拖","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"6.反射机制和游戏场景","slug":"游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景","date":"2025-02-18T03:33:39.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF/","excerpt":"","text":"Unity中的反射机制 Unity引擎本质是一个软件使用它时是处于运行中的我们是在一个运行中的软件里制作游戏的 Unity开发的本质就是 在Unity引擎的基础上利用反射和引擎提供的各种功能进行的拓展开发 回忆一下反射的概念 程序正在运行时，可以查看其它程序集或者自身的元数据（元数据就是程序当中的类，对象，函数，变量之类的东西） 一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射 在程序运行时，通过反射可以得到其它程序集或者自己程序集中 代码的各种信息，比如类，函数，变量，对象等等 我们可以实例化它们，执行它们，操作它们 Unity 反射机制的完整工作流 假设你写了一个 PlayerController.cs 脚本 12345678public class PlayerController : MonoBehaviour &#123; [SerializeField] private float _moveSpeed = 5.0f; void Update() &#123; // 移动逻辑 &#125;&#125; 脚本编译阶段： Unity 会通过 Mono/C# 编译器 将你的脚本编译到 Assembly-CSharp.dll 中，同时生成 元数据表 编辑器反射阶段： Unity Editor 通过反射扫描所有 MonoBehaviour 子类 解析 [SerializeField] 等特性 生成 Inspector 面板的 UI 元素 运行时反射阶段： 当场景加载时，Unity 通过反射： 实例化 PlayerController 对象 将序列化数据（如 _moveSpeed）注入到对应字段 构建消息系统的方法表（用于 SendMessage()） 游戏场景","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"5.工具栏与对象的父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系","date":"2025-02-18T03:27:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E5%B7%A5%E5%85%B7%E6%A0%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"4.Inspector和Console窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口","date":"2025-02-18T02:08:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.Inspector%E5%92%8CConsole%E7%AA%97%E5%8F%A3/","excerpt":"","text":"选择对象进行标记 选择是否激活对象 修改对象名 设置对象为静态对象 标签 层级","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"3.Game和Project窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口","date":"2025-02-18T01:56:51.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"2.Scene和Hierarchy窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口","date":"2025-02-16T02:24:38.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/","excerpt":"","text":"主要内容 窗口布局 左上角Layout选项 Scene和Hierarchy 场景窗口和层级窗口是息息相关的 层级窗口中看到的内容就是场景窗口中的显示对象","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"1.unity入门概述","slug":"游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述","date":"2025-02-16T01:27:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.unity%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/","excerpt":"","text":"主要学习内容 学习建议 以前做游戏 vs 现在做游戏 如何学习游戏引擎","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.使用obsidian来写hexo博客","slug":"hexo/1.使用obsidian来写hexo博客","date":"2025-02-09T12:59:52.000Z","updated":"2025-02-28T11:46:39.848Z","comments":true,"path":"2025/02/09/hexo/1.使用obsidian来写hexo博客/","permalink":"http://example.com/2025/02/09/hexo/1.%E4%BD%BF%E7%94%A8obsidian%E6%9D%A5%E5%86%99hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Front-Matter obsidian安装Template插件，设置目录后在该目录下创建HexoPost.md文件 HexoPost.md内容如下 123456789101112131415161718---title: &lt;% tp.file.title %&gt;date: &lt;% tp.date.now(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;toc: truecategories:&lt;%*// 自动生成分类（兼容Windows路径）let folders = await tp.file.folder(true).split(/[\\\\/]/); folders = folders.slice(2); // 移除 &quot;_posts&quot; 父级目录for (let category of folders) &#123; tR += ` - $&#123;category&#125;`;&#125;if (folders.length === 0) &#123; tR += &quot; - 未分类&quot;;&#125;%&gt;tags:--- 这样就可以在新建md文件后点击obsidian侧边来自动填充categories 图片管理 站点配置文件_config.yml 1post_asset_folder: true # 启用文章资源文件夹 obsidian安装 Custom Attachment Location插件并进行如下设置 其它小优化 设置新建笔记位置 关闭wiki链接 文章内跳转使用md语法 [显示文本](#锚点) md标题自动生成锚点（全小写，空格换-）或者自定义锚点（&lt;a id=&quot;nihao&quot;&gt;&lt;/a&gt;） 忽略文件夹 参考 使用 Hexo 搭建博客 | OHLIA’s Wiki Hexo和Obsidian：让个人博客写作更加优雅、高效 - ＊tree_fly 's Blog 给博客上Live2d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]},{"title":"你好呀","slug":"你好呀","date":"1999-12-31T16:00:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2000/01/01/你好呀/","permalink":"http://example.com/2000/01/01/%E4%BD%A0%E5%A5%BD%E5%91%80/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]}