{"meta":{"title":"akiraの博客思密达","subtitle":"","description":"","author":"akira23369","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2025-02-06T20:57:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2025-02-06T20:57:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2025-02-06T20:57:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-02-06T20:57:28.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"7.四元数常用方法","slug":"游戏引擎/unity/unity基础/7.四元数常用方法","date":"2025-03-02T03:00:47.000Z","updated":"2025-03-02T03:18:50.679Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/7.四元数常用方法/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"单位四元数 12345// 单位四元数 [1, (0, 0, 0)] Quaternion i = Quaternion.identity; //Object的Instantiate方法有重载 第三个参数可以传入四元数角度 Instantiate(testCube, Vector3.zero, Quaternion.identity); 插值运算 123456// 无限接近，先快后慢A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);// 匀速time += Time.deltaTime; B.transform.rotation = Quaternion.Slerp(start, target.rotation, time); 向量指向转四元数LookRotation 12345678public Transform target;public float rotateSpeed = 2f;void Update() &#123; Vector3 dir = target.position - transform.position; Quaternion targetRot = Quaternion.LookRotation(dir); transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"6.Quaternion四元数概念","slug":"游戏引擎/unity/unity基础/6.Quaternion四元数概念","date":"2025-03-02T02:26:57.000Z","updated":"2025-03-02T03:01:23.990Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/6.Quaternion四元数概念/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/","excerpt":"","text":"四元数概念 四元数构成 轴-角对 这里的n是3d向量 Unity中的四元数 Quaternion Unity中的四元数初始化方法 1234567//用四元数的计算原理 绕着(x,y,z)向量旋转β度(弧度)float timeAngle = Mathf.Sin(β / 2 * Mathf.Deg2Rad);Quaternion q = new Quaternion(timeAngle * x, timeAngle * y, timeAngle * z, Mathf.Cos(β / 2 * Mathf.Deg2Rad));//绕着(1,0,0)向量旋转60度 要传入弧度制 角度转弧度Quaternion q1 = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad)); 123//创建一个围绕 axis 旋转 offsetAngle 度的旋转。//提供的轴角对 初始化 四元数的方法 分别传入度数和向量轴Quaternion q2 = Quaternion.AngleAxis(60, Vector3.right); 四元数和欧拉角相互转换12345// 欧拉角 转 四元数Quaternion q = Quaternion.Euler(60, 0, 0);// 四元数 转 欧拉角print(q.eulerAngles);//(60.0, 0.0, 0.0) 弥补的欧拉角缺点 注意：四元数转换为欧拉角的范围始终是[-180°, 180°]之间123//每一帧绕着y轴旋转1度 //四元数绕 y轴转 *****物体坐标系****** 旋转this.transform.rotation *= Quaternion.AngleAxis(1, Vector3.up);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"5.Quaternion为什么要使用四元数","slug":"游戏引擎/unity/unity基础/5.Quaternion为什么要使用四元数","date":"2025-03-02T02:10:07.000Z","updated":"2025-03-02T03:01:30.593Z","comments":true,"path":"2025/03/02/游戏引擎/unity/unity基础/5.Quaternion为什么要使用四元数/","permalink":"http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/","excerpt":"","text":"在unity中将Rotation的x设置为90°，调整y和z都绕同一个轴旋转","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"4.Vector3向量","slug":"游戏引擎/unity/unity基础/4.Vector3向量","date":"2025-03-01T10:14:34.000Z","updated":"2025-03-02T03:01:40.668Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/4.Vector3向量/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/","excerpt":"","text":"Unity中的向量向量常用的成员和方法向量在数学和编程中有许多常用的成员和方法，常见的包括： 成员： x、y、z：向量的分量，表示向量在 x、y、z 方向上的值。 magnitude 或 length：向量的长度或模长，表示从原点到向量的终点的距离。 normalized：返回与当前向量方向相同但长度为1的单位向量。也可以 向量 /magnitude sqrMagnitude：向量长度的平方，用于比较向量长度时避免开方计算。 zero：零向量，所有分量均为0的向量。 方法： Vector3.Dot(Vector3 a, Vector3 b)：计算两个向量的点乘结果。返回弧度 Vector3.Cross(Vector3 a, Vector3 b)：计算两个向量的叉乘结果。 Vector3.Distance(Vector3 a, Vector3 b)：计算两个向量之间的距离。 Vector3.Lerp(Vector3 a, Vector3 b, float t)：在两个向量之间进行线性插值。 Vector3.Slerp(Vector3 a, Vector3 b, float t)：在两个向量之间进行球形插值 Vector3.Normalize(Vector3 value)：将向量转化为单位向量。 Vector3.Project(Vector3 vector, Vector3 onNormal)：将一个向量投影到另一个向量上。 Vector3.RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)：将一个向量从当前方向旋转到目标方向。 Vector3.Angle(Vector3 from, Vector3 to)：返回值float, 计算两个向量之间的角度值 例子eg: 利用 $A \\cdot B = |A| * |B| cos\\theta$ 或者 Vector.Angle()(角度) 来计算$\\theta$ $A\\cdot B &gt;= 0$ 前方 $A \\times B &lt; 0$ 则A右B左 线性插值 (匀速) 向量的点积12345678// Debug类中的DrawLine静态方法 画线段// 参数：前两个参数分别是起点和终点，最后一个参数是划线颜色。Debug.DrawLine(this.transform.position, this.transform.position + this.transform.forward, Color.red);// Debug类中的DrawRay静态方法 画射线// 参数：前两个参数分别是起点和方向，最后一个参数是划线颜色。Debug.DrawRay(this.transform.position, this.transform.up, Color.blue); 两个向量 a=(x1​,y1​) 和 b=(x2​,y2​) 的点积定义为 a⋅b=x1x2​+y1​y2​​，其结果是一个标量，且 a⋅b=∣a∣×∣b∣×cosθ，其中 θ 是 a 和 b 之间的夹角。$\\theta = Acos(单位向量a \\cdot 单位向量b )$点积可用于判断两个向量的前后关系12345678Vector3 forward = transform.forward;Vector3 toEnemy = enemy.position - transform.position;float dotResult = Vector3.Dot(forward, toEnemy.normalized);// 值&gt;0表示敌人在前方，&lt;0表示在后方if(dotResult &gt; 0.5f) &#123; // 敌人位于前方60度范围内&#125; 向量的叉积获取垂直向量（右手定则， 常用于计算旋转轴）可以用叉乘来判断两个向量的左右关系123456789Vector3 C = Vector3.Cross(A.position, B.position);if (C.y &gt; 0)&#123; Debug.Log(&quot;A在B的右侧&quot;);&#125;else&#123; Debug.Log(&quot;B在A的右侧&quot;);&#125; 向量插值运算插值公式和Mathf的插值运算差不多 线性插值先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置123// 可以理解为t不变 每次往方向向量加的值(end - start)一直会变小A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime); 匀速 每帧改变时间 当t&gt;=1时 得到结果123456789101112131415161718192021// 可以理解为t每一帧累加相同值 start和(end - start)不变 所以是匀速运动// 这种匀速移动 当time&gt;=1时 我改变了 目标位置后 它会直接瞬移到我们的目标位置 因为t&gt;=1时直接的得到结果public Transform target;private Vector3 startPos;private Vector3 tmpTarget;private float time = 0;void Update()&#123; // 每次终点移动变化, 重置时间, 起点 if (tmpTarget != target.position) &#123; tmpTarget = target.position; time = 0; startPos = transform.position; &#125; time += Time.deltaTime; transform.position = Vector3.Lerp(startPos, target.position, time); 球形插值从（10， 0， 0） 到 （0， 0， 10）12time += Time.deltaTime;A.position = Vector3.Slerp(Vector3.right * 10, Vector3.forward * 10, time); 练习用向量相关知识，实现摄像机跟随摄像机代码写在LateUpdate中如果在Update中更新摄像机的位置，可能会出现摄像机位置更新早于目标对象位置更新的情况，导致摄像机出现抖动或延迟跟随的问题。而在LateUpdate中更新摄像机位置，可以确保在目标对象位置更新完成后再进行摄像机的移动，从而实现平滑的跟随效果。1234567891011121314151617public float zOffect = 4;public float yOffect = 7;public Transform target;void LateUpdate()&#123; // 摄像机的位置等于目标的位置进行向量偏移 // 先朝目标对象的面朝向的反方向平移4米再朝目标的头顶位置平移7米 // 设置摄像机位置 this.transform.position = target.position - target.forward * zOffect + target.up * yOffect; // 看向目标 this.transform.LookAt(target);&#125; 发现入侵者当一个物体B在物体A前方45度角范围内，并且离A只有5米距离时，在控制台打印“发现入侵者” 12345678910111213141516171819// 手动算if (Vector3.Distance(this.transform.position, B.transform.position) &lt;= 5)&#123; // 第一步：算出点乘结果（方向向量） float dotResult = Vector3.Dot(this.transform.forward, (B.transform.position - this.transform.position).normalized); // 第二步：通过反余弦函数算出夹角 if (Mathf.Acos(dotResult) * Mathf.Rad2Deg &lt;= 22.5f) &#123; print(&quot;手动算角度 发现入侵者&quot;); &#125;&#125;// Angle直接算角度if (Vector3.Distance(this.transform.position, B.transform.position) &lt;= 5 &amp;&amp; Vector3.Angle(this.transform.forward, B.transform.position - this.transform.position) &lt;= 22.5f)&#123; print(&quot;Angle直接算角度 发现入侵者&quot;);&#125; 左上，左下 ，右上，右下哪个方位?判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class VectorPositionDetector : MonoBehaviour&#123; public Transform objectA; public Transform objectB; [Header(&quot;阈值&quot;)] public float angleThreshold = 45f; // 方向识别角度范围 void Update() &#123; // 获取A到B的水平方向向量 Vector3 aToB = objectB.position - objectA.position; aToB.y = 0; // 忽略垂直分量 // 获取A的基准方向向量（已水平化） Vector3 aForward = objectA.forward; aForward.y = 0; Vector3 aRight = objectA.right; aRight.y = 0; // 计算方向点积（自动处理向量长度） float forwardDot = Vector3.Dot(aToB.normalized, aForward.normalized); float rightDot = Vector3.Dot(aToB.normalized, aRight.normalized); // 精确角度计算版本 float angle = Vector3.Angle(aForward, aToB); // 基本方位判断 bool isFront = forwardDot &gt; 0; bool isBack = forwardDot &lt; 0; bool isRight = rightDot &gt; 0; bool isLeft = rightDot &lt; 0; // 精确方位判断（45度扇形区） bool inFrontSector = angle &lt;= angleThreshold; bool inRightSector = Vector3.Angle(aRight, aToB) &lt;= angleThreshold; Debug.Log($&quot;前方: &#123;isFront&#125; | 后方: &#123;isBack&#125;\\n&quot; + $&quot;右侧: &#123;isRight&#125; | 左侧: &#123;isLeft&#125;\\n&quot; + $&quot;前扇形区: &#123;inFrontSector&#125; | 右扇形区: &#123;inRightSector&#125;&quot;); // 计算八个方向识别 bool isFrontRight = forwardDot &gt; 0 &amp;&amp; rightDot &gt; 0; bool isFrontLeft = forwardDot &gt; 0 &amp;&amp; rightDot &lt; 0; // 距离综合判断 float distance = aToB.magnitude; bool inRange = distance &lt; 5f; // 5米范围内 // 运动方向预测（需记录上一帧位置） Vector3 velocity = (objectB.position - lastPosition) / Time.deltaTime; lastPosition = objectB.position; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using System.Collections;using System.Collections.Generic;using UnityEngine;public class Lesson08_练习题 : MonoBehaviour&#123; //拖拽得到AB位置变量 public Transform A; public Transform B; //点乘接过和叉乘结果变量 private float dotResult; private Vector3 crossResult; void Update() &#123; #region 练习题一 //判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位 //计算 A位置向量和AB方向差向量 点乘和叉乘结果 dotResult = Vector3.Dot(A.forward, B.position - A.position); crossResult = Vector3.Cross(A.forward, B.position - A.position); //根据点乘和叉乘的值判断前后左右 if (dotResult &gt;= 0) &#123; //右侧 if (crossResult.y &gt;= 0) &#123; print(&quot;右前&quot;); &#125; //左侧 else &#123; print(&quot;左前&quot;); &#125; &#125; else &#123; //右侧 if (crossResult.y &gt;= 0) &#123; print(&quot;右后&quot;); &#125; //左侧 else &#123; print(&quot;左后&quot;); &#125; &#125; // 练习题二 //当一个物体B在物体A左前方20度角或右前方30度范围内，并且离A只有5米距离时，在控制台打印“发现入侵者” //计算叉乘 用于判断左边还是右边 crossResult = Vector3.Cross(A.forward, B.position - A.position); //判断距离 if (Vector3.Distance(A.position, B.position) &lt;= 5) &#123; //A左前方20度角或右前方30度范围内 if (crossResult.y &gt;= 0 &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= 30 || crossResult.y &lt; 0 &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= 20) &#123; print(&quot;发现入侵者&quot;); &#125; &#125; &#125;&#125; 插值实现摄像机跟随123456789// 如果当前摄像机的目标位置不是目标对象的后方4米，向上偏7米 就设置目标位置 记录摄像机当前开始位置 重置时间if (cameraTargetPos != target.position + -target.forward * zOffect + target.up * yOffect)&#123; cameraTargetPos = target.position + -target.forward * zOffect + target.up * yOffect; startPos = this.transform.position; time = 0;&#125;time += Time.deltaTime;this.transform.position = Vector3.Lerp(startPos, cameraTargetPos, time * moveSpeed); 球形插值模拟太阳轨迹123456private void Update()&#123; time2 += Time.deltaTime; // sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10, time2 * 0.1f);//假如直接写最终值会不知道从哪里转 可能会平这转 sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10 + Vector3.up * 0.1f, time2 * 0.1f);//要给最终值加一点向上的向量 才会往上转&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"3.坐标系","slug":"游戏引擎/unity/unity基础/3.坐标系","date":"2025-03-01T07:57:07.000Z","updated":"2025-03-02T03:01:44.817Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/3.坐标系/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/","excerpt":"","text":"世界坐标系 this.transform.position-返回物体在世界坐标系中的位置 this.transform.rotation-返回物体在世界坐标系中的旋转四元数 this.transform.eulerAngles-返回物体在世界坐标系中的欧拉角 this.transform.lossyScale-返回物体在世界坐标系中的缩放 修改它们将导致相对于世界坐标系的变化 物体坐标系 this.transform.localPosition-返回物体在其父对象坐标系中的位置 this.transform.localEulerAngles-返回物体在其父对象坐标系中的旋转四元数 this.transform.localRotation-返回物体在其父对象坐标系中的欧拉角 this.transform.localScale-返回物体在其父对象坐标系中的缩放 修改它们将导致相对于父对象物体坐标系的变化 屏幕坐标系 Input.mousePosition-返回鼠标在屏幕坐标系中的位置 Screen.width-返回屏幕坐标系的宽度 Screen.height-返回屏幕坐标系的高度 currentResolution当前屏幕的分辨率为 视口坐标系 坐标转换点与向量在本地与世界之间的来回转换 世界转本地this.transform.InverseTransformDirection 将世界空间中的方向向量转换为本地空间中的方向向量。12Vector3 worldDirection = new Vector3(1, 0, 0);Vector3 localDirection = this.transform.InverseTransformDirection(worldDirection); // (不受缩放影响 this.transform.InverseTransformPoint 将世界空间中的点转换为本地空间中的点。12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 localPoint = this.transform.InverseTransformPoint(worldPoint); this.transform.InverseTransformVector 将世界空间中的向量转换为本地空间中的向量。12Vector3 worldVector = new Vector3(2, 1, 0);Vector3 localVector = this.transform.InverseTransformVector(worldVector); // (受缩放影响 本地转世界this.transform.TransformDirection 将本地空间中的方向向量转换为世界空间中的方向向量。12Vector3 localDirection = new Vector3(0, 1, 0);Vector3 worldDirection = this.transform.TransformDirection(localDirection);// (不受缩放影响 this.transform.TransformPoint 将本地空间中的点转换为世界空间中的点。12Vector3 localPoint = new Vector3(2, 3, 1);Vector3 worldPoint = this.transform.TransformPoint(localPoint); this.transform.TransformVector 将本地空间中的向量转换为世界空间中的向量。12Vector3 localVector = new Vector3(1, 0, 0);Vector3 worldVector = this.transform.TransformVector(localVector); // (受缩放影响 世界转屏幕Camera.main.WorldToScreenPoint 将世界空间中的点转换为屏幕空间中的点。12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 screenPoint = Camera.main.WorldToScreenPoint(worldPoint); 屏幕转世界Camera.main.ScreenToWorldPoint 将屏幕空间中的点转换为世界空间中的点。12Vector3 screenPoint = new Vector3(100, 200, 0);Vector3 worldPoint = Camera.main.ScreenToWorldPoint(screenPoint); 世界转视口Camera.main.WorldToViewportPoint 将世界空间中的点转换为视口空间中的点。12Vector3 worldPoint = new Vector3(5, 2, 3);Vector3 viewportPoint = Camera.main.WorldToViewportPoint(worldPoint); 视口转世界Camera.main.ViewportToWorldPoint 将视口空间中的点转换为世界空间中的点。12Vector3 viewportPoint = new Vector3(0.5f, 0.5f, 0);Vector3 worldPoint = Camera.main.ViewportToWorldPoint(viewportPoint); 视口转屏幕Camera.main.ViewportToScreenPoint 将视口空间中的点转换为屏幕空间中的点。12Vector3 viewportPoint = new Vector3(0.5f, 0.5f, 0);Vector3 screenPoint = Camera.main.ViewportToScreenPoint(viewportPoint); 屏幕转视口Camera.main.ScreenToViewportPoint 将屏幕空间中的点转换为视口空间中的点。12Vector3 screenPoint = new Vector3(100, 200, 0);Vector3 viewportPoint = Camera.main.ScreenToViewportPoint(screenPoint);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"2.Mathf数学计算结构体常用方法","slug":"游戏引擎/unity/unity基础/2.Mathf数学计算结构体常用方法","date":"2025-03-01T06:51:42.000Z","updated":"2025-03-02T03:01:47.531Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/2.Mathf数学计算结构体常用方法/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Mathf和Math Math是C#中封装好的用于数学计算的工具类，位于System命名空间中。 Mathf是Unity中封装好的用于数学计算的工具结构体，位于UnityEngine命名空间中。 他们都是提供来用于进行数学相关计算的。 Mathf和Math的区别 Mathf 和 Math中的相关方法几乎一样。 Math - C#自带数学库，提供基本的数学计算方法。 Mathf - Unity专门针对游戏开发增强的数学库，包含了Math中的方法，并添加了一些适用于游戏开发的方法。 Mathf中的常用方法PI常量 获取圆周率π12// 众所周知的“3.14159265358979...”值（只读）。print(Mathf.PI);//3.141593 Abs静态方法 取绝对值1234// 返回 f 的绝对值。print(Mathf.Abs(-10));//10print(Mathf.Abs(-20));//20print(Mathf.Abs(1));//1 CeilToInt静态方法 向上取整123456// 返回大于或等于 f 的最小整数。float f = 1.3f;int i = (int)f;print(i);//1print(Mathf.CeilToInt(f));//2print(Mathf.CeilToInt(1.00001f));//2 FloorToInt静态方法 向下取整12// 返回小于或等于 f 的最大整数。print(Mathf.FloorToInt(9.6f));//9 Clamp静态方法 钳制函数12345// 在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值。// 比最小还小，就取最小，比最大还大，就取最大，两者之间，就取本身print(Mathf.Clamp(10, 11, 20));//11print(Mathf.Clamp(21, 11, 20));//20print(Mathf.Clamp(15, 11, 20));//15 Max静态方法 获取最大值1234// 返回两个或更多值中的最大值。// 内部有一个可变长的参数print(Mathf.Max(1, 2, 3, 4, 5, 6, 7, 8));//8print(Mathf.Max(1, 2));//2 Min静态方法 获取最小值1234// 返回两个或更多值中的最小值。// 内部有一个可变长的参数print(Mathf.Min(1, 2, 3, 4, 545, 6, 1123, 123));//1print(Mathf.Min(1.1f, 0.4f));//0.4 Pow静态方法 一个数的n次幂123// 返回 f 的 p 次幂。print(&quot;一个数的n次方&quot; + Mathf.Pow(4, 2));//16print(&quot;一个数的n次方&quot; + Mathf.Pow(2, 3));//8 RoundToInt静态方法 四舍五入123// 返回舍入为最近整数的 / f /。print(&quot;四舍五入&quot; + Mathf.RoundToInt(1.3f));//1print(&quot;四舍五入&quot; + Mathf.RoundToInt(1.5f));//2 Sqrt静态方法 返回一个数的平方根1234// 返回 f 的平方根。print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(4));//2print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(16));//4print(&quot;返回一个数的平方根&quot; + Mathf.Sqrt(64));//8 IsPowerOfTwo静态方法 判断一个数是否是2的n次方12345// 如果值是 2 的幂，则返回 true。print(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(4));//trueprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(8));//trueprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(3));//falseprint(&quot;判断一个数是否是2的n次方&quot; + Mathf.IsPowerOfTwo(1));//true Sign静态方法 判断正负数1234567// 返回 f 的符号。// 正数和0就返回1，负数就返回-1print(&quot;判断正负数&quot; + Mathf.Sign(0));//1print(&quot;判断正负数&quot; + Mathf.Sign(10));//1print(&quot;判断正负数&quot; + Mathf.Sign(-10));//-1print(&quot;判断正负数&quot; + Mathf.Sign(3));//1print(&quot;判断正负数&quot; + Mathf.Sign(-2));//-1 插值运算Lerp : result = Mathf.Lerp(start, end, t);t为插值系数 取值范围[0, 1]result = start + (end - start) * t; 123456789101112// t不变，起点不断变化// 用法1 先快后慢, 无限趋近10float start = 1;start = Mathf.Lerp(start, 10, Time.deltaTime);// 起点不变，时间t匀速变化// 用法2 匀速变化float start = 1; float time = 0, result = 0;time += Time.deltaTime;result = Mathf.Lerp(start, 10, time); Rad2Deg常量 弧度转角度的常量1234// 弧度到度换算常量（只读）。float rad = 1;float anger = rad * Mathf.Rad2Deg;print(anger);//57.29578f; Deg2Rad常量 角度转弧度的常量1234// 度到弧度换算常量（只读）。anger = 1;rad = anger * Mathf.Deg2Rad;print(rad);//0.01745329 Unity中的三角函数注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值 Sin静态方法 计算正弦函数12// 返回角度 f 的正弦。print(Mathf.Sin(30 * Mathf.Deg2Rad));//0.5 Cos静态方法 计算余弦函数12// 返回角度 f 的余弦。print(Mathf.Cos(60 * Mathf.Deg2Rad));//0.5 注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度 Asin静态方法 反正弦函数123// 返回 f 的反正弦 - 其正弦为 f 的角度（以弧度为单位）。rad = Mathf.Asin(0.5f);print(rad * Mathf.Rad2Deg);//30 Acos静态方法 反余弦函数123// 返回 f 的反余弦 - 其余弦为 f 的角度（以弧度为单位）。rad = Mathf.Acos(0.5f);print(rad * Mathf.Rad2Deg);//60 练习使用插值实现一个方块跟随另一个方块移动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这个脚本将要挂载到方块A上 实现方块A跟随着方块Bpublic class Lesson02_练习题 : MonoBehaviour&#123; //要跟随的对象B public Transform B; //移动速度 public float moveSpeed; //位置中介 private Vector3 pos; //B当前的位置 private Vector3 bNowPos; //开始位置 private Vector3 startPos; //匀速运动累加的时间 private float time; //模式 public int mode = 1; void Update() &#123; if(mode == 1) &#123; //第一种 就是 先快后慢的形式 //记录当前这一帧A的位置 pos = this.transform.position; //传入这一帧A的位置算出下一帧A的位置 pos.x = Mathf.Lerp(pos.x, B.position.x, Time.deltaTime * moveSpeed); pos.y = Mathf.Lerp(pos.y, B.position.y, Time.deltaTime * moveSpeed); pos.z = Mathf.Lerp(pos.z, B.position.z, Time.deltaTime * moveSpeed); //算出下一帧A的位置赋值给A this.transform.position = pos; &#125; else if(mode == 2) &#123; //第二种 就是 匀速运动 //发现存储的B的位置不等于当前B的位置 if (bNowPos != B.transform.position) &#123; //清空时间 重写设置B的位置 开始位置是A当前的位置 time = 0; bNowPos = B.transform.position; startPos = this.transform.position; &#125; //时间每一帧运算累加 time += Time.deltaTime; //startPos和bNowPos其实定死了 只有time在变化 传入算出下一帧A的位置 pos.x = Mathf.Lerp(startPos.x, bNowPos.x, time * moveSpeed); pos.y = Mathf.Lerp(startPos.y, bNowPos.y, time * moveSpeed); pos.z = Mathf.Lerp(startPos.z, bNowPos.z, time * moveSpeed); //算出下一帧A的位置赋值给A this.transform.position = pos; &#125; &#125; private void OnGUI() &#123; if(GUI.Button(new Rect(0, 0, 200, 200), &quot;切换模式&quot;)) &#123; mode = 3 - mode; &#125; &#125;&#125; 实现一个物体按照曲线移动（正弦或余弦）1234567891011121314151617181920public class MathfTest : MonoBehaviour&#123; // 向前移动速度 public float moveSpeed = 5; // 振幅 public float changeSize = 10; // 频率 public float changeSpeed = 5; // 时间 public float time = 0; private void Update() &#123; this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); time += Time.deltaTime; this.transform.Translate(Vector3.right * Mathf.Sin(time * changeSpeed) * changeSize * Time.deltaTime); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"}]},{"title":"1.unity基础概述","slug":"游戏引擎/unity/unity基础/1.unity基础概述","date":"2025-03-01T06:43:09.000Z","updated":"2025-03-01T06:47:12.464Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity基础/1.unity基础概述/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"}]},{"title":"4.模型自资源的导入","slug":"游戏引擎/unity/unity入门/unity入门实践项目/4.模型自资源的导入","date":"2025-03-01T06:37:18.000Z","updated":"2025-03-01T06:40:34.472Z","comments":true,"path":"2025/03/01/游戏引擎/unity/unity入门/unity入门实践项目/4.模型自资源的导入/","permalink":"http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"泛型委托和泛型接口の协变和逆变","slug":"编程语言/Csharp/泛型委托和泛型接口の协变和逆变","date":"2025-03-01T02:26:27.000Z","updated":"2025-03-01T06:36:44.841Z","comments":true,"path":"2025/03/01/编程语言/Csharp/泛型委托和泛型接口の协变和逆变/","permalink":"http://example.com/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/","excerpt":"","text":"逆变与协变详解 - zhangweiwen - 博客园 (cnblogs.com) 协变和逆变是用来修饰泛型类型参数T的协变：out 表明修饰的T只能作为返回值来使用逆变：in 表明修饰的T只能作为参数来使j用只有泛型接口和泛型委托能使用 协变（Foo&lt;父类&gt; = Foo&lt;子类&gt; ）典型场景：生产者（输出数据），如返回值、只读集合。 12345678910111213141516171819202122232425262728293031//泛型委托：public delegate T MyFuncA&lt;T&gt;();//不支持逆变与协变public delegate T MyFuncB&lt;out T&gt;();//支持协变 MyFuncA&lt;object&gt; funcAObject = null;MyFuncA&lt;string&gt; funcAString = null;MyFuncB&lt;object&gt; funcBObject = null;MyFuncB&lt;string&gt; funcBString = null;MyFuncB&lt;int&gt; funcBInt = null; funcAObject = funcAString;//编译失败，MyFuncA不支持逆变与协变funcBObject = funcBString;//变了，协变funcBObject = funcBInt;//编译失败，值类型不参与协变或逆变 //泛型接口public interface IFlyA&lt;T&gt; &#123; &#125;//不支持逆变与协变public interface IFlyB&lt;out T&gt; &#123; &#125;//支持协变 IFlyA&lt;object&gt; flyAObject = null;IFlyA&lt;string&gt; flyAString = null;IFlyB&lt;object&gt; flyBObject = null;IFlyB&lt;string&gt; flyBString = null;IFlyB&lt;int&gt; flyBInt = null; flyAObject = flyAString;//编译失败，IFlyA不支持逆变与协变flyBObject = flyBString;//变了，协变flyBObject = flyBInt;//编译失败，值类型不参与协变或逆变 //数组：string[] strings = new string[] &#123; &quot;string&quot; &#125;;object[] objects = strings; 逆变（Foo&lt;子类&gt; = Foo&lt;父类&gt;）典型场景：消费者（输入数据），如函数参数、写入操作。 12345678910111213141516171819public delegate void MyActionA&lt;T&gt;(T param);//不支持逆变与协变public delegate void MyActionB&lt;in T&gt;(T param);//支持逆变 public interface IPlayA&lt;T&gt; &#123; &#125;//不支持逆变与协变public interface IPlayB&lt;in T&gt; &#123; &#125;//支持逆变 MyActionA&lt;object&gt; actionAObject = null;MyActionA&lt;string&gt; actionAString = null;MyActionB&lt;object&gt; actionBObject = null;MyActionB&lt;string&gt; actionBString = null;actionAString = actionAObject;//MyActionA不支持逆变与协变,编译失败actionBString = actionBObject;//变了，逆变 IPlayA&lt;object&gt; playAObject = null;IPlayA&lt;string&gt; playAString = null;IPlayB&lt;object&gt; playBObject = null;IPlayB&lt;string&gt; playBString = null;playAString = playAObject;//IPlayA不支持逆变与协变,编译失败playBString = playBObject;//变了，逆变 注意: 当前仅支持接口和委托的逆变与协变 ，不支持类和方法。但数组也有协变性。 值类型不参与逆变与协变。 12345678910public interface Base&lt;T&gt;&#123; T Test(T param);&#125;public class Sub&lt;T&gt; : Base&lt;T&gt;&#123; public T Test(T param) &#123; return default(T); &#125;&#125;Base&lt;string&gt; b = new Sub&lt;string&gt;();b.Test(&quot;你好&quot;); 在上面的例子中，b里面的实例是Sub&lt;string&gt; b.Test(&quot;你好&quot;)会把参数 “你好” 传入到Sub里面执行方法 即调用父类的方法，其实实际是调用子类的方法。可以看到，这个方法能够安全的调用，需要两个条件： 变式（父）的方法参数能安全转为原式（子）的参数； 原式（子）的返回值能安全的转为变式的返回值。 1234Base&lt;object&gt; BaseObject = null;Base&lt;string&gt; BaseString = null;BaseObject = BaseString;//编译失败BaseObject.Test(&quot;&quot;); 这里的“实际流程”如下，可以看到，参数那里是object是不能安全转换为string，所以编译失败： 看到这里如果都明白的话，我们不难得到逆变与协变的”实际流程图”（记住，它们是有in/out限制的）: 稍微难一点的问题下面哪个正确？12345678910111213public interface IBar&lt;in T&gt; &#123; &#125;//应该是inpublic interface IFoo&lt;in T&gt;&#123; void Test(IBar&lt;T&gt; bar);&#125;//还是outpublic interface IFoo&lt;out T&gt;&#123; void Test(IBar&lt;T&gt; bar);&#125; 答案是，如果是in的话，会编译失败，out才正确（当然不要泛型修饰符也能通过编译，但IFoo就没有协变能力了）。这里的意思就是说，一个有协变（逆变）能力的泛型（IBar），作为另一个泛型（IFoo）的参数时，影响到了它（IFoo）的泛型的定义。乍一看以为是in的其中一个陷阱是T是在Test方法的参数里的，所以以为是in。但这里Test的参数根本不是T，而是IBar&lt;T&gt;。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp事件","slug":"编程语言/Csharp/csharp事件","date":"2025-02-28T11:31:10.000Z","updated":"2025-03-01T03:26:04.293Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp事件/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"什么是事件？事件的核心是：当某件事发生时，自动通知所有关心它的人。在 C# 中，事件是一种机制，允许一个对象（发布者）在特定动作发生时，通知其他对象（订阅者）执行某些代码。 事件的核心三要素 发布者（Publisher）：定义事件并触发它 订阅者（Subscriber）：注册事件处理方法 事件处理方法（Handler）：当事件发生时执行的代码 游戏开发高频场景 场景 事件用法 代码灵魂示例 角色受伤 触发UI血条更新、音效、伤害数字 player.OnHurt += UpdateHealthBar; 敌人死亡 触发掉落物品、任务进度更新、成就解锁 enemy.OnDeath += DropLoot; 技能释放 触发特效、冷却计时、连击计数 skill.OnCast += PlayVFX; 游戏状态切换 暂停/继续、关卡加载完成、游戏结束 GameManager.OnPause += FreezeEnemies; UI交互 按钮点击、菜单打开/关闭、道具拖动 button.OnClick += OpenInventory; 代码示例角色受伤触发UI血条更新、音效、伤害数字 第一步：定义事件参数类（传递伤害值）为什么事件参数要继承 EventArgs？ 这是一个约定，保持代码统一性。 如果需要传递数据，推荐使用自定义的 EventArgs 子类。 EventArgs 作用： 通过自定义参数类，把伤害值传递给所有监听者，避免每个系统单独查询角色状态123456789public class DamageEventArgs : EventArgs&#123; public int Damage &#123; get; &#125; // 需要传递的伤害值 public DamageEventArgs(int damage) &#123; Damage = damage; &#125;&#125; 第二步：创建角色类（事件发布者）EventHandler&lt;T&gt; 委托 是 .NET 内置的泛型委托，无需自己定义。 签名：void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e)。 sender：触发事件的对象（通常是发布者自己）。 e：事件参数（传递额外数据）。 事件名称以 On 开头（如 OnClick）。1234567891011121314151617public class Character&#123; // 声明事件（使用自定义的EventArgs） public event EventHandler&lt;DamageEventArgs&gt; Damaged; public void TakeDamage(int damage) &#123; // 触发事件的通用写法 OnDamaged(new DamageEventArgs(damage)); &#125; // 触发事件 protected virtual void OnDamaged(DamageEventArgs e) &#123; Damaged?.Invoke(this, e); &#125;&#125; 第三步：创建各种事件订阅者12345678910111213141516171819202122232425262728293031323334353637// UI血条控制器public class UIHealthBar&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 更新血条 public void OnCharacterDamaged(object sender, DamageEventArgs e) &#123; UpdateHealthBar(e.Damage); Debug.Log($&quot;血条更新：减少&#123;e.Damage&#125;HP&quot;); &#125; private void UpdateHealthBar(int damage) &#123; /* 实际血条逻辑 */ &#125;&#125;// 音效系统public class SoundSystem&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 播放受伤音效 public void PlayHurtSound(object sender, DamageEventArgs e) &#123; Audio.Play(&quot;受伤音效&quot;); Debug.Log(&quot;播放受伤音效&quot;); &#125;&#125;// 伤害数字系统public class DamageNumbers&#123; // 别人sender发来通知，并携带了e的参数，你要做的事如下： 显示上海数字 public void ShowDamagePopup(object sender, DamageEventArgs e) &#123; CreateFloatingText(e.Damage); Debug.Log($&quot;显示伤害数字：&#123;e.Damage&#125;&quot;); &#125; private void CreateFloatingText(int damage) &#123; /* 数字弹窗逻辑 */ &#125;&#125; 第四步：连接事件订阅12345678910// 初始化所有对象Character player = new Character();UIHealthBar ui = new UIHealthBar();SoundSystem sound = new SoundSystem();DamageNumbers numbers = new DamageNumbers();// 订阅事件（+= 添加监听）player.Damaged += ui.OnCharacterDamaged;player.Damaged += sound.PlayHurtSound;player.Damaged += numbers.ShowDamagePopup; 第五步：触发事件1234567// 当玩家受到伤害时player.TakeDamage(50);// 输出结果：// 血条更新：减少50HP// 播放受伤音效// 显示伤害数字：50 事件与委托的区别 特性 委托（Delegate） 事件（Event） 访问权限 可直接调用或赋值（=） 只能在类内部触发（Invoke） 多播（Multicast） 支持（+=/-=） 支持（本质是委托的封装） 封装性 低（外部可任意修改委托链） 高（外部只能订阅/取消订阅） 典型用途 通用回调机制 发布-订阅模式的通知机制","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp表达式体","slug":"编程语言/Csharp/csharp表达式体","date":"2025-02-28T10:17:19.000Z","updated":"2025-02-28T10:32:37.134Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp表达式体/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93/","excerpt":"","text":"表达式体（Expression-bodied members）是 C# 6.0 及更高版本引入的特性，它允许用简洁的 =&gt; 语法替代传统代码块，适用于方法、属性、构造函数等成员。 注意：csharp的Lambda表达式（核心是创建匿名函数）表达式体成员（核心是简写方法体） 综合示例123456789101112131415161718public class Calculator &#123; // 只读属性 public string Model =&gt; &quot;Scientific-Calculator-3000&quot;; // 方法 public double Square(double x) =&gt; x * x; // 索引器 private double[] _history = new double[10]; public double this[int index] =&gt; _history[index]; // 构造函数 public Calculator(string model) =&gt; Model = model; // 运算符重载 public static Calculator operator +(Calculator a, Calculator b) =&gt; new Calculator($&quot;&#123;a.Model&#125;+&#123;b.Model&#125;&quot;);&#125; 方法（Methods）用 =&gt; 替代 &#123;&#125;，适用于单行返回值的方法。1234567// 传统写法public int Add(int a, int b) &#123; return a + b;&#125;// 表达式体写法public int Add(int a, int b) =&gt; a + b; 只读属性（Read-Only Properties）直接返回计算结果的属性（仅有 get 访问器）。1234567// 传统写法public string FullName &#123; get &#123; return $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; &#125;&#125;// 表达式体写法public string FullName =&gt; $&quot;&#123;FirstName&#125; &#123;LastName&#125;&quot;; 构造函数/析构函数（C# 7.0+）单行初始化或清理逻辑。12345678910// 构造函数public class Person &#123; public string Name &#123; get; &#125; public Person(string name) =&gt; Name = name; // 初始化&#125;// 析构函数public class Resource &#123; ~Resource() =&gt; Console.WriteLine(&quot;资源已释放&quot;); // 清理逻辑&#125; 索引器（Indexers）简化索引器的 get 访问器。123456789private string[] _data = new string[10];// 传统写法public string this[int index] &#123; get &#123; return _data[index]; &#125;&#125;// 表达式体写法public string this[int index] =&gt; _data[index]; 属性访问器（C# 7.0+）对 get 和 set 访问器分别使用表达式体。12345678910111213private string _name;// 传统写法public string Name &#123; get &#123; return _name; &#125; set &#123; _name = value; &#125;&#125;// 表达式体写法public string Name &#123; get =&gt; _name; set =&gt; _name = value ?? throw new ArgumentNullException();&#125; 事件访问器（C# 7.0+）简化事件的 add 和 remove 逻辑。12345678910111213private EventHandler _myEvent;// 传统写法public event EventHandler MyEvent &#123; add &#123; _myEvent += value; &#125; remove &#123; _myEvent -= value; &#125;&#125;// 表达式体写法public event EventHandler MyEvent &#123; add =&gt; _myEvent += value; remove =&gt; _myEvent -= value;&#125; 运算符重载（Operator Overloading）简化运算符的实现。1234567891011121314public class Vector &#123; public int X &#123; get; &#125; public int Y &#123; get; &#125; public Vector(int x, int y) =&gt; (X, Y) = (x, y); // 传统运算符重载 public static Vector operator +(Vector a, Vector b) &#123; return new Vector(a.X + b.X, a.Y + b.Y); &#125; // 表达式体写法 public static Vector operator +(Vector a, Vector b) =&gt; new(a.X + b.X, a.Y + b.Y);&#125; throw 表达式（C# 7.0+）直接在表达式中抛出异常。1234567891011// 参数校验public string GetName(string input) =&gt; input ?? throw new ArgumentNullException(nameof(input));// 替代传统写法：public string GetName(string input) &#123; if (input == null) &#123; throw new ArgumentNullException(nameof(input)); &#125; return input;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp的Lambda表达式","slug":"编程语言/Csharp/csharp的Lambda表达式","date":"2025-02-28T02:38:33.000Z","updated":"2025-02-28T10:33:14.120Z","comments":true,"path":"2025/02/28/编程语言/Csharp/csharp的Lambda表达式/","permalink":"http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"在C#中，Lambda表达式是一种简洁的匿名函数，用于创建委托或表达式树类型。 Lambda表达式的基本形式Lambda表达式分为两种形式： 表达式Lambda仅包含单个表达式，无需大括号，自动返回结果。1234(参数列表) =&gt; 表达式Func&lt;int, int&gt; square = x =&gt; x * x;Console.WriteLine(square(5)); // 输出 25 语句块Lambda包含多行语句，需用大括号包裹，显式使用return（若有返回值）。12345678910(参数列表) =&gt; &#123; 语句块; return 结果; &#125;Action&lt;string&gt; greet = name =&gt; &#123; string message = $&quot;Hello, &#123;name&#125;!&quot;; Console.WriteLine(message);&#125;;greet(&quot;Alice&quot;); // 输出 &quot;Hello, Alice!&quot; Lambda表达式的简写注意和csharp表达式体的区别 简化1：自动类型推断当委托类型明确时，参数类型可省略： (int x) =&gt; ... → x =&gt; ...123Func&lt;int, int&gt; doubler = (x) =&gt; &#123; return x * 2; &#125;; 简化2：单参数可省略括号若只有一个参数，()可省略： (x) =&gt; ... → x =&gt; ...123Func&lt;int, int&gt; doubler = x =&gt; &#123; return x * 2; &#125;; 简化3：单行表达式自动返回若主体是单行表达式，可省略&#123;&#125;和return： x =&gt; &#123; return x*2; &#125; → x =&gt; x*21Func&lt;int, int&gt; doubler = x =&gt; x * 2; 注意事项12345678910111213// 多参数必须保留括号：Func&lt;int, int, int&gt; add = (a, b) =&gt; a + b; // 正确Func&lt;int, int, int&gt; add = a, b =&gt; a + b; // 错误！ // 无参数时需空括号:Action printHello = () =&gt; Console.WriteLine(&quot;Hello&quot;);// 复杂逻辑仍需代码块：Action log = () =&gt; &#123; Console.WriteLine(&quot;Start&quot;); // 多行逻辑 Console.WriteLine(&quot;End&quot;);&#125;; Lambda的常见用途委托实例化 和 事件处理123Func&lt;int, int, int&gt; sum = (a, b) =&gt; a + b;Action&lt;string&gt; log = msg =&gt; Console.WriteLine(msg);button.Click += (sender, e) =&gt; MessageBox.Show(&quot;Clicked!&quot;); LINQ查询与LINQ方法结合，实现数据筛选、转换等操作：123var numbers = new List&lt;int&gt; &#123; 1, 2, 3, 4, 5 &#125;;var evenNumbers = numbers.Where(n =&gt; n % 2 == 0); // 筛选偶数var squares = numbers.Select(x =&gt; x * x); // 计算平方 表达式树（Expression Trees）将Lambda编译为表达式树，供其他框架（如EF Core）解析：1Expression&lt;Func&lt;int, bool&gt;&gt; expr = x =&gt; x &gt; 5; 闭包与变量捕获当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。 示例 1：基本闭包123456789Func&lt;int&gt; CreateCounter()&#123; int count = 0; return () =&gt; ++count; // 闭包捕获了外部变量 count&#125;var counter = CreateCounter();Console.WriteLine(counter()); // 输出 1Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态） 现象：count 本应在 CreateCounter 方法执行完毕后被销毁，但闭包保留了它的状态。 原理：编译器生成一个类，将 count 作为该类的字段存储，闭包通过这个类的实例访问 count。 示例 2：循环中的闭包陷阱123456789var actions = new List&lt;Action&gt;();for (int i = 0; i &lt; 3; i++)&#123; actions.Add(() =&gt; Console.WriteLine(i));&#125;foreach (var action in actions)&#123; action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）&#125; 问题原因：所有闭包共享同一个变量 i（在循环结束后，i 的值为 3）。 解决方案：在循环内部创建临时变量，让闭包捕获独立的值： 12345for (int i = 0; i &lt; 3; i++)&#123; int current = i; // 每次循环新建一个临时变量 actions.Add(() =&gt; Console.WriteLine(current)); // 输出 0, 1, 2&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"csharp委托","slug":"编程语言/Csharp/csharp委托","date":"2025-02-27T14:37:01.000Z","updated":"2025-03-01T03:21:55.888Z","comments":true,"path":"2025/02/27/编程语言/Csharp/csharp委托/","permalink":"http://example.com/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/","excerpt":"","text":"委托基本概念 定义：委托是类型安全的函数指针，通过 delegate 关键字声明。（ 委托就是一个用来装函数的类的类型） 作用：允许将方法作为参数传递、动态调用多个方法。 核心特点： 类型安全（编译时检查参数和返回值）。 支持多播（组合多个方法）。 可用于异步编程。 委托的声明与使用写在哪里？可以申明在namespace和class语句块中更多的写在namespace中 委托常用在： 作为类的成员 作为函数的参数 声明委托类型：123// 定义委托类型，指定方法签名// MathOperation是一个委托类型，只能引用接受两个 int 参数并返回 string 的方法。public delegate string MathOperation(int a, int b); 实例化委托：eg1：123456// 绑定到具体方法MathOperation add = (a, b) =&gt; a + b;MathOperation multiply = (a, b) =&gt; a * b;// 调用委托int result = add(3, 5); // 输出 8eg2：12345678public delegate int Fun(int a);static int MyFun1(int a) ...static int MyFun2(int a) ...Fun f = MyFun1;int tmp = f.Invoke(666);int tmp = f(666); 多播委托（Multicast Delegate） 功能：一个委托实例可绑定多个方法，按顺序执行。 操作符： += 添加方法。 -= 移除方法。 1234567MathOperation add = (a, b) =&gt; a + b;MathOperation multiply = (a, b) =&gt; a * b;MathOperation operations = add;operations += multiply;// 调用时会依次执行 add 和 multiplyint finalResult = operations(3, 5); // 返回 multiply 的结果 15（最后一个方法的返回值） 注意：返回值通常只保留最后一个方法的返回值，中间结果可能被覆盖。以下是一个示例，演示了如何获取多播委托每一个函数的返回值：12345678910111213141516171819202122232425262728293031323334using System;public delegate int MyDelegate();class Program&#123; static void Main() &#123; MyDelegate myDelegate = Method1; myDelegate += Method2; myDelegate += Method3; // 获取每一个函数的返回值 Delegate[] delegates = myDelegate.GetInvocationList(); foreach (var del in delegates) &#123; MyDelegate singleDelegate = (MyDelegate)del; int result = singleDelegate(); Console.WriteLine($&quot;Method returned: &#123;result&#125;&quot;); &#125; &#125; static int Method1() &#123; Console.WriteLine(&quot;Method1&quot;); return 1; &#125; static int Method2() &#123; Console.WriteLine(&quot;Method2&quot;); return 2; &#125; static int Method3() &#123; Console.WriteLine(&quot;Method3&quot;); return 3; &#125;&#125; 内置泛型委托Action：无返回值的方法，最多支持 16 个参数。12Action&lt;string&gt; log = message =&gt; Console.WriteLine(message);log(&quot;Hello, Action!&quot;); Func：有返回值的方法，最后一个类型参数为返回类型。12Func&lt;int, int, string&gt; formatSum = (a, b) =&gt; $&quot;&#123;a + b&#125;&quot;;Console.WriteLine(formatSum(3, 5)); // 输出 &quot;8&quot; 匿名方法匿名函数的使用主要是配合委托和事件进行使用何时使用？ 函数中传递委托参数时 委托或事件赋值时 缺点? 不能删的具体只能无脑null eg：12345678910111213141516171819202122232425262728293031323334 class Test&#123; public void Fun1(Action action) &#123; Console.WriteLine(&quot;需要委托作为参数的函数,使用函数更加方便&quot;); action(); &#125; public Action GetFun() &#123; return delegate () &#123; Console.WriteLine(&quot;匿名函数常用作返回值&quot;); &#125;; &#125;&#125;class Program&#123; static void Main(string[] args) &#123; // 匿名函数给委托赋值 Action a = delegate () &#123; Console.WriteLine(&quot;匿名函数逻辑&quot;); &#125;; Test t = new Test(); t.Fun1(a); t.GetFun()(); Func&lt;int, int&gt; b = delegate (int a) &#123; Console.WriteLine(&quot;匿名函数的返回值直接返回就行&quot;); return a; &#125;; &#125;&#125; csharp事件csharp的Lambda表达式泛型委托和泛型接口の协变和逆变","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"3.Unity随机数和UnityAction委托","slug":"游戏引擎/unity/unity入门/unity入门实践项目/3.Unity随机数和UnityAction委托","date":"2025-02-27T13:44:46.000Z","updated":"2025-02-28T10:39:30.253Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/3.Unity随机数和UnityAction委托/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.Unity%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8CUnityAction%E5%A7%94%E6%89%98/","excerpt":"","text":"unity当中的随机数用法1234int randomNum = Random.Range(0, 100); // [0, 100)// float重载，规则是左右都包含float randomNumF = Random.Range(1.1f, 99.9f); // [1.1~99.9f] CSharp中的随机数123// 左包含，右不包含System.Random random = new System.Random();random.Next(0, 100); // [0, 100) unity的委托要引用using UnityEngine.Events;命名空间 无参无返回的委托 123UnityAction uac = () =&gt;&#123;&#125;; string作为参数无返回值的委托 123UnityAction&lt;string&gt; uac1 = (s) =&gt;&#123;&#125;; csharp委托 无参无返回的委托123System.Action ac = () =&gt;&#123;&#125;; int和float作为参数无返回值的委托123System.Action&lt;int, float&gt; ac2 = (i, f) =&gt;&#123;&#125;; 无参int返回值的委托1234System.Func&lt;int&gt; fun1 = () =&gt;&#123; return 1;&#125;; int作为参数string作为返回值的委托1234System.Func&lt;int, string&gt; fun2 = (i) =&gt;&#123; return &quot;123&quot;;&#125;;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.鼠标的隐藏锁定图片","slug":"游戏引擎/unity/unity入门/unity入门实践项目/2.Cursor鼠标的隐藏锁定图片","date":"2025-02-27T13:35:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/2.Cursor鼠标的隐藏锁定图片/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.Cursor%E9%BC%A0%E6%A0%87%E7%9A%84%E9%9A%90%E8%97%8F%E9%94%81%E5%AE%9A%E5%9B%BE%E7%89%87/","excerpt":"","text":"Cursor.visible静态变量 设置鼠标显隐12// 隐藏鼠标Cursor.visible = false; Cursor.lockState静态变量 设置鼠标锁定状态确定硬件指针是否锁定到视图的中心、受限于窗口或者根本不受限制。 None: 不锁定鼠标 Locked: 锁定鼠标。鼠标会被限制在屏幕的中心点，不仅会被锁定，还会被隐藏。可以通过按下ESC键摆脱编辑模式下的锁定。要是回到Game窗口点击鼠标会被再次锁定隐藏。 Confined: 限制鼠标在Game窗口范围内。可以通过按下ESC键摆脱编辑模式下的限制。要是回到Game窗口点击鼠标会被再次限制。1Cursor.lockState = CursorLockMode.Confined; Cursor.SetCursor静态方法 设置鼠标图片将鼠标光标设置为给定纹理。参数一：光标图片参数二：偏移位置，相对图片左上角参数三：平台支持的光标模式（硬件或软件）（一般选CursorMode.Auto）123public Texture2D cursorTexture2D;Cursor.SetCursor(cursorTexture2D, Vector2.zero, CursorMode.Auto);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.场景切换和游戏退出","slug":"游戏引擎/unity/unity入门/unity入门实践项目/1.场景切换和游戏退出","date":"2025-02-27T13:28:07.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/游戏引擎/unity/unity入门/unity入门实践项目/1.场景切换和游戏退出/","permalink":"http://example.com/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E9%80%80%E5%87%BA/","excerpt":"","text":"场景切换按照 Build Settings 中的名称或索引加载场景。要引入using UnityEngine.SceneManagement;命名空间。直接写代码切换场景可能会报错。注意: 切换必须要将场景拖到Unity 中的file-BuildSetting的Scene列表中然后可用用代码来切换1ScenneManager.Load(&quot;scenename&quot;); 退出游戏退出播放器应用程序。执行这句代码就会退出游戏。但是在编辑模式下没有作用，一定是发布游戏过后才有用。12// 退出游戏Application.Quit();","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.自定义控件拼面板","slug":"UI系统/GUI/GUI实践项目/12.自定义控件拼面板","date":"2025-02-27T09:11:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/12.自定义控件拼面板/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/12.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E6%8B%BC%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"先拼面板 TestBeginPanel.cs1234567891011121314151617181920212223public class BeginPanel : MonoBehaviour&#123; public CustomGUIButton btnBegin; public CustomGUIButton btnEnd; public CustomGUIButton btnQuit; void Start() &#123; btnBegin.clickEvent += () =&gt; &#123; Debug.Log(&quot;Begin&quot;); &#125;; btnEnd.clickEvent += () =&gt; &#123; Debug.Log(&quot;End&quot;); &#125;; btnQuit.clickEvent += () =&gt; &#123; this.gameObject.SetActive(false); &#125;; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.自定义图片绘制","slug":"UI系统/GUI/GUI实践项目/11.自定义图片绘制","date":"2025-02-27T09:01:50.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/11.自定义图片绘制/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/11.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6/","excerpt":"","text":"CustomGUITexture.cs12345678910111213public class CustomGUITexture : CustomGUIControl&#123; // 方便外部缩放模式调整 public ScaleMode mode = ScaleMode.StretchToFill; protected override void DrawIsOff() &#123; GUI.DrawTexture(guiPos.Pos, guiContent.image, mode); &#125; protected override void DrawIsOn() &#123; GUI.DrawTexture(guiPos.Pos, guiContent.image, mode); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"10.自定义输入框和拖动条","slug":"UI系统/GUI/GUI实践项目/10.自定义输入框和拖动条","date":"2025-02-27T08:49:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/10.自定义输入框和拖动条/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/10.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"CustomGUIInput.cs12345678910111213141516171819202122232425public class CustomGUIInput : CustomGUIControl&#123; // 当输入框变化时的事件 public event UnityAction&lt;string&gt; changeText; private string oldStr = &quot;&quot;; protected override void DrawIsOff() &#123; guiContent.text = GUI.TextField(guiPos.Pos, guiContent.text); // 当输入框变化时调用的委托函数 if (oldStr != guiContent.text) &#123; changeText?.Invoke(guiContent.text); oldStr = guiContent.text; &#125; &#125; protected override void DrawIsOn() &#123; guiContent.text = GUI.TextField(guiPos.Pos, guiContent.text, style); if (oldStr != guiContent.text) &#123; changeText?.Invoke(guiContent.text); oldStr = guiContent.text; &#125; &#125;&#125; CustomGUISlide.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public enum E_Slider_Type&#123; Horizontal, Vertical,&#125;public class CustomGUISlide : CustomGUIControl&#123; public float minValue = 0; public float maxValue = 1; public float nowValue = 0; public E_Slider_Type sliderType = E_Slider_Type.Horizontal; // 默认的style是条的, 这里还需要滑块的style public GUIStyle styleThumb; public event UnityAction&lt;float&gt; changeValue; private float oldValu e; protected override void DrawIsOff() &#123; switch (sliderType) &#123; case E_Slider_Type.Horizontal: nowValue = GUI.HorizontalSlider(guiPos.Pos, nowValue, minValue, maxValue); break; case E_Slider_Type.Vertical: nowValue = GUI.VerticalSlider(guiPos.Pos, nowValue, minValue, maxValue); break; &#125; if (oldValue != nowValue) &#123; changeValue?.Invoke(nowValue); oldValue = nowValue; &#125; &#125; protected override void DrawIsOn() &#123; switch (sliderType) &#123; case E_Slider_Type.Horizontal: nowValue = GUI.HorizontalSlider(guiPos.Pos, nowValue, minValue, maxValue, style, styleThumb); break; case E_Slider_Type.Vertical: nowValue = GUI.VerticalSlider(guiPos.Pos, nowValue, minValue, maxValue, style, styleThumb); break; &#125; if (oldValue != nowValue) &#123; changeValue?.Invoke(nowValue); oldValue = nowValue; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"9.自定义单选框","slug":"UI系统/GUI/GUI实践项目/9.自定义单选框","date":"2025-02-27T07:47:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/9.自定义单选框/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/9.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E9%80%89%E6%A1%86/","excerpt":"","text":"回顾闭包当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。 示例 1：基本闭包123456789Func&lt;int&gt; CreateCounter()&#123; int count = 0; return () =&gt; ++count; // 闭包捕获了外部变量 count&#125;var counter = CreateCounter();Console.WriteLine(counter()); // 输出 1Console.WriteLine(counter()); // 输出 2（说明闭包修改并保留了 count 的状态） 现象：count 本应在 CreateCounter 方法执行完毕后被销毁，但闭包保留了它的状态。 原理：编译器生成一个类，将 count 作为该类的字段存储，闭包通过这个类的实例访问 count。 示例 2：循环中的闭包陷阱123456789var actions = new List&lt;Action&gt;();for (int i = 0; i &lt; 3; i++)&#123; actions.Add(() =&gt; Console.WriteLine(i));&#125;foreach (var action in actions)&#123; action(); // 输出 3, 3, 3（而非预期的 0, 1, 2）&#125; 问题原因：所有闭包共享同一个变量 i（在循环结束后，i 的值为 3）。 解决方案：在循环内部创建临时变量，让闭包捕获独立的值： 12345for (int i = 0; i &lt; 3; i++)&#123; int current = i; // 每次循环新建一个临时变量 actions.Add(() =&gt; Console.WriteLine(current)); // 输出 0, 1, 2&#125; CustomGUIToggleGroup.cs创建自定义单选框，添加多选框数组，通过管理多选框实现单选框，在添加一个记录上一次为true的toggle123456789101112131415161718192021222324252627282930313233343536public class CustomGUIToggleGroup : MonoBehaviour&#123; [SerializeField] private CustomGUIToggle[] _toggles; private CustomGUIToggle _frontTrueToggle； // 上一次为true的toggle // 注意只有游戏运行才能用 void Start() &#123; for (int i = 0; i &lt; _toggles.Length; i++) &#123; CustomGUIToggle tmp = _toggles[i]; // 为每个Toggle添加一个一旦其值为true时, 其它Toggle变为false的委托 // Lambda函数捕获了外部变量（tmp）!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! tmp.changeEvent += (value) =&gt; &#123; if (value) &#123; for (int j = 0; j &lt; _toggles.Length; j++) &#123; if (tmp != _toggles[j]) // 只要不是自己 &#123; _toggles[j].isSel = false; &#125; &#125; // 这里可以记录上一次为true的toggle _frontTrueToggle = tmp; &#125; else if (_frontTrueToggle == tmp) // 如果是上一次为true的toggle &#123; tmp.isSel = true; // 永远保持选中的状态 &#125; &#125;; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"8.自定义多选框","slug":"UI系统/GUI/GUI实践项目/8.自定义多选框","date":"2025-02-27T07:42:31.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/8.自定义多选框/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/8.%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E9%80%89%E6%A1%86/","excerpt":"","text":"CustomGUIToggle.cs12345678910111213141516171819202122232425262728public class CustomGUIToggle : CustomGUIControl&#123; // 单选的那个bool public bool isSel; private bool oldSel; // 当选中时所要执行的事件 public event UnityAction&lt;bool&gt; changeEvent; protected override void DrawIsOff() &#123; isSel = GUI.Toggle(guiPos.Pos, isSel, guiContent); // 防止一直true true true一直调用事件执行 // 只有当 true 和 false 发生变化的时候才去处理 if (isSel != oldSel) &#123; changeEvent?.Invoke(isSel); oldSel = isSel; &#125; &#125; protected override void DrawIsOn() &#123; isSel = GUI.Toggle(guiPos.Pos, isSel, guiContent, style); if (isSel != oldSel) &#123; changeEvent?.Invoke(isSel); oldSel = isSel; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"7.自定义文本和按钮","slug":"UI系统/GUI/GUI实践项目/7.自定义文本和按钮","date":"2025-02-27T07:19:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/7.自定义文本和按钮/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/7.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E5%92%8C%E6%8C%89%E9%92%AE/","excerpt":"","text":"创建自定义文本和按钮，将其脚本拖入到空物体上做成预制体 CustomGUILabel.cs1234567891011public class CustomGUILabel : CustomGUIControl&#123; protected override void DrawIsOff() &#123; GUI.Label(guiPos.Pos, guiContent); &#125; protected override void DrawIsOn() &#123; GUI.Label(guiPos.Pos, guiContent, style); &#125;&#125; CustomGUIButton.cs1234567891011121314151617181920public class CustomGUIButton : CustomGUIControl&#123; // 提供给外部的按钮点击事件, 想要按钮点击后做啥往里加函数就行, Unity自带的事件 public event UnityAction clickEvent; protected override void DrawIsOff() &#123; if (GUI.Button(guiPos.Pos, guiContent)) &#123; clickEvent?.Invoke(); &#125; &#125; protected override void DrawIsOn() &#123; if (GUI.Button(guiPos.Pos, guiContent, style)) &#123; clickEvent?.Invoke(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"6.控件根对象","slug":"UI系统/GUI/GUI实践项目/6.控件根对象","date":"2025-02-27T07:06:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/6.控件根对象/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/6.%E6%8E%A7%E4%BB%B6%E6%A0%B9%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"解决两个问题 所见即所得（编辑模式下能看到GUI） 可以控制控件的绘制顺序 创建所有自定义GUI的根部类,添加ExecuteAlways特性在类名添加ExecuteAlways特性，可以让编辑模式下指定代码运行。12345[ExecuteAlways]//所有自定义GUI的根部类public class CustomGUIRoot : MonoBehaviour&#123;&#125; 在Start方法中获取所有子对象的控件父类脚本12345void Start()&#123; //通过每一次绘制之前 得到所有子对象控件的 父类脚本 allControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;();&#125; 在OnGUI方法中按照得到的顺序来绘制每个控件，用控件父类中定义好的绘制方法1234567891011121314151617181920//在这同一绘制子对象控件的内容private void OnGUI()&#123; //编辑状态下 才会一直执行 //if (!Application.isPlaying) //&#123; //这句代码 浪费性能 因为每次 gui都会来获取所有的 控件对应的脚本 所以要在编辑状态下才会一直执行 //在编辑状态下运行是因为想一直看到控件的移动 //最后没开启是因为只得了一次子对象的CustomGUIControl 就算子对象被隐藏了也不会重写得CustomGUIControl 会有问题 allControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); //&#125; //遍历每一个控件 让其 执行绘制 for (int i = 0; i &lt; allControls.Length; i++) &#123; allControls[i].GUIDraw(); &#125;&#125; CustomGUIRoot.cs12345678910111213141516171819202122[ExecuteAlways]public class CustomGUIRoot : MonoBehaviour&#123; private CustomGUIControl[] _customGUIControls; private void Start() &#123; _customGUIControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); &#125; // 统一控制所有子对象挂载的控件的 绘制 private void OnGUI() &#123; if (!Application.isPlaying) // 这里的条件判断主要是为了性能, 实际运行可能会出错 &#123; _customGUIControls = this.GetComponentsInChildren&lt;CustomGUIControl&gt;(); &#125; for (int i = 0; i &lt; _customGUIControls.Length; i++) &#123; _customGUIControls[i].GUIDraw(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"5.控件父类","slug":"UI系统/GUI/GUI实践项目/5.控件父类","date":"2025-02-27T02:19:18.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/5.控件父类/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/5.%E6%8E%A7%E4%BB%B6%E7%88%B6%E7%B1%BB/","excerpt":"","text":"这是所有控件的公共基类自定义样式是否启用的开关枚举定义了一个枚举类型 E_Style_onoff 用于表示自定义样式是否启用。12345public enum E_Style_onoff&#123; On, Off,&#125; 自定义控件父类是一个抽象类，继承自MonoBehaviour。123public abstract class CustomGUIControl : MonoBehaviour&#123;&#125; 提取控件的共同表现位置信息显示内容信息自定义样式以及自定义样式是否启用的开关。123456789101112// 位置信息public CustomGUIPos guiPos;// 显示内容信息public GUIContent content;// 自定义样式public GUIStyle style;// 自定义样式是否启用的开关public E_Style_OnOff styleOnOrOff = E_Style_OnOff.Off; 根据是否使用style写两个抽象方法1234567891011121314151617181920212223public void DrawGUI()&#123; switch (styleOnOrOff) &#123; case E_Style_OnOff.On: StyleOnDraw(); break; case E_Style_OnOff.Off: StyleOffDraw(); break; &#125;&#125;/// &lt;summary&gt;/// 自定义样式开启时的绘制抽象方法/// &lt;/summary&gt;protected abstract void StyleOnDraw();/// &lt;summary&gt;/// 自定义样式关闭时的绘制抽象方法/// &lt;/summary&gt;protected abstract void StyleOffDraw(); CustomGUIControl.cs12345678910111213141516171819202122232425262728293031323334public enum E_Style_onoff&#123; On, Off,&#125;public abstract class CustomGUIControl : MonoBehaviour&#123; // GUI控件公共部分 !!!!!! // 位置信息 public CustomGUIPos guiPos; // 显示内容信息 public GUIContent guiContent; // 自定义样式 public GUIStyle style; // 自定义样式开关 public E_Style_onoff styleIsOn = E_Style_onoff.Off; // 提供公共的控件绘制 public void GUIDraw() &#123; switch (styleIsOn) &#123; case E_Style_onoff.On: // 样式开启时使用的绘制函数 DrawIsOn(); break; case E_Style_onoff.Off: DrawIsOff(); break; &#125; &#125; protected abstract void DrawIsOn(); protected abstract void DrawIsOff();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"4.控件位置信息类","slug":"UI系统/GUI/GUI实践项目/4.控件位置信息类","date":"2025-02-27T01:54:24.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/4.控件位置信息类/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%8E%A7%E4%BB%B6%E4%BD%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%B1%BB/","excerpt":"","text":"CustomGUIPos.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132//对齐方式九宫格枚举定义public enum E_Alignment_Type&#123; Up, Down, Left, Right, Center, Left_Up, Left_Down, Right_Up, Right_Down,&#125;// 自定义类需要再Inspector面板显示[System.Serializable]public class CustomGUIPos&#123; // 控件位置 private Rect _pos = new Rect(0, 0, 101, 100); // 屏幕九宫格对齐方式 public E_Alignment_Type Screen_Alignment_Type = E_Alignment_Type.Center; // 控件中心点对齐方式 public E_Alignment_Type Constrol_Center_Alignment_Type = E_Alignment_Type.Center; // 偏移位置 public Vector2 dPos; // 控件宽高 public float Width = 100; public float Height = 50; // 计算后的控件位置 public Rect Pos &#123; get &#123; CalcCenterPos(); CalcPos(); _pos.width = Width; _pos.height = Height; return _pos; &#125; &#125; // 计算最后的位置 private void CalcPos() &#123; switch (Screen_Alignment_Type) &#123; case E_Alignment_Type.Up: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Down: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Center: _pos.x = Screen.width / 2 + _centerPos.x + dPos.x; _pos.y = Screen.height / 2 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left_Up: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Left_Down: _pos.x = Screen.width * 0 + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right_Up: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height * 0 + _centerPos.y + dPos.y; break; case E_Alignment_Type.Right_Down: _pos.x = Screen.width + _centerPos.x + dPos.x; _pos.y = Screen.height + _centerPos.y + dPos.y; break; &#125; &#125; // 控件中心点位置 private Vector2 _centerPos; private void CalcCenterPos() &#123; switch (Constrol_Center_Alignment_Type) &#123; case E_Alignment_Type.Up: _centerPos.x = -Width / 2; _centerPos.y = 0; break; case E_Alignment_Type.Down: _centerPos.x = -Width / 2; _centerPos.y = -Height; break; case E_Alignment_Type.Left: _centerPos.x = 0; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Right: _centerPos.x = -Width; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Center: _centerPos.x = -Width / 2; _centerPos.y = -Height / 2; break; case E_Alignment_Type.Left_Up: _centerPos.x = 0; _centerPos.y = 0; break; case E_Alignment_Type.Left_Down: _centerPos.x = 0; _centerPos.y = -Height; break; case E_Alignment_Type.Right_Up: _centerPos.x = -Width; _centerPos.y = 0; break; case E_Alignment_Type.Right_Down: _centerPos.x = -Width; _centerPos.y = -Height; break; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"3.九宫格概念","slug":"UI系统/GUI/GUI实践项目/3.九宫格概念","date":"2025-02-27T01:41:15.000Z","updated":"2025-02-28T11:54:17.740Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/3.九宫格概念/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"相对屏幕位置：红点的位置中心点偏移位置：控件的九个点的位置","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.需求分析","slug":"UI系统/GUI/GUI实践项目/2.需求分析","date":"2025-02-27T01:35:44.000Z","updated":"2025-02-28T11:48:54.741Z","comments":true,"path":"2025/02/27/UI系统/GUI/GUI实践项目/2.需求分析/","permalink":"http://example.com/2025/02/27/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"使用GUI制作出控件预制体，不需要运行时在OnGUI写逻辑才能看到UI","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.hexo源码上传到GitHub","slug":"hexo/2.hexo源码上传到GitHub","date":"2025-02-26T13:54:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/hexo/2.hexo源码上传到GitHub/","permalink":"http://example.com/2025/02/26/hexo/2.hexo%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub/","excerpt":"","text":"在你的github中创建一个新的分支用来保存源码名字随便，这里我的是hexo git clone 你的仓库复制.git文件夹到你的博客目录123git add .git commit -m &quot;Update&quot;git push origin hexo 参考链接：hexo源码上传到GitHub - choco莉特 - 博客园","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"1.编辑模式下让指定代码运行","slug":"UI系统/GUI/GUI实践项目/1.编辑模式下让指定代码运行","date":"2025-02-26T13:42:40.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI实践项目/1.编辑模式下让指定代码运行/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%AE%A9%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C/","excerpt":"","text":"在类名上添加 [ExecuteAlways] 特性可以让指定代码在编辑模式下运行编辑模式下，缩放Game窗口大小每一帧相关也会执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//在类名添加ExecuteAlways特性 可以让编辑模式下让指定代码运行[ExecuteAlways]public class Lesson01_必备知识点_编辑模式下让指定代码运行 : MonoBehaviour&#123; private void Awake() &#123; Debug.Log(&quot;对象初始化时调用（即使脚本未启用）。&quot;); &#125; private void OnEnable() &#123; Debug.Log(&quot;脚本启用或对象激活时调用（在Awake之后，若对象初始启用）。&quot;); &#125; void Start() &#123; Debug.Log(&quot;在首次Update前调用（仅一次，需脚本启用）。&quot;); &#125; private void FixedUpdate() &#123; Debug.Log(&quot;按固定时间间隔调用（物理计算阶段，可能一帧多次）。&quot;); &#125; private void OnTriggerEnter(Collider other) &#123; Debug.Log(&quot;物理触发事件，在FixedUpdate之后、Update之前处理。&quot;); &#125; void Update() &#123; Debug.Log(&quot;每帧调用一次。&quot;); &#125; private void LateUpdate() &#123; Debug.Log(&quot;所有Update完成后调用。&quot;); &#125; private void OnGUI() &#123; Debug.Log(&quot;渲染GUI时调用，每帧可能多次（在LateUpdate之后）。&quot;); &#125; private void OnDisable() &#123; Debug.Log(&quot;脚本禁用或对象失活时调用。&quot;); &#125; private void OnDestroy() &#123; Debug.Log(&quot;对象销毁前调用。&quot;); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.GUI总结","slug":"UI系统/GUI/GUI基础知识/12.GUI总结","date":"2025-02-26T12:22:28.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/12.GUI总结/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GUI%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"11.GUILayout自动布局","slug":"UI系统/GUI/GUI基础知识/11.GUILayout自动布局","date":"2025-02-26T12:13:57.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/11.GUILayout自动布局/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.GUILayout%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546// GUILayout是一个类似GUI的类，里面的API和GUI类似，只是可以帮我们自动布局，不用手动调整位置，方便一点。// GUILayout 类是 Unity GUI 的接口，并且具有自动布局功能。// 主要用于进行编辑器开发，如果用它来做游戏UI不太合适。// GUILayout和GUI可以相互配合着使用GUI.BeginGroup(new Rect(100, 100, 500, 300));GUILayout.BeginArea(new Rect(10, 10, 400, 300)); // 在一个固定的屏幕区域中开始 GUI 控件的 GUILayout 块。GUILayout.BeginVertical(); // 开始一个垂直控件组。GUILayout.Button(&quot;竖直123&quot;, GUILayout.Width(200)); // 控件的固定宽高GUILayout.Button(&quot;竖直245666656565&quot;);GUILayout.Button(&quot;竖直235&quot;, GUILayout.ExpandWidth(false)); // 允许或禁止水平拓展GUILayout.EndVertical(); // 闭合以 BeginVertical 开始的组。GUILayout.BeginHorizontal(); // 开始一个水平控件组。GUILayout.Button(&quot;水平123&quot;, GUILayout.Height(300)); // 控件的固定宽高GUILayout.Button(&quot;水平245666656565&quot;);GUILayout.Button(&quot;水平235&quot;, GUILayout.ExpandWidth(false)); // 允许或禁止水平拓展GUILayout.EndHorizontal(); // 闭合以 BeginHorizontal 开始的组。GUILayout.EndArea(); // 闭合以 BeginArea 开始的 GUILayout 块。GUI.EndGroup();GUILayoutOption 布局选项 //控件的固定宽高 GUILayout.Width(300); GUILayout.Height(200); //允许控件的最小宽高 GUILayout.MinWidth(50); GUILayout.MinHeight(50); //允许控件的最大宽高 GUILayout.MaxWidth(100); GUILayout.MaxHeight(100); //允许或禁止水平拓展 GUILayout.ExpandWidth(true);//允许 GUILayout.ExpandHeight(false);//禁止 GUILayout.ExpandHeight(true);//允许 GUILayout.ExpandHeight(false);//禁止","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"10.自定义皮肤样式","slug":"UI系统/GUI/GUI基础知识/10.自定义皮肤样式","date":"2025-02-26T12:00:57.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/10.自定义皮肤样式/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%AE%E8%82%A4%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"颜色*color静态变量 全局的着色颜色123456// GUI 的全局着色颜色。GUI.color = Color.red;GUI.Label(new Rect(0, 50, 150, 30), &quot;全局着色颜色标签红&quot;);GUI.Button(new Rect(0, 100, 150, 30), &quot;全局着色颜色按钮红&quot;);GUI.color = Color.white;GUI.Button(new Rect(0, 150, 150, 30), &quot;全局着色颜色按钮白&quot;, style); contentColor静态变量 文本着色颜色1234// 文本着色颜色，会和全局颜色相乘。// 为 GUI 渲染的所有文本着色。GUI.contentColor = Color.yellow;GUI.Button(new Rect(0, 200, 150, 30), &quot;文本着色颜色&quot;); backgroundColor静态变量 背景元素着色颜色1234// 用于 GUI 渲染的所有背景元素的全局着色颜色。// 背景元素着色颜色会和全局颜色相乘。GUI.backgroundColor = Color.green;GUI.Button(new Rect(0, 250, 150, 30), &quot;背景元素着色颜色&quot;, style); 整体皮肤样式在Project窗口可以右键创建GUI皮肤 skin静态变量 全局皮肤123456public GUISkin mySkin;private void OnGUI()&#123; GUI.skin = mySkin; // 为null就是默认的样式，单个Style会覆盖&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"9.窗口","slug":"UI系统/GUI/GUI基础知识/9.窗口","date":"2025-02-26T11:35:31.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/9.窗口/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%AA%97%E5%8F%A3/","excerpt":"","text":"窗口1234567891011121314// 第一个参数是窗口唯一id// 第三个参数是一个 要一个int作为参数的无返回值的委托, 用来处理窗口内容的GUI.Window(1, new Rect(0, 0, 500, 500), (a) =&gt;&#123; // 一个函数处理不同的窗口 switch (a) &#123; case 1: GUI.Button(new Rect(0, 0, 100, 30), &quot;第一个窗口逻辑&quot;); break; case 2: break; &#125;&#125;, &quot;测试窗口&quot;); 模态窗口1234567// 显示一个模态窗口。// 模态窗口可以让其它控件不再有用。// 你可以理解该窗口在最上层，其它按钮都点击不到了，只能点击该窗口上控件。// 只有把模态窗口处理后, 才可以点击其它窗口GUI.ModalWindow(3, new Rect(300, 100, 200, 150), (a) =&gt; &#123;&#125;, &quot;模态窗口&quot;);// 可能应用于警告弹窗，必须先处理的弹出 拖动窗口12345678public Rect winRect = new Rect(100, 100, 200, 200);winRect = GUI.Window(3, winRect, (a) =&gt;&#123; // 无参默认窗口所有位置都可以拖动 // 参数指定窗口的哪一部分可以被鼠标拖动 GUI.DragWindow(); // 必须要调用这个才能拖动&#125;, &quot;拖动窗口测试&quot;); 练习在之前制作的开始界面中，点击退出游戏按钮，弹出一个模态窗口，让玩家确定是否退出（退出，取消），点击取消后关闭窗口，点击退出后 退出游戏QuitTipPanel.cs1234567891011121314151617181920212223private void OnGUI()&#123; // 绘制模态窗口 GUI.ModalWindow(1, winPos, DrawWindow, &quot;提示&quot;);&#125;private void DrawWindow(int id)&#123; // 标签 GUI.Label(labPos, &quot;是否退出&quot;); // 两个按钮 if(GUI.Button(btnPos1, &quot;退出&quot;)) &#123; Application.Quit(); &#125; if(GUI.Button(btnPos2, &quot;取消&quot;)) &#123; HideMe(); BeginPanel.ShowMe(); &#125;&#125; BeginPanel.cs12345if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle))&#123; QuitTipPanel.ShowMe(); HideMe();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"8.滚动列表和分组","slug":"UI系统/GUI/GUI基础知识/8.滚动列表和分组","date":"2025-02-26T11:04:59.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/8.滚动列表和分组/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%E5%92%8C%E5%88%86%E7%BB%84/","excerpt":"","text":"分组 BeginGroup1234567891011121314//BeginGroup静态方法 开始分组//开始一个组。必须与 EndGroup 调用配对使用。//用于批量控制控件位置 //可以理解为 包裹着的控件加了一个父对象 //可以通过控制分组来控制包裹控件的位置GUI.BeginGroup(groupRect); // 必须搭配EndGroup来使用//组内的组件GUI.Button(new Rect(0, 0, 100, 50), &quot;测试按钮&quot;);GUI.Label(new Rect(0, 60, 100, 20), &quot;Label信息&quot;);//EndGroup静态方法 结束分组//结束组。GUI.EndGroup(); 滚动列表 BeginScrollView在Unity中，GUI.BeginScrollView函数用于创建一个可以滚动的视图区域，允许在较小的矩形区域内显示较大的内容。该函数的参数如下所示： position (Rect)：指定 滚动视图 的矩形区域，使用Rect类型来表示，包含了左上角的位置坐标和宽度、高度。 scrollPosition (Vector2)：指定当前滚动位置的二维向量，表示在滚动视图中内容的偏移量。 viewRect (Rect)：指定 具体内容 的矩形区域大小，使用Rect类型来表示，包含了左上角的位置坐标和宽度、高度。 12345678910111213public Rect scrollPos;public Rect showView;public Vector2 nowPos;nowPos = GUI.BeginScrollView(scrollPos, nowPos, showView);// 中间填想要放在滚动列表里面的UI eg:GUI.Toolbar(new Rect(0, 0, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 60, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 120, 300, 50), 0, strs); GUI.Toolbar(new Rect(0, 180, 300, 50), 0, strs);GUI.EndScrollView(); 练习制作一个滚动视图，外部有一个字符串数组，通过在Inspector修改这个字符串数组数量，会在滚动视图内部动态的创建label依次显示内容想让滚动视图的真实内容大小 随内容(这里是strings)大小变化而变化 1234567891011121314151617181920public string[] strs;public Rect scrollPos;public Rect showView;public Vector2 nowPos;private void OnGUI()&#123; // 想让滚动视图的真实内容大小 随内容(这里是strings)大小变化而变化 // 在绘制滚动视图之前把变化的数据计算好 showView.height = strs.Length * 30; // 计算你要生成的内容的高度 nowPos = GUI.BeginScrollView(scrollPos, nowPos, showView); for (int i = 0; i &lt; strs.Length; i++) &#123; GUI.Label(new Rect(0, i * 30, 100, 30), strs[i]); &#125; GUI.EndScrollView();&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"7.工具栏和选择网格","slug":"UI系统/GUI/GUI基础知识/7.工具栏和选择网格","date":"2025-02-26T09:41:39.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/7.工具栏和选择网格/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E9%80%89%E6%8B%A9%E7%BD%91%E6%A0%BC/","excerpt":"","text":"工具栏Toolbar1234567891011121314151617181920// 创建一个工具栏。// 需要声明一个 int 变量用于选择 和一个 string 数组用于显示当前选择的工具栏的内容。public int toolbarIndex = 0;public string toolbarInfos = new string[] &#123; &quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot; &#125;;// Toolbar静态方法会返回一个 int 值，也需要重新赋值个给选择的 int 变量。toolbarIndex = GUI.Toolbar(new Rect(0, 0, 200, 30), toolbarIndex, toolbarInfos);// 工具栏可以帮助我们根据不同的返回索引 来处理不同的逻辑switch (toolbarIndex)&#123; case 0: // 处理索引为0的逻辑 break; case 1: // 处理索引为1的逻辑 break; case 2: // 处理索引为2的逻辑 break;&#125; 选择网格SelectionGrid1234// 创建一个按钮网格。// 也需要声明一个 int 变量用于选择 和一个 string 数组用于显示当前选择的工具栏的内容。// 相对 toolbar 多了一个参数 xCount 代表 水平方向最多显示的按钮数量 比如有三个按钮 这参数天了填了2 那么一行最多只要两个按钮。selGridIndex = GUI.SelectionGrid(new Rect(0, 50, 200, 60), selGridIndex, toolbarInfos, 2); 练习12345678910111213141516171819202122232425262728293031public class TestPanel : MonoBehaviour&#123; public Rect toolbarPos; public Rect selGridPos; public string[] strs = new string[] &#123; &quot;装备&quot;, &quot;进阶&quot;, &quot;幻化&quot; &#125;; private int nowSelIndex = 0; public Rect labelPos; private void OnGUI() &#123; nowSelIndex = GUI.Toolbar(toolbarPos, nowSelIndex, strs); nowSelIndex = GUI.SelectionGrid(selGridPos, nowSelIndex, strs, 1); switch (nowSelIndex) &#123; case 0: GUI.Label(labelPos, &quot;装备信息&quot;); break; case 1: GUI.Label(labelPos, &quot;进阶信息&quot;); break; case 2: GUI.Label(labelPos, &quot;幻化信息&quot;); break; &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"6.图片绘制和框","slug":"UI系统/GUI/GUI基础知识/6.图片绘制和框","date":"2025-02-26T09:26:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/6.图片绘制和框/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E5%92%8C%E6%A1%86/","excerpt":"","text":"DrawTextureDrawTexture静态方法重载中的参数12345//DrawTexture静态方法所有重载public static void DrawTexture(Rect position, Texture image);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend);public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect); ScaleMode: 当图像的宽高比不适合要绘制的宽高比时，如何缩放图像。 ScaleAndCrop: 也会通过宽高比来计算图片 但是会进行裁剪。 ScaleToFit: 会自动根据宽高比进行计算 不会拉变形 会一直保持图片全部显示的状态。 StretchToFill: 始终填充满你传入的 Rect 范围。 alphaBlend: 绘制图像时是否应用 Alpha 混合（默认启用）。 用来控制图片是否开启透明通道。 imageAspect: 用于源图像的宽高比。如果为 0（默认值），则使用图像的宽高比。传入 w/h 来指定所需的宽高比。这让您能够在不改变像素宽度和高度的情况下调整源图像的宽高比。 基本使用12345678public Rect texPos;public Texture tex;public ScaleMode mode = ScaleMode.StretchToFillpublic bool alpha = true;public float wh = 0;// 在一个矩形内绘制纹理。GUI.DrawTexture(texPos, tex, mode, alpha, wh); 框12// 在 GUI 层上创建一个框。GUI.Box(texPos, &quot;123&quot;); 练习为各个面板加上背景图片123456789101112131415// 开始面板脚本public class BeginPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125; 123456789101112131415// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125; 123456789101112131415// 登陆面板脚本public class LoginPanel : MonoBehaviour&#123; // 背景图片 public Rect bkPos; public Texture bkTex; private void OnGUI() &#123; // 背景 GUI.DrawTexture(bkPos, bkTex); // **API: GUI.DrawTexture** // 其他代码... &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"5.输入框和拖动条","slug":"UI系统/GUI/GUI基础知识/5.输入框和拖动条","date":"2025-02-26T09:04:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/5.输入框和拖动条/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E8%BE%93%E5%85%A5%E6%A1%86%E5%92%8C%E6%8B%96%E5%8A%A8%E6%9D%A1/","excerpt":"","text":"输入普通输入TextField 输入框 重要参数： 显示内容 string 最大输入字符串的长度 和多选框类似 要不停得到自己输入的内容 1234public string inputStr = &quot;hello&quot;;// 创建一个可供用户编辑字符串的单行文本字段。inputStr = GUI.TextField(new Rect(0, 0, 100, 30), inputStr, 5);//最多显示5个字符 超过了不会在打出来了 密码输入框PasswordField1234public string inputPW = &quot;&quot;;// 创建一个可让用户输入密码的文本字段。inputPW = GUI.PasswordField(new Rect(0, 50, 100, 30), inputPW, &#x27;★&#x27;);//密码文本是★ 拖动条水平拖动条 拖动条重要参数 当前的值 最小值 left 最大值 right 也是要不停得到自己输入的内容 12345public float nowValue = 0;// 用户可以拖动的水平滑动条，用于在最小值和最大值之间更改某值。nowValue = GUI.HorizontalSlider(new Rect(0, 100, 100, 50), nowValue, 0, 1);Debug.Log(nowValue); 竖直拖动条12 // 用户可以拖动的垂直滑动条，用于在最小值和最大值之间更改某值。nowValue = GUI.VerticalSlider(new Rect(0, 150, 50, 100), nowValue, 0, 1); 练习在设置面板中加入拖动条控制音乐大小12345678910111213141516// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 拖动条控制音乐大小 private float musicValue = 1; public Rect musicPos; private float soundValue = 1; public Rect soundPos; private void OnGUI() &#123; // 拖动条 musicValue = GUI.HorizontalSlider(musicPos, musicValue, 0, 1); soundValue = GUI.HorizontalSlider(soundPos, soundValue, 0, 1); &#125;&#125; 制作一个登陆面板请在之前的基础上,制作一个登陆面板,有用户名输入和密码输入,有进入游戏和返回上一级按钮,点击开始界面中的开始游戏后 进入登陆面板,输入的用户名为admin密码为8888才能切换场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class LoginPanel : MonoBehaviour&#123; //面板的显示隐藏 所有地方都能够快速使用的 //静态 方法 和静态变量 就可以直接通过类名就用了 private static LoginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; //两个 按钮 public Rect btn1Pos; public Rect btn2Pos; //两个 label public Rect lab1Pos; public Rect lab2Pos; //两个 输入框 public Rect input1Pos; public Rect input2Pos; //用户名和密码 private string userName = &quot;&quot;; private string passWord = &quot;&quot;; private void Awake() &#123; instance = this; HideMe(); &#125; private void OnGUI() &#123; //登录按钮 if ( GUI.Button(btn1Pos, &quot;登录游戏&quot;) ) &#123; if(userName == &quot;admin&quot; &amp;&amp; passWord == &quot;8888&quot;) &#123; SceneManager.LoadScene(&quot;GameScene&quot;); &#125; else &#123; Debug.Log(&quot;用户名或者密码错误&quot;); &#125; &#125; //返回按钮 if( GUI.Button(btn2Pos, &quot;返回&quot;) ) &#123; BeginPanel.ShowMe(); HideMe(); &#125; //文本 GUI.Label(lab1Pos, &quot;用户名&quot;); GUI.Label(lab2Pos, &quot;密码&quot;); //输入框 userName = GUI.TextField(input1Pos, userName); passWord = GUI.PasswordField(input2Pos, passWord, &#x27;*&#x27;); &#125;&#125;#endregion","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"4.多选框和单选框","slug":"UI系统/GUI/GUI基础知识/4.多选框和单选框","date":"2025-02-26T08:10:32.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/4.多选框和单选框/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.%E5%A4%9A%E9%80%89%E6%A1%86%E5%92%8C%E5%8D%95%E9%80%89%E6%A1%86/","excerpt":"","text":"多选框GUI.Toggle的返回值是该Toggle被点击后是否选中Toggle静态方法 创建多选框123456789// 创建一个打开 / 关闭的开关按钮。// 要传入一个布尔值，true为选中，false为不选中// Toggle静态方法会返回一个布尔值，返回的布尔值是, 上次鼠标改变Toggle后是否选中// 普通样式isSel = GUI.Toggle(new Rect(0, 0, 100, 30), isSel, &quot;效果开关&quot;);// GUI.Toggle的点击范围是用的Rect中的宽高// 用fixedWidth和fixedHeight 改变图片的大小，但是不改变点击范围// 修改从GUIStyle边缘到内容起始处的空间 paddingisSel2 = GUI.Toggle(new Rect(0, 40, 100, 30), isSel2, &quot;音效开关&quot;, style); 修改多选框样式 单选框单选框通过多选框来实现的123456789// 单选框 (一般通过一个int来控制所有的flag, 可通过点击来改变是否选中)if (GUI.Toggle(rect, selIndex == 1, &quot;选项1&quot;))&#123; selIndex = 1;&#125;if (GUI.Toggle(rect, selIndex == 2, &quot;选项2&quot;))&#123; selIndex = 2;&#125; 练习控制一个面板（比如设置面板的UI）的显隐，通常是将显示面板的脚本挂载到一个Pannel的游戏对象上，在控制这个游戏对象的失活与激活来是否显示面板和隐藏面板 要完成面板之间相互控制显示有3种方法： 第一种：都写在一个 OnGUI 中，通过 bool 标识去控制显影。 第二种：挂载在同一个对象上，通过控制脚本的 gameObject.SetActive(true/false) 去控制面板的显影。 第三种：挂载在不同对象上，通过控制对象的 gameObject.SetActive(true/false) 来达到面板的显影。 关键的是如何在多个面板之间相互调用显隐。我们是通过静态变量和静态方法的形式，在 Awake 方法中初始化静态变量。如果要用该方法，一开始这个对象不能失活。 制作一个游戏设置面板，上面有背景音乐的开关和音效的开关，并且点击开始界面的设置面板可以打开设置面板 单例模式，控制各个面板的显隐1234567891011121314151617181920212223242526272829303132333435// 开始面板脚本public class BeginPanel : MonoBehaviour&#123; // 开始面板的显示隐藏 private static BeginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; private void Awake() &#123; instance = this; HideMe(); &#125; // 其他代码... private void OnGUI() &#123; // 其他代码... &#125;&#125; 设置面板脚本SettingPanel.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 设置面板脚本public class SettingPanel : MonoBehaviour&#123; // 音乐开关和音效开关 public Rect toggleMusicPos; // **API: Rect** public Rect toggleSoundPos; // **API: Rect** private bool isSelMusic = true; private bool isSelSound = true; private static SettingPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; private void Awake() &#123; instance = this; HideMe(); &#125; private void OnGUI() &#123; // 音乐开关和音效开关 isSelMusic = GUI.Toggle(toggleMusicPos, isSelMusic, &quot;音乐开关&quot;); isSelSound = GUI.Toggle(toggleSoundPos, isSelSound, &quot;音效开关&quot;); // 关闭按钮 设置面板 if (GUI.Button(btnPos, &quot;&quot;, btnStyle)) &#123; // 关闭自己这个面板的功能 HideMe(); // 显示开始界面 BeginPanel.ShowMe(); &#125; &#125;&#125; 开始面板BeginPanel.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//开始面板public class BeginPanel : MonoBehaviour&#123; //面板的显示隐藏 所有地方都能够快速使用的 //静态 方法 和静态变量 就可以直接通过类名就用了 private static BeginPanel instance; public static void ShowMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(true); &#125; &#125; public static void HideMe() &#123; if (instance != null) &#123; instance.gameObject.SetActive(false); &#125; &#125; //游戏标题 public Rect labPos; public GUIContent labContent; public GUIStyle labStyle; //3个游戏按钮 public Rect btn1Pos; public Rect btn2Pos; public Rect btn3Pos; public GUIStyle btnStyle; private void Awake() &#123; instance = this; &#125; private void OnGUI() &#123; //游戏标题 GUI.Label(labPos, labContent, labStyle); //3个游戏按钮 if (GUI.Button(btn1Pos, &quot;开始游戏&quot;, btnStyle)) &#123; //SceneManager.LoadScene(&quot;GameScene&quot;); LoginPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn2Pos, &quot;设置游戏&quot;, btnStyle)) &#123; //显示设置界面 SettingPanel.ShowMe(); //隐藏自己 HideMe(); &#125; if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle)) &#123; QuitTipPanel.ShowMe(); HideMe(); &#125; &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.文本和按钮控件","slug":"UI系统/GUI/GUI基础知识/3.文本和按钮控件","date":"2025-02-26T07:18:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/3.文本和按钮控件/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.%E6%96%87%E6%9C%AC%E5%92%8C%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"GUI控件绘制的共同点 他们都是GUI公共类中提供的静态函数，直接调用即可。 他们的参数都大同小异： 位置参数：Rect参数（x、y位置，w、h尺寸），左上角为坐标系原点 显示文本：string参数 图片信息：Texture参数 综合信息：GUIContent参数 （综合显示 文本，图片，tooltip） 自定义样式：GUIStyle参数 每一种控件都有多种重载，都是各个参数的排列组合。 注意： 必备的参数内容是位置信息和显示信息 GUI的原点（0,0）Rect在左上角，x向右，y向下 为正 文本控件Label静态方法所有重载12345678// 在屏幕上创建一个文本或纹理标签。// Label静态方法所有重载public static void Label(Rect position, string text);public static void Label(Rect position, Texture image);public static void Label(Rect position, GUIContent guiContent);public static void Label(Rect position, string text, GUIStyle style);public static void Label(Rect position, Texture image, GUIStyle style);public static void Label(Rect position, GUIContent guiContent, GUIStyle style); string参数 和 Texture参数1234// 基本使用 传入位置信息和显示信息 显示信息可以是显示文本和图片信息GUI.Label(new Rect(100, 20, 100, 20), &quot;666666欢迎你&quot;);// public static void Label(Rect position, Texture image);GUI.Label(labelRect1, image); GUIContent1234567// 综合使用 传入位置信息和综合信息// 综合信息GUIContent类里包括显示文本和图片信息// public static void Label(Rect position, GUIContent labelGuiContent);GUI.Label(labelRect2, guiContent);// tooltip静态变量 可以获取当前鼠标或者键盘选中的GUI控件 对应的 tooltip信息// 鼠标指针当前悬停在其上或具有键盘焦点的控件的工具提示。（只读）Debug.Log(GUI.tooltip); GUIStyle参数 字体在：C:\\Windows\\Fonts 下面 按钮控件参数和使用方式与文本控件一毛一样12// 按钮控件 (在按钮范围内 按下鼠标再抬起鼠标 才算一次点击 才会返回trueGUI.Button(btnRect, btnContent, btnStyle); 12345// 长按按钮控件 (只要在长按按钮范围内 按下鼠标 就会一直返回trueif (GUI.RepeatButton(btnRect, btnContent))&#123; Debug.Log(&quot;只要在长按按钮范围内 按下鼠标 就会一直返回true&quot;);&#125; 练习请用GUI制作一个游戏开始界面，上面有开始游戏，退出游戏，设置等等按钮选项，点击开始游戏可以切换到游戏场景 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using UnityEngine;public class StartMenu : MonoBehaviour&#123; // 游戏标题 public Rect labPos; public GUIContent labContent; public GUIStyle labStyle; // 三个按钮位置和样式 public Rect btn1Pos; public Rect btn2Pos; public Rect btn3Pos; public GUIStyle btnStyle; void OnGUI() &#123; // 渲染游戏标题 GUI.Label(labPos, labContent, labStyle); // 渲染三个按钮 if (GUI.Button(btn1Pos, &quot;开始游戏&quot;, btnStyle)) &#123; // 点击开始游戏按钮事件处理 // SceneManager.LoadScene(&quot;GameScene&quot;); LoginPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn2Pos, &quot;设置游戏&quot;, btnStyle)) &#123; // 点击设置游戏按钮事件处理 SettingPanel.ShowMe(); HideMe(); &#125; if (GUI.Button(btn3Pos, &quot;退出游戏&quot;, btnStyle)) &#123; // 点击退出游戏按钮事件处理 QuitTipPanel.ShowMe(); HideMe(); &#125; &#125; // 隐藏当前界面 void HideMe() &#123; gameObject.SetActive(false); &#125;&#125;","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.GUI工作原理与主要作用","slug":"UI系统/GUI/GUI基础知识/2.GUI工作原理与主要作用","date":"2025-02-26T07:09:04.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/2.GUI工作原理与主要作用/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.GUI%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8/","excerpt":"","text":"GUI是什么GUI，即即时模式游戏用户交互界面（IMGUI），在Unity中一般简称为GUI。它是一个代码驱动的UI系统。 GUI的主要作用 作为程序员的调试工具，创建游戏内调试工具。 为脚本组件创建自定义检视面板。 创建新的编辑器窗口和工具以拓展Unity本身（一般用作内置游戏工具）。注意： 不要用它为玩家制作UI功能。 GUI的工作原理在继承MonoBehaviour的脚本中的特殊函数OnGUI里调用GUI提供的方法，类似生命周期函数。 1234private void OnGUI()&#123; //在其中书写 GUI相关代码 即可显示GUI内容&#125; OnGUI函数注意事项 它每帧执行，相当于是用于专门绘制GUI界面的函数。 一般只在其中执行GUI相关界面绘制和操作逻辑。 该函数在OnDisable之前，LateUpdate之后执行。 生命周期函数 只要是继承Mono的脚本，都可以在OnGUI中绘制GUI。","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.GUI概述","slug":"UI系统/GUI/GUI基础知识/1.GUI概述","date":"2025-02-26T07:05:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/26/UI系统/GUI/GUI基础知识/1.GUI概述/","permalink":"http://example.com/2025/02/26/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.GUI%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"13.打包PlayerPrefsDataMgr","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/13.打包PlayerPrefsDataMgr","date":"2025-02-24T03:14:19.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/13.打包PlayerPrefsDataMgr/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/13.%E6%89%93%E5%8C%85PlayerPrefsDataMgr/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; else &#123; // 如果value的类型是自定义类型 Save(value, key); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; object v = Activator.CreateInstance(type); // 填充数据 FieldInfo[] fieldInfos = type.GetFields(); string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;type.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; // 和存储的一样 fieldInfo.SetValue(v, LoadValue(fieldInfo.FieldType, keyName)); &#125; return v; &#125; private object LoadValue(Type fieldType, string key) &#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return Load(fieldType, key); &#125; &#125;&#125; 右键PlayerPrefsDataMgr文件，导出包","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"12.加密思路","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/12.加密思路","date":"2025-02-24T03:07:58.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/12.加密思路/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/12.%E5%8A%A0%E5%AF%86%E6%80%9D%E8%B7%AF/","excerpt":"","text":"找不到把存在硬盘上的内容放在一个不容易找到的地方多层文件夹包裹名字辨识度低 但是对于PlayerPrefs不太适用因为位置已经固定了我们改不了 看不懂让数据的Key和Value让别人看不懂俗称加密为Key和Value加密 解不出不让别人获取到你加密的规则就解不出来了 注意单机游戏加密只是提高别人修改你数据的门槛只要别人获取到你的源代码知道你的加密规则一切都没有任何意义但是对于一般玩家来说几乎是不可能的事情 eg:存的时候按照一定规则来存储123456789if (fieldType == typeof(int))&#123; Log(&quot;存储int:&quot; + keyName + &quot;值 = &quot; + (int)value); //为int数据加密 int rValue = (int)value; rValue += 10; PlayerPrefs.SetInt(keyName, rValue);&#125; 读取的时候按一定规则来读123456if( fieldType == typeof(int) )&#123; Log(&quot;读取int:&quot; + keyName + &quot;值 = &quot; + (PlayerPrefs.GetInt(keyName, 0) - 10)); //解密 减10 return PlayerPrefs.GetInt(keyName, 0) - 10;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"11.反射读取自定义类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/11.反射读取自定义类型","date":"2025-02-24T02:56:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/11.反射读取自定义类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/11.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return Load(fieldType, key); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"10.反射读取Dictionary数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/10.反射读取Dictionary数据类型","date":"2025-02-24T02:52:01.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/10.反射读取Dictionary数据类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/10.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96Dictionary%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125; else if (typeof(IDictionary).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); Type keyType = fieldType.GetGenericArguments()[0]; Type valueType = fieldType.GetGenericArguments()[1]; IDictionary dic = Activator.CreateInstance(fieldType) as IDictionary; for (int i = 0; i &lt; count; i++) &#123; object k = LoadValue(keyType, key + &quot;_key_&quot; + i.ToString()); object v = LoadValue(valueType, key + &quot;_value_&quot; + i.ToString()); dic.Add(k, v); &#125; return dic; &#125; else &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"9.反射读取List数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/9.反射读取List数据类型","date":"2025-02-24T02:45:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/9.反射读取List数据类型/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/9.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930private object LoadValue(Type fieldType, string key)&#123; if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, &quot;&quot;); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key, 0) == 1 ? true : false; &#125; else if (typeof(IList).IsAssignableFrom(fieldType)) &#123; int count = PlayerPrefs.GetInt(key, 0); IList list = Activator.CreateInstance(fieldType) as IList; Type type = fieldType.GetGenericArguments()[0]; for (int i = 0; i &lt; count; i++) &#123; list.Add(LoadValue(type, $&quot;&#123;key&#125;_&#123;i&#125;&quot;)); &#125; return list; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"8.反射读取常用成员数据","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/8.反射读取常用成员数据","date":"2025-02-24T02:40:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/24/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/8.反射读取常用成员数据/","permalink":"http://example.com/2025/02/24/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/8.%E5%8F%8D%E5%B0%84%E8%AF%BB%E5%8F%96%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%95%B0%E6%8D%AE/","excerpt":"","text":"1234567891011121314public object Load(Type type, string key) &#123; object v = Activator.CreateInstance(type); FieldInfo[] fieldInfos = type.GetFields(); string loadKey = null; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; FieldInfo tmp = fieldInfos[i]; loadKey = $&quot;&#123;key&#125;_&#123;type.Name&#125;_&#123;tmp.FieldType.Name&#125;_&#123;tmp.Name&#125;&quot;; // 给v对象的字段赋值 tmp.SetValue(v, LoadValue(tmp.FieldType, loadKey)); &#125; return v; &#125; 1234567891011121314151617181920212223242526// 得单个数据private object LoadValue(Type fieldType, string key)&#123; //object v = Activator.CreateInstance(fieldType); // 根据字段类型调用不同API if (fieldType == typeof(int)) &#123; return PlayerPrefs.GetInt(key, 0); &#125; else if (fieldType == typeof(float)) &#123; return PlayerPrefs.GetFloat(key, 0); &#125; else if (fieldType == typeof(string)) &#123; return PlayerPrefs.GetString(key, null); &#125; else if (fieldType == typeof(bool)) &#123; return PlayerPrefs.GetInt(key) == 1; &#125; else &#123; return null; &#125;&#125; 12// 测试代码Player p = PlayerPrefsDataMgr.Instance.Load(typeof(Player), &quot;player&quot;) as Player;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"7.反射存储自定义类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/7.反射存储自定义类型","date":"2025-02-22T02:58:33.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/7.反射存储自定义类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/7.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"SaveData本来就是存储自定义类12345else&#123; // 如果value的类型是自定义类型 Save(value, key);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); Debug.Log(key + &quot;_key_&quot; + index.ToString()); Debug.Log(key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; else &#123; // 如果value的类型是自定义类型 Save(value, key); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"6.反射存储Dictionary数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/6.反射存储Dictionary数据类型","date":"2025-02-22T02:46:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/6.反射存储Dictionary数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/6.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8Dictionary%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"类似反射存储List数据类型 123456789101112else if (typeof(IDictionary).IsAssignableFrom(value.GetType()))&#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; else if (typeof(IDictionary).IsAssignableFrom(value.GetType())) &#123; IDictionary dic = value as IDictionary; PlayerPrefs.SetInt(key, dic.Count); int index = 0; foreach (object item in dic.Keys) &#123; SaveValue(item, key + &quot;_key_&quot; + index.ToString()); SaveValue(dic[item], key + &quot;_value_&quot; + index.ToString()); index++; &#125; &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"5.反射存储List数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/5.反射存储List数据类型","date":"2025-02-22T02:38:46.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/5.反射存储List数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/5.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8List%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"普通数据存储画风1234if (value is int)&#123; PlayerPrefs.SetInt(key, (int)value);&#125; List数据存储画风12345678910if (typeof(IList).IsAssignableFrom(value.GetType()))&#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;&#123;key&#125;_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; SaveValue(fieldInfo.GetValue(obj), keyName); &#125; // 只要Save了一次, 就马上存盘 PlayerPrefs.Save(); &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; // 如果value的类型是List&lt;XXX&gt; else if (typeof(IList).IsAssignableFrom(value.GetType())) &#123; IList list = value as IList; PlayerPrefs.SetInt(key, list.Count); // 要先保存List的长度 for (int i = 0; i &lt; list.Count; i++) &#123; Debug.Log($&quot;&#123;key&#125;_&#123;i&#125;&quot;); SaveValue(list[i], $&quot;&#123;key&#125;_&#123;i&#125;&quot;); &#125; &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"4.反射存储常用数据类型","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/4.反射存储常用数据类型","date":"2025-02-22T02:23:22.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/4.反射存储常用数据类型/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E5%8F%8D%E5%B0%84%E5%AD%98%E5%82%A8%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; Type dataType = obj.GetType(); FieldInfo[] fieldInfos = dataType.GetFields(); //我们存储都是通过PlayerPrefs来进行存储的 //保证key的唯一性 我们就需要自己定一个key的规则 //我们自己定一个规则 // keyName_数据类类型_字段类型_字段名 string keyName = &quot;&quot;; FieldInfo fieldInfo; for (int i = 0; i &lt; fieldInfos.Length; i++) &#123; fieldInfo = fieldInfos[i]; keyName = $&quot;keyName_&#123;dataType.Name&#125;_&#123;fieldInfo.FieldType.Name&#125;_&#123;fieldInfo.Name&#125;&quot;; Debug.Log(keyN ame); &#125; &#125; private void SaveValue(object value, string key) &#123; if (value is int) &#123; PlayerPrefs.SetInt(key, (int)value); &#125; else if (value is float) &#123; PlayerPrefs.SetFloat(key, (float)value); &#125; else if (value is string) &#123; PlayerPrefs.SetString(key, (string)value); &#125; else if (value is bool) &#123; PlayerPrefs.SetInt(key, (bool)value ? 1 : 0); &#125; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"3.数据管理类的创建","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/3.数据管理类的创建","date":"2025-02-22T01:48:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/3.数据管理类的创建/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/3.%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"","text":"123456789101112131415161718192021public class PlayerPrefsDataMgr&#123; private static PlayerPrefsDataMgr instance = new PlayerPrefsDataMgr(); public static PlayerPrefsDataMgr Instance =&gt; instance; private PlayerPrefsDataMgr() &#123; &#125; public void Save(object obj, string key) &#123; &#125; //不用object对象传入 而使用 Type传入 //主要目的是节约一行代码（在外部） //假设现在你要 读取一个Player类型的数据 如果是传入object 你就必须在外部new一个对象传入 //现在有Type的 你只用传入 一个Type typeof(Player) 然后我在内部动态创建一个对象给你返回出来 //达到了 让你在外部 少写一行代码的作用 public object Load(Type type, String key) &#123; return null; &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"2.需求分析","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/2.需求分析","date":"2025-02-22T01:05:48.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/2.需求分析/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/2.%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"1.反射知识补充","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/1.反射知识补充","date":"2025-02-22T00:43:30.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/22/数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目/1.反射知识补充/","permalink":"http://example.com/2025/02/22/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%8F%8D%E5%B0%84%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","excerpt":"","text":"反射知识回顾反射3剑客—— 1T 两 A Type —— 用于获取类的所有信息，包括字段、属性、方法等等 Assembly —— 用于获取程序集，通过程序集获取Type Activator —— 用于快速实例化对象 csharp反射 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"}]},{"title":"csharp反射","slug":"编程语言/Csharp/csharp反射","date":"2025-02-21T12:55:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/编程语言/Csharp/csharp反射/","permalink":"http://example.com/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Csharp源代码到运行时主要阶段在 C# 中，从源代码到运行时的整个过程可以分为以下主要阶段：1源代码(.cs) → 编译 → IL/程序集(.exe/.dll) → CLR加载 → JIT编译 → 本机代码 → 执行 源代码阶段： 编写源代码： 开发者编写 C# 源代码文件（.cs）。 编译阶段： 编译： 使用 C# 编译器（csc.exe）将源代码编译为中间语言（IL，Intermediate Language）代码。生成的文件通常是一个扩展名为 .exe（可执行文件）或 .dll（动态链接库）的程序集。 生成[[元数据]]： 编译过程中，生成包含程序集信息的[[元数据]]，包括类型、成员、版本等信息。 JIT 编译阶段： JIT 编译： 在运行时，Common Language Runtime（CLR）的 JIT 编译器负责将 IL 代码编译为本地机器代码。这一步是在程序加载到内存时进行的，即时（Just-In-Time）编译。 执行阶段： 加载程序集： CLR 加载编译好的程序集，包括 IL 代码和[[元数据]]。 执行程序： 程序在 CLR 中执行，JIT 编译器将 IL 代码转换为本地机器代码。执行过程中，CLR 负责内存管理、类型检查、垃圾回收等任务。 总结： 开发者阶段： 编写源代码。 编译阶段： 编译源代码生成 IL 代码和[[元数据]]。 JIT 编译阶段： 在运行时将 IL 代码编译为本地机器代码。 执行阶段： 加载程序集，执行程序，CLR 负责管理运行时环境。 编译 vs 运行 编译期 运行时 发生时间 发生在构建过程中，源代码被翻译为目标代码或中间代码。 发生在程序实际运行时，加载到内存并执行。 可能出现的错误 静态检查错误，如语法错误、类型错误等。 动态运行时错误，如空指针引用、除零错误等。 排查难度 错误信息清晰，易于定位和修复。 错误可能更难以排查，需要使用调试工具进行追踪。 无运行时 有运行时 内存管理 程序员需要手动管理内存分配和释放。 运行时环境负责内存管理，可能包括自动内存分配和垃圾回收。 线程模型 通常依赖操作系统提供的线程机制。 可能提供自己的线程管理机制，与操作系统的线程模型有一定差异。 系统调用 直接使用操作系统提供的系统调用接口。 通过运行时环境提供的接口进行系统调用，可能会屏蔽一些底层细节。 运行效率 对于底层硬件和操作系统有更直接的控制。 需要运行时环境的支持，可能引入一些开销。 动态库 vs. 静态库 - 编译和链接阶段： 阶段 静态库 动态库 定义 静态库是在编译时被链接到程序的库，代码在程序编译阶段就被静态地合并。 态库是在运行时加载到内存的库，它的代码在程序执行时被动态地链接。 文件格式 .lib（Windows）或 .a（Unix/Linux） .dll（Windows）或 .so（Unix/Linux） 编译和链接阶段 静态库的代码在编译时被整合到程序中 编译时不包含库的代码，只在链接时引用库的符号 作用 提供独立的代码副本，每个程序有自己的库的实例，适用于没有外部库的环境 节省内存，允许在运行时替换库的版本，减小程序的可执行文件大小 动态库 vs. 静态库 - 区别和使用场景： 特点 静态库 动态库 链接方式 链接在编译时 链接在运行时 内存占用 每个程序有自己的库的实例，可能占用更多内存 共享内存，多个程序可以共享同一个动态库的实例 更新和维护 需要重新编译整个程序，更新较为繁琐 可在运行时替换库的版本，更容易更新 可执行文件大小 可执行文件较大，因为库的代码在编译时合并到可执行文件中 可执行文件较小，因为库的代码在运行时加载 反射程序正在运行时，可以查看其它[[程序集]]或者自身的[[元数据]]。一个运行的程序查看本身或者其它程序的[[元数据]]的行为就叫做反射 在程序运行时，通过反射可以得到其它[[程序集]]或者自己[[程序集]]代码的各种信息类，函数，变量，对象等等，实例化它们，执行它们，操作它们 exe/dll(主要区别是exe有入口)metadata: 描述dll/exe文件的一个 数据清单反射: 用来操作获取[[元数据]] 就是一个操作metadata的一个类库, 用来操作[[元数据]]中的类, 方法, 属性, [[csharp特性]], 为什么通过反射去间接操作? 我们需要动态 (这些 “动态” 操作都是在运行时期根据运行时的信息来进行的，而不是在编译时期就确定好的。这使得程序更加灵活，能够处理一些在编译时难以确定的情况。) 读取私有的对象 Type（类的信息类）它是反射功能的基础！它是访问[[元数据]]的主要方式。使用 Type 的成员获取有关类型声明的信息有关类型的成员（如构造函数、方法、字段、属性和类的[[事件]]） 1234567int a = 32;Type t1 = a.GetType();Type t2 = typeof(int);// 必须要包含命名空间.类名Type t3 = Type.GetType(&quot;System.Int32&quot;);// 每一个类只有一份元数据, 所以上面的t1, t2, t3 指向的是同一个堆空间 获取所有公共成员 （GetMembers成员包括：成员变量，成员函数等等1234567891011121314151617181920212223class Test&#123; private int i = 0; public int j = 1; public string str = &quot;hello world&quot;; public Test() &#123; &#125; public Test(int i) &#123; this.i = i; &#125; public Test(int i, string s) : this(i) &#123; this.str = s; &#125; public void Fun() &#123; Console.WriteLine(str); &#125;&#125;Type t = typeof(Test);MemberInfo[] memberInfos = t.GetMembers();for (int i = 0; i &lt; memberInfos.Length; i++) Console.WriteLine(memberInfos[i]); 获取类所有的公共构造函数并调用 （GetConstructors1234567891011121314151617// 所有公共构造函数ConstructorInfo[] ctors = t.GetConstructors();// 得构造函数传入 Type数组 数组中内容按顺序是参数类型// 执行构造函数传入 object数组 表示按顺序传入的参数// 无参构造获取Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[0]);Test test = constructorInfo.Invoke(null) as Test;// 有参构造获取 获取一个参数为int的构造函数Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[1] &#123; typeof(int) &#125;);Test test = constructorInfo.Invoke(new object[1] &#123; 666 &#125;) as Test; 获取类所有公共成员变量 （GetFieldsFieldInfo 类是 .NET 反射中的一个类，用于表示和操作类或结构体的字段信息。字段是类或结构体中的成员变量，通常用于存储对象的状态。FieldInfo 类提供了访问字段的[[元数据]]和运行时值的方法。 以下是一些 FieldInfo 类的常用属性和方法： 属性： Name: 获取字段的名称。 FieldType: 获取字段的类型。 IsPublic, IsPrivate, IsStatic, IsInitOnly: 判断字段的访问修饰符和其他属性。 DeclaringType: 获取定义该字段的类的 Type 对象。 方法： GetValue(object obj): 获取指定对象上的字段值。需要传递目标对象的实例作为参数。 SetValue(object obj, object value): 设置指定对象上的字段值。需要传递目标对象的实例和要设置的值作为参数。 以下是一个简单的示例，演示如何使用 FieldInfo 获取和操作字段：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 得到所有公共成员变量Type t = typeof(Test);FieldInfo[] fieldInfos = t.GetFields();// 得到指定名称的公共成员Type t = typeof(Test);FieldInfo fieldInfo = t.GetField(&quot;str&quot;);// 通过反射 获取其它程序集的对象的某个成员变量的值// 假设下面的Test是其他程序集new出来的, Test.str = &quot;wocao&quot;Test test = new Test(999, &quot;wocao&quot;);Console.WriteLine(fieldInfo.GetValue(test)); // 获取到test.str // 通过反射 设置其它程序集的对象的某个成员变量的值 第一个参数是想要通过反射操作的对象!fieldInfo.SetValue(test, &quot;hello world&quot;);Console.WriteLine(fieldInfo.GetValue(test));using System;using System.Reflection;public class MyClass&#123; public int PublicField; private string PrivateField; public MyClass(int value) &#123; PublicField = value; PrivateField = &quot;PrivateFieldValue&quot;; &#125;&#125;class Program&#123; static void Main() &#123; Type myClassType = typeof(MyClass); // 获取字段信息 FieldInfo publicFieldInfo = myClassType.GetField(&quot;PublicField&quot;); FieldInfo privateFieldInfo = myClassType.GetField(&quot;PrivateField&quot;, BindingFlags.NonPublic | BindingFlags.Instance); // 创建 MyClass 实例 MyClass myObject = new MyClass(42); // 读取和修改字段的值 int publicFieldValue = (int)publicFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PublicField value: &#123;publicFieldValue&#125;&quot;); privateFieldInfo.SetValue(myObject, &quot;NewPrivateFieldValue&quot;); string privateFieldValue = (string)privateFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PrivateField value: &#123;privateFieldValue&#125;&quot;); &#125;&#125; 获取了所有公共成员函数 （GetMethods1234567891011121314151617181920212223242526272829303132333435363738394041// 获取所有公共成员函数并执行Type t = typeof(string);MethodInfo[] methodInfos = t.GetMethods();for (int i = 0; i &lt; methodInfos.Length; i++) Console.WriteLine(methodInfos[i]);// 获取特定名称的公共成员函数MethodInfo methodInfo = t.GetMethod(&quot;Substring&quot;, new Type[] &#123; typeof(int), typeof(int) &#125;);// 执行该方法string str = &quot;hello world&quot;;// 第一个参数是想要通过反射操作的对象 相当于 对象.XX 如果是静态就传 null str = methodInfo.Invoke(str, new object[] &#123; 0, 5 &#125;) as string;Console.WriteLine(str);Type myClassType = typeof(MyClass);// 获取所有公共方法MethodInfo[] publicMethods = myClassType.GetMethods();// 输出方法信息foreach (MethodInfo methodInfo in publicMethods)&#123; Console.WriteLine($&quot;Method Name: &#123;methodInfo.Name&#125;&quot;); Console.WriteLine($&quot;Return Type: &#123;methodInfo.ReturnType&#125;&quot;); // 获取方法的参数信息 ParameterInfo[] parameters = methodInfo.GetParameters(); Console.Write(&quot;Parameters: &quot;); foreach (ParameterInfo parameter in parameters) &#123; Console.Write($&quot;&#123;parameter.ParameterType&#125; &#123;parameter.Name&#125; &quot;); &#125; Console.WriteLine(); Console.WriteLine();&#125; 其它 type.GetXXX1234567891011121314151617//得枚举GetEnumNameGetEnumNames//得事件GetEventGetEvents//得接口GetInterfaceGetInterfaces//得属性GetPropertyGetPropertys//等等 快速通过反射实例化对象 Activator使用 Activator 类的主要优势在于在运行时创建对象，尤其是当不知道具体类型的情况下。然而，需要注意的是，使用 Activator 可能会导致性能损失，因为它依赖于反射机制。在已知类型的情况下，直接使用 new 操作符通常是更好的选择。12345// 快速将Type实例化为对象 无参构造Type t = typeof(Test);Test test = Activator.CreateInstance(t) as Test;// 有参构造 后面参数如果不对会报错test = Activator.CreateInstance(t, 666, &quot;wocao&quot;) as Test; Assembly[[程序集]]类Assembly: 主要用来加载其它[[程序集]]，加载后 才能用Type来使用其它[[程序集]]中的信息如果想要使用不是自己[[程序集]]中的内容 需要先加载[[程序集]] 比如 dll文件(库文件)简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类 三种加载[[程序集]]的函数:一般用来加载在同一文件下的其它[[程序集]]Assembly asembly2 = Assembly.Load(“[[程序集]]名称”); 一般用来加载不在同一文件下的其它[[程序集]]Assembly asembly = Assembly.LoadFrom(“包含[[程序集]]清单的文件的名称或路径”);Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”); 12345Assembly assembly = Assembly.LoadFrom(@&quot;D:\\\\Myproject VS\\\\静态\\\\bin\\\\Debug\\\\net8.0\\\\test.dll&quot;);Type[] types = assembly.GetTypes();Type t = assembly.GetType(&quot;test.Icon&quot;);t.XXX 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"4.PlayerPrefs总结","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结","date":"2025-02-21T12:27:02.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/","excerpt":"","text":"练习要在游戏中做一个排行榜功能，排行榜主要记录玩家名（可重复）,玩家得分，玩家通关时间，请用PlayerPrefs存储读取排行榜相关信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/// &lt;summary&gt;/// 排行榜多条具体信息/// &lt;/summary&gt;public class RankListInfo&#123; //排行榜单条信息列表 public List&lt;RankInfo&gt; rankList; //初始化的时候就是读取数据 public RankListInfo() &#123; Load(); &#125; /// &lt;summary&gt; /// 新加排行榜信息 /// &lt;/summary&gt; public void Add(string name, int score, int time) &#123; rankList.Add(new RankInfo(name, score, time)); &#125; //存储数据 public void Save() &#123; //存储有多少条数据 PlayerPrefs.SetInt(&quot;rankListCount&quot;, rankList.Count); for (int i = 0; i &lt; rankList.Count; i++) &#123; RankInfo info = rankList[i]; PlayerPrefs.SetString(&quot;rankInfo&quot; + i, info.playerName); PlayerPrefs.SetInt(&quot;rankScore&quot; + i, info.playerScore); PlayerPrefs.SetInt(&quot;rankTime&quot; + i, info.playerTime); &#125; &#125; //读取数据 private void Load() &#123; int rankListCount = PlayerPrefs.GetInt(&quot;rankListCount&quot;, 0); rankList = new List&lt;RankInfo&gt;(); for (int i = 0; i &lt; rankListCount; i++) &#123; RankInfo info = new RankInfo( PlayerPrefs.GetString(&quot;rankInfo&quot; + i), PlayerPrefs.GetInt(&quot;rankScore&quot; + i), PlayerPrefs.GetInt(&quot;rankTime&quot; + i)); rankList.Add(info); &#125; &#125;&#125;/// &lt;summary&gt;/// 排行榜单条信息/// &lt;/summary&gt;public class RankInfo&#123; public string playerName; public int playerScore; public int playerTime; public RankInfo(string name, int score, int time) &#123; playerName = name; playerScore = score; playerTime = time; &#125;&#125;#endregionpublic class Lesson03_练习题 : MonoBehaviour&#123; void Start() &#123; //初始化一个排行榜 RankListInfo rankListInfo = new RankListInfo(); print(rankListInfo.rankList.Count); //打印排行榜所有信息 for (int i = 0; i &lt; rankListInfo.rankList.Count; i++) &#123; print(&quot;姓名&quot; + rankListInfo.rankList[i].playerName); print(&quot;分数&quot; + rankListInfo.rankList[i].playerScore); print(&quot;时间&quot; + rankListInfo.rankList[i].playerTime); &#125; //添加排行榜单条信息保存 rankListInfo.Add(&quot;nihao&quot;, 100, 66); rankListInfo.Save(); &#125;&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.PlayerPrefs不同平台的存储位置","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置","date":"2025-02-21T12:09:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.PlayerPrefs%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"PlayerPrefs存储的数据存在哪里？在不同平台上，PlayerPrefs存储的位置会有所不同： PlayerPrefs的存储位置Windows：PlayerPrefs 存储在注册表（regedit）中。具体位置为： 32位系统：HKEY_CURRENT_USER\\Software\\[公司名]\\[产品名] 64位系统：HKEY_CURRENT_USER\\Software\\WOW6432Node\\[公司名]\\[产品名] Android：在Android上，PlayerPrefs 存储在应用的持久数据目录中。具体路径为：/data/data/[包名]/shared_prefs/unity.[公司名].[产品名]_prefs.xml。 Linux：在Linux上，PlayerPrefs 存储在用户主目录的 .config/unity3d/[公司名]/[产品名]/prefs 目录中。 iOS：在iOS上，PlayerPrefs 存储在应用的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。 macOS：在macOS上，PlayerPrefs 存储在用户主目录的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.PlayerPrefs基本方法","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法","date":"2025-02-21T11:49:40.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.PlayerPrefs%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/","excerpt":"","text":"PlayerPrefs是什么PlayerPrefs是Unity提供的可以用于存储读取玩家数据的公共类。PlayerPrefs，你可以轻松地存储和获取一些简单的数据，例如玩家的分数、游戏设置、解锁的关卡等。这些数据将在应用程序关闭后仍然保留，可以在下次启动应用程序时继续使用。 PlayerPrefs的数据存储 PlayerPrefs的数据存储类似于键值对存储，一个键对应一个值。 提供了存储3种数据的方法 int float string。 键: string类型。 值：int float string 对应3种API。 SetInt方法 SetFloat方法 SetString方法 存储数据1234//设置由 key 标识的偏好的值。PlayerPrefs.SetInt(&quot;第几帅&quot;, 1);PlayerPrefs.SetFloat(&quot;存个浮点数&quot;, 1.1f);PlayerPrefs.SetString(&quot;黄&quot;, &quot;先生&quot;); Save方法 马上存储数据到硬盘中直接调用Set相关方法只会把数据存到内存里。当游戏结束时 Unity会自动把数据存到硬盘中。如果游戏不是正常结束的而是崩溃 数据是不会存到硬盘中的。调用该方法马上存到硬盘(各个平台默认位置)1PlayerPrefs.Save(); PlayerPrefs局限性1234//PlayerPrefs是有局限性的 它只能存3种类型的数据。//如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储。bool sex = true;PlayerPrefs.SetInt(&quot;sex&quot;, sex ? 1 : 0); 如果不同类型用同一键名进行存储 会进行覆盖12PlayerPrefs.SetInt(&quot;myAge&quot;, 18);PlayerPrefs.SetFloat(&quot;myAge&quot;, 20.2f);//覆盖上一行存储的myAge数据 读取相关12// 如果填了第二个参数代表没找到就返回后的默认值, 可用来进行基础数据的初始化string test = PlayerPrefs.GetString(&quot;黄&quot;); 注意： 运行时只要你Set了对应键值对 即使你没有马上存储Save在本地 也能够读取出信息 如果存的是SetInt(&quot;myAge&quot;， 18); 读取的是GetFloat(&quot;myAge&quot;);则会使用Float默认值0 键的存在与删除12345678if (PlayerPrefs.HasKey(&quot;测试&quot;))&#123; // 删除 // 根据键来删除 PlayerPrefs.DeleteKey(&quot;测试&quot;); // 删除所有键值对 PlayerPrefs.DeleteAll();&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.PlayerPrefs概述","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述","date":"2025-02-21T11:42:51.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"34.unity入门基础知识总结","slug":"游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结","date":"2025-02-21T08:54:06.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"33.Microphone麦克风","slug":"游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风","date":"2025-02-21T08:21:52.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.Microphone%E9%BA%A6%E5%85%8B%E9%A3%8E/","excerpt":"","text":"Unity提供了Microphone类 获取设备信息1234// 获取设备Microphone信息string[] strs = Microphone.devices;for (int i = 0; i &lt; strs.Length; i++) print(strs[i]); 开始, 结束录制并存储12345678910111213141516171819202122232425// 开始录制 (1. 设备名 传null使用默认设备, 2. 超过录制长度是否重新录制// (3. 录制时长, 4. 采样率if (Input.GetKeyDown(KeyCode.Space))&#123; _audioClip = Microphone.Start(null, false, 10, 44100);&#125;// 结束录制if (Input.GetKeyUp(KeyCode.Space))&#123; // 为null表示默认设备 Microphone.End(null); // 播放录制音频 AudioSource audio = GetComponent&lt;AudioSource&gt;() ?? gameObject.AddComponent&lt;AudioSource&gt;(); audio.clip = _audioClip; audio.Play(); //AudioClip类的channels变量和samples变量 //channels变量 音频剪辑中的声道数。（只读） //samples变量 样本中音频剪辑的长度。（只读） //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[_audioClip.channels * _audioClip.samples]; // 把数据存储到浮点数数组里 第二个参数是偏离的位置, 默认填0 _audioClip.GetData(f, 0);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"32.AudioSource音频源代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制","date":"2025-02-21T07:58:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"代码控制播放停止12345678910111213141516171819202122232425_audioSource = GetComponent&lt;AudioSource&gt;();// 按下p键播放if (Input.GetKeyDown(KeyCode.P))&#123; _audioSource.Play(); //_audioSource.PlayDelayed(4); // 4秒后播放&#125;// 音频停止if (Input.GetKeyDown(KeyCode.S))&#123; _audioSource.Stop();&#125;// 音频暂停 if (Input.GetKeyDown(KeyCode.Space))&#123; _audioSource.Pause(); //_audioSource.UnPause();再次播放可恢复 (或者使用停止暂停&#125;// 音量大小audioSource.volume = floatValue;// 是否静音audioSource.mute = true 检测播放是否完毕AudioSource没有提供相关12345// 检测音频是否播放完 if (!_audioSource.isPlaying)&#123; print($&quot;在Update中不断检测该属性可以判断是否播放完毕&quot;);&#125; 控制音频播放几种方式 直接在要播放音频的对象上挂载脚本来控制 自己创建一个挂载了音频脚本的GameObject(放在prefab预设体里) 用得少在其他脚本中实例化(如果playOnAwake实例化时播放) 这个对象 用一个AudioSource来控制不同的音效 _audioSource.clip = XXX（AudioClip) ps: 注意: 一个GameObject可以挂载多个音频源脚本AudioSource, 但一定要自己管理好, 不然谁是谁都不知道","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"31.AudioSource音频源组件和AudioListener音频监听组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件","date":"2025-02-21T07:31:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/","excerpt":"","text":"添加AudioSource 音频源脚本 AudioClip 声音剪辑文件（音频文件） 可以拖拽音频文件到这个变量上 Output 输出* 默认不设置的话将直接输出到场景中的音频监听器 可以更改为输出到混音器 混音器是高级功能，以后再讲解 Mute 静音开关Bypass Effect 开关滤波器效果*Bypass Listener Effects 快速开关所有监听器*Bypass Reverb Zones 快速开关所有混响区*Play On Awake 唤醒时播放 对象创建时就播放音乐 开启的话启动游戏默认就播放 关闭的话启动游戏默认就不播放 Loop 循环 循环播放音乐，一般背景音乐才用 Priority 优先级 优先级越高，越不容易被别的音效覆盖 Volume 音量大小Pitch 音调 可以理解为音乐快放满房 Stereo Pan 立体声效 2D声音立体声位置 相当于左右声道 Spatial Blend 空间混合 音频受3D空间的影响程度，默认是2D音效，拖满为1变成3D音效 Reverb Zone Mix 混响区混音* 到混响区的输出信号量 3D Sound Settings 3D声音设置 和Spatial Blend参数成正比应用 Doppler Level 多普勒效果等级 Spread 扩张 扩散角度设置为3D立体声还是多声道 Volume Rolloff 音量衰减 声音衰减速度，蓝线横轴可以理解为离耳朵的远近，红线纵轴可以理解为声音大小，耳朵可以理解为AudioListener音频监听脚本 Logarithmic Rolloff 对数衰减 靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff 线性衰减 与音频源的距离越远，听到的声音越小。 Custom Rolloff 自定义衰减 音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance 最大最小距离 最小距离内，声音保持最大响度 最大距离外，声音开始减弱 AudioListener 音频监听脚本 默认挂载到场景的主摄像机上，可以理解为是我们的耳朵 有且只有一个，两个把另外一个要移除","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"30.音频文件导入","slug":"游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入","date":"2025-02-20T15:03:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/","excerpt":"","text":"音频文件常用格式 wav mp3 ogg aiff （不常用） 导入音频文件导入音频文件直接从外部拖拽音频文件到Project窗口即可 Force To Mono 强制变为单声道 多声道转单声道 Normalize 归一化 强制为单声道时，混合过程中被标准化 Load In Background 后台加载在后台加载，不阻塞主线程 Ambisonic 全景声音* 立体混响声 非常适合 360 度视频和 XR 应用程序 如果音频文件包含立体混响声编码的音频，请启用此选项 LoadType 加载类型 Decompress On Load 加载时压缩 不压缩形式存在内存，加载块，但是内存占用高 适用于小音效 Compress in memory 压缩内存 压缩形式存在内存，加载慢，内存小 仅适用于较大音效文件 Streaming 流式处理 以流形式存在，使用时解码。内存占用最小，cpu消耗高 性能换内存 Preload Audio Data 预加载音频数据 预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format 压缩格式 PCM 音频以最高质量存储 Vorbis 相对PCM压缩的更小，根据质量决定 ADPCM 包含噪音，会被多次播放的声音，如碰撞声 Quality 音频质量* 确定要应用于压缩剪辑的压缩量。 不适用于 PCM/ADPCM/HEVAG 格式 Sample Rate Setting 采样率设置* PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率 Preserve Sample Rate 保持采样率 此设置可保持采样率不变（默认值） Optimize Sample Rate 优化采样率 此设置根据分析的最高频率内容自动优化采样率 Override Sample Rate 覆盖采样率 此设置允许手动覆盖采样率 因此可有效地将其用于丢弃频率内容。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"29.刚体加力","slug":"游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力","date":"2025-02-20T12:09:49.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/","excerpt":"","text":"刚体加力12345678910111213141516171819202122// 获取刚体组件对象rigidbody = this.GetComponent&lt;Rigidbody&gt;();// 添加力// (相对世界坐标系rigidbody.AddForce(Vector3.forward * 10);// (相对本地坐标系rigidbody.AddRelativeForce(Vector3.forward * 10);// 添加扭矩力// (世界坐标系 // 没有扭矩阻力会一直动rigidbody.AddTorque(Vector3.up * 10);// (本地坐标系rigidbody.AddRelativeTorque(Vector3.forward * 10);// 改变刚体速度 用的少, 位移一般用translate或者给力// 世界坐标系rigidbody.velocity = Vector3.forward;// 模拟爆炸 在中心产生半径 20m 40的力// 如果想要所有刚体都产生同样的爆炸效果就必须所有的刚体组件都要调用AddExplosionForce方法rigidbody.AddExplosionForce(40, Vector3.zero, 20); AddForce方法第二个参数力的模式1. ForceMode.Force（默认模式） 公式：F t = m v 说明： 力会持续作用，受物体质量（mass）影响，质量越大加速度越小。 需要乘以 Time.fixedDeltaTime 才能与物理时间步长匹配（Unity 已自动处理）。 示例：123// 推动质量为2kg的物体，每帧施加10N的力rb.AddForce(Vector3.forward * 10, ForceMode.Force);// 最终加速度 = 10N / 2kg = 5m/s² 2. ForceMode.Acceleration 公式：F * t = v （m 为 1） 说明： 直接施加加速度，忽略物体质量。 适合需要固定加速度的场景（如模拟重力）。 示例：12// 无论质量如何，物体以5m/s²的加速度运动rb.AddForce(Vector3.forward * 5, ForceMode.Acceleration); 3. ForceMode.Impulse 公式：F = m * v （t 为 1） 说明： 瞬间施加一个冲量，效果类似“一次性爆发力”。 受质量影响，质量越大效果越弱。123// 施加一个冲量为100N·s的力（相当于100N的力作用1秒）rb.AddForce(Vector3.up * 100, ForceMode.Impulse);// 质量为2kg时，速度增量 = 100 / 2 = 50m/s 4. ForceMode.VelocityChange 公式：F = v （m 为 1， t 为 1） 说明： 直接修改速度，忽略质量和时间步长。 效果类似“瞬间设置速度”。 示例：12// 直接将物体的Y轴速度增加10m/s（无视质量）rb.AddForce(Vector3.up * 10, ForceMode.VelocityChange); 恒力场组件 刚体的休眠Unity为了节约性能，可能会让刚体休眠。比如让一个有刚体的Cube，受重力影响掉落一个平面上。当他们静止时，斜向下旋转刚体，这个时候Cube可能不会往下落，因为Cube休眠了。假如这个时候移动一下平面的位置，Cube可能又会往下落，因为移动平面唤醒了刚体。12345678910// IsSleeping方法 获取刚体是否处于休眠状态if (rigidBody.IsSleeping())&#123;&#125;// 唤醒休眠if (rigidBody.IsSleeping())&#123; rigidBody.WakeUp();&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"28.碰撞检测之碰撞检测函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数","date":"2025-02-20T11:22:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/","excerpt":"","text":"注意:碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用ps：只要挂载的对象能和其它物体产生碰撞检测才会响应下面的函数如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的，必须挂载到这个刚体父对象上才行。 物理碰撞检测响应函数12345678910111213141516171819202122232425262728293031private void OnCollisionEnter(Collision collision)&#123; // Collision类 (碰撞信息类 // 碰撞到的对象碰撞器的信息 Collider collider1 = collision.collider; // 碰撞到的对象的所依附的对象 (GameObject) GameObject gameObject1 = collision.gameObject; // 碰撞到的对象的transform组件信息 Transform transform1 = collision.transform; // 触碰点数相关 接触点具体坐标 ContactPoint[] contacts = collision.contacts; print($&quot;我被&#123;collision.gameObject.name&#125;碰撞到了&quot;);&#125;// 碰撞结束分离时, 自动执行private void OnCollisionExit(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;碰撞分离了&quot;);&#125;// 两个物体相互摩擦时会不停调用该函数private void OnCollisionStay(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;一直在产生摩擦&quot;);&#125; 触发器检测响应函数1234567891011121314151617// 触发开始时会自动调用该函数 (传入的是Collider脚本对象)private void OnTriggerEnter(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;触发了&quot;);&#125;// 当Stay结束时调用private void OnTriggerExit(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;结束触发了&quot;);&#125;// 当两触发器相交会不停调用private void OnTriggerStay(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;水乳相融&quot;);&#125; 碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑 一般会把想要重写的碰撞和触发检测函数写成protected保护类型的，加上virtual变成虚函数。 没有必要写成public，因为不会自己手动调用碰撞和触发检测函数，都是Unity通过反射帮助我们自动调用的。 小练习在之前Input和Screen中的练习题基础上，加入一个点击鼠标左键可以发射一颗子弹飞出的功能 给坦克添加一个炮口空物体当做子弹飞出来的位置添加点击飞出子弹代码，创建子弹预设体，拖拽赋值炮口空物体和子弹预设体12345678910//Update内 if (Input.GetMouseButtonDown(0)) &#123; //实例化一个子弹对象 GameObject obj = Instantiate(bulletObj); //设置对象的位置 obj.transform.position = bulletPos.position; //设置对象的角度 obj.transform.eulerAngles = bulletPos.eulerAngles; &#125;子弹一直飞12//Update内 //子弹一直往前飞 this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); 加入子弹触碰到地面会自动消失的功能123456789101112131415private void OnTriggerEnter(Collider other)&#123; //问题一：如果发射子弹时 和坦克自身的碰撞和重合了 可能一开始 就会被移除 //解决方案：判断自己碰撞到的对象 是什么 一定是特定对象 才移除自己 if (other.gameObject.CompareTag(&quot;Ground&quot;) || other.gameObject.CompareTag(&quot;Monster&quot;)) &#123; //碰撞到别的东西 就让子弹小时 //一定是移除自己依附的GameObject对象 而不是脚本自己 Destroy(this.gameObject); &#125; //问题二：坦克本身就带有碰撞盒 当子弹和坦克自身的碰撞盒碰撞可能会产生力的作用 出现一些意想不到的效果 //解决方案：把子弹做成触发器 这样就没有了力的作用&#125; 123456789101112131415public int HP = 3;//当子弹碰到我时 就减血 血量为0了 就移除private void OnTriggerEnter(Collider other)&#123; //由于场景上 只有子弹时触发器 所以我们可以不用进行任何判断 就可以完成这个功能 //减血 HP -= 1; //为0就移除自己 if (HP &lt;= 0) &#123; Destroy(this.gameObject); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"27.碰撞检测之物理材质","slug":"游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质","date":"2025-02-20T11:15:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/","excerpt":"","text":"创建物理材质 在Project窗口加号创建或者右键创建 把物理材质拖拽到两个碰撞器上才能相互作用 物理材质参数Dynamic Friction 动摩擦力 已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。 Static Friction 静摩擦力 当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness 弹性 表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine 摩擦力组合 两个碰撞对象的摩擦力的组合方式。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。 Bounce Combine 反弹组合 两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"26.碰撞检测之碰撞器","slug":"游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器","date":"2025-02-20T10:39:05.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/","excerpt":"","text":"知识回顾两个物体都有碰撞器，至少一个物体有刚体碰撞器表示物体的体积（形状）刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用 3D碰撞器种类1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 共同参数Edit Collider 编辑碰撞器改变碰撞体大小 Is Trigger 是否是触发器 如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略 主要用于进行没有物理效果的碰撞检测 Material 物理材质* 可以确定碰撞体和其它对象碰撞时的交互（表现）方式。 Center 碰撞器中心 碰撞体在对象局部空间中的中心点位置 常用碰撞器BoxCollider 盒状碰撞器 Size 大小：碰撞体在X、Y、Z方向上的大小 Sphere Collider 球状碰撞器 Radius 半径：球形碰撞体的半径大小 Capsule Collider 胶囊碰撞器 Radius 半径：胶囊体的半径 Height 高度：胶囊体的高度 Direction 轴向：胶囊体在对象局部空间中的轴向 异形物体使用多种碰撞器组合 刚体对象的子对象碰撞器信息参与碰撞检测 比如金字塔预设体，只在金字塔最高层级对象添加刚体，子对象的所有Cube都会参与碰撞检测 再比如一个Cube添加刚体，再给他添加两个空物体，两个空物体分别添加斜着的盒型碰撞器当做支架，这样这个Cube下落时就会被支架撑起来，即便两个空物体连模型都没有只有碰撞器 不常用碰撞器*Mesh Collider 网格碰撞器* 不常用的原因是性能消耗较高 默认不会显示绿色的碰撞器边框，开启Convex 才会显示绿色的碰撞器边框 Convex Mesh Collider 最多 255 个三角形。 Wheel Collider 轮胎碰撞器* 可以通过给车的父对象加刚体（注意刚体质量一定要大），子对象加车轮碰撞器模拟汽车 Terrain Collider 地形碰撞器* 不常用的原因是性能消耗很高","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"25.碰撞检测之刚体","slug":"游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体","date":"2025-02-20T09:28:06.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/","excerpt":"","text":"碰撞产生的必要条件：两个物体都有碰撞器，至少一个物体有刚体 RigidBody组件信息如下 Mass 质量 默认为千克 质量越大惯性越大 Drag 空气阻力 根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力 Angular Drag 角阻力（扭矩阻力） 通俗理解就是阻碍对象旋转的阻力，角阻力越大越不容易旋转 0 表示没有空气阻力。 Use Gravity 重力开关 是否受重力影响 Is Kinematic 控制物理是否影响刚体。 可以理解为开启后不受力的影响，只能通过Transform移动 如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用。 Interpolate 插值运算 让刚体物体移动更平滑 可以更改FixTime，改成一秒，这样对象会很突兀的一秒移动一次，这时开启插值运算就可以让刚体对象平滑移动 None 无插值运算模式 不应用插值运算 Interpolate 插值模式 插值将始终滞后一点，但比外推更流畅。 根据前一帧的变换来平滑变换。 Extrapolate 外推模式 外推将根据当前速度预测刚体的位置。 根据下一帧的估计变换来平滑变换。 Collision Detection 碰撞检测模式 Continuous Dynamic 连续动态检测 &gt; Continuous Speculative 连续推测检测 &gt; Continuous 连续检测 &gt; Discrete 离散检测 用于防止快速移动的对象穿过其它对象而不检测碰撞 Discrete 离散检测 默认的碰撞检测模式。 在每一帧中进行一次碰撞检测，适用于大多数普通物体。 最省性能，但可能会错过高速物体的碰撞。 适合一般速度移动的物体，不适合高速移动的小物体。 对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值） Continuous 连续检测 提高了碰撞检测的精度，特别适合高速移动的物体。 在每一帧中进行多次碰撞检测，避免高速物体穿过其他物体。 比 Discrete 消耗更多的性能，但减少了穿透问题。 适用于高速移动的物体，如子弹或快速飞行的物体。 对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用连续碰撞检测。 设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置） 其他刚体将使用离散碰撞检测。 Continuous Dynamic 连续动态检测 针对快速移动的物体和其他静止或缓慢移动的物体之间的碰撞检测。 结合 Continuous 和 Discrete 的优点，对高速物体进行多次检测，对慢速或静止物体进行一次检测。 在保证精度的同时比 Continuous 更省性能。 适用于快速移动的物体与静止或缓慢移动的物体之间的碰撞检测，如快速移动的角色或车辆。 性能消耗高 对设置为连续 (Continuous)和连续动态 (Continuous Dynamic)碰撞的游戏对象使用连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。 对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。 Continuous Speculative 连续推测检测 使用预测的方式进行碰撞检测。 预测物体的未来位置，并在物体穿过其他物体前进行检测和处理。 性能较高，精度也不错，但有时可能会出现误判。 适合大多数需要高精度且有较高速度的物体。 对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 Constraints 刚体约束 对刚体运动的限制 Freeze Position 冻结位置 有选择地停止刚体沿世界 X、Y 和 Z 轴的移动。 Freeze Rotation 冻结旋转 有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"24.光面板","slug":"游戏引擎/unity/unity入门/unity入门基础知识/24.光面板","date":"2025-02-20T09:07:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/24.光面板/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"Skybox Material 天空盒材质可以改变天空盒可以在project窗口右键创建材质，材质选择成天空盒着色器 Sun Source 太阳来源*不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting 环境光设置*Source 环境光光源颜色* Skybox 天空盒：天空和材质作为环境光颜色 Gradient 渐变：可以为天空、地平线、地面单独选择颜色和他们之间混合 Color颜色 Intensity Multiplier 环境光亮度*Ambient Mode 环境模式* 全局光照模式，只有启用了实时全局和全局烘焙时才有用 Realtime 实时（已弃用） Baked 烘焙 OtherSettings 其它设置*Fog 雾开关* Color 雾颜色 Mode 雾计算模式 Linear 线性模式 随距离线性增加 Start 开始距离 离摄像机多远开始有雾 End 结束距离 离摄像机多远完全遮挡 Exponential 指数模式 随距离指数增加 Density 密度 雾强度 Exponential Qquare 指数平方模式 随距离比指数更快的增加 Density 密度 雾强度 Halo Texture 光晕材质*光源周围挥着光环的纹理 Halo Strength 光晕强度*光环可见性 Flare Fade Speed 炫光交叉淡化速度*耀斑淡出时间，最初出现之后淡出的时间 Flare Strength 炫光强度*耀斑可见性 Spot Cookie 聚光灯剪影*聚光灯剪影纹理","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"23.Light光源组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件","date":"2025-02-20T08:10:23.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/","excerpt":"","text":"Type光源类型 Spot聚光灯 Spot Angle光锥角度 Range发光范围距离 Directional方向光(环境光) Point点光源 Area面光源 Mode 光源模式 Realtime 实时光源：每帧实时计算，效果好，性能消耗大 Baked 烘焙光源：事先计算好，无法动态变化 Mixed 混合光源：预先计算+实时运算 Intensity 光源强度Indirect Multiplier 间接系数 *改变间接光的强度低于1，每次反弹会使光更暗大于1，每次反弹会使光更亮 Shadow Type 阴影类型 NoShadows 关闭阴影 HardShadows 生硬阴影 SoftShadows 柔和阴影 Realtime Shadows 实时阴影* Strength 强度: 阴影暗度 0~1之间，越大越黑 Resolution 分辨率: 阴影贴图渲染分辨率，越高越逼真，消耗越高 （Project Setting中的Quallty的设置） Bias 偏离: 阴影推离光源的距离 Normal Bias 法线偏离: 阴影投射面沿法线收缩距离 Near Panel 近平面: 渲染阴影的近裁剪面 Cookie 剪影投影遮罩: 一般用于聚光灯，显示图案 Draw Halo 绘制光晕球形光环开关可以用于蜡烛等效果 Flare 眩光耀斑有点类似于太阳耀斑效果想要在Game窗口看到耀斑要在摄像机Camera上加FlareLayer脚本 Render Mode 渲染模式* Auto 自动: 运行时确定 Important 重要: 以像素质量为单位进行渲染，效果逼真，消耗大 Not Important 非重要: 以快速模式进行渲染 Culling Mask 剔除遮罩 剔除遮罩层，决定哪些层的对象受到该光源影响 ps：所有参数都可都可以在代码中设置","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"22.Camera代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制","date":"2025-02-20T06:40:08.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"重要静态成员1234567891011121314151617181920// 获取主摄像机 只能是有MainCamera tag的print(Camera.main?.name); **************// 所有摄像机数量print(Camera.allCamerasCount);// 所有摄像机Camera[] allCameras = Camera.allCameras;// 渲染相关委托// 摄像机剔除前处理的委托函 数Camera.onPreCull += (c) =&gt;&#123;&#125;;// 摄像机渲染前处理的委托Camera.onPreRender += (c) =&gt;&#123;&#125;;// 摄像机渲染后处理的委托Camera.onPostRender += (c) =&gt;&#123;&#125;; 重要成员Inspector窗口的所有值都能用代码得到并修改比如：Camera.main.depth = 10; 下面非常常用12345// 世界坐标 转 屏幕坐标// 转换后的x, y就是屏幕坐标, z则为 Camera.main 离 这个物体position有多远 (纵深// 用这个来做 头顶血条 ****************Vector3 vector3 = Camera.main.WorldToScreenPoint(this.transform.position);print(vector3); 设置z之后，屏幕坐标就会转换到世界坐标的距离摄像机的z距离的平面上12345// 屏幕坐标 转 世界坐标// 转换要自己设定z轴的距离, 否则为0, 一直在视口点上坐标不变Vector3 v = Input.mousePosition; ***********v.z = 10;Vector3 vector31 = Camera.main.ScreenToWorldPoint(v);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"21.Camera","slug":"游戏引擎/unity/unity入门/unity入门基础知识/21.Camera","date":"2025-02-20T05:43:21.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/21.Camera/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/","excerpt":"","text":"Camera可编辑参数 Clear Flags清楚标志skybox天空盒 （做3d游戏）Solid Color颜色填充 （做2d游戏）Depth only 只画该层，背景透明 （一般多个摄像机叠加渲染的时候使用，一般与下面的Depth配合使用）Don’t Clear 不移除，覆盖渲染 （不常用，会保留每一帧的渲染内容，就像黄金体验镇魂曲） Culling Mask剔除遮罩选择渲染部分层级（Layer） ProjectionFOV Axis Fov轴：视野轴，决定了光学仪器的视野范围。 Perspective 透视模式 Field of view 视野：摄像机视角（以沿着 FOV Axis__ 下拉选单中指定轴的度数为单位）。0-180度之间，一般保持默认60就行。 orthographic 正交摄像机（一般用于2D游戏制作） Size：摄制范围 Clipping Planes裁剪平面Near：近平面Far：远平面 Depth深度渲染顺序上的深度 （数字越小，越先渲染）数字小的照片会先放， 数字大的照片会叠在上面，天空盒有背景是不透明，depth only透明 Target Texture目标纹理可以把摄像机画面渲染到一张图上， 主要用于制作小地图在Project右键创建 Render Texture，将创建的Render Texture拖到摄像机，就会把摄像机看到的画面渲染到一张图上 Occlusion Culling剔除遮挡勾选时一些游戏物体被大一点的物体挡住可以不用渲染 不常用的参数Viewport Rect视口范围 屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏，0~1 相当于宽高百分比 Redering path渲染路径","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"20.Screen屏幕相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关","date":"2025-02-20T02:50:13.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.Screen%E5%B1%8F%E5%B9%95%E7%9B%B8%E5%85%B3/","excerpt":"","text":"常用1234567891011// 当前屏幕分辨率 (设备的分辨率Resolution currentResolution = Screen.currentResolution;print($&quot;当前分辨率宽:&#123;currentResolution.width&#125;, 高:&#123;currentResolution.height&#125;&quot;);// 当前游戏窗口分辨率 print($&quot;当前窗口分辨率为:&#123;Screen.width&#125; * &#123;Screen.height&#125;&quot;);// 屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; 不常用123456789101112131415161718192021// 运行时是否全屏Screen.fullScreen = true;// 窗口模式 (以后在发布的时候在设置, 一般不用代码去设置)// 独占全屏 FullScreenMode.ExclusiveFullScreen// 全屏窗口 FullScreenMode.FullScreenWindow;// 最大化窗口 FullScreenMode.MaximizedWindow// 窗口模式 FullScreenMode.Windowed;Screen.fullScreenMode = FullScreenMode.FullScreenWindow;// 移动设备转向相关...Screen.autorotateToLandscapeLeft = true;// 指定屏幕显示方向Screen.orientation = ScreenOrientation.LandscapeLeft;// 设置分辨率 第三个参数是否为全屏 (移动设备不用, Screen.SetResolution(1920, 1080, false);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"19.Input输入相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关","date":"2025-02-20T02:39:16.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.Input%E8%BE%93%E5%85%A5%E7%9B%B8%E5%85%B3/","excerpt":"","text":"输入内容一定是写在Update当中的 鼠标位置屏幕坐标的原点是在左下角，右是x轴正向，上是y轴正向123// 鼠标位置// 返回一个Vector3, 但只有x, y有值print(Input.mousePosition); 检测鼠标输入1234567891011// 检测鼠标输入 (0左键, 1右键, 2滚轮if (Input.GetMouseButtonDown(0)) print(&quot;你按了一次 鼠标左键&quot;);if (Input.GetMouseButtonUp(1)) print(&quot;你抬起了一次 鼠标右键&quot;);if (Input.GetMouseButton(0)) print(&quot;你是一直在按着 鼠标左键&quot;);// 返回一个Vector2, 而滚动会改变其中的y值// y值 -1 往下棍, 0 没滚, 1 往上滚Vector2 mouseScrollDelta = Input.mouseScrollDelta;print(mouseScrollDelta); 检测键盘输入123// 键盘按下 up抬起, 无长按...if (Input.GetKeyDown(KeyCode.W)) print(&quot;你按下了W键&quot;); 检测默认轴记不住单词可以在Project Setting中的Input Manager查看1234567891011121314// 默认轴输入// 当键盘A,D键按下时, 返回-1 到 1之间的变换 // 即一直按A的话, 返回值会慢慢从0变到 -1// Input.GetAxisRaw是只会有 -1, 0, 1三个数字之间的突变float v = Input.GetAxis(&quot;Horizontal&quot;);print(v);// W, S 返回-1, 到 1float v1 = Input.GetAxis(&quot;Vertical&quot;);print(v1);// 鼠标横向移动 纵向 Mouse Yfloat v2 = Input.GetAxis(&quot;Mouse X&quot;);print(v2); 其它123456789101112131415161718192021222324252627282930313233343536373839404142434445// 是否有任意键或鼠标长按bool anyKey = Input.anyKey;if (Input.anyKeyDown)&#123; print($&quot;有一个键按下了按下的是&#123;Input.inputString&#125;&quot;);&#125;// 得到连接的手柄的所有按钮名字string[] strings = Input.GetJoystickNames();for (int i = 0; i &lt; strings.Length; i++)&#123; print(&quot;你连接的所有按钮有&quot;); print(strings[i]);&#125;// 某一手柄键按下, 抬起, 长按...bool v3 = Input.GetButtonDown(strings[0]);// 移动设备触摸if (Input.touchCount &gt; 0)&#123; Touch touch = Input.touches[0]; // 位置 print(touch.position); // 相对上次位置的变化 print(touch.deltaPosition);&#125;// 是否启用多点触控Input.multiTouchEnabled = true;// 陀螺仪 (重力感应)// 是否开启陀螺仪Input.gyro.enabled = true;// 重力加速度 Vector3 gravity = Input.gyro.gravity;// 旋转速度Vector3 rotationRate = Input.gyro.rotationRate;// 陀螺仪 当前旋转的四元数// 比如用这个角度信息 来控制场景上的一个3D物体收到重力影响// 手机怎么动, 他就怎么动Quaternion attitude = Input.gyro.attitude; 练习用WASD键控制前进后退，左右转向123//ws键 控制位移 // 这公式 是 ： 前进方向 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime * Input.GetAxis(&quot;Vertical&quot;)); //ad键 控制 左右转向 // 这公式 是 ： 转动的轴 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Horizontal&quot;)); 鼠标左右移动控制炮口的转向1head.Rotate(Vector3.up * headRotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Mouse X&quot;));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"18.坐标转换","slug":"游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换","date":"2025-02-19T13:07:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"世界 -&gt; 本地 世界坐标系的点 -&gt; 本地坐标系的点123// 世界坐标 转换为 本地坐标 (会受到缩放影响// 即 在世界坐标系下的 (0, 0, 1) 在本地坐标系下表示为 transform.InverseTransformPoint(Vector3.forward)print(this.transform.InverseTransformPoint(Vector3.forward)); 世界坐标系的向量 -&gt; 本地坐标系的向量1234// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (不受缩放影响print(this.transform.InverseTransformDirection(Vector3.forward));// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (受缩放影响print(this.transform.InverseTransformVector(Vector3.forward)); 本地 -&gt; 世界本地坐标系的点 -&gt; 世界坐标系的点 （最重要的*）1234567// 本地坐标 转换为 世界坐标 (会受到缩放影响// 即 在本地坐标系下的 (0, 0, 1) 在世界坐标系下表示为 transform.TransformPoint(Vector3.forward)print(this.transform.TransformPoint(Vector3.forward));// eg:GameObject obj = new GameObject(&quot;左前方物体&quot;);obj.transform.position = this.transform.TransformPoint(new Vector3(-1, 0, 1)); // 在本地坐标的左前方（-1,0,1）处创建物体 本地坐标系的向量 -&gt; 世界坐标系的向量1234// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (不受缩放影响print(this.transform.TransformDirection(Vector3.forward));// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (受缩放影响print(this.transform.TransformVector(Vector3.forward));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"17.父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系","date":"2025-02-19T08:56:46.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"获取和设置父对象1234567891011121314151617// 获取父对象print(this.transform.parent);// 断绝父子关系this.transform.parent = null; // 认父亲 // 也会顺带把孙子的爷爷也换了this.transform.parent = GameObject.Find(&quot;obj&quot;).transform;// 下面这种认父亲的方法 特殊一些// 第二个参数为true 则不会改掉物体本来的世界坐标位置,大小什么的// 为false, 则会把原来Inspector面板上的数字原封不动的赋值到新的Inspector窗口上，则会用自己的transform中的数值// 子对象世界坐标 = 父对象世界坐标 × 子对象局部坐标（当 worldPositionStays = false 时）。// 动态创建ui时常用this.transform.SetParent(GameObject.Find(&quot;obj&quot;).transform, false); 抛妻弃子12// 和自己所有儿子断绝关系, 不会断掉儿子和孙子的this.transform.DetachChildren(); 获取子对象及其操作12345678910111213141516171819// 根据名字查找儿子对象 (不可以查找孙子, 可以找到失活的儿子，GameObject的find不能查找失活的对象 )print(this.transform.Find(&quot;Capsule&quot;));// 查找Father的儿子Sonprint(this.transform.Find(&quot;Father/Son&quot;));// 儿子数量print(this.transform.childCount);// 遍历for (int i = 0; i &lt; this.transform.childCount; i++) print(this.transform.GetChild(i)); // 判断是不是自己是不是另一个对象的儿子bool v = this.transform.IsChildOf(transform.parent);// 设置自己作为儿子编号this.transform.SetSiblingIndex(0);// 得到自己作为儿子的编号print(this.transform.GetSiblingIndex()); 练习 请为Transform写一个拓展方法，可以将它的子对象按名字的长短进行排序改变他们的顺序，名字短的在前面，名字长的在后面1234567891011121314151617181920212223242526272829public static class TransformExtensions&#123; public static void SortChildrenByNameLength(this Transform obj) &#123; //var children = obj.Cast&lt;Transform&gt;().ToList(); //children = children.OrderBy(child =&gt; child.name.Length).ToList(); //for (int i = 0; i &lt; children.Count; i++) //&#123; // children[i].SetSiblingIndex(i); //&#125; List&lt;Transform&gt; list = new List&lt;Transform&gt;(); for (int i = 0; i &lt; obj.childCount; i++) &#123; list.Add(obj.GetChild(i)); &#125; //这是根据 名字长短进行排序 利用的 是list的排序 传个函数进去 list.Sort((a, b) =&gt; a.transform.name.Length - b.transform.name.Length); //根据 list中的排序结果 重新设置每一个对象的 索引编号 for (int i = 0; i &lt; list.Count; i++) &#123; list[i].SetSiblingIndex(i); &#125; &#125;&#125; 请为Transform写一个拓展方法，传入一个名字查找子对象，即使是子对象的子对象也能查找到123456789101112131415161718public static class TransformExtensions&#123; public static Transform CustomFind(this Transform obj, string name) &#123; Transform res = null; res = obj.Find(name); if (res != null) return res; for (int i = 0; i &lt; obj.childCount; i++) &#123; res = obj.GetChild(i).CustomFind(name); if (res != null) return res; &#125; return res; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"16.缩放和看向","slug":"游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向","date":"2025-02-19T08:23:15.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/16.%E7%BC%A9%E6%94%BE%E5%92%8C%E7%9C%8B%E5%90%91/","excerpt":"","text":"缩放12345678// 相对于世界坐标系 // 不能改print(this.transform.lossyScale);// 相对于父对象 // 可以改print(this.transform.localScale);// unity 没有提供缩放相关的API, 只能自己手动来搞 eg: this.transform.localScale += Vector3.one * Time.deltaTime; 看向12// 将自己的面朝向源点，相对于世界坐标系this.transform.LookAt(Vector3.zero);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"15.角度和旋转","slug":"游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转","date":"2025-02-19T07:30:32.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/15.%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC/","excerpt":"","text":"角度相关123456789// 相对于世界坐标角度print(this.transform.eulerAngles);// 相对于父对象角度// Inspector中显示的是相对父对象的角度，localEulerAngles的角度只能是0~360，但Inspector面板是可以负数的print(this.transform.localEulerAngles);// 不能单个x, y, z赋值this.transform.localEulerAngles = new Vector3(10, 10, 10); 旋转相关123456789101112// 自转API 第二个参数默认不写的话，绕着自己坐标转this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime * 100, Space.World); // 每帧绕y轴增加100 * （0，10，0）//相对于某个轴 转多少度//参数一:是相对哪个轴进行转动//参数二:是转动的 角度 是多少//参数三:默认不填 就是相对于自己的坐标系 进行旋转transform.Rotate(Vector3.up, Time.deltaTime * 100); // 在自己的坐标系的y轴旋转// 绕着某个点旋转 绕着源点, y轴, 转的多少度this.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime); 代码 原理 效率 可读性 Rotate(new Vector3(0,1,0) * dt * 100) 欧拉角增量 较低（需创建Vector3） 一般 Rotate(Vector3.up, dt * 100) 轴-角度 较高 更佳","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"14.位置位移坐标系相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关","date":"2025-02-19T06:59:04.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/14.%E4%BD%8D%E7%BD%AE%E4%BD%8D%E7%A7%BB%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3/","excerpt":"","text":"Vector常用用的是世界坐标123456789Vector3.forward 001Vector3.up 010Vector3.down 0-10Vector3.left -100Vector3.right 100Vector3.back 00-1// 两点之间的距离Vector3.Distance(v1, v2); 位置1234567891011// 相对世界坐标原点的值print($&quot;距离世界源点 &#123;this.transform.position&#125;&quot;);// 相对父对象 没父对象就相对于源点print($&quot;距离父对象坐标点 &#123;this.transform.localPosition&#125;&quot;);// 位置的赋值不能单独改x, y, z 只能整体来赋值this.transform.position = new Vector(5, this.transform.position.y, ...);// 或者Vector3 tmp = this.transform.position; tmp.y = 666;this.transfomr.position = tmp; 朝向本地坐标系，游戏对象当前的朝向123print(this.transform.forward); // 游戏对象当前的面朝向print(this.transform.up); // 对象当前的头顶朝向Vector3 right = this.transform.right; // 右手边 位移123456789101112131415// 1 位移 = 方向 * 速度 * 时间 (手动写, 世界坐标系的话用Vector3.XX)最终位置 = 当前的位置 + 我要变化的位置的路程//this.transform.position += this.transform.forward * 1 * Time.deltaTime;// 2 位移API// 参数1 表示位移多少 位移 = 方向 * 速度 * 时间// 参数2 移动所采用的坐标系, 即(1, 0, 0)是哪个坐标系的(1, 0, 0) (不填的话，默认本地相对坐标系Space.Self)this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); // 沿着世界坐标系的001去动this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.World); // 世界坐标系中沿着自己的面朝向去动this.transform.Translate（Vector3.forward * 1 * Time.deltaTime, Space.Self); // 沿着自己坐标系的001去动// 不会这样移动, 自己相对于世界坐标系的歪曲的数据 再应用于自己的坐标系this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.Self); // 傻逼","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"13.时间相关Time","slug":"游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time","date":"2025-02-19T06:00:25.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13.%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3Time/","excerpt":"","text":"时间缩放比例12// 时间停止 // 恢复正常 // 2倍速Time.timeScale = 0; Time.timeScale = 1; Time.timeScale = 2; 帧间隔时间即 两帧之间的时间作用: 计算位移 每帧移动的距离由speed * Time.deltaTime确定，确保了在不同帧率下物体移动的速度一致典型应用：transform.Translate(Vector3.forward * speed * Time.deltaTime);通过乘以 deltaTime，物体每秒移动的距离为 speed 单位，无论帧率如何变化。123// 帧间隔时间print(&quot;受timeScale影响的 &quot; + Time.deltaTime);print(&quot;不受timeScale影响的&quot; + Time.unscaledDeltaTime); 游戏开始到现在时间一般都单机游戏用，网游一般用服务器时间123// 游戏开始到现在的时间print(&quot;受timeScale影响的&quot; + Time.time);print(&quot;不受影响的&quot; + Time.unscaledTime); 物理帧间隔时间123456void FixedUpdate()&#123; // 物理帧间隔时间 print(&quot;受影响的 &quot; + Time.fixedDeltaTime); print(&quot;不受影响的 &quot; + Time.fixedUnscaledDeltaTime);&#125; 总帧数 (帧同步)从开始到现在游戏跑了多少帧（即多少次循环）1print(Time.frameCount);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"12.GameObject","slug":"游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject","date":"2025-02-19T02:07:20.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GameObject/","excerpt":"","text":"成员变量12345678910// 名字this.gameObject.name = &quot;改名desu&quot;;// 是否激活bool activeSelf = this.gameObject.activeSelf;// 是否静态bool isStatic = this.gameObject.isStatic;// 层级int layer = this.gameObject.layer;// 给游戏对象分的标签string tag1 = this.gameObject.tag; 静态方法创建自带几何体123// 创建自带几何体GameObject gameObject1 = GameObject.CreatePrimitive(PrimitiveType.Cube);gameObject1.name = &quot;自己起的名字&quot;; 在场景中查找对象只能找到激活对象，无法找到失活对象使用单个查找的api，如果场景有满足调教的多个对象，无法指定找到的是谁1234567891011121314151617// 在场景中查找对象 // 1.1 单个查找 名字(同名不行)// 查找效率低 会查询所有场景中所有的对象GameObject gameObject2 = GameObject.Find(&quot;自己起的名字&quot;);print(gameObject2?.name);// 1.2 单个查找 tagGameObject gameObject3 = GameObject.FindWithTag(&quot;MainCamera&quot;);print(gameObject3?.name);// 1.3 通过Inspector面板去拖到本地的public// 2 多对象查找 tagGameObject[] gameObjects = GameObject.FindGameObjectsWithTag(&quot;Player&quot;);print(gameObjects?.Length);// FindObjectOfTypes 效率低 克隆对象根据一个GameObject对象, 创建一个一模一样的对象1GameObject obj = GameObject.Instantiate(MyObj); 删除 删除一个指定游戏对象 删除一个指定脚本对象 注意:Destroy方法不会马上移除对象, 只是加了一个移除标识一般情况下, 会在下一帧时把这个对象从内存中移除1234567// 删除对象GameObject.Destroy(gameObject4, 5); // 第二个参数是延时几秒// 删除脚本对象GameObject.Destroy(this);// 一定要马上移除 // 没特殊需求不用GameObject.DestroyImmediate(gameObject4); 切场景不移除默认情况下, 切场景会删除该场景的所有对象一般写自己依附的对象不被删除1GameObject.DontDestroyOnLoad(this.gameObject); // 不移除该脚本依附的游戏对象 成员方法创建空物体顺带加上Test2脚本1GameObject gameObject5 = new GameObject(&quot;创建的空物体名字&quot;, typeof(Test2)); 动态给GameObject对象添加脚本12// 给gameObject5加上Test2脚本Test2 test2 = gameObject5.AddComponent&lt;Test2&gt;(); 获取脚本对象 和[[Mono中的重要内容#^155e67 | 继承Mono的类]]获取脚本对象的方法一毛一样标签比较12345678if (gameObject5.CompareTag(&quot;Player&quot;))&#123; print(&quot;对象标签是Player&quot;);&#125;if (gameObject5.tag == &quot;Player&quot;)&#123; print(&quot;这和上面是一样的&quot;);&#125; 设置 失活 和 激活1gameObject5.SetActive(false); // 失活 不建议使用的成员方法通过广播或者发送消息的形式, 让自己或者别人 执行某些行为和方法123456789// 让自己去执行TestFun这个函数, 会在自己对象上挂着的所有脚本去找这个名字的函数, 有一个执行一个// 涉及到反射 比较影响性能this.gameObject.SendMessage(&quot;TestFun&quot;);// 广播行为 让自己及其子对象发送消息并执行，让自己及其子对象 执行相同的名字的方法this.gameObject.BroadcastMessage(&quot;TestFun&quot;);// 让自己及其父对象发送消息并执行this.gameObject.SendMessageUpwards(&quot;函数名&quot;); 继承自Object自然可以用Object.xxx的方式来调用静态函数","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"11.MonoBehavior中的重要内容","slug":"游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容","date":"2025-02-18T10:13:17.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.MonoBehavior%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/","excerpt":"","text":"8.脚本基本规则 重要成员获取依附的GameObject1print(this.gameObject.name); 获取依附的GameObject的位置信息1234567//得到对象位置信息print(this.transform.position);//位置print(this.transform.eulerAngles);//角度print(this.transform.lossyScale);//缩放大小//这种写法和上面是一样的效果 都是得到依附的对象的位置信息this.gameObject.transform 设置脚本是否激活1234//this.enabled = true;print($&quot;这是其它脚本对象 otherTest, 可以使用本脚本的其它脚本对象来获取gameObject &#123;otherTest.gameObject.name&#125;&quot;); 重要方法获取依附对象上挂载的其它脚本 三个重载获取1234567891011// 通过挂载脚本名Component component = this.GetComponent(&quot;Test2&quot;);Test2 t = component as Test2;print(t);// 通过typet = this.GetComponent(typeof(Test2)) as Test2;// 通过 *************用最多*************t = this.GetComponent&lt;Test2&gt;(); 获取多个脚本123456Test2[] test2s = this.GetComponents&lt;Test2&gt;();List&lt;Test2&gt; list = new List&lt;Test2&gt;();this.GetComponents&lt;Test2&gt;(list); 找自己及其子对象的所挂载的脚本123// 这里可以不传参数, 默认传false表示不找失活状态的脚本// 找自己及其父对象的同理this.GetComponentsInChildren&lt;Test2&gt;(false); 注意要想操作其它GameObject对象, 必须获取其它的脚本对象, 而且得用Inspector来赋值","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"csharp特性","slug":"编程语言/Csharp/csharp特性","date":"2025-02-18T09:18:38.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/编程语言/Csharp/csharp特性/","permalink":"http://example.com/2025/02/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%89%B9%E6%80%A7/","excerpt":"","text":"特性特性是一种允许我们向程序的[[程序集]]添加[[元数据]]的语言结构它是用于保存程序结构信息的某种特殊类型的类 特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。特性与程序实体关联后，即可在运行时使用[[csharp反射]]查询特性信息 特性的目的是告诉编译器把程序结构的某组[[元数据]]嵌入[[程序集]]中它可以放置在几乎所有的声明中（类、变量、函数等等申明） 说人话：特性本质是个类我们可以利用特性类为[[元数据]]添加额外信息比如一个类、成员变量、成员方法等等为他们添加更多的额外信息之后可以通过[[csharp反射]]来获取这些额外信息 自定义特性12345678910111213class MyCustomAttribute : Attribute&#123; //特性中的成员 一般根据需求来写 public string info; public MyCustomAttribute(string info) &#123; this.info = info; &#125; public void TestFun() &#123; Console.WriteLine(&quot;特性的方法&quot;); &#125;&#125; 特性的使用基本语法: [特性名(参数列表)]本质上 就是在调用特性类的构造函数写在哪里？ 类、函数、变量上一行，表示他们具有该特性信息 1234567891011121314151617181920212223[MyCustom(&quot;这是我自己的类&quot;)]class MyClass&#123; [MyCustom(&quot;这是一个int型的成员变量&quot;)] public int Value; [MyCustom(&quot;这是用来测试的成员函数&quot;)] public void TestFun([MyCustom(&quot;这是用来测试的函数参数&quot;)] int a) &#123; Console.WriteLine(a); &#125;&#125;Type t = typeof(MyClass);if (t.IsDefined(typeof(MyCustomAttribute), false))&#123; Console.WriteLine(&quot;判断一个类型是否使用了某个特性&quot;);&#125;// 获取Type元数据中的所有特性object[] objects = t.GetCustomAttributes(true);for (int i = 0; i &lt; objects.Length; i++) Console.WriteLine((objects[i] as MyCustomAttribute).Info); 为特性类加特性 限制其使用范围12345[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]//参数一：AttributeTargets —— 特性能够用在哪些地方//参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上//参数三：Inherited —— 特性是否能被派生类和重写成员继承public class MyCustom2Attribute : Attribute &#123; &#125; 系统自带特性——过时特性 Obsolete用于提示用户 使用的方法等成员已经过时 建议使用新方法 123456//一般加在函数前的特性[Obsolete(&quot;这个是旧方法&quot;, false)]// 第一个参数是提示信息, 第二个参数 true直接报错, false警告public void OldFun() &#123; &#125; 系统自带特性——调用者信息特性 (快速查出哪里的错误)12345678910111213141516171819202122232425//哪个文件调用？//CallerFilePath特性//哪一行调用？//CallerLineNumber特性//哪个函数调用？//CallerMemberName特性class TestClass&#123; [Obsolete(&quot;这个是旧方法&quot;, false)] // 第一个参数是提示信息, 第二个参数 true直接报错, false警告 public void OldFun() &#123; &#125; public void NewFun(string str, [CallerFilePath] string fileName = &quot;&quot;, [CallerLineNumber] int line = 0, [CallerMemberName] string memberName = &quot;&quot;) &#123; Console.WriteLine(&quot;这些使用的CallerXXX特性会在, 其它调用者调用时自动将调用者的额外信息填入参数中&quot;); Console.WriteLine(&quot;调用者的文件名 fileName = &quot; + fileName); Console.WriteLine(&quot;调用者的所在的行数 line = &quot; + line); Console.WriteLine(&quot;调用者的所处的调用函数名 memberName = &quot; + memberName); &#125;&#125; 系统自带特性——条件编译特性Conditional 它会和[[预处理指令]] #define配合使用123456[Conditional(&quot;Fun&quot;)] // 如果 #define 下面就会编译static void Fun()&#123; Console.WriteLine(&quot;如果有#define 我就会执行&quot;);&#125; 系统自带特性——外部Dll包函数特性 DllImport用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。一般用来调用 C或者C++的Dll包写好的方法需要引用[[命名空间]] using System.Runtime.InteropServices 123[DllImport(&quot;Test.dll&quot;)] // 下面这个函数一定在dll中有一模一样的public static extern int Add(int a, int b);//需要引用命名空间 using System.Runtime.CompilerServices;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"10.inspector 窗口可编辑变量","slug":"游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量","date":"2025-02-18T08:47:53.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.inspector%20%E7%AA%97%E5%8F%A3%E5%8F%AF%E7%BC%96%E8%BE%91%E5%8F%98%E9%87%8F/","excerpt":"","text":"知识点一 私有和保护无法显示编辑12private int i1;protected string str1; 知识点二 让私有的和保护的也可以被显示SerializeField加上强制序列化字段csharp特性 [SerializeField]所谓序列化就是把一个对象保存到一个文件或数据库字段中去1234[SerializeField]private int privateInt;[SerializeField]protected string protectedStr; 知识点三 公共的可以显示编辑12public int publicInt = 10;public bool publicBool = false; 知识点四 公共的也不让其显示编辑HideInInspector在变量前加上csharp特性 [HideInInspector]12[HideInInspector]public int publicInt2 = 50; 知识点五 大部分类型都能显示编辑12345678910public int[] array;public List&lt;int&gt; list;public E_TestEnum type;public GameObject gameObj;//字典不能被Inspector窗口显示public Dictionary&lt;int, string&gt; dic;//自定义类型变量public MyStruct myStruct;public MyClass myClass; 知识点六 让自定义类型可以被访问加上序列化csharp特性[System.Serializable]字典怎样都不行12345678910111213[System.Serializable]public struct MyStruct&#123; public int age; public bool sex;&#125;[System.Serializable]public class MyClass&#123; public int age; public bool sex;&#125; 知识点七 一些辅助csharp特性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//1.分组说明特性Header **************有用**************//为成员分组//Header特性//[Header(&quot;分组说明&quot;)][Header(&quot;基础属性&quot;)]public int age;public bool sex;[Header(&quot;战斗属性&quot;)]public int atk;public int def;//2.悬停注释Tooltip//为变量添加说明//[Tooltip(&quot;说明内容&quot;)][Tooltip(&quot;闪避&quot;)]public int miss;//3.间隔特性 Space()//让两个字段间出现间隔//[Space()][Space()]public int crit;//4.修饰数值的滑条范围Range **************有用**************//[Range(最小值, 最大值)][Range(0,10)]public float luck;//5.多行显示字符串 默认不写参数显示3行//写参数就是对应行//[Multiline(4)][Multiline(5)]public string tips;//6.滚动条显示字符串 //默认不写参数就是超过3行显示滚动条//[TextArea(3, 4)]//最少显示3行，最多4行，超过4行就显示滚动条[TextArea(3,4)]public string myLife;//7.为变量添加快捷方法 ContextMenuItem **************有用**************//参数1 显示按钮名//参数2 方法名 不能有参数//[ContextMenuItem(&quot;显示按钮名&quot;, &quot;方法名&quot;)][ContextMenuItem(&quot;重置钱&quot;, &quot;Test&quot;)]public int money;private void Test()&#123; money = 99;&#125;//8.为方法添加特性能够在Inspector中执行//[ContextMenu(&quot;测试函数&quot;)][ContextMenu(&quot;哈哈哈哈&quot;)]private void TestFun()&#123; print(&quot;测试方法&quot;);&#125; 注意 Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变 要么老老实实的在Inspector窗口改默认值 要么重新挂载脚本 运行中修改的信息不会保存","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"9.生命周期函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数","date":"2025-02-18T07:39:12.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"碰撞检测函数 知识点一 了解帧的概念 Unity 底层已经帮助我们做好了死循环 我们需要学习Unity的生命周期函数 利用它做好的规则来执行我们的游戏逻辑就行了 知识点二 生命周期函数的概念 所有继承MonoBehavior的脚本 最终都会挂载到GameObject游戏对象上 生命周期函数 就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中 会通过反射自动调用的一些特殊函数 注意：生命周期函数的访问修饰符一般为private和protected因为不需要再外部自己调用生命周期函数 都是Unity自己帮助我们调用的当对象（自己这个类脚本对象）被创建时 才会调用该生命周期函数生命周期函数支持多态如果GameObject一开始失活就不会调用生命周期函数 awake，onenable,start, fixedUpdate,update, laterupdate, ondisenable,ondestroy Awake：类似构造函数的存在 我们可以在一个类对象 该创建 进行一些初始化操作 OnEnable：对于我们来说 想要当一个对象被激活时 进行一些逻辑处理 就可以写在这个函数 Start：主要作用还是用于初始化信息的 但是它相对Awake来说 要晚一点如果我们在update中动态的创建对象，这个对象马上会执行Awake，但不会立即执行Start，要等到在下一帧的第一次 Update() 之前执行才会执行Start FixedUpdate：它主要是用于 进行物理更新它是每一帧的执行的 但是 这里的帧 和游戏帧 有点不同它的时间间隔 是可以在 project setting中的 Time里去设置的 Update：主要用于处理游戏核心逻辑更新的函数 LateUpdate：一般这个更新是用来处理 摄像机位置更新相关内容的Update和LateUpdate之间 Unity进了一些处理 处理我们动画相关的更新 OnDisable：如果我们希望在一个对象失活时做一些处理 就可以在该函数中写逻辑失活后不参与游戏循环了，激活后又可以循环 OnDestroy：当对象销毁后调用 问题：不同对象的生命周期函数是在同一个线程中执行吗？","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"8.脚本基本规则","slug":"游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则","date":"2025-02-18T07:10:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/","excerpt":"","text":"MonoBehavior基类 创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 继承了MonoBehavior的脚本可以在一个对象上挂多个（如果没有加DisallowMultipleComponent特性） 继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 不继承MonoBehavior的类 不继承Mono的类 不能挂载在GameObject上 不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 不继承Mono的类 一般是单例模式的类（用于管理模块） 或者数据结构类（用于存储数据） 不继承Mono的类 不用保留默认出现的几个函数 设置挂载脚本的执行顺序，默认时间前是系统必须执行的，可以设置自己添加的脚本的执行顺序，数字越小脚本越先执行 打开 当前unity版本下的Editor\\Data\\Resources\\ScriptTemplates目录可以更改默认的脚本模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"7.预制体和资源包的导入导出","slug":"游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出","date":"2025-02-18T07:01:18.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E9%A2%84%E5%88%B6%E4%BD%93%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"预设体是 Unity 中非常重要的概念，可以理解为一个游戏对象及其组件的集合。其目的是使游戏对象及其资源能够重复使用。当修改预设体时，实例也会同步修改。 创建预设体将其拖到asset文件夹下右键可以取消预设体 资源包导出直接右键，导入直接拖","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"6.反射机制和游戏场景","slug":"游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景","date":"2025-02-18T03:33:39.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF/","excerpt":"","text":"Unity中的反射机制Unity引擎本质是一个软件使用它时是处于运行中的我们是在一个运行中的软件里制作游戏的Unity开发的本质就是在Unity引擎的基础上利用反射和引擎提供的各种功能进行的拓展开发 回忆一下反射的概念程序正在运行时，可以查看其它程序集或者自身的元数据（元数据就是程序当中的类，对象，函数，变量之类的东西）一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射在程序运行时，通过反射可以得到其它程序集或者自己程序集中代码的各种信息，比如类，函数，变量，对象等等我们可以实例化它们，执行它们，操作它们 Unity 反射机制的完整工作流假设你写了一个 PlayerController.cs 脚本12345678public class PlayerController : MonoBehaviour &#123; [SerializeField] private float _moveSpeed = 5.0f; void Update() &#123; // 移动逻辑 &#125;&#125; 脚本编译阶段：Unity 会通过 Mono/C# 编译器 将你的脚本编译到 Assembly-CSharp.dll 中，同时生成 元数据表 编辑器反射阶段： Unity Editor 通过反射扫描所有 MonoBehaviour 子类 解析 [SerializeField] 等特性 生成 Inspector 面板的 UI 元素 运行时反射阶段： 当场景加载时，Unity 通过反射： 实例化 PlayerController 对象 将序列化数据（如 _moveSpeed）注入到对应字段 构建消息系统的方法表（用于 SendMessage()） 游戏场景","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"5.工具栏与对象的父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系","date":"2025-02-18T03:27:14.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E5%B7%A5%E5%85%B7%E6%A0%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"4.Inspector和Console窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口","date":"2025-02-18T02:08:55.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.Inspector%E5%92%8CConsole%E7%AA%97%E5%8F%A3/","excerpt":"","text":"选择对象进行标记选择是否激活对象修改对象名设置对象为静态对象标签层级","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"3.Game和Project窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口","date":"2025-02-18T01:56:51.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"2.Scene和Hierarchy窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口","date":"2025-02-16T02:24:38.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/","excerpt":"","text":"主要内容 窗口布局左上角Layout选项 Scene和Hierarchy场景窗口和层级窗口是息息相关的层级窗口中看到的内容就是场景窗口中的显示对象","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"1.unity入门概述","slug":"游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述","date":"2025-02-16T01:27:03.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.unity%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/","excerpt":"","text":"主要学习内容 学习建议 以前做游戏 vs 现在做游戏 如何学习游戏引擎","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.使用obsidian来写hexo博客","slug":"hexo/1.使用obsidian来写hexo博客","date":"2025-02-09T12:59:52.000Z","updated":"2025-02-28T11:46:39.848Z","comments":true,"path":"2025/02/09/hexo/1.使用obsidian来写hexo博客/","permalink":"http://example.com/2025/02/09/hexo/1.%E4%BD%BF%E7%94%A8obsidian%E6%9D%A5%E5%86%99hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Front-Matterobsidian安装Template插件，设置目录后在该目录下创建HexoPost.md文件 HexoPost.md内容如下123456789101112131415161718---title: &lt;% tp.file.title %&gt;date: &lt;% tp.date.now(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;toc: truecategories:&lt;%*// 自动生成分类（兼容Windows路径）let folders = await tp.file.folder(true).split(/[\\\\/]/); folders = folders.slice(2); // 移除 &quot;_posts&quot; 父级目录for (let category of folders) &#123; tR += ` - $&#123;category&#125;`;&#125;if (folders.length === 0) &#123; tR += &quot; - 未分类&quot;;&#125;%&gt;tags:--- 这样就可以在新建md文件后点击obsidian侧边来自动填充categories 图片管理站点配置文件_config.yml1post_asset_folder: true # 启用文章资源文件夹obsidian安装 Custom Attachment Location插件并进行如下设置 其它小优化设置新建笔记位置 关闭wiki链接文章内跳转使用md语法[显示文本](#锚点)md标题自动生成锚点（全小写，空格换-）或者自定义锚点（&lt;a id=&quot;nihao&quot;&gt;&lt;/a&gt;） 忽略文件夹 参考使用 Hexo 搭建博客 | OHLIA’s WikiHexo和Obsidian：让个人博客写作更加优雅、高效 - ＊tree_fly ‘s Blog给博客上Live2d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]},{"title":"你好呀","slug":"你好呀","date":"1999-12-31T16:00:00.000Z","updated":"2025-02-28T07:30:17.000Z","comments":true,"path":"2000/01/01/你好呀/","permalink":"http://example.com/2000/01/01/%E4%BD%A0%E5%A5%BD%E5%91%80/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity基础","slug":"游戏引擎/unity/unity基础","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"游戏引擎/unity/unity入门/unity入门实践项目","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"},{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"UI系统/GUI","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/"},{"name":"GUI实践项目","slug":"UI系统/GUI/GUI实践项目","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"GUI基础知识","slug":"UI系统/GUI/GUI基础知识","permalink":"http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/GUI/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs实践项目","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity基础","slug":"unity基础","permalink":"http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"},{"name":"3D数学","slug":"3D数学","permalink":"http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门实践项目","slug":"unity入门实践项目","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"},{"name":"UI系统","slug":"UI系统","permalink":"http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"},{"name":"GUI","slug":"GUI","permalink":"http://example.com/tags/GUI/"},{"name":"GUI实践项目","slug":"GUI实践项目","permalink":"http://example.com/tags/GUI%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"GUI基础知识","slug":"GUI基础知识","permalink":"http://example.com/tags/GUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs实践项目","slug":"PlayerPrefs实践项目","permalink":"http://example.com/tags/PlayerPrefs%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]}