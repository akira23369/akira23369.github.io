{"meta":{"title":"akiraの博客思密达","subtitle":"","description":"","author":"akira23369","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2025-02-06T20:57:21.000Z","updated":"2025-02-06T20:57:21.750Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2025-02-06T20:57:16.000Z","updated":"2025-02-06T20:57:16.631Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2025-02-06T20:57:28.000Z","updated":"2025-02-06T20:57:49.778Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2025-02-06T20:57:05.000Z","updated":"2025-02-06T20:57:05.099Z","comments":true,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""}],"posts":[{"title":"反射","slug":"编程语言/Csharp/反射","date":"2025-02-21T12:55:53.000Z","updated":"2025-02-21T14:22:39.717Z","comments":true,"path":"2025/02/21/编程语言/Csharp/反射/","permalink":"http://example.com/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"Csharp源代码到运行时主要阶段 在 C# 中，从源代码到运行时的整个过程可以分为以下主要阶段： 1源代码(.cs) → 编译 → IL/程序集(.exe/.dll) → CLR加载 → JIT编译 → 本机代码 → 执行 源代码阶段： 编写源代码： 开发者编写 C# 源代码文件（.cs）。 编译阶段： 编译： 使用 C# 编译器（csc.exe）将源代码编译为中间语言（IL，Intermediate Language）代码。生成的文件通常是一个扩展名为 .exe（可执行文件）或 .dll（动态链接库）的程序集。 生成[[元数据]]： 编译过程中，生成包含程序集信息的[[元数据]]，包括类型、成员、版本等信息。 JIT 编译阶段： JIT 编译： 在运行时，Common Language Runtime（CLR）的 JIT 编译器负责将 IL 代码编译为本地机器代码。这一步是在程序加载到内存时进行的，即时（Just-In-Time）编译。 执行阶段： 加载程序集： CLR 加载编译好的程序集，包括 IL 代码和[[元数据]]。 执行程序： 程序在 CLR 中执行，JIT 编译器将 IL 代码转换为本地机器代码。执行过程中，CLR 负责内存管理、类型检查、垃圾回收等任务。 总结： 开发者阶段： 编写源代码。 编译阶段： 编译源代码生成 IL 代码和[[元数据]]。 JIT 编译阶段： 在运行时将 IL 代码编译为本地机器代码。 执行阶段： 加载程序集，执行程序，CLR 负责管理运行时环境。 编译 vs 运行 编译期 运行时 发生时间 发生在构建过程中，源代码被翻译为目标代码或中间代码。 发生在程序实际运行时，加载到内存并执行。 可能出现的错误 静态检查错误，如语法错误、类型错误等。 动态运行时错误，如空指针引用、除零错误等。 排查难度 错误信息清晰，易于定位和修复。 错误可能更难以排查，需要使用调试工具进行追踪。 无运行时 有运行时 内存管理 程序员需要手动管理内存分配和释放。 运行时环境负责内存管理，可能包括自动内存分配和垃圾回收。 线程模型 通常依赖操作系统提供的线程机制。 可能提供自己的线程管理机制，与操作系统的线程模型有一定差异。 系统调用 直接使用操作系统提供的系统调用接口。 通过运行时环境提供的接口进行系统调用，可能会屏蔽一些底层细节。 运行效率 对于底层硬件和操作系统有更直接的控制。 需要运行时环境的支持，可能引入一些开销。 动态库 vs. 静态库 - 编译和链接阶段： 阶段 静态库 动态库 定义 静态库是在编译时被链接到程序的库，代码在程序编译阶段就被静态地合并。 态库是在运行时加载到内存的库，它的代码在程序执行时被动态地链接。 文件格式 .lib（Windows）或 .a（Unix/Linux） .dll（Windows）或 .so（Unix/Linux） 编译和链接阶段 静态库的代码在编译时被整合到程序中 编译时不包含库的代码，只在链接时引用库的符号 作用 提供独立的代码副本，每个程序有自己的库的实例，适用于没有外部库的环境 节省内存，允许在运行时替换库的版本，减小程序的可执行文件大小 动态库 vs. 静态库 - 区别和使用场景： 特点 静态库 动态库 链接方式 链接在编译时 链接在运行时 内存占用 每个程序有自己的库的实例，可能占用更多内存 共享内存，多个程序可以共享同一个动态库的实例 更新和维护 需要重新编译整个程序，更新较为繁琐 可在运行时替换库的版本，更容易更新 可执行文件大小 可执行文件较大，因为库的代码在编译时合并到可执行文件中 可执行文件较小，因为库的代码在运行时加载 反射 程序正在运行时，可以查看其它[[程序集]]或者自身的[[元数据]]。 一个运行的程序查看本身或者其它程序的[[元数据]]的行为就叫做反射 在程序运行时，通过反射可以得到其它[[程序集]]或者自己[[程序集]]代码的各种信息 类，函数，变量，对象等等，实例化它们，执行它们，操作它们 exe/dll(主要区别是exe有入口) metadata: 描述dll/exe文件的一个 数据清单 反射: 用来操作获取[[元数据]] 就是一个操作metadata的一个类库, 用来操作[[元数据]]中的**类, 方法, 属性, [[特性]], ** 为什么通过反射去间接操作? 我们需要动态 (这些 “动态” 操作都是在运行时期根据运行时的信息来进行的，而不是在编译时期就确定好的。这使得程序更加灵活，能够处理一些在编译时难以确定的情况。) 读取私有的对象 Type（类的信息类） 它是反射功能的基础！ 它是访问[[元数据]]的主要方式。 使用 Type 的成员获取有关类型声明的信息 有关类型的成员（如构造函数、方法、字段、属性和类的[[事件]]） 1234567int a = 32;Type t1 = a.GetType();Type t2 = typeof(int);// 必须要包含命名空间.类名Type t3 = Type.GetType(&quot;System.Int32&quot;);// 每一个类只有一份元数据, 所以上面的t1, t2, t3 指向的是同一个堆空间 获取所有公共成员 （GetMembers 成员包括：成员变量，成员函数等等 1234567891011121314151617181920212223class Test&#123; private int i = 0; public int j = 1; public string str = &quot;hello world&quot;; public Test() &#123; &#125; public Test(int i) &#123; this.i = i; &#125; public Test(int i, string s) : this(i) &#123; this.str = s; &#125; public void Fun() &#123; Console.WriteLine(str); &#125;&#125;Type t = typeof(Test);MemberInfo[] memberInfos = t.GetMembers();for (int i = 0; i &lt; memberInfos.Length; i++) Console.WriteLine(memberInfos[i]); 获取类所有的公共构造函数并调用 （GetConstructors 1234567891011121314151617// 所有公共构造函数ConstructorInfo[] ctors = t.GetConstructors();// 得构造函数传入 Type数组 数组中内容按顺序是参数类型// 执行构造函数传入 object数组 表示按顺序传入的参数// 无参构造获取Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[0]);Test test = constructorInfo.Invoke(null) as Test;// 有参构造获取 获取一个参数为int的构造函数Type t = typeof(Test);ConstructorInfo constructorInfo = t.GetConstructor(new Type[1] &#123; typeof(int) &#125;);Test test = constructorInfo.Invoke(new object[1] &#123; 666 &#125;) as Test; 获取类所有公共成员变量 （GetFields FieldInfo 类是 .NET 反射中的一个类，用于表示和操作类或结构体的字段信息。字段是类或结构体中的成员变量，通常用于存储对象的状态。FieldInfo 类提供了访问字段的[[元数据]]和运行时值的方法。 以下是一些 FieldInfo 类的常用属性和方法： 属性： Name: 获取字段的名称。 FieldType: 获取字段的类型。 IsPublic, IsPrivate, IsStatic, IsInitOnly: 判断字段的访问修饰符和其他属性。 DeclaringType: 获取定义该字段的类的 Type 对象。 方法： GetValue(object obj): 获取指定对象上的字段值。需要传递目标对象的实例作为参数。 SetValue(object obj, object value): 设置指定对象上的字段值。需要传递目标对象的实例和要设置的值作为参数。 以下是一个简单的示例，演示如何使用 FieldInfo 获取和操作字段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 得到所有公共成员变量Type t = typeof(Test);FieldInfo[] fieldInfos = t.GetFields();// 得到指定名称的公共成员Type t = typeof(Test);FieldInfo fieldInfo = t.GetField(&quot;str&quot;);// 通过反射 获取其它程序集的对象的某个成员变量的值// 假设下面的Test是其他程序集new出来的, Test.str = &quot;wocao&quot;Test test = new Test(999, &quot;wocao&quot;);Console.WriteLine(fieldInfo.GetValue(test)); // 获取到test.str // 通过反射 设置其它程序集的对象的某个成员变量的值 第一个参数是想要通过反射操作的对象!fieldInfo.SetValue(test, &quot;hello world&quot;);Console.WriteLine(fieldInfo.GetValue(test));using System;using System.Reflection;public class MyClass&#123; public int PublicField; private string PrivateField; public MyClass(int value) &#123; PublicField = value; PrivateField = &quot;PrivateFieldValue&quot;; &#125;&#125;class Program&#123; static void Main() &#123; Type myClassType = typeof(MyClass); // 获取字段信息 FieldInfo publicFieldInfo = myClassType.GetField(&quot;PublicField&quot;); FieldInfo privateFieldInfo = myClassType.GetField(&quot;PrivateField&quot;, BindingFlags.NonPublic | BindingFlags.Instance); // 创建 MyClass 实例 MyClass myObject = new MyClass(42); // 读取和修改字段的值 int publicFieldValue = (int)publicFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PublicField value: &#123;publicFieldValue&#125;&quot;); privateFieldInfo.SetValue(myObject, &quot;NewPrivateFieldValue&quot;); string privateFieldValue = (string)privateFieldInfo.GetValue(myObject); Console.WriteLine($&quot;PrivateField value: &#123;privateFieldValue&#125;&quot;); &#125;&#125; 获取了所有公共成员函数 （GetMethods 1234567891011121314151617181920212223242526272829303132333435363738394041// 获取所有公共成员函数并执行Type t = typeof(string);MethodInfo[] methodInfos = t.GetMethods();for (int i = 0; i &lt; methodInfos.Length; i++) Console.WriteLine(methodInfos[i]);// 获取特定名称的公共成员函数MethodInfo methodInfo = t.GetMethod(&quot;Substring&quot;, new Type[] &#123; typeof(int), typeof(int) &#125;);// 执行该方法string str = &quot;hello world&quot;;// 第一个参数是想要通过反射操作的对象 相当于 对象.XX 如果是静态就传 null str = methodInfo.Invoke(str, new object[] &#123; 0, 5 &#125;) as string;Console.WriteLine(str);Type myClassType = typeof(MyClass);// 获取所有公共方法MethodInfo[] publicMethods = myClassType.GetMethods();// 输出方法信息foreach (MethodInfo methodInfo in publicMethods)&#123; Console.WriteLine($&quot;Method Name: &#123;methodInfo.Name&#125;&quot;); Console.WriteLine($&quot;Return Type: &#123;methodInfo.ReturnType&#125;&quot;); // 获取方法的参数信息 ParameterInfo[] parameters = methodInfo.GetParameters(); Console.Write(&quot;Parameters: &quot;); foreach (ParameterInfo parameter in parameters) &#123; Console.Write($&quot;&#123;parameter.ParameterType&#125; &#123;parameter.Name&#125; &quot;); &#125; Console.WriteLine(); Console.WriteLine();&#125; 其它 type.GetXXX 1234567891011121314151617//得枚举GetEnumNameGetEnumNames//得事件GetEventGetEvents//得接口GetInterfaceGetInterfaces//得属性GetPropertyGetPropertys//等等 快速通过反射实例化对象 Activator 使用 Activator 类的主要优势在于在运行时创建对象，尤其是当不知道具体类型的情况下。然而，需要注意的是，使用 Activator 可能会导致性能损失，因为它依赖于反射机制。在已知类型的情况下，直接使用 new 操作符通常是更好的选择。 12345// 快速将Type实例化为对象 无参构造Type t = typeof(Test);Test test = Activator.CreateInstance(t) as Test;// 有参构造 后面参数如果不对会报错test = Activator.CreateInstance(t, 666, &quot;wocao&quot;) as Test; Assembly [[程序集]]类Assembly: 主要用来加载其它[[程序集]]，加载后 才能用Type来使用其它[[程序集]]中的信息 如果想要使用不是自己[[程序集]]中的内容 需要先加载[[程序集]] 比如 dll文件(库文件) 简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类 三种加载[[程序集]]的函数: 一般用来加载在同一文件下的其它[[程序集]] Assembly asembly2 = Assembly.Load(“[[程序集]]名称”); 一般用来加载不在同一文件下的其它[[程序集]] Assembly asembly = Assembly.LoadFrom(“包含[[程序集]]清单的文件的名称或路径”); Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”); 12345Assembly assembly = Assembly.LoadFrom(@&quot;D:\\\\Myproject VS\\\\静态\\\\bin\\\\Debug\\\\net8.0\\\\test.dll&quot;);Type[] types = assembly.GetTypes();Type t = assembly.GetType(&quot;test.Icon&quot;);t.XXX 判断一个类型是否可以让其它类型给自己分配空间 (父类装子类) IsAssignableFrom 12345678910class Father &#123;&#125;class Son : Father &#123;&#125;Type fatherType = typeof(Father);Type sonType = typeof(Son);if (fatherType.IsAssignableFrom(sonType))&#123; Console.WriteLine(&quot;可以用sonType来给fatherType分配内存&quot;); Father f = Activator.CreateInstance&lt;Son&gt;();&#125; 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments 12345Dictionary&lt;int, List&lt;string&gt;&gt; dic = new Dictionary&lt;int, List&lt;string&gt;&gt;();Type dicType = dic.GetType();Type[] types = dicType.GetGenericArguments();for (int i = 0; i &lt; types.Length; i++) Console.WriteLine(types[i]);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"4.PlayerPrefs总结","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结","date":"2025-02-21T12:27:02.000Z","updated":"2025-02-21T12:27:41.462Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/4.PlayerPrefs总结/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3.PlayerPrefs不同平台的存储位置","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置","date":"2025-02-21T12:09:14.000Z","updated":"2025-02-21T12:18:05.485Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/3.PlayerPrefs不同平台的存储位置/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.PlayerPrefs%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"PlayerPrefs存储的数据存在哪里？ 在不同平台上，PlayerPrefs存储的位置会有所不同： PlayerPrefs的存储位置 Windows： PlayerPrefs 存储在注册表（regedit）中。具体位置为： 32位系统：HKEY_CURRENT_USER\\Software\\[公司名]\\[产品名] 64位系统：HKEY_CURRENT_USER\\Software\\WOW6432Node\\[公司名]\\[产品名] Android： 在Android上，PlayerPrefs 存储在应用的持久数据目录中。具体路径为：/data/data/[包名]/shared_prefs/unity.[公司名].[产品名]_prefs.xml。 Linux： 在Linux上，PlayerPrefs 存储在用户主目录的 .config/unity3d/[公司名]/[产品名]/prefs 目录中。 iOS： 在iOS上，PlayerPrefs 存储在应用的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。 macOS： 在macOS上，PlayerPrefs 存储在用户主目录的 Library/Preferences 目录中，文件名是 unity.[公司名].[产品名].plist。","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2.PlayerPrefs基本方法","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法","date":"2025-02-21T11:49:40.000Z","updated":"2025-02-21T12:08:14.770Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/2.PlayerPrefs基本方法/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.PlayerPrefs%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/","excerpt":"","text":"PlayerPrefs是什么 PlayerPrefs是Unity提供的可以用于存储读取玩家数据的公共类。 PlayerPrefs，你可以轻松地存储和获取一些简单的数据，例如玩家的分数、游戏设置、解锁的关卡等。这些数据将在应用程序关闭后仍然保留，可以在下次启动应用程序时继续使用。 PlayerPrefs的数据存储 PlayerPrefs的数据存储类似于键值对存储，一个键对应一个值。 提供了存储3种数据的方法 int float string。 键: string类型。 值：int float string 对应3种API。 SetInt方法 SetFloat方法 SetString方法 存储数据 1234//设置由 key 标识的偏好的值。PlayerPrefs.SetInt(&quot;第几帅&quot;, 1);PlayerPrefs.SetFloat(&quot;存个浮点数&quot;, 1.1f);PlayerPrefs.SetString(&quot;黄&quot;, &quot;先生&quot;); Save方法 马上存储数据到硬盘中 直接调用Set相关方法只会把数据存到内存里。 当游戏结束时 Unity会自动把数据存到硬盘中。 如果游戏不是正常结束的而是崩溃 数据是不会存到硬盘中的。 调用该方法马上存到硬盘(各个平台默认位置) 1PlayerPrefs.Save(); PlayerPrefs局限性 1234//PlayerPrefs是有局限性的 它只能存3种类型的数据。//如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储。bool sex = true;PlayerPrefs.SetInt(&quot;sex&quot;, sex ? 1 : 0); 如果不同类型用同一键名进行存储 会进行覆盖 12PlayerPrefs.SetInt(&quot;myAge&quot;, 18);PlayerPrefs.SetFloat(&quot;myAge&quot;, 20.2f);//覆盖上一行存储的myAge数据 读取相关 12// 如果填了第二个参数代表没找到就返回后的默认值, 可用来进行基础数据的初始化string test = PlayerPrefs.GetString(&quot;黄&quot;); 注意： 运行时只要你Set了对应键值对 即使你没有马上存储Save在本地 也能够读取出信息 如果存的是SetInt(&quot;myAge&quot;， 18); 读取的是GetFloat(&quot;myAge&quot;);则会使用Float默认值0 键的存在与删除 12345678if (PlayerPrefs.HasKey(&quot;测试&quot;))&#123; // 删除 // 根据键来删除 PlayerPrefs.DeleteKey(&quot;测试&quot;); // 删除所有键值对 PlayerPrefs.DeleteAll();&#125;","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1.PlayerPrefs概述","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述","date":"2025-02-21T11:42:51.000Z","updated":"2025-02-21T11:47:56.848Z","comments":true,"path":"2025/02/21/数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识/1.PlayerPrefs概述/","permalink":"http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/","excerpt":"","text":"","categories":[{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"34.unity入门基础知识总结","slug":"游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结","date":"2025-02-21T08:54:06.000Z","updated":"2025-02-21T08:56:05.646Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/34.unity入门基础知识总结/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"33.Microphone麦克风","slug":"游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风","date":"2025-02-21T08:21:52.000Z","updated":"2025-02-21T08:44:22.060Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/33.Microphone麦克风/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.Microphone%E9%BA%A6%E5%85%8B%E9%A3%8E/","excerpt":"","text":"Unity提供了Microphone类 获取设备信息 1234// 获取设备Microphone信息string[] strs = Microphone.devices;for (int i = 0; i &lt; strs.Length; i++) print(strs[i]); 开始, 结束录制并存储 12345678910111213141516171819202122232425// 开始录制 (1. 设备名 传null使用默认设备, 2. 超过录制长度是否重新录制// (3. 录制时长, 4. 采样率if (Input.GetKeyDown(KeyCode.Space))&#123; _audioClip = Microphone.Start(null, false, 10, 44100);&#125;// 结束录制if (Input.GetKeyUp(KeyCode.Space))&#123; // 为null表示默认设备 Microphone.End(null); // 播放录制音频 AudioSource audio = GetComponent&lt;AudioSource&gt;() ?? gameObject.AddComponent&lt;AudioSource&gt;(); audio.clip = _audioClip; audio.Play(); //AudioClip类的channels变量和samples变量 //channels变量 音频剪辑中的声道数。（只读） //samples变量 样本中音频剪辑的长度。（只读） //规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度 float[] f = new float[_audioClip.channels * _audioClip.samples]; // 把数据存储到浮点数数组里 第二个参数是偏离的位置, 默认填0 _audioClip.GetData(f, 0);&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"32.AudioSource音频源代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制","date":"2025-02-21T07:58:00.000Z","updated":"2025-02-21T08:13:34.597Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/32.AudioSource音频源代码控制/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"代码控制播放停止 12345678910111213141516171819202122232425_audioSource = GetComponent&lt;AudioSource&gt;();// 按下p键播放if (Input.GetKeyDown(KeyCode.P))&#123; _audioSource.Play(); //_audioSource.PlayDelayed(4); // 4秒后播放&#125;// 音频停止if (Input.GetKeyDown(KeyCode.S))&#123; _audioSource.Stop();&#125;// 音频暂停 if (Input.GetKeyDown(KeyCode.Space))&#123; _audioSource.Pause(); //_audioSource.UnPause();再次播放可恢复 (或者使用停止暂停&#125;// 音量大小audioSource.volume = floatValue;// 是否静音audioSource.mute = true 检测播放是否完毕 AudioSource没有提供相关 12345// 检测音频是否播放完 if (!_audioSource.isPlaying)&#123; print($&quot;在Update中不断检测该属性可以判断是否播放完毕&quot;);&#125; 控制音频播放几种方式 直接在要播放音频的对象上挂载脚本来控制 自己创建一个挂载了音频脚本的GameObject(放在prefab预设体里) 用得少 在其他脚本中实例化(如果playOnAwake实例化时播放) 这个对象 用一个AudioSource来控制不同的音效 _audioSource.clip = XXX（AudioClip) ps: 注意: 一个GameObject可以挂载多个音频源脚本AudioSource, 但一定要自己管理好, 不然谁是谁都不知道","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"31.AudioSource音频源组件和AudioListener音频监听组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件","date":"2025-02-21T07:31:03.000Z","updated":"2025-02-21T07:57:18.027Z","comments":true,"path":"2025/02/21/游戏引擎/unity/unity入门/unity入门基础知识/31.AudioSource音频源组件和AudioListener音频监听组件/","permalink":"http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/","excerpt":"","text":"添加AudioSource 音频源脚本 AudioClip 声音剪辑文件（音频文件） 可以拖拽音频文件到这个变量上 Output 输出* 默认不设置的话将直接输出到场景中的音频监听器 可以更改为输出到混音器 混音器是高级功能，以后再讲解 Mute 静音开关 Bypass Effect 开关滤波器效果* Bypass Listener Effects 快速开关所有监听器* Bypass Reverb Zones 快速开关所有混响区* Play On Awake 唤醒时播放 对象创建时就播放音乐 开启的话启动游戏默认就播放 关闭的话启动游戏默认就不播放 Loop 循环 循环播放音乐，一般背景音乐才用 Priority 优先级 优先级越高，越不容易被别的音效覆盖 Volume 音量大小 Pitch 音调 可以理解为音乐快放满房 Stereo Pan 立体声效 2D声音立体声位置 相当于左右声道 Spatial Blend 空间混合 音频受3D空间的影响程度，默认是2D音效，拖满为1变成3D音效 Reverb Zone Mix 混响区混音* 到混响区的输出信号量 3D Sound Settings 3D声音设置 和Spatial Blend参数成正比应用 Doppler Level 多普勒效果等级 Spread 扩张 扩散角度设置为3D立体声还是多声道 Volume Rolloff 音量衰减 声音衰减速度，蓝线横轴可以理解为离耳朵的远近，红线纵轴可以理解为声音大小，耳朵可以理解为AudioListener音频监听脚本 Logarithmic Rolloff 对数衰减 靠近音频源时，声音很大，但离开对象时，声音降低得非常快。 Linear Rolloff 线性衰减 与音频源的距离越远，听到的声音越小。 Custom Rolloff 自定义衰减 音频源的音频效果是根据曲线图的设置变化的。 Min/Max Distance 最大最小距离 最小距离内，声音保持最大响度 最大距离外，声音开始减弱 AudioListener 音频监听脚本 默认挂载到场景的主摄像机上，可以理解为是我们的耳朵 有且只有一个，两个把另外一个要移除","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"30.音频文件导入","slug":"游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入","date":"2025-02-20T15:03:03.000Z","updated":"2025-02-20T15:14:04.577Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/30.音频文件导入/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/","excerpt":"","text":"音频文件常用格式 wav mp3 ogg aiff （不常用） 导入音频文件 导入音频文件直接从外部拖拽音频文件到Project窗口即可 Force To Mono 强制变为单声道 多声道转单声道 Normalize 归一化 强制为单声道时，混合过程中被标准化 Load In Background 后台加载 在后台加载，不阻塞主线程 Ambisonic 全景声音* 立体混响声 非常适合 360 度视频和 XR 应用程序 如果音频文件包含立体混响声编码的音频，请启用此选项 LoadType 加载类型 Decompress On Load 加载时压缩 不压缩形式存在内存，加载块，但是内存占用高 适用于小音效 Compress in memory 压缩内存 压缩形式存在内存，加载慢，内存小 仅适用于较大音效文件 Streaming 流式处理 以流形式存在，使用时解码。内存占用最小，cpu消耗高 性能换内存 Preload Audio Data 预加载音频数据 预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载 Compression Format 压缩格式 PCM 音频以最高质量存储 Vorbis 相对PCM压缩的更小，根据质量决定 ADPCM 包含噪音，会被多次播放的声音，如碰撞声 Quality 音频质量* 确定要应用于压缩剪辑的压缩量。 不适用于 PCM/ADPCM/HEVAG 格式 Sample Rate Setting 采样率设置* PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率 Preserve Sample Rate 保持采样率 此设置可保持采样率不变（默认值） Optimize Sample Rate 优化采样率 此设置根据分析的最高频率内容自动优化采样率 Override Sample Rate 覆盖采样率 此设置允许手动覆盖采样率 因此可有效地将其用于丢弃频率内容。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"}]},{"title":"29.刚体加力","slug":"游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力","date":"2025-02-20T12:09:49.000Z","updated":"2025-02-20T15:00:43.499Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/29.刚体加力/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/","excerpt":"","text":"刚体加力 12345678910111213141516171819202122// 获取刚体组件对象rigidbody = this.GetComponent&lt;Rigidbody&gt;();// 添加力// (相对世界坐标系rigidbody.AddForce(Vector3.forward * 10);// (相对本地坐标系rigidbody.AddRelativeForce(Vector3.forward * 10);// 添加扭矩力// (世界坐标系 // 没有扭矩阻力会一直动rigidbody.AddTorque(Vector3.up * 10);// (本地坐标系rigidbody.AddRelativeTorque(Vector3.forward * 10);// 改变刚体速度 用的少, 位移一般用translate或者给力// 世界坐标系rigidbody.velocity = Vector3.forward;// 模拟爆炸 在中心产生半径 20m 40的力// 如果想要所有刚体都产生同样的爆炸效果就必须所有的刚体组件都要调用AddExplosionForce方法rigidbody.AddExplosionForce(40, Vector3.zero, 20); AddForce方法第二个参数力的模式 1. ForceMode.Force（默认模式） 公式：F * t = m * v 说明： 力会持续作用，受物体质量（mass）影响，质量越大加速度越小。 需要乘以 Time.fixedDeltaTime 才能与物理时间步长匹配（Unity 已自动处理）。 示例： 123// 推动质量为2kg的物体，每帧施加10N的力rb.AddForce(Vector3.forward * 10, ForceMode.Force);// 最终加速度 = 10N / 2kg = 5m/s² 2. ForceMode.Acceleration 公式：F * t = v （m 为 1） 说明： 直接施加加速度，忽略物体质量。 适合需要固定加速度的场景（如模拟重力）。 示例： 12// 无论质量如何，物体以5m/s²的加速度运动rb.AddForce(Vector3.forward * 5, ForceMode.Acceleration); 3. ForceMode.Impulse 公式：F = m * v （t 为 1） 说明： 瞬间施加一个冲量，效果类似“一次性爆发力”。 受质量影响，质量越大效果越弱。 123// 施加一个冲量为100N·s的力（相当于100N的力作用1秒）rb.AddForce(Vector3.up * 100, ForceMode.Impulse);// 质量为2kg时，速度增量 = 100 / 2 = 50m/s 4. ForceMode.VelocityChange 公式：F = v （m 为 1， t 为 1） 说明： 直接修改速度，忽略质量和时间步长。 效果类似“瞬间设置速度”。 示例： 12// 直接将物体的Y轴速度增加10m/s（无视质量）rb.AddForce(Vector3.up * 10, ForceMode.VelocityChange); 恒力场组件 刚体的休眠 Unity为了节约性能，可能会让刚体休眠。 比如让一个有刚体的Cube，受重力影响掉落一个平面上。 当他们静止时，斜向下旋转刚体，这个时候Cube可能不会往下落，因为Cube休眠了。 假如这个时候移动一下平面的位置，Cube可能又会往下落，因为移动平面唤醒了刚体。 12345678910// IsSleeping方法 获取刚体是否处于休眠状态if (rigidBody.IsSleeping())&#123;&#125;// 唤醒休眠if (rigidBody.IsSleeping())&#123; rigidBody.WakeUp();&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"28.碰撞检测之碰撞检测函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数","date":"2025-02-20T11:22:55.000Z","updated":"2025-02-20T11:50:51.481Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/28.碰撞检测之碰撞检测函数/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/","excerpt":"","text":"注意:碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用 ps： 只要挂载的对象能和其它物体产生碰撞检测才会响应下面的函数 如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的，必须挂载到这个刚体父对象上才行。 物理碰撞检测响应函数 12345678910111213141516171819202122232425262728293031private void OnCollisionEnter(Collision collision)&#123; // Collision类 (碰撞信息类 // 碰撞到的对象碰撞器的信息 Collider collider1 = collision.collider; // 碰撞到的对象的所依附的对象 (GameObject) GameObject gameObject1 = collision.gameObject; // 碰撞到的对象的transform组件信息 Transform transform1 = collision.transform; // 触碰点数相关 接触点具体坐标 ContactPoint[] contacts = collision.contacts; print($&quot;我被&#123;collision.gameObject.name&#125;碰撞到了&quot;);&#125;// 碰撞结束分离时, 自动执行private void OnCollisionExit(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;碰撞分离了&quot;);&#125;// 两个物体相互摩擦时会不停调用该函数private void OnCollisionStay(Collision collision)&#123; print($&quot;我和&#123;collision.gameObject.name&#125;一直在产生摩擦&quot;);&#125; 触发器检测响应函数 1234567891011121314151617// 触发开始时会自动调用该函数 (传入的是Collider脚本对象)private void OnTriggerEnter(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;触发了&quot;);&#125;// 当Stay结束时调用private void OnTriggerExit(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;结束触发了&quot;);&#125;// 当两触发器相交会不停调用private void OnTriggerStay(Collider other)&#123; print($&quot;我被&#123;other.gameObject.name&#125;水乳相融&quot;);&#125; 碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑 一般会把想要重写的碰撞和触发检测函数写成protected保护类型的，加上virtual变成虚函数。 没有必要写成public，因为不会自己手动调用碰撞和触发检测函数，都是Unity通过反射帮助我们自动调用的。 小练习 在之前Input和Screen中的练习题基础上，加入一个点击鼠标左键可以发射一颗子弹飞出的功能 给坦克添加一个炮口空物体当做子弹飞出来的位置 添加点击飞出子弹代码，创建子弹预设体，拖拽赋值炮口空物体和子弹预设体 12345678910//Update内 if (Input.GetMouseButtonDown(0)) &#123; //实例化一个子弹对象 GameObject obj = Instantiate(bulletObj); //设置对象的位置 obj.transform.position = bulletPos.position; //设置对象的角度 obj.transform.eulerAngles = bulletPos.eulerAngles; &#125; 子弹一直飞 12//Update内 //子弹一直往前飞 this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime); 加入子弹触碰到地面会自动消失的功能 123456789101112131415private void OnTriggerEnter(Collider other)&#123; //问题一：如果发射子弹时 和坦克自身的碰撞和重合了 可能一开始 就会被移除 //解决方案：判断自己碰撞到的对象 是什么 一定是特定对象 才移除自己 if (other.gameObject.CompareTag(&quot;Ground&quot;) || other.gameObject.CompareTag(&quot;Monster&quot;)) &#123; //碰撞到别的东西 就让子弹小时 //一定是移除自己依附的GameObject对象 而不是脚本自己 Destroy(this.gameObject); &#125; //问题二：坦克本身就带有碰撞盒 当子弹和坦克自身的碰撞盒碰撞可能会产生力的作用 出现一些意想不到的效果 //解决方案：把子弹做成触发器 这样就没有了力的作用&#125; 123456789101112131415public int HP = 3;//当子弹碰到我时 就减血 血量为0了 就移除private void OnTriggerEnter(Collider other)&#123; //由于场景上 只有子弹时触发器 所以我们可以不用进行任何判断 就可以完成这个功能 //减血 HP -= 1; //为0就移除自己 if (HP &lt;= 0) &#123; Destroy(this.gameObject); &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"27.碰撞检测之物理材质","slug":"游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质","date":"2025-02-20T11:15:21.000Z","updated":"2025-02-20T11:22:12.609Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/27.碰撞检测之物理材质/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/","excerpt":"","text":"创建物理材质 在Project窗口加号创建或者右键创建 把物理材质拖拽到两个碰撞器上才能相互作用 物理材质参数 Dynamic Friction 动摩擦力 已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。 Static Friction 静摩擦力 当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。 Bounciness 弹性 表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。 Friction Combine 摩擦力组合 两个碰撞对象的摩擦力的组合方式。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。 Bounce Combine 反弹组合 两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同。 Average 对两个摩擦值求平均值。 Minimum 使用两个值中的最小值。 Maximum 使用两个值中的最大值。 Multiply 两个摩擦值相乘。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"26.碰撞检测之碰撞器","slug":"游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器","date":"2025-02-20T10:39:05.000Z","updated":"2025-02-20T11:11:29.063Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/26.碰撞检测之碰撞器/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/","excerpt":"","text":"知识回顾 两个物体都有碰撞器，至少一个物体有刚体 碰撞器表示物体的体积（形状） 刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用 3D碰撞器种类 1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形 共同参数 Edit Collider 编辑碰撞器 改变碰撞体大小 Is Trigger 是否是触发器 如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略 主要用于进行没有物理效果的碰撞检测 Material 物理材质* 可以确定碰撞体和其它对象碰撞时的交互（表现）方式。 Center 碰撞器中心 碰撞体在对象局部空间中的中心点位置 常用碰撞器 BoxCollider 盒状碰撞器 Size 大小：碰撞体在X、Y、Z方向上的大小 Sphere Collider 球状碰撞器 Radius 半径：球形碰撞体的半径大小 Capsule Collider 胶囊碰撞器 Radius 半径：胶囊体的半径 Height 高度：胶囊体的高度 Direction 轴向：胶囊体在对象局部空间中的轴向 异形物体使用多种碰撞器组合 刚体对象的子对象碰撞器信息参与碰撞检测 比如金字塔预设体，只在金字塔最高层级对象添加刚体，子对象的所有Cube都会参与碰撞检测 再比如一个Cube添加刚体，再给他添加两个空物体，两个空物体分别添加斜着的盒型碰撞器当做支架，这样这个Cube下落时就会被支架撑起来，即便两个空物体连模型都没有只有碰撞器 不常用碰撞器* Mesh Collider 网格碰撞器* 不常用的原因是性能消耗较高 默认不会显示绿色的碰撞器边框，开启Convex 才会显示绿色的碰撞器边框 Convex Mesh Collider 最多 255 个三角形。 Wheel Collider 轮胎碰撞器* 可以通过给车的父对象加刚体（注意刚体质量一定要大），子对象加车轮碰撞器模拟汽车 Terrain Collider 地形碰撞器* 不常用的原因是性能消耗很高","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"25.碰撞检测之刚体","slug":"游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体","date":"2025-02-20T09:28:06.000Z","updated":"2025-02-20T10:21:59.657Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/25.碰撞检测之刚体/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/","excerpt":"","text":"碰撞产生的必要条件：两个物体都有碰撞器，至少一个物体有刚体 RigidBody组件信息如下 Mass 质量 默认为千克 质量越大惯性越大 Drag 空气阻力 根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力 Angular Drag 角阻力（扭矩阻力） 通俗理解就是阻碍对象旋转的阻力，角阻力越大越不容易旋转 0 表示没有空气阻力。 Use Gravity 重力开关 是否受重力影响 Is Kinematic 控制物理是否影响刚体。 可以理解为开启后不受力的影响，只能通过Transform移动 如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用。 Interpolate 插值运算 让刚体物体移动更平滑 可以更改FixTime，改成一秒，这样对象会很突兀的一秒移动一次，这时开启插值运算就可以让刚体对象平滑移动 None 无插值运算模式 不应用插值运算 Interpolate 插值模式 插值将始终滞后一点，但比外推更流畅。 根据前一帧的变换来平滑变换。 Extrapolate 外推模式 外推将根据当前速度预测刚体的位置。 根据下一帧的估计变换来平滑变换。 Collision Detection 碰撞检测模式 Continuous Dynamic 连续动态检测 &gt; Continuous Speculative 连续推测检测 &gt; Continuous 连续检测 &gt; Discrete 离散检测 用于防止快速移动的对象穿过其它对象而不检测碰撞 Discrete 离散检测 默认的碰撞检测模式。 在每一帧中进行一次碰撞检测，适用于大多数普通物体。 最省性能，但可能会错过高速物体的碰撞。 适合一般速度移动的物体，不适合高速移动的小物体。 对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值） Continuous 连续检测 提高了碰撞检测的精度，特别适合高速移动的物体。 在每一帧中进行多次碰撞检测，避免高速物体穿过其他物体。 比 Discrete 消耗更多的性能，但减少了穿透问题。 适用于高速移动的物体，如子弹或快速飞行的物体。 对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用连续碰撞检测。 设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置） 其他刚体将使用离散碰撞检测。 Continuous Dynamic 连续动态检测 针对快速移动的物体和其他静止或缓慢移动的物体之间的碰撞检测。 结合 Continuous 和 Discrete 的优点，对高速物体进行多次检测，对慢速或静止物体进行一次检测。 在保证精度的同时比 Continuous 更省性能。 适用于快速移动的物体与静止或缓慢移动的物体之间的碰撞检测，如快速移动的角色或车辆。 性能消耗高 对设置为连续 (Continuous)和连续动态 (Continuous Dynamic)碰撞的游戏对象使用连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。 对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。 Continuous Speculative 连续推测检测 使用预测的方式进行碰撞检测。 预测物体的未来位置，并在物体穿过其他物体前进行检测和处理。 性能较高，精度也不错，但有时可能会出现误判。 适合大多数需要高精度且有较高速度的物体。 对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。 Constraints 刚体约束 对刚体运动的限制 Freeze Position 冻结位置 有选择地停止刚体沿世界 X、Y 和 Z 轴的移动。 Freeze Rotation 冻结旋转 有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转。","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"24.光面板","slug":"游戏引擎/unity/unity入门/unity入门基础知识/24.光面板","date":"2025-02-20T09:07:17.000Z","updated":"2025-02-20T09:35:08.172Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/24.光面板/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/","excerpt":"","text":"Skybox Material 天空盒材质 可以改变天空盒 可以在project窗口右键创建材质，材质选择成天空盒着色器 Sun Source 太阳来源* 不设置会默认使用场景中最亮的方向光代表太阳 Environment Lighting 环境光设置* Source 环境光光源颜色* Skybox 天空盒：天空和材质作为环境光颜色 Gradient 渐变：可以为天空、地平线、地面单独选择颜色和他们之间混合 Color颜色 Intensity Multiplier 环境光亮度* Ambient Mode 环境模式* 全局光照模式，只有启用了实时全局和全局烘焙时才有用 Realtime 实时（已弃用） Baked 烘焙 OtherSettings 其它设置* Fog 雾开关* Color 雾颜色 Mode 雾计算模式 Linear 线性模式 随距离线性增加 Start 开始距离 离摄像机多远开始有雾 End 结束距离 离摄像机多远完全遮挡 Exponential 指数模式 随距离指数增加 Density 密度 雾强度 Exponential Qquare 指数平方模式 随距离比指数更快的增加 Density 密度 雾强度 Halo Texture 光晕材质* 光源周围挥着光环的纹理 Halo Strength 光晕强度* 光环可见性 Flare Fade Speed 炫光交叉淡化速度* 耀斑淡出时间，最初出现之后淡出的时间 Flare Strength 炫光强度* 耀斑可见性 Spot Cookie 聚光灯剪影* 聚光灯剪影纹理","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"23.Light光源组件","slug":"游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件","date":"2025-02-20T08:10:23.000Z","updated":"2025-02-20T09:35:01.927Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/23.Light光源组件/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/","excerpt":"","text":"Type光源类型 Spot聚光灯 Spot Angle光锥角度 Range发光范围距离 Directional方向光(环境光) Point点光源 Area面光源 Mode 光源模式 Realtime 实时光源：每帧实时计算，效果好，性能消耗大 Baked 烘焙光源：事先计算好，无法动态变化 Mixed 混合光源：预先计算+实时运算 Intensity 光源强度 Indirect Multiplier 间接系数 * 改变间接光的强度 低于1，每次反弹会使光更暗 大于1，每次反弹会使光更亮 Shadow Type 阴影类型 NoShadows 关闭阴影 HardShadows 生硬阴影 SoftShadows 柔和阴影 Realtime Shadows 实时阴影* Strength 强度: 阴影暗度 0~1之间，越大越黑 Resolution 分辨率: 阴影贴图渲染分辨率，越高越逼真，消耗越高 （Project Setting中的Quallty的设置） Bias 偏离: 阴影推离光源的距离 Normal Bias 法线偏离: 阴影投射面沿法线收缩距离 Near Panel 近平面: 渲染阴影的近裁剪面 Cookie 剪影 投影遮罩: 一般用于聚光灯，显示图案 Draw Halo 绘制光晕 球形光环开关 可以用于蜡烛等效果 Flare 眩光 耀斑 有点类似于太阳耀斑效果 想要在Game窗口看到耀斑要在摄像机Camera上加FlareLayer脚本 Render Mode 渲染模式* Auto 自动: 运行时确定 Important 重要: 以像素质量为单位进行渲染，效果逼真，消耗大 Not Important 非重要: 以快速模式进行渲染 Culling Mask 剔除遮罩 剔除遮罩层，决定哪些层的对象受到该光源影响 ps：所有参数都可都可以在代码中设置","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"22.Camera代码控制","slug":"游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制","date":"2025-02-20T06:40:08.000Z","updated":"2025-02-20T09:34:11.418Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/22.Camera代码控制/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/","excerpt":"","text":"重要静态成员 1234567891011121314151617181920// 获取主摄像机 只能是有MainCamera tag的print(Camera.main?.name); **************// 所有摄像机数量print(Camera.allCamerasCount);// 所有摄像机Camera[] allCameras = Camera.allCameras;// 渲染相关委托// 摄像机剔除前处理的委托函 数Camera.onPreCull += (c) =&gt;&#123;&#125;;// 摄像机渲染前处理的委托Camera.onPreRender += (c) =&gt;&#123;&#125;;// 摄像机渲染后处理的委托Camera.onPostRender += (c) =&gt;&#123;&#125;; 重要成员 Inspector窗口的所有值都能用代码得到并修改 比如：Camera.main.depth = 10; 下面非常常用 12345// 世界坐标 转 屏幕坐标// 转换后的x, y就是屏幕坐标, z则为 Camera.main 离 这个物体position有多远 (纵深// 用这个来做 头顶血条 ****************Vector3 vector3 = Camera.main.WorldToScreenPoint(this.transform.position);print(vector3); 设置z之后，屏幕坐标就会转换到世界坐标的距离摄像机的z距离的平面上 12345// 屏幕坐标 转 世界坐标// 转换要自己设定z轴的距离, 否则为0, 一直在视口点上坐标不变Vector3 v = Input.mousePosition; ***********v.z = 10;Vector3 vector31 = Camera.main.ScreenToWorldPoint(v);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"21.Camera","slug":"游戏引擎/unity/unity入门/unity入门基础知识/21.Camera","date":"2025-02-20T05:43:21.000Z","updated":"2025-02-20T09:34:08.115Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/21.Camera/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/","excerpt":"","text":"Camera可编辑参数 Clear Flags清楚标志 skybox天空盒 （做3d游戏） Solid Color颜色填充 （做2d游戏） Depth only 只画该层，背景透明 （一般多个摄像机叠加渲染的时候使用，一般与下面的Depth配合使用） Don’t Clear 不移除，覆盖渲染 （不常用，会保留每一帧的渲染内容，就像黄金体验镇魂曲） Culling Mask剔除遮罩 选择渲染部分层级（Layer） Projection FOV Axis Fov轴：视野轴，决定了光学仪器的视野范围。 Perspective 透视模式 Field of view 视野：摄像机视角（以沿着 FOV Axis__ 下拉选单中指定轴的度数为单位）。0-180度之间，一般保持默认60就行。 orthographic 正交摄像机（一般用于2D游戏制作） Size：摄制范围 Clipping Planes裁剪平面 Near：近平面 Far：远平面 Depth深度 渲染顺序上的深度 （数字越小，越先渲染） 数字小的照片会先放， 数字大的照片会叠在上面，天空盒有背景是不透明，depth only透明 Target Texture目标纹理 可以把摄像机画面渲染到一张图上， 主要用于制作小地图 在Project右键创建 Render Texture，将创建的Render Texture拖到摄像机，就会把摄像机看到的画面渲染到一张图上 Occlusion Culling剔除遮挡 勾选时一些游戏物体被大一点的物体挡住可以不用渲染 不常用的参数 Viewport Rect视口范围 屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏，0~1 相当于宽高百分比 Redering path渲染路径","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"20.Screen屏幕相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关","date":"2025-02-20T02:50:13.000Z","updated":"2025-02-20T09:33:59.444Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/20.Screen屏幕相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.Screen%E5%B1%8F%E5%B9%95%E7%9B%B8%E5%85%B3/","excerpt":"","text":"常用 1234567891011// 当前屏幕分辨率 (设备的分辨率Resolution currentResolution = Screen.currentResolution;print($&quot;当前分辨率宽:&#123;currentResolution.width&#125;, 高:&#123;currentResolution.height&#125;&quot;);// 当前游戏窗口分辨率 print($&quot;当前窗口分辨率为:&#123;Screen.width&#125; * &#123;Screen.height&#125;&quot;);// 屏幕休眠模式 Screen.sleepTimeout = SleepTimeout.NeverSleep; 不常用 123456789101112131415161718192021// 运行时是否全屏Screen.fullScreen = true;// 窗口模式 (以后在发布的时候在设置, 一般不用代码去设置)// 独占全屏 FullScreenMode.ExclusiveFullScreen// 全屏窗口 FullScreenMode.FullScreenWindow;// 最大化窗口 FullScreenMode.MaximizedWindow// 窗口模式 FullScreenMode.Windowed;Screen.fullScreenMode = FullScreenMode.FullScreenWindow;// 移动设备转向相关...Screen.autorotateToLandscapeLeft = true;// 指定屏幕显示方向Screen.orientation = ScreenOrientation.LandscapeLeft;// 设置分辨率 第三个参数是否为全屏 (移动设备不用, Screen.SetResolution(1920, 1080, false);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"19.Input输入相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关","date":"2025-02-20T02:39:16.000Z","updated":"2025-02-20T09:33:54.556Z","comments":true,"path":"2025/02/20/游戏引擎/unity/unity入门/unity入门基础知识/19.Input输入相关/","permalink":"http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/19.Input%E8%BE%93%E5%85%A5%E7%9B%B8%E5%85%B3/","excerpt":"","text":"输入内容一定是写在Update当中的 鼠标位置 屏幕坐标的原点是在左下角，右是x轴正向，上是y轴正向 123// 鼠标位置// 返回一个Vector3, 但只有x, y有值print(Input.mousePosition); 检测鼠标输入 1234567891011// 检测鼠标输入 (0左键, 1右键, 2滚轮if (Input.GetMouseButtonDown(0)) print(&quot;你按了一次 鼠标左键&quot;);if (Input.GetMouseButtonUp(1)) print(&quot;你抬起了一次 鼠标右键&quot;);if (Input.GetMouseButton(0)) print(&quot;你是一直在按着 鼠标左键&quot;);// 返回一个Vector2, 而滚动会改变其中的y值// y值 -1 往下棍, 0 没滚, 1 往上滚Vector2 mouseScrollDelta = Input.mouseScrollDelta;print(mouseScrollDelta); 检测键盘输入 123// 键盘按下 up抬起, 无长按...if (Input.GetKeyDown(KeyCode.W)) print(&quot;你按下了W键&quot;); 检测默认轴 记不住单词可以在Project Setting中的Input Manager查看 1234567891011121314// 默认轴输入// 当键盘A,D键按下时, 返回-1 到 1之间的变换 // 即一直按A的话, 返回值会慢慢从0变到 -1// Input.GetAxisRaw是只会有 -1, 0, 1三个数字之间的突变float v = Input.GetAxis(&quot;Horizontal&quot;);print(v);// W, S 返回-1, 到 1float v1 = Input.GetAxis(&quot;Vertical&quot;);print(v1);// 鼠标横向移动 纵向 Mouse Yfloat v2 = Input.GetAxis(&quot;Mouse X&quot;);print(v2); 其它 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 是否有任意键或鼠标长按bool anyKey = Input.anyKey;if (Input.anyKeyDown)&#123; print($&quot;有一个键按下了按下的是&#123;Input.inputString&#125;&quot;);&#125;// 得到连接的手柄的所有按钮名字string[] strings = Input.GetJoystickNames();for (int i = 0; i &lt; strings.Length; i++)&#123; print(&quot;你连接的所有按钮有&quot;); print(strings[i]);&#125;// 某一手柄键按下, 抬起, 长按...bool v3 = Input.GetButtonDown(strings[0]);// 移动设备触摸if (Input.touchCount &gt; 0)&#123; Touch touch = Input.touches[0]; // 位置 print(touch.position); // 相对上次位置的变化 print(touch.deltaPosition);&#125;// 是否启用多点触控Input.multiTouchEnabled = true;// 陀螺仪 (重力感应)// 是否开启陀螺仪Input.gyro.enabled = true;// 重力加速度 Vector3 gravity = Input.gyro.gravity;// 旋转速度Vector3 rotationRate = Input.gyro.rotationRate;// 陀螺仪 当前旋转的四元数// 比如用这个角度信息 来控制场景上的一个3D物体收到重力影响// 手机怎么动, 他就怎么动Quaternion attitude = Input.gyro.attitude; 练习 用WASD键控制前进后退，左右转向 123//ws键 控制位移 // 这公式 是 ： 前进方向 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime * Input.GetAxis(&quot;Vertical&quot;)); //ad键 控制 左右转向 // 这公式 是 ： 转动的轴 * 速度 * 时间 * 输入相关（-1~1 相当于 正向还是反向的感觉 不按就不动 0this.transform.Rotate(Vector3.up * rotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Horizontal&quot;)); 鼠标左右移动控制炮口的转向 1head.Rotate(Vector3.up * headRotateSpeed * Time.deltaTime * Input.GetAxis(&quot;Mouse X&quot;));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"18.坐标转换","slug":"游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换","date":"2025-02-19T13:07:14.000Z","updated":"2025-02-20T09:33:45.396Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/18.坐标转换/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"世界 -&gt; 本地 世界坐标系的点 -&gt; 本地坐标系的点 123// 世界坐标 转换为 本地坐标 (会受到缩放影响// 即 在世界坐标系下的 (0, 0, 1) 在本地坐标系下表示为 transform.InverseTransformPoint(Vector3.forward)print(this.transform.InverseTransformPoint(Vector3.forward)); 世界坐标系的向量 -&gt; 本地坐标系的向量 1234// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (不受缩放影响print(this.transform.InverseTransformDirection(Vector3.forward));// 世界坐标系的向量 平移到 本地坐标系后的向量值是 (受缩放影响print(this.transform.InverseTransformVector(Vector3.forward)); 本地 -&gt; 世界 本地坐标系的点 -&gt; 世界坐标系的点 （最重要的***） 1234567// 本地坐标 转换为 世界坐标 (会受到缩放影响// 即 在本地坐标系下的 (0, 0, 1) 在世界坐标系下表示为 transform.TransformPoint(Vector3.forward)print(this.transform.TransformPoint(Vector3.forward));// eg:GameObject obj = new GameObject(&quot;左前方物体&quot;);obj.transform.position = this.transform.TransformPoint(new Vector3(-1, 0, 1)); // 在本地坐标的左前方（-1,0,1）处创建物体 本地坐标系的向量 -&gt; 世界坐标系的向量 1234// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (不受缩放影响print(this.transform.TransformDirection(Vector3.forward));// 本地坐标系的向量 平移到 世界坐标系后的向量值是 (受缩放影响print(this.transform.TransformVector(Vector3.forward));","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"17.父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系","date":"2025-02-19T08:56:46.000Z","updated":"2025-02-20T09:32:55.448Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/17.父子关系/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/17.%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"获取和设置父对象 1234567891011121314151617// 获取父对象print(this.transform.parent);// 断绝父子关系this.transform.parent = null; // 认父亲 // 也会顺带把孙子的爷爷也换了this.transform.parent = GameObject.Find(&quot;obj&quot;).transform;// 下面这种认父亲的方法 特殊一些// 第二个参数为true 则不会改掉物体本来的世界坐标位置,大小什么的// 为false, 则会把原来Inspector面板上的数字原封不动的赋值到新的Inspector窗口上，则会用自己的transform中的数值// 子对象世界坐标 = 父对象世界坐标 × 子对象局部坐标（当 worldPositionStays = false 时）。// 动态创建ui时常用this.transform.SetParent(GameObject.Find(&quot;obj&quot;).transform, false); 抛妻弃子 12// 和自己所有儿子断绝关系, 不会断掉儿子和孙子的this.transform.DetachChildren(); 获取子对象及其操作 12345678910111213141516171819// 根据名字查找儿子对象 (不可以查找孙子, 可以找到失活的儿子，GameObject的find不能查找失活的对象 )print(this.transform.Find(&quot;Capsule&quot;));// 查找Father的儿子Sonprint(this.transform.Find(&quot;Father/Son&quot;));// 儿子数量print(this.transform.childCount);// 遍历for (int i = 0; i &lt; this.transform.childCount; i++) print(this.transform.GetChild(i)); // 判断是不是自己是不是另一个对象的儿子bool v = this.transform.IsChildOf(transform.parent);// 设置自己作为儿子编号this.transform.SetSiblingIndex(0);// 得到自己作为儿子的编号print(this.transform.GetSiblingIndex()); 练习 请为Transform写一个拓展方法，可以将它的子对象按名字的长短进行排序改变他们的顺序，名字短的在前面，名字长的在后面 1234567891011121314151617181920212223242526272829public static class TransformExtensions&#123; public static void SortChildrenByNameLength(this Transform obj) &#123; //var children = obj.Cast&lt;Transform&gt;().ToList(); //children = children.OrderBy(child =&gt; child.name.Length).ToList(); //for (int i = 0; i &lt; children.Count; i++) //&#123; // children[i].SetSiblingIndex(i); //&#125; List&lt;Transform&gt; list = new List&lt;Transform&gt;(); for (int i = 0; i &lt; obj.childCount; i++) &#123; list.Add(obj.GetChild(i)); &#125; //这是根据 名字长短进行排序 利用的 是list的排序 传个函数进去 list.Sort((a, b) =&gt; a.transform.name.Length - b.transform.name.Length); //根据 list中的排序结果 重新设置每一个对象的 索引编号 for (int i = 0; i &lt; list.Count; i++) &#123; list[i].SetSiblingIndex(i); &#125; &#125;&#125; 请为Transform写一个拓展方法，传入一个名字查找子对象，即使是子对象的子对象也能查找到 123456789101112131415161718public static class TransformExtensions&#123; public static Transform CustomFind(this Transform obj, string name) &#123; Transform res = null; res = obj.Find(name); if (res != null) return res; for (int i = 0; i &lt; obj.childCount; i++) &#123; res = obj.GetChild(i).CustomFind(name); if (res != null) return res; &#125; return res; &#125;&#125;","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"16.缩放和看向","slug":"游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向","date":"2025-02-19T08:23:15.000Z","updated":"2025-02-20T09:32:39.559Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/16.缩放和看向/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/16.%E7%BC%A9%E6%94%BE%E5%92%8C%E7%9C%8B%E5%90%91/","excerpt":"","text":"缩放 12345678// 相对于世界坐标系 // 不能改print(this.transform.lossyScale);// 相对于父对象 // 可以改print(this.transform.localScale);// unity 没有提供缩放相关的API, 只能自己手动来搞 eg: this.transform.localScale += Vector3.one * Time.deltaTime; 看向 12// 将自己的面朝向源点，相对于世界坐标系this.transform.LookAt(Vector3.zero);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"15.角度和旋转","slug":"游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转","date":"2025-02-19T07:30:32.000Z","updated":"2025-02-20T09:32:35.248Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/15.角度和旋转/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/15.%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC/","excerpt":"","text":"角度相关 123456789// 相对于世界坐标角度print(this.transform.eulerAngles);// 相对于父对象角度// Inspector中显示的是相对父对象的角度，localEulerAngles的角度只能是0~360，但Inspector面板是可以负数的print(this.transform.localEulerAngles);// 不能单个x, y, z赋值this.transform.localEulerAngles = new Vector3(10, 10, 10); 旋转相关 123456789101112// 自转API 第二个参数默认不写的话，绕着自己坐标转this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime * 100, Space.World); // 每帧绕y轴增加100 * （0，10，0）//相对于某个轴 转多少度//参数一:是相对哪个轴进行转动//参数二:是转动的 角度 是多少//参数三:默认不填 就是相对于自己的坐标系 进行旋转transform.Rotate(Vector3.up, Time.deltaTime * 100); // 在自己的坐标系的y轴旋转// 绕着某个点旋转 绕着源点, y轴, 转的多少度this.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime); 代码 原理 效率 可读性 Rotate(new Vector3(0,1,0) * dt * 100) 欧拉角增量 较低（需创建Vector3） 一般 Rotate(Vector3.up, dt * 100) 轴-角度 较高 更佳","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"14.位置位移坐标系相关","slug":"游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关","date":"2025-02-19T06:59:04.000Z","updated":"2025-02-20T09:32:22.769Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/14.位置位移坐标系相关/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/14.%E4%BD%8D%E7%BD%AE%E4%BD%8D%E7%A7%BB%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9B%B8%E5%85%B3/","excerpt":"","text":"Vector常用 用的是世界坐标 123456789Vector3.forward 001Vector3.up 010Vector3.down 0-10Vector3.left -100Vector3.right 100Vector3.back 00-1// 两点之间的距离Vector3.Distance(v1, v2); 位置 1234567891011// 相对世界坐标原点的值print($&quot;距离世界源点 &#123;this.transform.position&#125;&quot;);// 相对父对象 没父对象就相对于源点print($&quot;距离父对象坐标点 &#123;this.transform.localPosition&#125;&quot;);// 位置的赋值不能单独改x, y, z 只能整体来赋值this.transform.position = new Vector(5, this.transform.position.y, ...);// 或者Vector3 tmp = this.transform.position; tmp.y = 666;this.transfomr.position = tmp; 朝向 本地坐标系，游戏对象当前的朝向 123print(this.transform.forward); // 游戏对象当前的面朝向print(this.transform.up); // 对象当前的头顶朝向Vector3 right = this.transform.right; // 右手边 位移 123456789101112131415// 1 位移 = 方向 * 速度 * 时间 (手动写, 世界坐标系的话用Vector3.XX)最终位置 = 当前的位置 + 我要变化的位置的路程//this.transform.position += this.transform.forward * 1 * Time.deltaTime;// 2 位移API// 参数1 表示位移多少 位移 = 方向 * 速度 * 时间// 参数2 移动所采用的坐标系, 即(1, 0, 0)是哪个坐标系的(1, 0, 0) (不填的话，默认本地相对坐标系Space.Self)this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World); // 沿着世界坐标系的001去动this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.World); // 世界坐标系中沿着自己的面朝向去动this.transform.Translate（Vector3.forward * 1 * Time.deltaTime, Space.Self); // 沿着自己坐标系的001去动// 不会这样移动, 自己相对于世界坐标系的歪曲的数据 再应用于自己的坐标系this.transform.Translate(transform.forward * 1 * Time.deltaTime, Space.Self); // 傻逼","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"13.时间相关Time","slug":"游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time","date":"2025-02-19T06:00:25.000Z","updated":"2025-02-20T09:32:15.891Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/13.时间相关Time/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/13.%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3Time/","excerpt":"","text":"时间缩放比例 12// 时间停止 // 恢复正常 // 2倍速Time.timeScale = 0; Time.timeScale = 1; Time.timeScale = 2; 帧间隔时间 即 两帧之间的时间 作用: 计算位移 每帧移动的距离由speed * Time.deltaTime确定，确保了在不同帧率下物体移动的速度一致 典型应用：transform.Translate(Vector3.forward * speed * Time.deltaTime); 通过乘以 deltaTime，物体每秒移动的距离为 speed 单位，无论帧率如何变化。 123// 帧间隔时间print(&quot;受timeScale影响的 &quot; + Time.deltaTime);print(&quot;不受timeScale影响的&quot; + Time.unscaledDeltaTime); 游戏开始到现在时间 一般都单机游戏用，网游一般用服务器时间 123// 游戏开始到现在的时间print(&quot;受timeScale影响的&quot; + Time.time);print(&quot;不受影响的&quot; + Time.unscaledTime); 物理帧间隔时间 123456void FixedUpdate()&#123; // 物理帧间隔时间 print(&quot;受影响的 &quot; + Time.fixedDeltaTime); print(&quot;不受影响的 &quot; + Time.fixedUnscaledDeltaTime);&#125; 总帧数 (帧同步) 从开始到现在游戏跑了多少帧（即多少次循环） 1print(Time.frameCount);","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"12.GameObject","slug":"游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject","date":"2025-02-19T02:07:20.000Z","updated":"2025-02-20T09:32:08.542Z","comments":true,"path":"2025/02/19/游戏引擎/unity/unity入门/unity入门基础知识/12.GameObject/","permalink":"http://example.com/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.GameObject/","excerpt":"","text":"成员变量 12345678910// 名字this.gameObject.name = &quot;改名desu&quot;;// 是否激活bool activeSelf = this.gameObject.activeSelf;// 是否静态bool isStatic = this.gameObject.isStatic;// 层级int layer = this.gameObject.layer;// 给游戏对象分的标签string tag1 = this.gameObject.tag; 静态方法 创建自带几何体 123// 创建自带几何体GameObject gameObject1 = GameObject.CreatePrimitive(PrimitiveType.Cube);gameObject1.name = &quot;自己起的名字&quot;; 在场景中查找对象 只能找到激活对象，无法找到失活对象 使用单个查找的api，如果场景有满足调教的多个对象，无法指定找到的是谁 1234567891011121314151617// 在场景中查找对象 // 1.1 单个查找 名字(同名不行)// 查找效率低 会查询所有场景中所有的对象GameObject gameObject2 = GameObject.Find(&quot;自己起的名字&quot;);print(gameObject2?.name);// 1.2 单个查找 tagGameObject gameObject3 = GameObject.FindWithTag(&quot;MainCamera&quot;);print(gameObject3?.name);// 1.3 通过Inspector面板去拖到本地的public// 2 多对象查找 tagGameObject[] gameObjects = GameObject.FindGameObjectsWithTag(&quot;Player&quot;);print(gameObjects?.Length);// FindObjectOfTypes 效率低 克隆对象 根据一个GameObject对象, 创建一个一模一样的对象 1GameObject obj = GameObject.Instantiate(MyObj); 删除 删除一个指定游戏对象 删除一个指定脚本对象 注意: Destroy方法不会马上移除对象, 只是加了一个移除标识 一般情况下, 会在下一帧时把这个对象从内存中移除 1234567// 删除对象GameObject.Destroy(gameObject4, 5); // 第二个参数是延时几秒// 删除脚本对象GameObject.Destroy(this);// 一定要马上移除 // 没特殊需求不用GameObject.DestroyImmediate(gameObject4); 切场景不移除 默认情况下, 切场景会删除该场景的所有对象 一般写自己依附的对象不被删除 1GameObject.DontDestroyOnLoad(this.gameObject); // 不移除该脚本依附的游戏对象 成员方法 创建空物体 顺带加上Test2脚本 1GameObject gameObject5 = new GameObject(&quot;创建的空物体名字&quot;, typeof(Test2)); 动态给GameObject对象添加脚本 12// 给gameObject5加上Test2脚本Test2 test2 = gameObject5.AddComponent&lt;Test2&gt;(); 获取脚本对象 和[[Mono中的重要内容#^155e67 | 继承Mono的类]]获取脚本对象的方法一毛一样 标签比较 12345678if (gameObject5.CompareTag(&quot;Player&quot;))&#123; print(&quot;对象标签是Player&quot;);&#125;if (gameObject5.tag == &quot;Player&quot;)&#123; print(&quot;这和上面是一样的&quot;);&#125; 设置 失活 和 激活 1gameObject5.SetActive(false); // 失活 不建议使用的成员方法 通过广播或者发送消息的形式, 让自己或者别人 执行某些行为和方法 123456789// 让自己去执行TestFun这个函数, 会在自己对象上挂着的所有脚本去找这个名字的函数, 有一个执行一个// 涉及到反射 比较影响性能this.gameObject.SendMessage(&quot;TestFun&quot;);// 广播行为 让自己及其子对象发送消息并执行，让自己及其子对象 执行相同的名字的方法this.gameObject.BroadcastMessage(&quot;TestFun&quot;);// 让自己及其父对象发送消息并执行this.gameObject.SendMessageUpwards(&quot;函数名&quot;); 继承自Object自然可以用Object.xxx的方式来调用静态函数","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"}]},{"title":"11.MonoBehavior中的重要内容","slug":"游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容","date":"2025-02-18T10:13:17.000Z","updated":"2025-02-20T09:31:58.691Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/11.MonoBehavior中的重要内容/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.MonoBehavior%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%86%85%E5%AE%B9/","excerpt":"","text":"8.脚本基本规则 重要成员 获取依附的GameObject 1print(this.gameObject.name); 获取依附的GameObject的位置信息 1234567//得到对象位置信息print(this.transform.position);//位置print(this.transform.eulerAngles);//角度print(this.transform.lossyScale);//缩放大小//这种写法和上面是一样的效果 都是得到依附的对象的位置信息this.gameObject.transform 设置脚本是否激活 1234//this.enabled = true;print($&quot;这是其它脚本对象 otherTest, 可以使用本脚本的其它脚本对象来获取gameObject &#123;otherTest.gameObject.name&#125;&quot;); 重要方法 获取依附对象上挂载的其它脚本 三个重载获取 1234567891011// 通过挂载脚本名Component component = this.GetComponent(&quot;Test2&quot;);Test2 t = component as Test2;print(t);// 通过typet = this.GetComponent(typeof(Test2)) as Test2;// 通过 *************用最多*************t = this.GetComponent&lt;Test2&gt;(); 获取多个脚本 123456Test2[] test2s = this.GetComponents&lt;Test2&gt;();List&lt;Test2&gt; list = new List&lt;Test2&gt;();this.GetComponents&lt;Test2&gt;(list); 找自己及其子对象的所挂载的脚本 123// 这里可以不传参数, 默认传false表示不找失活状态的脚本// 找自己及其父对象的同理this.GetComponentsInChildren&lt;Test2&gt;(false); 注意 要想操作其它GameObject对象, 必须获取其它的脚本对象, 而且得用Inspector来赋值","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"特性","slug":"编程语言/Csharp/特性","date":"2025-02-18T09:18:38.000Z","updated":"2025-02-18T09:20:20.755Z","comments":true,"path":"2025/02/18/编程语言/Csharp/特性/","permalink":"http://example.com/2025/02/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E7%89%B9%E6%80%A7/","excerpt":"","text":"特性 特性是一种允许我们向程序的[[程序集]]添加[[元数据]]的语言结构 它是用于保存程序结构信息的某种特殊类型的类 特性提供功能强大的方法以将声明信息与 C# 代码（类型、方法、属性等）相关联。 特性与程序实体关联后，即可在运行时使用[[反射]]查询特性信息 特性的目的是告诉编译器把程序结构的某组[[元数据]]嵌入[[程序集]]中 它可以放置在几乎所有的声明中（类、变量、函数等等申明） 说人话： 特性本质是个类 我们可以利用特性类为[[元数据]]添加额外信息 比如一个类、成员变量、成员方法等等为他们添加更多的额外信息 之后可以通过[[反射]]来获取这些额外信息 自定义特性 12345678910111213class MyCustomAttribute : Attribute&#123; //特性中的成员 一般根据需求来写 public string info; public MyCustomAttribute(string info) &#123; this.info = info; &#125; public void TestFun() &#123; Console.WriteLine(&quot;特性的方法&quot;); &#125;&#125; 特性的使用 基本语法: [特性名(参数列表)] 本质上 就是在调用特性类的构造函数 写在哪里？ 类、函数、变量上一行，表示他们具有该特性信息 1234567891011121314151617181920212223[MyCustom(&quot;这是我自己的类&quot;)]class MyClass&#123; [MyCustom(&quot;这是一个int型的成员变量&quot;)] public int Value; [MyCustom(&quot;这是用来测试的成员函数&quot;)] public void TestFun([MyCustom(&quot;这是用来测试的函数参数&quot;)] int a) &#123; Console.WriteLine(a); &#125;&#125;Type t = typeof(MyClass);if (t.IsDefined(typeof(MyCustomAttribute), false))&#123; Console.WriteLine(&quot;判断一个类型是否使用了某个特性&quot;);&#125;// 获取Type元数据中的所有特性object[] objects = t.GetCustomAttributes(true);for (int i = 0; i &lt; objects.Length; i++) Console.WriteLine((objects[i] as MyCustomAttribute).Info); 为特性类加特性 限制其使用范围 12345[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]//参数一：AttributeTargets —— 特性能够用在哪些地方//参数二：AllowMultiple —— 是否允许多个特性实例用在同一个目标上//参数三：Inherited —— 特性是否能被派生类和重写成员继承public class MyCustom2Attribute : Attribute &#123; &#125; 系统自带特性——过时特性 Obsolete 用于提示用户 使用的方法等成员已经过时 建议使用新方法 123456//一般加在函数前的特性[Obsolete(&quot;这个是旧方法&quot;, false)]// 第一个参数是提示信息, 第二个参数 true直接报错, false警告public void OldFun() &#123; &#125; 系统自带特性——调用者信息特性 (快速查出哪里的错误) 12345678910111213141516171819202122232425//哪个文件调用？//CallerFilePath特性//哪一行调用？//CallerLineNumber特性//哪个函数调用？//CallerMemberName特性class TestClass&#123; [Obsolete(&quot;这个是旧方法&quot;, false)] // 第一个参数是提示信息, 第二个参数 true直接报错, false警告 public void OldFun() &#123; &#125; public void NewFun(string str, [CallerFilePath] string fileName = &quot;&quot;, [CallerLineNumber] int line = 0, [CallerMemberName] string memberName = &quot;&quot;) &#123; Console.WriteLine(&quot;这些使用的CallerXXX特性会在, 其它调用者调用时自动将调用者的额外信息填入参数中&quot;); Console.WriteLine(&quot;调用者的文件名 fileName = &quot; + fileName); Console.WriteLine(&quot;调用者的所在的行数 line = &quot; + line); Console.WriteLine(&quot;调用者的所处的调用函数名 memberName = &quot; + memberName); &#125;&#125; 系统自带特性——条件编译特性 Conditional 它会和[[预处理指令]] #define配合使用 123456[Conditional(&quot;Fun&quot;)] // 如果 #define 下面就会编译static void Fun()&#123; Console.WriteLine(&quot;如果有#define 我就会执行&quot;);&#125; 系统自带特性——外部Dll包函数特性 DllImport 用来标记非.Net(C#)的函数，表明该函数在一个外部的DLL中定义。 一般用来调用 C或者C++的Dll包写好的方法 需要引用[[命名空间]] using System.Runtime.InteropServices 123[DllImport(&quot;Test.dll&quot;)] // 下面这个函数一定在dll中有一模一样的public static extern int Add(int a, int b);//需要引用命名空间 using System.Runtime.CompilerServices;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"}]},{"title":"10.inspector 窗口可编辑变量","slug":"游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量","date":"2025-02-18T08:47:53.000Z","updated":"2025-02-20T09:31:36.451Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/10.inspector 窗口可编辑变量/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.inspector%20%E7%AA%97%E5%8F%A3%E5%8F%AF%E7%BC%96%E8%BE%91%E5%8F%98%E9%87%8F/","excerpt":"","text":"知识点一 私有和保护无法显示编辑 12private int i1;protected string str1; 知识点二 让私有的和保护的也可以被显示SerializeField 加上强制序列化字段特性 [SerializeField] 所谓序列化就是把一个对象保存到一个文件或数据库字段中去 1234[SerializeField]private int privateInt;[SerializeField]protected string protectedStr; 知识点三 公共的可以显示编辑 12public int publicInt = 10;public bool publicBool = false; 知识点四 公共的也不让其显示编辑HideInInspector 在变量前加上特性 [HideInInspector] 12[HideInInspector]public int publicInt2 = 50; 知识点五 大部分类型都能显示编辑 12345678910public int[] array;public List&lt;int&gt; list;public E_TestEnum type;public GameObject gameObj;//字典不能被Inspector窗口显示public Dictionary&lt;int, string&gt; dic;//自定义类型变量public MyStruct myStruct;public MyClass myClass; 知识点六 让自定义类型可以被访问 加上序列化特性[System.Serializable] 字典怎样都不行 12345678910111213[System.Serializable]public struct MyStruct&#123; public int age; public bool sex;&#125;[System.Serializable]public class MyClass&#123; public int age; public bool sex;&#125; 知识点七 一些辅助特性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//1.分组说明特性Header **************有用**************//为成员分组//Header特性//[Header(&quot;分组说明&quot;)][Header(&quot;基础属性&quot;)]public int age;public bool sex;[Header(&quot;战斗属性&quot;)]public int atk;public int def;//2.悬停注释Tooltip//为变量添加说明//[Tooltip(&quot;说明内容&quot;)][Tooltip(&quot;闪避&quot;)]public int miss;//3.间隔特性 Space()//让两个字段间出现间隔//[Space()][Space()]public int crit;//4.修饰数值的滑条范围Range **************有用**************//[Range(最小值, 最大值)][Range(0,10)]public float luck;//5.多行显示字符串 默认不写参数显示3行//写参数就是对应行//[Multiline(4)][Multiline(5)]public string tips;//6.滚动条显示字符串 //默认不写参数就是超过3行显示滚动条//[TextArea(3, 4)]//最少显示3行，最多4行，超过4行就显示滚动条[TextArea(3,4)]public string myLife;//7.为变量添加快捷方法 ContextMenuItem **************有用**************//参数1 显示按钮名//参数2 方法名 不能有参数//[ContextMenuItem(&quot;显示按钮名&quot;, &quot;方法名&quot;)][ContextMenuItem(&quot;重置钱&quot;, &quot;Test&quot;)]public int money;private void Test()&#123; money = 99;&#125;//8.为方法添加特性能够在Inspector中执行//[ContextMenu(&quot;测试函数&quot;)][ContextMenu(&quot;哈哈哈哈&quot;)]private void TestFun()&#123; print(&quot;测试方法&quot;);&#125; 注意 Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量 拖曳到GameObject对象后 再改变脚本中变量默认值 界面上不会改变 要么老老实实的在Inspector窗口改默认值 要么重新挂载脚本 运行中修改的信息不会保存","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"9.生命周期函数","slug":"游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数","date":"2025-02-18T07:39:12.000Z","updated":"2025-02-20T09:31:25.618Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/9.生命周期函数/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/","excerpt":"","text":"知识点一 了解帧的概念 Unity 底层已经帮助我们做好了死循环 我们需要学习Unity的生命周期函数 利用它做好的规则来执行我们的游戏逻辑就行了 知识点二 生命周期函数的概念 所有继承MonoBehavior的脚本 最终都会挂载到GameObject游戏对象上 生命周期函数 就是该脚本对象依附的GameObject对象从出生到消亡整个生命周期中 会通过反射自动调用的一些特殊函数 注意： 生命周期函数的访问修饰符一般为private和protected 因为不需要再外部自己调用生命周期函数 都是Unity自己帮助我们调用的 当对象（自己这个类脚本对象）被创建时 才会调用该生命周期函数 生命周期函数支持多态 如果GameObject一开始失活就不会调用生命周期函数 awake，onenable,start, fixedUpdate,update, laterupdate, ondisenable,ondestroy Awake： 类似构造函数的存在 我们可以在一个类对象 该创建 进行一些初始化操作 OnEnable： 对于我们来说 想要当一个对象被激活时 进行一些逻辑处理 就可以写在这个函数 Start： 主要作用还是用于初始化信息的 但是它相对Awake来说 要晚一点 如果我们在update中动态的创建对象，这个对象马上会执行Awake，但不会立即执行Start，要等到在下一帧的第一次 Update() 之前执行才会执行Start FixedUpdate： 它主要是用于 进行物理更新 它是每一帧的执行的 但是 这里的帧 和游戏帧 有点不同 它的时间间隔 是可以在 project setting中的 Time里去设置的 Update： 主要用于处理游戏核心逻辑更新的函数 LateUpdate： 一般这个更新是用来处理 摄像机位置更新相关内容的 Update和LateUpdate之间 Unity进了一些处理 处理我们动画相关的更新 OnDisable： 如果我们希望在一个对象失活时做一些处理 就可以在该函数中写逻辑 失活后不参与游戏循环了，激活后又可以循环 OnDestroy： 当对象销毁后调用 问题：不同对象的生命周期函数是在同一个线程中执行吗？","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"8.脚本基本规则","slug":"游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则","date":"2025-02-18T07:10:14.000Z","updated":"2025-02-20T09:31:22.671Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/8.脚本基本规则/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99/","excerpt":"","text":"MonoBehavior基类 创建的脚本默认都继承MonoBehaviour 继承了它才能够挂载在GameObject上 继承了MonoBehavior的脚本不能new 只能挂！！！！！！！！ 继承了MonnBehavior的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义 继承了MonoBehavior的脚本可以在一个对象上挂多个（如果没有加DisallowMultipleComponent特性） 继承MonoBehavior的类也可以再次被继承，遵循面向对象继承多态的规则 不继承MonoBehavior的类 不继承Mono的类 不能挂载在GameObject上 不继承Mono的类 想怎么写怎么写 如果要使用需要自己new 不继承Mono的类 一般是单例模式的类（用于管理模块） 或者数据结构类（用于存储数据） 不继承Mono的类 不用保留默认出现的几个函数 设置挂载脚本的执行顺序，默认时间前是系统必须执行的，可以设置自己添加的脚本的执行顺序，数字越小脚本越先执行 打开 当前unity版本下的Editor\\Data\\Resources\\ScriptTemplates目录可以更改默认的脚本模板","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"}]},{"title":"7.预制体和资源包的导入导出","slug":"游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出","date":"2025-02-18T07:01:18.000Z","updated":"2025-02-20T09:31:08.835Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/7.预制体和资源包的导入导出/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.%E9%A2%84%E5%88%B6%E4%BD%93%E5%92%8C%E8%B5%84%E6%BA%90%E5%8C%85%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"","text":"预设体是 Unity 中非常重要的概念，可以理解为一个游戏对象及其组件的集合。其目的是使游戏对象及其资源能够重复使用。当修改预设体时，实例也会同步修改。 创建预设体 将其拖到asset文件夹下 右键可以取消预设体 资源包导出直接右键，导入直接拖","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"6.反射机制和游戏场景","slug":"游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景","date":"2025-02-18T03:33:39.000Z","updated":"2025-02-20T09:31:03.404Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/6.反射机制和游戏场景/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B8%B8%E6%88%8F%E5%9C%BA%E6%99%AF/","excerpt":"","text":"Unity中的反射机制 Unity引擎本质是一个软件使用它时是处于运行中的我们是在一个运行中的软件里制作游戏的 Unity开发的本质就是 在Unity引擎的基础上利用反射和引擎提供的各种功能进行的拓展开发 回忆一下反射的概念 程序正在运行时，可以查看其它程序集或者自身的元数据（元数据就是程序当中的类，对象，函数，变量之类的东西） 一个运行的程序查看本身或者其它程序的元数据的行为就叫做反射 在程序运行时，通过反射可以得到其它程序集或者自己程序集中 代码的各种信息，比如类，函数，变量，对象等等 我们可以实例化它们，执行它们，操作它们 Unity 反射机制的完整工作流 假设你写了一个 PlayerController.cs 脚本 12345678public class PlayerController : MonoBehaviour &#123; [SerializeField] private float _moveSpeed = 5.0f; void Update() &#123; // 移动逻辑 &#125;&#125; 脚本编译阶段： Unity 会通过 Mono/C# 编译器 将你的脚本编译到 Assembly-CSharp.dll 中，同时生成 元数据表 编辑器反射阶段： Unity Editor 通过反射扫描所有 MonoBehaviour 子类 解析 [SerializeField] 等特性 生成 Inspector 面板的 UI 元素 运行时反射阶段： 当场景加载时，Unity 通过反射： 实例化 PlayerController 对象 将序列化数据（如 _moveSpeed）注入到对应字段 构建消息系统的方法表（用于 SendMessage()） 游戏场景","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"5.工具栏与对象的父子关系","slug":"游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系","date":"2025-02-18T03:27:14.000Z","updated":"2025-02-20T09:30:45.577Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/5.工具栏与对象的父子关系/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.%E5%B7%A5%E5%85%B7%E6%A0%8F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"4.Inspector和Console窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口","date":"2025-02-18T02:08:55.000Z","updated":"2025-02-20T09:30:37.997Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/4.Inspector和Console窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.Inspector%E5%92%8CConsole%E7%AA%97%E5%8F%A3/","excerpt":"","text":"选择对象进行标记 选择是否激活对象 修改对象名 设置对象为静态对象 标签 层级","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"3.Game和Project窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口","date":"2025-02-18T01:56:51.000Z","updated":"2025-02-20T09:30:31.196Z","comments":true,"path":"2025/02/18/游戏引擎/unity/unity入门/unity入门基础知识/3.Game和Project窗口/","permalink":"http://example.com/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.Game%E5%92%8CProject%E7%AA%97%E5%8F%A3/","excerpt":"","text":"","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"2.Scene和Hierarchy窗口","slug":"游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口","date":"2025-02-16T02:24:38.000Z","updated":"2025-02-20T09:30:19.732Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/2.Scene和Hierarchy窗口/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.Scene%E5%92%8CHierarchy%E7%AA%97%E5%8F%A3/","excerpt":"","text":"主要内容 窗口布局 左上角Layout选项 Scene和Hierarchy 场景窗口和层级窗口是息息相关的 层级窗口中看到的内容就是场景窗口中的显示对象","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]},{"title":"1.unity入门概述","slug":"游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述","date":"2025-02-16T01:27:03.000Z","updated":"2025-02-16T01:27:13.273Z","comments":true,"path":"2025/02/16/游戏引擎/unity/unity入门/unity入门基础知识/1.unity入门概述/","permalink":"http://example.com/2025/02/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.unity%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/","excerpt":"","text":"主要学习内容 学习建议 以前做游戏 vs 现在做游戏 如何学习游戏引擎","categories":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"使用obsidian来写hexo博客","slug":"hexo/使用obsidian来写hexo博客","date":"2025-02-09T12:59:52.000Z","updated":"2025-02-09T14:27:43.346Z","comments":true,"path":"2025/02/09/hexo/使用obsidian来写hexo博客/","permalink":"http://example.com/2025/02/09/hexo/%E4%BD%BF%E7%94%A8obsidian%E6%9D%A5%E5%86%99hexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Front-Matter obsidian安装Template插件，设置目录后在该目录下创建HexoPost.md文件 HexoPost.md内容如下 123456789101112131415161718---title: &lt;% tp.file.title %&gt;date: &lt;% tp.date.now(&quot;YYYY-MM-DD HH:mm:ss&quot;) %&gt;toc: truecategories:&lt;%*// 自动生成分类（兼容Windows路径）let folders = await tp.file.folder(true).split(/[\\\\/]/); folders = folders.slice(2); // 移除 &quot;_posts&quot; 父级目录for (let category of folders) &#123; tR += ` - $&#123;category&#125;`;&#125;if (folders.length === 0) &#123; tR += &quot; - 未分类&quot;;&#125;%&gt;tags:--- 这样就可以在新建md文件后点击obsidian侧边来自动填充categories 图片管理 站点配置文件_config.yml 1post_asset_folder: true # 启用文章资源文件夹 obsidian安装 Custom Attachment Location插件并进行如下设置 其它小优化 设置新建笔记位置 关闭wiki链接 文章内跳转使用md语法 [显示文本](#锚点) md标题自动生成锚点（全小写，空格换-）或者自定义锚点（&lt;a id=&quot;nihao&quot;&gt;&lt;/a&gt;） 忽略文件夹 参考 使用 Hexo 搭建博客 | OHLIA’s Wiki Hexo和Obsidian：让个人博客写作更加优雅、高效 - ＊tree_fly 's Blog 给博客上Live2d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"编程语言/Csharp","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"},{"name":"数据","slug":"数据","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据/数据持久化","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"数据/数据持久化/PlayerPrefs","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"数据/数据持久化/PlayerPrefs/PlayerPrefs基础知识","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"游戏引擎/unity","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"},{"name":"unity入门","slug":"游戏引擎/unity/unity入门","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"游戏引擎/unity/unity入门/unity入门基础知识","permalink":"http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Csharp","slug":"Csharp","permalink":"http://example.com/tags/Csharp/"},{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"数据持久化","slug":"数据持久化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"PlayerPrefs","slug":"PlayerPrefs","permalink":"http://example.com/tags/PlayerPrefs/"},{"name":"PlayerPrefs基础知识","slug":"PlayerPrefs基础知识","permalink":"http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"unity入门","slug":"unity入门","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8/"},{"name":"unity入门基础知识","slug":"unity入门基础知识","permalink":"http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"核心系统","slug":"核心系统","permalink":"http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"},{"name":"音效系统","slug":"音效系统","permalink":"http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"},{"name":"物理系统","slug":"物理系统","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"name":"光源系统","slug":"光源系统","permalink":"http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"},{"name":"Unity重要组件和API","slug":"Unity重要组件和API","permalink":"http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"},{"name":"Unity脚本基础","slug":"Unity脚本基础","permalink":"http://example.com/tags/Unity%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/"},{"name":"Unity工作原理","slug":"Unity工作原理","permalink":"http://example.com/tags/Unity%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"Unity界面基础","slug":"Unity界面基础","permalink":"http://example.com/tags/Unity%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"}]}