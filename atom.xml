<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>akiraの博客思密达</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-03T13:09:41.419Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>akira23369</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>csharp迭代器</title>
    <link href="http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2025-03-03T12:31:58.000Z</published>
    <updated>2025-03-03T13:09:41.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器是什么"><a class="markdownIt-Anchor" href="#迭代器是什么"></a> 迭代器是什么</h1><p>在 C# 中，<strong>迭代器（Iterator）</strong> 是一种用于遍历集合（如数组、列表等）元素的机制，它允许你按顺序访问集合中的每个元素而不必暴露集合的内部结构。迭代器的核心是通过 <code>IEnumerable</code> 和 <code>IEnumerator</code> 接口实现的，但 C# 提供了更简洁的语法（<code>yield</code> 关键字）来简化迭代器的创建。</p><p>在表现效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口。设计人员无需关心容器对象的内存分配的实现细节，可以用foreach遍历的类，都是实现了迭代器的。</p><h1 id="迭代器的基本概念"><a class="markdownIt-Anchor" href="#迭代器的基本概念"></a> <strong>迭代器的基本概念</strong></h1><ul><li><strong><code>IEnumerable</code> 接口</strong>：表示一个集合可以被迭代，包含一个 <code>GetEnumerator</code> 方法。</li><li><strong><code>IEnumerator</code> 接口</strong>：提供了遍历集合的能力，包含 <code>MoveNext()</code>、<code>Reset()</code> 和 <code>Current</code> 属性。</li></ul><p><strong>标准迭代器实现（手动版）</strong><br /><strong>接口定义</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>; <span class="comment">// 实际开发中通常不实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完整实现示例</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCollection</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span> =&gt; <span class="keyword">new</span> MyEnumerator(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义枚举器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">MyEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span>[] data;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyEnumerator</span>(<span class="params"><span class="built_in">int</span>[] data</span>)</span> =&gt; <span class="keyword">this</span>.data = data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> index &lt; data.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">object</span> Current =&gt; data[index];</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span> =&gt; index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="built_in">int</span> num <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">MyCollection</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num); <span class="comment">// 输出 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="foreach本质"><a class="markdownIt-Anchor" href="#foreach本质"></a> foreach本质</h1><p><strong>foreach本质</strong>:</p><ol><li>先获取in后面这个对象的 <code>IEnumerator</code> 会调用对象其中的<code>GetEnumerator</code>方法</li><li>执行得到这个<code>IEnumerator</code>对象中的 <code>MoveNext</code>方法</li><li>只要<code>MoveNext()</code>方法的返回值时true 就会去得到<code>Current</code>然后复制给 item</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> collection) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">IEnumerator enumerator = collection.GetEnumerator();</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (enumerator.MoveNext()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = enumerator.Current;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> </span><br><span class="line">&#123;</span><br><span class="line">    IDisposable disposable = enumerator <span class="keyword">as</span> IDisposable;</span><br><span class="line">    disposable?.Dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="yield-return-语法糖"><a class="markdownIt-Anchor" href="#yield-return-语法糖"></a> <code>yield return</code> 语法糖</h1><p>C# 的 <code>yield return</code> 关键字可以快速定义迭代器，无需手动实现 <code>IEnumerator</code></p><h2 id="基本作用简化迭代器"><a class="markdownIt-Anchor" href="#基本作用简化迭代器"></a> <strong>基本作用：简化迭代器</strong></h2><p><code>yield return</code> 的作用是告诉编译器：“帮我自动生成一个迭代器，按我写的顺序逐个返回这些值”。例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>GetNumbers()</code> 时，它不会一次性返回所有值，而是返回一个“待执行的迭代器”。只有当你用 <code>foreach</code> 遍历时，才会按顺序取出每个值。</p><h2 id="关键特性延迟执行lazy"><a class="markdownIt-Anchor" href="#关键特性延迟执行lazy"></a> <strong>关键特性：延迟执行（Lazy）</strong></h2><p><code>yield return</code> 的代码不会一次性全部执行，而是按需执行。看这个例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">GetMessages</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;开始迭代&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;第一步&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行到中间&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;第二步&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;结束迭代&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码：</span></span><br><span class="line"><span class="keyword">var</span> messages = GetMessages();  <span class="comment">// 这里不会输出任何内容！</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;准备遍历&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> messages)  <span class="comment">// 此时才开始真正执行</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li>调用 <code>GetMessages()</code> 时，代码不会运行，只是返回一个“迭代器对象”。</li><li>当 <code>foreach</code> 开始遍历时，代码才从头执行，每次遇到 <code>yield return</code> 时：<ul><li>返回一个值，</li><li><strong>暂停当前方法</strong>，记录当前位置（状态）。</li><li>下次循环时，从暂停的位置继续执行。</li></ul></li></ul><p><strong>底层原理：状态机</strong><br />编译器会将 <code>yield return</code> 代码转换为一个隐藏的“状态机”类。例如，上述 <code>GetMessages()</code> 会被编译成一个类似如下的类：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GeneratedStateMachine</span> : <span class="title">IEnumerator</span>&lt;<span class="title">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Current &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;开始迭代&quot;</span>);</span><br><span class="line">                Current = <span class="string">&quot;第一步&quot;</span>;</span><br><span class="line">                _state = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;执行到中间&quot;</span>);</span><br><span class="line">                Current = <span class="string">&quot;第二步&quot;</span>;</span><br><span class="line">                _state = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;结束迭代&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 结束</span></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他接口方法（略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield-break"><a class="markdownIt-Anchor" href="#yield-break"></a> yield break</h2><p><strong><code>yield break</code> 的基本作用</strong></p><ul><li><strong>功能</strong>：在迭代器方法中，<code>yield break</code> 会立即终止迭代，不再生成后续的值。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>; <span class="comment">// 这里终止，后续的 yield return 不会执行</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 永远不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> num <span class="keyword">in</span> <span class="title">GetNumbers</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1, 2</span></span><br></pre></td></tr></table></figure><h2 id="实际应用案例"><a class="markdownIt-Anchor" href="#实际应用案例"></a> <strong>实际应用案例</strong></h2><p><strong>分页加载数据</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">LoadBigData</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pageSize = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> page = <span class="number">0</span>; ; page++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = QueryDatabase(page, pageSize);</span><br><span class="line">        <span class="keyword">if</span> (data.Count == <span class="number">0</span>) <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>游戏技能连招系统</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">ComboAttack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">PlayAnimation</span>(<span class="params"><span class="string">&quot;Attack1&quot;</span></span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetButton(<span class="string">&quot;Attack&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">PlayAnimation</span>(<span class="params"><span class="string">&quot;Attack2&quot;</span></span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButton(<span class="string">&quot;Attack&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">PlayAnimation</span>(<span class="params"><span class="string">&quot;FinalBlow&quot;</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树形结构遍历</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable&lt;Node&gt; <span class="title">Traverse</span>(<span class="params">Node root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> root.Children)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> node <span class="keyword">in</span> <span class="title">Traverse</span>(<span class="params">child</span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迭代器是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#迭代器是什么&quot;&gt;&lt;/a&gt; 迭代器是什么&lt;/h1&gt;
&lt;p&gt;在 C# 中，&lt;strong&gt;迭代器（Iterator）&lt;/strong&gt; 是一种用于遍历集合（如数组、列表等）元素的机</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>csharp多线程</title>
    <link href="http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2025-03-03T12:20:16.000Z</published>
    <updated>2025-03-03T12:20:30.543Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wyt007/p/9486752.html">c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园</a></p><h1 id="线程基础"><a class="markdownIt-Anchor" href="#线程基础"></a> 线程基础</h1><h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2><p><code>Thread t = new Thread(PrintNumbers)</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(PrintNumbers);</span><br><span class="line">    t.Start();<span class="comment">//线程开始执行</span></span><br><span class="line">    PrintNumbers();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暂停线程"><a class="markdownIt-Anchor" href="#暂停线程"></a> 暂停线程</h2><p><code>Thread.Sleep</code><br />工作原理：<br />当线程处于休眠状态时，它会占用尽可能少的 CPU 时间。结果我们会发现通常后运行的 PrintNumbers 方法中的代码会比独立线程中的 PrintNumbersWithDelay暂停2S 方法中的代码先执行。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        PrintNumbers();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithDelay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));<span class="comment">//暂停2S</span></span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程等待"><a class="markdownIt-Anchor" href="#线程等待"></a> 线程等待</h2><p><code>t.Join()</code><br />工作原理：<br />但我们在主程序中调用了 t.Join 方法，该方法允许我们等待直到线程 t 完成。当线程 t 完成时，主程序会继续运行。<br />借助该技术可以实现在两个线程间同步执行步骤。第一个线程会等待另一个线程完成后再继续执行。第一个线程等待时是处于阻塞状态 (正如暂停线程中调用 Thread.Sleep 方法一样)。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting program...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        t.Join();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Thread completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithDelay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="终止线程"><a class="markdownIt-Anchor" href="#终止线程"></a> 终止线程</h2><p><code> t.Abort()</code> 弃用了<br />工作原理：<br />当主程序和单独的数字打印线程运行时，我们等待 6 秒后对线程调用了 t.Abort 方法。<br />这给线程注入了 ThreadAbortException 方法，导致线程被终结。这非常危险，因为该异常可以在任何时刻发生并可能彻底摧毁应用程序。<br />另外，使用该技术也不一定总能终止线程。目标线程可以通过处理该异常并调用 Thread.ResetAbort 方法来拒绝被终止。因此<strong>并不推荐使用 Abort 方法来关闭线程。</strong> 可优先使用一些其他方法，比如提供一个 CancellationToken 方法来取消线程的执行。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting program...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">6</span>));</span><br><span class="line">        t.Abort();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A thread has been aborted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithDelay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监测线程状态"><a class="markdownIt-Anchor" href="#监测线程状态"></a> 监测线程状态</h2><p><code>Thread 对象的 ThreadState</code>:</p><ul><li>Unstarted：线程已被创建，但尚未调用 <code>Start</code> 方法启动。</li><li>Running ：线程正在执行。当调用 <code>Start</code> 方法后，线程进入此状态并开始执行其关联的方法。</li><li>WaitSleepJoin：线程正在等待、休眠或被阻塞。当线程调用 <code>Sleep</code>、<code>Wait</code> 或 <code>Join</code> 方法时，会进入此状态。</li><li>Suspended（不推荐使用）：线程已被挂起。可以使用 <code>Suspend</code> 方法将线程挂起，但该方法已被弃用，因为它可能会导致死锁等问题。</li><li>Stopped：线程已完成执行或被终止，处于停止状态。</li><li>Aborted：线程已被调用 <code>Abort</code> 方法终止，但尚未完全停止执行。</li><li>。。。。。。。。。<br />工作原理：<br />当主程序启动时定义了两个不同的线程。一个将被终止，另一个则会成功完成运行。<br /><strong>线程状态位于 Thread 对象的 ThreadState 属性中。ThreadState 属性是一个 C# 枚举对象。</strong><br />刚开始线程状态为 ThreadState.Unstarted, 然后我们启动线程，并估计在一个周期为 30 次迭代的区间中，线程状态会从 ThreadState.Running 变为 ThreadState.WaitSleepJoin。<br />请注意始终可以通过 <code>Thread.CurrentThread</code> 静态属性获得当前 Thread 对象。<br />如果实际情况与以上不符，请增加迭代次数。终止第一个线程后，会看到现在该线程状态为 ThreadState.Aborted, 程序也有可能会打印出 ThreadState.AbortRequested 状态。这充分说明了同步两个线程的复杂性。请记住不要在程序中使用线程终止。我在这里使用它只是为了展示相应的线程状态。<br />最后可以看到第二个线程 t2 成功完成并且状态为 ThreadState.Stopped。另外还有一些其他的线程状态，但是要么已经被弃用，要么没有我们实验过的几种状态有用。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting program...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithStatus);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(DoNothing);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 t 的初始状态</span></span><br><span class="line">        Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        t2.Start();</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 29 次，输出线程 t 的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠 6 秒</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止线程 t</span></span><br><span class="line">        t.Abort();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A thread has been aborted&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 t 终止后的状态</span></span><br><span class="line">        Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        <span class="comment">// 线程 t2 的状态</span></span><br><span class="line">        Console.WriteLine(t2.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoNothing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithStatus</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出当前线程的状态</span></span><br><span class="line">        Console.WriteLine(Thread.CurrentThread.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 9 次，每次打印一个数字，每次循环间隔 2 秒</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h2><p><code>Thread.CurrentThread.Priority</code></p><p>工作原理：<br />当主程序启动时定义了两个不同的线程。<br />第一个线程优先级为 ThreadPriority.Highest, 即具有最高优先级。<br />第二个线程优先级为 ThreadPriority.Lowest, 即具有最低优先级。<br />我们先打印出主线程的优先级值，然后在所有可用的 CPU 核心上启动这两个线程。如果拥有一个 1 以上的计算核心，将在两秒钟内得到初步结果。最高优先级的线程通常会计算更多的迭代，但是两个值应该很接近。然而，如果有其他程序占用了所有的 CPU 核心运行负载，结果则会截然不同。<br />为了模拟该情形，我们设置了 <code>ProcessorAffinity</code> 选项，让操作系统将所有的线程运行在单个 CPU 核心 (第一个核心) 上。现在结果完全不同，并且计算耗时将超过 2 秒钟。这是因为 CPU 核心大部分时间在运行高优先级的线程，只留给剩下的线程很少的时间来运行。<br />请注意这是操作系统使用线程优先级的一个演示。通常你无需使用这种行为编写程序。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出当前线程的优先级</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Current thread priority: &#123;0&#125;&quot;</span>, Thread.CurrentThread.Priority);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Running on all cores available&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 RunThreads 方法启动线程, 程序将在所有可用核心上运行</span></span><br><span class="line">        RunThreads();</span><br><span class="line">        <span class="comment">// 主线程休眠 2 秒</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Running on a single core&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置当前进程仅使用一个核心</span></span><br><span class="line">        Process.GetCurrentProcess().ProcessorAffinity = <span class="keyword">new</span> IntPtr(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        RunThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动两个线程并设置不同优先级的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunThreads</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sample = <span class="keyword">new</span> ThreadSample();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> threadOne = <span class="keyword">new</span> Thread(sample.CountNumbers);</span><br><span class="line">        threadOne.Name = <span class="string">&quot;ThreadOne&quot;</span>;  <span class="comment">// 线程命名</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> threadTwo = <span class="keyword">new</span> Thread(sample.CountNumbers);</span><br><span class="line">        threadTwo.Name = <span class="string">&quot;ThreadTwo&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第一个线程的优先级为最高</span></span><br><span class="line">        threadOne.Priority = ThreadPriority.Highest;</span><br><span class="line">        <span class="comment">// 设置第二个线程的优先级为最低</span></span><br><span class="line">        threadTwo.Priority = ThreadPriority.Lowest;</span><br><span class="line"></span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadTwo.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠 2 秒</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 调用 Stop 方法停止线程计数</span></span><br><span class="line">        sample.Stop();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadSample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于控制线程计数循环的标志</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">bool</span> _isStopped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止线程计数的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _isStopped = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程执行的计数方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化计数器</span></span><br><span class="line">            <span class="built_in">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要未停止，就持续计数</span></span><br><span class="line">            <span class="keyword">while</span> (!_isStopped)</span><br><span class="line">            &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出线程名称、优先级和计数结果</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; with &#123;1,11&#125; priority &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;has a count = &#123;2,13&#125;&quot;</span>, Thread.CurrentThread.Name,</span><br><span class="line">                        Thread.CurrentThread.Priority,</span><br><span class="line">                        counter.ToString(<span class="string">&quot;N0&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前台线程和后台线程"><a class="markdownIt-Anchor" href="#前台线程和后台线程"></a> 前台线程和后台线程</h2><p><code>thread.IsBackground = true</code><br />工作原理：<br />当主程序启动时定义了两个不同的线程。默认情况下，显式创建的线程是前台线程。通过手动的设置 threadTwo 对象的 IsBackground 属性为 ture 来创建一个后台线程(可以在主线程设置其它线程执行完毕的条件)。通过配置来实现第一个线程会比第二个线程先完成。然后运行程序。<br />第一个线程完成后，程序结束并且后台线程被终结。这是前台线程与后台线程的主要区别：<strong>进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结束工作。</strong><br />一个重要注意事项是：如果程序定义了一个不会完成的前台线程，主程序并不会正常结束。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sampleForeground = <span class="keyword">new</span> ThreadSample(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">var</span> sampleBackground = <span class="keyword">new</span> ThreadSample(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> threadOne = <span class="keyword">new</span> Thread(sampleForeground.CountNumbers);</span><br><span class="line">        threadOne.Name = <span class="string">&quot;ForegroundThread&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> threadTwo = <span class="keyword">new</span> Thread(sampleBackground.CountNumbers);</span><br><span class="line">        threadTwo.Name = <span class="string">&quot;BackgroundThread&quot;</span>;</span><br><span class="line">        threadTwo.IsBackground = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadTwo.Start();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadSample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _iterations;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadSample</span>(<span class="params"><span class="built_in">int</span> iterations</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _iterations = iterations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(<span class="number">0.5</span>));</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; prints &#123;1&#125;&quot;</span>, Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向线程传递参数"><a class="markdownIt-Anchor" href="#向线程传递参数"></a> 向线程传递参数</h2><p><strong>通过实例字段间接传递参数</strong></p><p><strong>Thread.Start 方法传入object类型参数</strong><br />另一种传递数据的方式是使用 Thread.Start 方法。该方法会接收一个对象，并将该对象传递给线程。为了应用该方法，在线程中启动的方法必须接受 object 类型的单个参数。在创建 threadTwo 线程时演示了该方式。我们将 8 作为一个对象传递给了 Count 方法，然后 Count 方法被转换为整型。</p><p><strong>使用 Lambda 表达式捕获变量</strong><br />接下来的方式是使用 lambda 表达式。lambda 表达式定义了一个不属于任何类的方法。我们创建了一个方法，该方法使用需要的参数调用了另一个方法，并在另一个线程中运行该方法。当启动 threadThree 线程时，打印出了 12 个数字，这正是我们通过 lambda 表达式传递的数字。</p><p>使用 lambda 表达式引用另一个 C# 对象的方式被称为<a href="/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#%E9%97%AD%E5%8C%85%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7" title="csharp的Lambda表达式">csharp的Lambda表达式</a>。当在 lambda 表达式中使用任何局部变量时，C# 会生成一个类，并将该变量作为该类的一个属性。所以实际上该方式与 threadOne 线程中使用的一样，但是我们无须定义该类，C# 编译器会自动帮我们实现。<br />这可能会导致几个问题。例如，如果在多个 lambda 表达式中使用相同的变量，它们会共享该变量值。在前一个例子中演示了这种情况。当启动 threadFour 和 threadFive 线程时，它们都会打印 20, 因为在这两个线程启动之前变量被修改为 20。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定迭代次数为 10</span></span><br><span class="line">        <span class="keyword">var</span> sample = <span class="keyword">new</span> ThreadSample(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第一个线程，执行 sample 实例的 CountNumbers 方法</span></span><br><span class="line">        <span class="keyword">var</span> threadOne = <span class="keyword">new</span> Thread(sample.CountNumbers);</span><br><span class="line">        threadOne.Name = <span class="string">&quot;ThreadOne&quot;</span>;</span><br><span class="line">        threadOne.Start();</span><br><span class="line">        <span class="comment">// 主线程等待 threadOne 执行完毕</span></span><br><span class="line">        threadOne.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第二个线程，执行静态方法 Count</span></span><br><span class="line">        <span class="keyword">var</span> threadTwo = <span class="keyword">new</span> Thread(Count);</span><br><span class="line">        threadTwo.Name = <span class="string">&quot;ThreadTwo&quot;</span>;</span><br><span class="line">        <span class="comment">// 启动线程并传递参数 8</span></span><br><span class="line">        threadTwo.Start(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 主线程等待 threadTwo 执行完毕</span></span><br><span class="line">        threadTwo.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第三个线程，使用 Lambda 表达式调用静态方法 CountNumbers</span></span><br><span class="line">        <span class="keyword">var</span> threadThree = <span class="keyword">new</span> Thread(() =&gt; CountNumbers(<span class="number">12</span>));</span><br><span class="line">        threadThree.Name = <span class="string">&quot;ThreadThree&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        threadThree.Start();</span><br><span class="line">        <span class="comment">// 主线程等待 threadThree 执行完毕</span></span><br><span class="line">        threadThree.Join();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个整数变量 i 并初始化为 10</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 创建第四个线程，使用 Lambda 表达式调用静态方法 PrintNumber</span></span><br><span class="line">        <span class="keyword">var</span> threadFour = <span class="keyword">new</span> Thread(() =&gt; PrintNumber(i));</span><br><span class="line">        <span class="comment">// 修改变量 i 的值为 20</span></span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 创建第五个线程，使用 Lambda 表达式调用静态方法 PrintNumber</span></span><br><span class="line">        <span class="keyword">var</span> threadFive = <span class="keyword">new</span> Thread(() =&gt; PrintNumber(i));</span><br><span class="line">        threadFour.Start(); </span><br><span class="line">        threadFive.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params"><span class="built_in">object</span> iterations</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CountNumbers((<span class="built_in">int</span>)iterations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法，用于循环打印线程名称和迭代次数，每次循环间隔 0.5 秒</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>(<span class="params"><span class="built_in">int</span> iterations</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= iterations; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">0.5</span>));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; prints &#123;1&#125;&quot;</span>, Thread.CurrentThread.Name, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumber</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadSample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 迭代次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _iterations;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadSample</span>(<span class="params"><span class="built_in">int</span> iterations</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _iterations = iterations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环打印线程名称和迭代次数，每次循环间隔 0.5 秒</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= _iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(<span class="number">0.5</span>));</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; prints &#123;1&#125;&quot;</span>, Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-c-中的-lock-关键字"><a class="markdownIt-Anchor" href="#使用-c-中的-lock-关键字"></a> 使用 C# 中的 lock 关键字</h2><p><strong>lock 的作用</strong></p><ul><li><strong>线程同步</strong>：确保在多线程环境下，同一时间只有一个线程可以访问临界区（被锁保护的代码块）。</li><li><strong>解决竞态条件</strong>：防止多个线程同时修改共享资源导致数据不一致。</li></ul><p><strong>基本语法</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _lockObj = <span class="keyword">new</span> <span class="built_in">object</span>(); <span class="comment">// 锁对象必须是引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadSafeMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_lockObj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 临界区代码（同一时间仅一个线程可执行）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层原理</strong><br /><strong>基于 Monitor 类</strong>：<code>lock</code> 是语法糖，编译后等价于：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Enter(_lockObj, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        Monitor.Exit(_lockObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不安全的计数器（Counter 类）</strong> 与 <strong>安全的计数器（CounterWithLock 类）</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不正确的计数器</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Incorrect counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> t1 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c));</span><br><span class="line">        <span class="keyword">var</span> t2 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c));</span><br><span class="line">        <span class="keyword">var</span> t3 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c));</span><br><span class="line">        t1.Start();</span><br><span class="line">        t2.Start();</span><br><span class="line">        t3.Start();</span><br><span class="line">        t1.Join();</span><br><span class="line">        t2.Join();</span><br><span class="line">        t3.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Total count: &#123;0&#125;&quot;</span>,c.Count);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确的计数器</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Correct counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c1 = <span class="keyword">new</span> CounterWithLock();</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c1));</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c1));</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c1));</span><br><span class="line">        t1.Start();</span><br><span class="line">        t2.Start();</span><br><span class="line">        t3.Start();</span><br><span class="line">        t1.Join();</span><br><span class="line">        t2.Join();</span><br><span class="line">        t3.Join();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Total count: &#123;0&#125;&quot;</span>, c1.Count);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestCounter</span>(<span class="params">CounterBase c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.Increment();</span><br><span class="line">            c.Decrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没加锁的计数器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Counter</span> : <span class="title">CounterBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加了锁的计数器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">CounterWithLock</span> : <span class="title">CounterBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _syncRoot = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_syncRoot)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_syncRoot)</span><br><span class="line">            &#123;</span><br><span class="line">                Count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CounterBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lock相关注意：</strong><br /><strong>(1) 锁对象的选择</strong></p><ul><li><strong>锁对象必须是引用类型</strong>：值类型会被装箱，每次装箱生成新对象，导致锁失效。</li><li><strong>私有且只读</strong>：防止锁对象被修改。推荐模式：<code>private readonly object _lockObj = new object(); // 专用锁对象</code><br /><strong>(2) 临界区最小化</strong></li><li><strong>锁的粒度要细</strong>：仅保护真正需要同步的资源，减少锁持有时间</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：锁范围过大</span></span><br><span class="line"><span class="keyword">lock</span> (_lockObj)</span><br><span class="line">&#123;</span><br><span class="line">    ReadData();</span><br><span class="line">    ProcessData(); <span class="comment">// 长时间计算</span></span><br><span class="line">    WriteData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：仅锁共享数据操作</span></span><br><span class="line"><span class="keyword">var</span> data = ReadData();</span><br><span class="line"><span class="keyword">var</span> result = ProcessData(data); <span class="comment">// 无锁计算</span></span><br><span class="line"><span class="keyword">lock</span> (_lockObj)</span><br><span class="line">&#123;</span><br><span class="line">    WriteData(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(3) 避免嵌套锁</strong></p><ul><li><strong>死锁风险</strong>：若多个锁以不同顺序嵌套获取，可能引发死锁。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">lock</span> (A)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (B) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">lock</span> (B) <span class="comment">// 若线程1已持A等B，线程2持B等A → 死锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (A) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用monitor类锁定资源"><a class="markdownIt-Anchor" href="#使用monitor类锁定资源"></a> 使用Monitor类锁定资源*</h2><p><strong>代码行为分析</strong></p><p><strong>第一部分（使用 TryEnter 避免死锁）</strong></p><ol><li><strong>线程1</strong>执行 <code>LockTooMuch</code>：获取 <code>lock1</code> → 休眠 1 秒 → 尝试获取 <code>lock2</code>。</li><li><strong>主线程</strong>：获取 <code>lock2</code> → 休眠 1 秒 → 尝试通过 <code>TryEnter</code> 获取 <code>lock1</code>（超时 5 秒）。</li></ol><p><strong>可能的执行结果</strong>：</p><ul><li><strong>线程1</strong>持有 <code>lock1</code>，等待 <code>lock2</code>；<strong>主线程</strong>持有 <code>lock2</code>，等待 <code>lock1</code> → <strong>死锁条件成立</strong>。</li><li>但由于主线程使用 <code>TryEnter</code>，5 秒后会超时并释放 <code>lock2</code>，随后线程1最终能获取 <code>lock2</code>，继续执行。</li><li>输出：<code>Timeout acquiring a resource!</code>。</li></ul><p><strong>第二部分（直接死锁）</strong></p><ol><li><strong>线程2</strong>再次执行 <code>LockTooMuch</code>（同上）。</li><li><strong>主线程</strong>再次尝试以 <code>lock2 → lock1</code> 顺序获取锁。<br /><strong>结果</strong>：主线程持有 <code>lock2</code>，等待 <code>lock1</code>；线程2持有 <code>lock1</code>，等待 <code>lock2</code> → <strong>死锁</strong>，程序永久阻塞。</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建两个锁对象</span></span><br><span class="line">        <span class="built_in">object</span> lock1 = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">        <span class="built_in">object</span> lock2 = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动第一个线程：尝试以 lock1 → lock2 顺序获取锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程尝试以 lock2 → lock1 顺序获取锁</span></span><br><span class="line">        <span class="keyword">lock</span> (lock2) <span class="comment">// 主线程获取 lock2</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 等待 1 秒（让第一个线程先获取 lock1）</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Monitor.TryEnter 允许不阻塞，在超时后返回 false&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试在 5 秒内获取 lock1（非阻塞式）</span></span><br><span class="line">            <span class="keyword">if</span> (Monitor.TryEnter(lock1, TimeSpan.FromSeconds(<span class="number">5</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;成功获取受保护资源！&quot;</span>);</span><br><span class="line">                Monitor.Exit(lock1); <span class="comment">// 释放锁（实际代码中应使用 finally 确保释放）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;获取资源超时！&quot;</span>); </span><br><span class="line">                <span class="comment">// 此处未获取到 lock1，但 lock2 会在当前代码块结束后自动释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次启动线程：再次尝试 lock1 → lock2 顺序</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程再次尝试以 lock2 → lock1 顺序获取锁（此次无超时机制）</span></span><br><span class="line">        <span class="keyword">lock</span> (lock2) <span class="comment">// 获取 lock2</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这将引发死锁！&quot;</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试获取 lock1（此时第一个线程可能持有 lock1 并等待 lock2）</span></span><br><span class="line">            <span class="keyword">lock</span> (lock1) <span class="comment">// 阻塞在此处，无法继续执行</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;成功获取受保护资源！&quot;</span>); <span class="comment">// 永远不会执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockTooMuch</span>(<span class="params"><span class="built_in">object</span> lock1, <span class="built_in">object</span> lock2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (lock1) <span class="comment">// 先获取 lock1</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 等待 1 秒（让主线程有机会获取 lock2）</span></span><br><span class="line">            <span class="keyword">lock</span> (lock2) <span class="comment">// 再尝试获取 lock2（可能导致死锁）</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 临界区代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程异常处理"><a class="markdownIt-Anchor" href="#多线程异常处理"></a> <strong>多线程异常处理</strong></h2><p><strong>异常作用域规则</strong></p><ul><li><strong>线程是独立执行路径</strong>：每个线程拥有自己的异常处理上下文。</li><li><strong>主线程无法直接捕获子线程的异常</strong>：<code>try-catch</code> 在父线程中无法捕获子线程未处理的异常。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一个线程：内部捕获异常</span></span><br><span class="line">        <span class="keyword">var</span> t = <span class="keyword">new</span> Thread(FaultyThread);</span><br><span class="line">        t.Start();    <span class="comment">// 启动线程</span></span><br><span class="line">        t.Join();     <span class="comment">// 等待线程结束（此时异常已被内部处理，不会传播到主线程）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程：未处理异常</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(BadFaultyThread);</span><br><span class="line">            t.Start(); <span class="comment">// 启动线程（但未调用 Join）</span></span><br><span class="line">            <span class="comment">// 主线程不会等待此线程结束，try-catch 无法捕获子线程异常！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此处永远不会执行，因为子线程的异常不会传递到主线程</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;We won&#x27;t get here!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：内部捕获异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FaultyThread</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Starting a faulty thread...&quot;</span>);</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Boom!&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 异常在此处被捕获并处理</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Exception handled: &#123;0&#125;&quot;</span>, ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：未处理异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BadFaultyThread</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting a faulty thread...&quot;</span>);</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Boom!&quot;</span>); <span class="comment">// 抛出未捕获的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确捕获子线程异常的方法</strong><br /><strong>(1) 在线程方法内部处理异常</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SafeThreadMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">/* 代码 */</span> &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123; <span class="comment">/* 记录或处理异常 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 使用 <code>Task</code> 替代 <code>Thread</code></strong></p><ul><li><strong>优势</strong>：通过 <code>Task.Exception</code> 属性聚合所有异常（<code>AggregateException</code>）。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能抛异常的代码</span></span><br><span class="line">&#125;).ContinueWith(t =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.Exception != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;捕获异常: &quot;</span> + t.Exception.InnerException.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, TaskContinuationOptions.OnlyOnFaulted);</span><br></pre></td></tr></table></figure><p><strong>(3) 全局异常捕获（不推荐）</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppDomain.CurrentDomain.UnhandledException += (sender, e) =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;全局捕获: &quot;</span> + e.ExceptionObject.ToString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wyt007/p/9486752.html&quot;&gt;c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;线程基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>10.协同程序</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-03-02T11:15:55.000Z</published>
    <updated>2025-03-03T14:46:22.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单回顾csharp中的多线程"><a class="markdownIt-Anchor" href="#简单回顾csharp中的多线程"></a> 简单回顾csharp中的多线程</h1><a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="csharp多线程">csharp多线程</a><h1 id="unity是否支持多线程"><a class="markdownIt-Anchor" href="#unity是否支持多线程"></a> Unity是否支持多线程？</h1><ol><li>Unity是支持多线程的，只是新开线程无法访问Unity相关场景上对象的内容。例如this.transform（必须在主线程调用）。</li><li>注意：<strong>Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑</strong></li><li>在Unity中，不会开启多线程访问Unity相关。<strong>当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。</strong> 当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新线程</span></span><br><span class="line">Thread newThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西</span></span><br><span class="line">Queue&lt;Vector3&gt; queue = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//副线程可能也要拿主线程的数据用来判断做逻辑</span></span><br><span class="line">Queue&lt;Vector3&gt; queue2 = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//首先要明确一点</span></span><br><span class="line">    <span class="comment">//Unity是支持多线程的</span></span><br><span class="line">    <span class="comment">//只是新开线程无法访问Unity相关对象的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用System.Threading命名空间</span></span><br><span class="line">    newThread = <span class="keyword">new</span> Thread(newThreadLogic);</span><br><span class="line">    newThread.Start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//Unity中的多线程 要记住关闭</span></span><br><span class="line">    <span class="comment">//不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容</span></span><br><span class="line">    <span class="comment">//可以在OnDestroy执行关闭线程逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用</span></span><br><span class="line">    <span class="keyword">if</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = queue.Dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新线程逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        print(<span class="string">&quot;新线程逻辑 每隔一秒的打印&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们在Unity中，不会开启多线程访问Unity相关</span></span><br><span class="line">        <span class="comment">//当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿</span></span><br><span class="line">        <span class="comment">//这时就可以开启多线程用于A星寻路算法，网络收发相关</span></span><br><span class="line">        <span class="comment">//当算好了结果或者收到了消息过后，放在公共的内存区域</span></span><br><span class="line">        <span class="comment">//主线程判断判断公共的内存区域有没有想要的对象，拿来使用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这句代码会报错 不能在副线程控制Unity相关</span></span><br><span class="line">        <span class="comment">//UnityException: get_transform can only be called from the main thread.</span></span><br><span class="line">        <span class="comment">//this.transform.Translate(Vector3.forward * Time.deltaTime);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中</span></span><br><span class="line">        <span class="comment">//用Unity的随机数都不能用 用C#里的随机数</span></span><br><span class="line">        System.Random r = <span class="keyword">new</span> System.Random();</span><br><span class="line">        queue.Enqueue(<span class="keyword">new</span> Vector3(r.Next(<span class="number">-10</span>, <span class="number">10</span>), r.Next(<span class="number">-10</span>, <span class="number">10</span>), r.Next(<span class="number">-10</span>, <span class="number">10</span>)));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关闭线程</span></span><br><span class="line">    newThread.Abort();</span><br><span class="line">    <span class="comment">//关闭线程后置空</span></span><br><span class="line">    newThread = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="什么是协程"><a class="markdownIt-Anchor" href="#什么是协程"></a> <strong>什么是协程？</strong></h1><p>协程（Coroutine）是Unity中一种特殊的函数，可以<strong>分步执行代码</strong>并<strong>跨越多帧运行</strong>。它通过<code>yield</code>关键字暂停执行，并在特定条件（如等待时间结束、帧结束等）满足后继续执行。</p><ul><li><p>它是“假”的多线程，它不是多线程</p></li><li><p><strong>它的本质是<a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="csharp迭代器">迭代器</a></strong></p></li><li><p>C#的<a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="csharp迭代器">迭代器</a>**函数”分步执行”的特点</p></li><li><p>加上 Unity自己定义的一些协程调度逻辑</p></li><li><p>实现的一套分时执行函数的规则</p></li></ul><h1 id="协程的主要作用"><a class="markdownIt-Anchor" href="#协程的主要作用"></a> <strong>协程的主要作用</strong></h1><p>将代码分时执行，不卡主线程<br />简单理解，是把可能会让主线程卡顿的耗时的逻辑<strong>分时分步</strong>执行</p><ul><li><strong>处理延时操作</strong>：例如等待1秒后执行代码。</li><li><strong>分步执行任务</strong>：将复杂任务拆分成多个步骤，避免卡顿。</li><li><strong>按帧控制逻辑</strong>：逐帧处理动画、AI行为等。</li><li><strong>异步加载资源</strong>：分批加载资源防止主线程阻塞。</li><li><strong>异步下载文件</strong></li><li><strong>场景异步加载</strong></li><li><strong>批量创建时防止卡顿</strong></li></ul><h1 id="主要使用场景"><a class="markdownIt-Anchor" href="#主要使用场景"></a> <strong>主要使用场景</strong></h1><ul><li>角色技能冷却倒计时。</li><li>分批次加载大型场景或资源。</li><li>实现平滑的动画过渡（如物体渐隐）。</li><li>等待网络请求返回后更新UI。</li></ul><h1 id="协同程序和线程的区别"><a class="markdownIt-Anchor" href="#协同程序和线程的区别"></a> 协同程序和线程的区别</h1><ul><li>新开一个线程是独立的一个管道，与主线程并行执行。</li><li>新开一个协程是在原线程之上开启，进行<strong>逻辑分时分步执行</strong>。</li></ul><h1 id="-swig12-"><a class="markdownIt-Anchor" href="#-swig12-"></a> <a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/#yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96" title="csharp迭代器">回顾yield return相关知识点</a></h1><h1 id="协程的使用方法"><a class="markdownIt-Anchor" href="#协程的使用方法"></a> <strong>协程的使用方法</strong></h1><p><strong>基本规则</strong>：</p><ol><li>协程方法的返回类型必须是 <code>IEnumerator</code>。</li><li>使用 <code>yield return</code> 指定暂停条件（如 <code>new WaitForSeconds(2)</code>）。</li><li>通过 <code>StartCoroutine()</code> 启动协程。</li></ol><h2 id="启动协程"><a class="markdownIt-Anchor" href="#启动协程"></a> <strong>启动协程</strong>：</h2><p><strong>基本语法：</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoroutineExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动协程</span></span><br><span class="line">        StartCoroutine(SimpleCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="built_in">string</span> hello</span>)</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;协程开始，say hello\n<span class="subst">&#123;hello&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 暂停1秒</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;1秒后执行&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2</span></span>)</span>; <span class="comment">// 再暂停2秒</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;又过了2秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 提供了多种内置的等待指令，可以直接在协程中使用：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>说明</strong></th><th>指令满足之后在哪里执行</th></tr></thead><tbody><tr><td><code>null 或者 数字</code></td><td>等待到下一帧（等同 <code>yield return null</code>）</td><td><code>Update</code>和<code>LateUpdate</code>之间执行</td></tr><tr><td><code>WaitForSeconds</code></td><td>等待指定秒数（受<code>Time.timeScale</code>时间缩放影响）</td><td><code>Update</code>和<code>LateUpdate</code>之间执行</td></tr><tr><td><code>WaitForSecondsRealtime</code></td><td>等待指定秒数（不受<code>Time.timeScale</code>时间缩放影响）</td><td><code>Update</code>之后</td></tr><tr><td><code>WaitForFixedUpdate</code></td><td>等待到下一个 FixedUpdate</td><td>在<code>FixedUpdate</code>和碰撞检测相关函数之后执行</td></tr><tr><td><code>WaitForEndOfFrame</code></td><td>等待到帧结束（截图功能）</td><td>等待摄像机和GUI渲染完成后执行，在LateUpdate之后的渲染相关处理完毕后之后</td></tr><tr><td><code>WWW</code> 或 <code>UnityWebRequest</code></td><td>等待网络请求完成</td><td><code>Update</code>之后</td></tr></tbody></table><h2 id="停止协程"><a class="markdownIt-Anchor" href="#停止协程"></a> 停止协程</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止单个协程</span></span><br><span class="line">Coroutine coroutine = StartCoroutine(MyCoroutine());</span><br><span class="line">StopCoroutine(coroutine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止所有协程</span></span><br><span class="line">StopAllCoroutines();</span><br></pre></td></tr></table></figure><h1 id="协程的典型使用场景"><a class="markdownIt-Anchor" href="#协程的典型使用场景"></a> <strong>协程的典型使用场景</strong></h1><h2 id="场景-1延迟执行"><a class="markdownIt-Anchor" href="#场景-1延迟执行"></a> <strong>场景 1：延迟执行</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DelayedAction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;3秒后执行爆炸效果&quot;</span>);</span><br><span class="line">    <span class="comment">// 触发爆炸动画、音效等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景-2分帧处理大数据"><a class="markdownIt-Anchor" href="#场景-2分帧处理大数据"></a> <strong>场景 2：分帧处理大数据</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">ProcessLargeData</span>(<span class="params">List&lt;Item&gt; data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> data)</span><br><span class="line">    &#123;</span><br><span class="line">        ProcessItem(item); <span class="comment">// 处理单个数据</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧处理一个，避免卡顿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景-3按顺序执行多段逻辑"><a class="markdownIt-Anchor" href="#场景-3按顺序执行多段逻辑"></a> <strong>场景 3：按顺序执行多段逻辑</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DialogueSequence</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ShowText(<span class="string">&quot;你好，旅行者！&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params">(</span>)</span> =&gt; Input.GetKeyDown(KeyCode.Space)); <span class="comment">// 等待玩家按空格</span></span><br><span class="line">    ShowText(<span class="string">&quot;前方有危险...&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2</span></span>)</span>;</span><br><span class="line">    ShowText(<span class="string">&quot;准备好了吗？&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程受对象和组件失活销毁的影响"><a class="markdownIt-Anchor" href="#协程受对象和组件失活销毁的影响"></a> 协程受对象和组件失活销毁的影响</h1><ul><li>协程开启后：<ul><li>组件或物体销毁，物体失活，则协程不再执行。</li><li>组件失活时，协程仍然执行。</li></ul></li></ul><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="协程实现的计秒器"><a class="markdownIt-Anchor" href="#协程实现的计秒器"></a> <strong>协程实现的计秒器</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Timer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Text timerText; <span class="comment">// 关联UI文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> elapsedTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isRunning;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(CountSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">CountSeconds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isRunning = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isRunning)</span><br><span class="line">        &#123;</span><br><span class="line">            elapsedTime += Time.deltaTime;</span><br><span class="line">            <span class="comment">// 显示格式化为整数秒（或保留1位小数）</span></span><br><span class="line">            timerText.text = <span class="string">&quot;Time: &quot;</span> + elapsedTime.ToString(<span class="string">&quot;F1&quot;</span>); </span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止计时（可选）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopTimer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分帧创建10万立方体无卡顿"><a class="markdownIt-Anchor" href="#分帧创建10万立方体无卡顿"></a> <strong>分帧创建10万立方体（无卡顿）</strong></h2><p>原本 1帧 创建 10万个<br />现在 1帧 创建 cubesPerFrame 个</p><p>比较蠢的做法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">    obj.transform.position = <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-100</span>, <span class="number">100</span>), Random.Range(<span class="number">-100</span>, <span class="number">100</span>), Random.Range(<span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeSpawner</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject cubePrefab; <span class="comment">// 立方体预制体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> totalCubes = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> cubesPerFrame = <span class="number">500</span>; <span class="comment">// 每帧生成的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(SpawnCubes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">SpawnCubes</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> created = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (created &lt; totalCubes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cubesPerFrame; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (created &gt;= totalCubes) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 随机生成位置（范围可调）</span></span><br><span class="line">                Vector3 pos = <span class="keyword">new</span> Vector3(</span><br><span class="line">                    Random.Range(<span class="number">-50f</span>, <span class="number">50f</span>),</span><br><span class="line">                    Random.Range(<span class="number">-50f</span>, <span class="number">50f</span>),</span><br><span class="line">                    Random.Range(<span class="number">-50f</span>, <span class="number">50f</span>)</span><br><span class="line">                );</span><br><span class="line">                Instantiate(cubePrefab, pos, Quaternion.identity);</span><br><span class="line">                created++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧分批生成</span></span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;生成完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单回顾csharp中的多线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简单回顾csharp中的多线程&quot;&gt;&lt;/a&gt; 简单回顾csharp中的多线程&lt;/h1&gt;
&lt;a href=&quot;/2025/03/03/%E7%BC%96%E7%A8</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>9.延迟函数</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/9.%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/9.%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0/</id>
    <published>2025-03-02T09:08:38.000Z</published>
    <updated>2025-03-02T09:32:59.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是延迟函数"><a class="markdownIt-Anchor" href="#什么是延迟函数"></a> 什么是延迟函数</h1><p>延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。<br />它是<code>MonoBehaviour</code>基类中实现好的方法。</p><h1 id="延迟函数的使用"><a class="markdownIt-Anchor" href="#延迟函数的使用"></a> 延迟函数的使用</h1><h2 id="invoke方法-开启延迟函数"><a class="markdownIt-Anchor" href="#invoke方法-开启延迟函数"></a> Invoke方法 开启延迟函数</h2><p>注意:</p><ul><li>没法调用有参数的函数</li><li>必须是该脚本上申明的函数</li><li>可以用<code>DelayedFunction</code>间接调用到其它对象, 或者有参数的函数</li><li><strong>只有挂载的脚本对象失活可以继续执行, 其它情况都会无法继续执行</strong></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在time秒后调用methodName方法。 </span></span><br><span class="line"><span class="comment">// 参数一：函数名字符串 </span></span><br><span class="line"><span class="comment">// 参数二：延迟时间，秒为单位 </span></span><br><span class="line">Invoke(<span class="string">&quot;DelayDoSomething&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="invokerepeating方法-开启延迟重复执行函数"><a class="markdownIt-Anchor" href="#invokerepeating方法-开启延迟重复执行函数"></a> InvokeRepeating方法 开启延迟重复执行函数</h2><p>与<code>Invoke</code>类似，但可以设置重复调用的间隔时间。<br />参数2：第一次延迟的时间<br />参数3：以后每次延迟的时间</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InvokeRepeating(<span class="string">&quot;RepeatedFunction&quot;</span>, <span class="number">2.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 延时2秒后每隔1秒调用一次RepeatedFunction方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RepeatedFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在这里写重复延时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cancelinvoke-取消延时调用"><a class="markdownIt-Anchor" href="#cancelinvoke-取消延时调用"></a> CancelInvoke 取消延时调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CancelInvoke(<span class="string">&quot;Fun&quot;</span>);        <span class="comment">// 只取消Fun，所有延迟执行Fun的都会没</span></span><br><span class="line">CancelInvoke();             <span class="comment">// 无参数取消所有延时函数</span></span><br></pre></td></tr></table></figure><h2 id="isinvoking方法-判断是否有延迟函数"><a class="markdownIt-Anchor" href="#isinvoking方法-判断是否有延迟函数"></a> IsInvoking方法 判断是否有延迟函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否有任何待处理的methodName调用？</span></span><br><span class="line"><span class="comment">// 不传入参数，判断该脚本上是否存在任何延迟函数</span></span><br><span class="line"><span class="keyword">if</span> (IsInvoking())</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;存在延迟函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入参数，判断该脚本上是否存在指定延迟函数</span></span><br><span class="line"><span class="keyword">if</span> (IsInvoking(<span class="string">&quot;DelayDoSomething&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;存在延迟函数DelayDoSomething&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="延迟函数受对象失活销毁影响"><a class="markdownIt-Anchor" href="#延迟函数受对象失活销毁影响"></a> 延迟函数受对象失活销毁影响</h1><p>延迟函数在依附对象或者脚本失活时不受影响，但在对象销毁或者移除脚本时无法继续执行。<br />如果想在失活 或者 激活 的时候来执行延迟函数， 可以在<a href="/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/" title="9.生命周期函数">生命周期函数</a><code>OnEnable</code>和<code>OnDisable</code>中做逻辑</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对象激活的生命周期函数中，开启延迟（重复执行的延迟）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对象失活的生命周期函数中，停止延迟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="利用延时函数实现一个计秒器"><a class="markdownIt-Anchor" href="#利用延时函数实现一个计秒器"></a> 利用延时函数实现一个计秒器</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用延迟重复函数，一进来直接调用，然后每隔一秒调用，实现计时器</span></span><br><span class="line">InvokeRepeating(<span class="string">&quot;DelayTimer&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接执行函数 函数里面在写一个普通延迟函数每秒调用自己</span></span><br><span class="line">DelayTimer2();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayTimer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    ++time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayTimer2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    ++time;</span><br><span class="line">    Invoke(<span class="string">&quot;DelayTimer2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="请用两种方式延时销毁一个指定对象"><a class="markdownIt-Anchor" href="#请用两种方式延时销毁一个指定对象"></a> 请用两种方式延时销毁一个指定对象</h2><p>一个只能销毁，一个销毁还可以写逻辑</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Destroy来进行延迟销毁</span></span><br><span class="line">Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟函数销毁，内部使用销毁逻辑，</span></span><br><span class="line"><span class="comment">// 包裹一层，相比于Destroy直接销毁，假如想有其他逻辑也可以写在延迟销毁函数中</span></span><br><span class="line">Invoke(<span class="string">&quot;DelayDestroy&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是延迟函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是延迟函数&quot;&gt;&lt;/a&gt; 什么是延迟函数&lt;/h1&gt;
&lt;p&gt;延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。&lt;br /&gt;
它是&lt;co</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>8.Quaternion四元数计算</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/</id>
    <published>2025-03-02T07:55:47.000Z</published>
    <updated>2025-03-02T09:02:57.869Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302160521675.png" alt="" /></p><h1 id="四元数相乘"><a class="markdownIt-Anchor" href="#四元数相乘"></a> 四元数相乘</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302155620368.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过轴角对API传入要转的轴和角度</span></span><br><span class="line"><span class="comment">//绕着y轴转20度</span></span><br><span class="line">Quaternion q = Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up);</span><br><span class="line"><span class="comment">//乘上这个脚本挂载的立方体当前旋转四元数 让这个脚本挂载的立方体绕着y轴转20度</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= q;</span><br><span class="line"><span class="comment">//注意1：用四元数旋转完可能和Inspector窗口上的旋转对不上 不用管它</span></span><br><span class="line"><span class="comment">//注意2：旋转相对的坐标系 是物体自身坐标系 </span></span><br></pre></td></tr></table></figure><h1 id="四元数乘以向量"><a class="markdownIt-Anchor" href="#四元数乘以向量"></a> 四元数乘以向量</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302160009145.png" alt="" /><br />注意一定是 <code>向量 = 四元数 * 向量</code> 不是 <s><code>向量 = 向量 * 四元数</code></s></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个向量</span></span><br><span class="line">    Vector3 vector = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个四元数表示45度绕Y轴的旋转</span></span><br><span class="line">    Quaternion rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用四元数旋转向量</span></span><br><span class="line">    Vector3 rotatedVector = rotation * vector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;Original Vector: &quot;</span> + vector);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Rotated Vector: &quot;</span> + rotatedVector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="模拟飞机发射不同类型子弹的方法单发双发扇形环形"><a class="markdownIt-Anchor" href="#模拟飞机发射不同类型子弹的方法单发双发扇形环形"></a> 模拟飞机发射不同类型子弹的方法：单发，双发，扇形，环形</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明发射类型枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> E_FireType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//单发</span></span><br><span class="line">    One,</span><br><span class="line">    <span class="comment">//双发</span></span><br><span class="line">    Two,</span><br><span class="line">    <span class="comment">//扇形</span></span><br><span class="line">    Three,</span><br><span class="line">    <span class="comment">//环形</span></span><br><span class="line">    Round</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明发射类型变量 </span></span><br><span class="line">    <span class="keyword">private</span> E_FireType nowType = E_FireType.One;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹</span></span><br><span class="line">    <span class="keyword">public</span> GameObject bullet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> roundNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Update内添加按按键切换发射类型逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.One;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Two;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Three;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha4))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Round;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Update内添加按按键发射子弹逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            Fire();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开火方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (nowType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.One:</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Two:</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Three:</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="comment">//左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">-20</span>, Vector3.up));</span><br><span class="line">                <span class="comment">//右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Round:</span><br><span class="line">                <span class="built_in">float</span> angle = <span class="number">360</span> / roundNum;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; roundNum; i++)</span><br><span class="line">                    <span class="comment">//角度是当前偏移度数乘飞机自己的旋转</span></span><br><span class="line">                    Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将此脚本制作成预制体，并拖到飞机的bullet</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子弹一直往前飞，五秒后销毁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="摄像机跟随"><a class="markdownIt-Anchor" href="#摄像机跟随"></a> 摄像机跟随</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302165252272.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302170255830.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个脚本要挂载到摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对头顶的偏移位置 看向头顶多高的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> headOffsetH = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机倾斜的角度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> offsetAngle = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机离观测点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> cameraDis = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机离观测点的距离必须是3和10之间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minDis = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxDis = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标中间滚动控制的移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> roundSpeed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看向对象时 四元数 旋转的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lookAtSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟随对象移动的 速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前摄像机应该在的位置</span></span><br><span class="line">    Vector3 nowPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头顶一个在的位置</span></span><br><span class="line">    Vector3 headPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头顶位置指向摄像机的方向向量</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 nowDir;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实现了鼠标中键 滚动 来改变摄像机远近</span></span><br><span class="line">        cameraDis += Input.GetAxis(<span class="string">&quot;Mouse ScrollWheel&quot;</span>) * roundSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取最大值和最小值之间的数</span></span><br><span class="line">        cameraDis = Mathf.Clamp(cameraDis, minDis, maxDis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向头顶偏移位置</span></span><br><span class="line">        headPos = target.position + target.up * headOffsetH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用要倾斜的角度和轴算出要旋转的四元数 乘上当前向后的向量 就能得到摄像机偏移角度后往后方偏移位置</span></span><br><span class="line">        <span class="comment">//通俗理解 nowDir就是头顶位置指向摄像机的方向向量</span></span><br><span class="line">        nowDir = Quaternion.AngleAxis(offsetAngle, target.right) * -target.forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用头顶位置加上要偏移的角度乘摄像机离观测点的距离 就是当前摄像机应该在的位置</span></span><br><span class="line">        nowPos = headPos + nowDir * cameraDis;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接把算出来的位置 进行赋值</span></span><br><span class="line">        <span class="comment">//this.transform.position = nowPos;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过插值运算缓慢移动相机位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = Vector3.Lerp(<span class="keyword">this</span>.transform.position, nowPos, Time.deltaTime * moveSpeed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是通过插值运算来缓动看向物体</span></span><br><span class="line">        <span class="comment">//摄像机要看的是nowDir的反向向量 所以通过LookRotation算出旋转成的四元数 传入当做插值函数的终点</span></span><br><span class="line">        <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, Quaternion.LookRotation(-nowDir), Time.deltaTime * lookAtSpeed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画出头顶和摄像机的连线</span></span><br><span class="line">        Debug.DrawLine(<span class="keyword">this</span>.transform.position, headPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3.hexo插件</title>
    <link href="http://example.com/2025/03/02/hexo/3.hexo%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2025/03/02/hexo/3.hexo%E6%8F%92%E4%BB%B6/</id>
    <published>2025-03-02T07:07:49.000Z</published>
    <updated>2025-03-02T07:36:58.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h1><p><strong>安装</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-simple-mindmap</span><br></pre></td></tr></table></figure><p><strong>使用</strong><br />使用 Hexo 的 pullquote 将思维导图的内容包裹起来，<code>mindmap</code> 是思维导图渲染的标志<br />尺寸有三种规格：<code>mindmap-sm</code>、<code>mindmap-md</code> 和 <code>mindmap-lg</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote mindmap mindmap-sm %&#125;</span><br><span class="line">- [在 Hexo 中使用思维导图](https://hunterx.xyz/use-mindmap-in-hexo.html)</span><br><span class="line">  - 前言</span><br><span class="line">  - 操作指南</span><br><span class="line">    - 准备需要的文件</span><br><span class="line">    - 为主题添加 CSS/JS 文件</span><br><span class="line">  - 使用方法</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote mindmap mindmap-sm"><ul><li><a href="https://hunterx.xyz/use-mindmap-in-hexo.html">在 Hexo 中使用思维导图</a><ul><li>前言</li><li>操作指南<ul><li>准备需要的文件</li><li>为主题添加 CSS/JS 文件</li></ul></li><li>使用方法</li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思维导图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#思维导图&quot;&gt;&lt;/a&gt; 思维导图&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>csharp拓展方法</title>
    <link href="http://example.com/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-02T06:56:36.000Z</published>
    <updated>2025-03-02T07:42:37.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓展方法基本概念"><a class="markdownIt-Anchor" href="#拓展方法基本概念"></a> 拓展方法基本概念</h1><p>C# 中的扩展方法是 C# 3.0 引入的一项特性，它允许开发者在不修改原始类或对象的情况下，向现有类添加新方法</p><p><strong>作用</strong></p><ol><li>提升程序拓展性</li><li>不需要再对象中重新写方法</li><li>不需要继承来添加方法</li><li>为别人封装的类型写额外的方法</li></ol><p><strong>特点</strong></p><ol><li>一定是写在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ol><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><p><code>访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名,参数类型 参数名....)</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法 </span></span><br><span class="line">    <span class="comment">//成员方法 是需要 实例化对象后 才 能使用的</span></span><br><span class="line">    <span class="comment">//value 代表 使用该方法的 实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法 的逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为int拓展的方法&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakStringInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">string</span> str2, <span class="built_in">string</span> str3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为string拓展的方法&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用方法的对象&quot;</span> + str);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;传的参数&quot;</span> + str2 + str3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun3</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为test拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为自定义的类型拓展方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;拓展方法&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">        i.SpeakValue();</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        str.SpeakStringInfo(<span class="string">&quot;卧槽&quot;</span>, <span class="string">&quot;nm&quot;</span>);</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.Fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：</span></span><br><span class="line"><span class="comment">//概念：为现有的非静态 变量类型 添加 方法</span></span><br><span class="line"><span class="comment">//作用：</span></span><br><span class="line"><span class="comment">// 提升程序拓展性</span></span><br><span class="line"><span class="comment">// 不需要再在对象中重新写方法</span></span><br><span class="line"><span class="comment">// 不需要继承来添加方法</span></span><br><span class="line"><span class="comment">// 为别人封装的类型写额外的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特点：</span></span><br><span class="line"><span class="comment">//静态类中的静态方法</span></span><br><span class="line"><span class="comment">//第一个参数 代表拓展的目标</span></span><br><span class="line"><span class="comment">//第一个参数前面一定要加 this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//可以有返回值 和 n个参数</span></span><br><span class="line"><span class="comment">//根据需求而定</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拓展方法基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#拓展方法基本概念&quot;&gt;&lt;/a&gt; 拓展方法基本概念&lt;/h1&gt;
&lt;p&gt;C# 中的扩展方法是 C# 3.0 引入的一项特性，它允许开发者在不修改原始类或对象的情况下，向现有类添加新</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>7.Quaternion四元数常用方法</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-02T03:00:47.000Z</published>
    <updated>2025-03-02T09:06:50.413Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302110057184.png" alt="" /></p><h1 id="单位四元数"><a class="markdownIt-Anchor" href="#单位四元数"></a> 单位四元数</h1><p>满足条件：<code>x² + y² + z² + w² = 1</code><br /><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302110228942.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单位四元数 [1, (0, 0, 0)]</span></span><br><span class="line"> Quaternion i = Quaternion.identity;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//Object的Instantiate方法有重载 第三个参数可以传入四元数角度 </span></span><br><span class="line"> Instantiate(testCube, Vector3.zero, Quaternion.identity);</span><br></pre></td></tr></table></figure><h1 id="插值运算"><a class="markdownIt-Anchor" href="#插值运算"></a> 插值运算</h1><p><img src="../../../../../public/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302110554680.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限接近，先快后慢</span></span><br><span class="line">A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匀速</span></span><br><span class="line">time += Time.deltaTime; </span><br><span class="line">B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);</span><br></pre></td></tr></table></figure><h1 id="向量指向转四元数lookrotation"><a class="markdownIt-Anchor" href="#向量指向转四元数lookrotation"></a> 向量指向转四元数LookRotation</h1><p><img src="../../../../../public/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302111627899.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> rotateSpeed = <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    Vector3 dir = target.position - transform.position;</span><br><span class="line">    Quaternion targetRot = Quaternion.LookRotation(dir);</span><br><span class="line">    transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="为transform拓展方法实现lookat"><a class="markdownIt-Anchor" href="#为transform拓展方法实现lookat"></a> 为transform拓展方法实现LookAt</h2><p><strong>使用<a href="/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/" title="csharp拓展方法">拓展方法</a> ，利用四元数的LookRotation方法，使transform实现LookAt的效果</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自己写的看向目标的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyLookAt</span>(<span class="params"><span class="keyword">this</span> Transform obj, Transform target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//算出目标和自己的向量</span></span><br><span class="line">        Vector3 vec = target.position - obj.position;</span><br><span class="line">        <span class="comment">//用LookRotation得到转向的四元数赋值给自己</span></span><br><span class="line">        obj.transform.rotation = Quaternion.LookRotation(vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123; </span><br><span class="line">    <span class="comment">//调用自己写的拓展方法看向B </span></span><br><span class="line">    lookA.MyLookAt(lookB); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="摄像机使用slerp来缓慢看向玩家"><a class="markdownIt-Anchor" href="#摄像机使用slerp来缓慢看向玩家"></a> 摄像机使用Slerp来缓慢看向玩家</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发现目标对象位置改变时</span></span><br><span class="line"><span class="keyword">if</span> (targetQ != Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重新用目标的位置减去摄像机的位置计算出新的面朝向向量四元数</span></span><br><span class="line">    targetQ = Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position);</span><br><span class="line">    <span class="comment">// 清空累加时间 不然时间一直大于1 会一直盯着目标看 不能达到匀速旋转看向目标的效果</span></span><br><span class="line">    roundTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重置摄像机开始旋转位置</span></span><br><span class="line">    startQ = <span class="keyword">this</span>.transform.rotation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加时间</span></span><br><span class="line">roundTime += Time.deltaTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入发现目标对象位置改变后定死的摄像机开始旋转位置，目标旋转位置，和累加的时间</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(startQ, targetQ, roundTime * roundSpeed);</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>6.Quaternion四元数概念</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/</id>
    <published>2025-03-02T02:26:57.000Z</published>
    <updated>2025-03-02T09:05:07.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四元数概念"><a class="markdownIt-Anchor" href="#四元数概念"></a> 四元数概念</h1><p><strong>数学定义</strong><br />四元数由4个分量组成：<code>x</code>, <code>y</code>, <code>z</code>, <code>w</code>，数学表示为 <code>q = xi + yj + zk + w</code><br /><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302102720902.png" alt="" /></p><h1 id="四元数构成"><a class="markdownIt-Anchor" href="#四元数构成"></a> 四元数构成</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302102808972.png" alt="" /></p><h1 id="轴-角对"><a class="markdownIt-Anchor" href="#轴-角对"></a> 轴-角对</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302102917944.png" alt="" /></p><p>这里的n是3d向量<br /><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302103043266.png" alt="" /></p><h1 id="unity中的四元数-quaternion"><a class="markdownIt-Anchor" href="#unity中的四元数-quaternion"></a> Unity中的四元数 Quaternion</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302103241431.png" alt="" /></p><h1 id="unity中的四元数初始化方法"><a class="markdownIt-Anchor" href="#unity中的四元数初始化方法"></a> Unity中的四元数初始化方法</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302103358189.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用四元数的计算原理 绕着(x,y,z)向量旋转β度(弧度)</span></span><br><span class="line"><span class="built_in">float</span> timeAngle = Mathf.Sin(β / <span class="number">2</span> * Mathf.Deg2Rad);</span><br><span class="line">Quaternion q = <span class="keyword">new</span> Quaternion(timeAngle * x, timeAngle * y, timeAngle * z, Mathf.Cos(β / <span class="number">2</span> * Mathf.Deg2Rad));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//绕着(1,0,0)向量旋转60度 要传入弧度制 角度转弧度</span></span><br><span class="line">Quaternion q1 = <span class="keyword">new</span> Quaternion(Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad), <span class="number">0</span>, <span class="number">0</span>, Mathf.Cos(<span class="number">30</span> * Mathf.Deg2Rad));</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个围绕 axis 旋转 offsetAngle 度的旋转。</span></span><br><span class="line"><span class="comment">//提供的轴角对 初始化 四元数的方法 分别传入度数和向量轴</span></span><br><span class="line">Quaternion q2 = Quaternion.AngleAxis(<span class="number">60</span>, Vector3.right);</span><br></pre></td></tr></table></figure><h1 id="四元数和欧拉角相互转换"><a class="markdownIt-Anchor" href="#四元数和欧拉角相互转换"></a> 四元数和欧拉角相互转换</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欧拉角 转 四元数</span></span><br><span class="line">Quaternion q = Quaternion.Euler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四元数 转 欧拉角</span></span><br><span class="line">print(q.eulerAngles);<span class="comment">//(60.0, 0.0, 0.0)</span></span><br></pre></td></tr></table></figure><h1 id="弥补的欧拉角缺点"><a class="markdownIt-Anchor" href="#弥补的欧拉角缺点"></a> 弥补的欧拉角缺点</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302104937133.png" alt="" /></p><p>注意：四元数转换为欧拉角的范围始终是<code>[-180°, 180°]</code>之间</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一帧绕着y轴旋转1度 </span></span><br><span class="line"><span class="comment">//四元数绕 y轴转  *****物体坐标系****** 旋转</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= Quaternion.AngleAxis(<span class="number">1</span>, Vector3.up);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302105740026.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四元数概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#四元数概念&quot;&gt;&lt;/a&gt; 四元数概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数学定义&lt;/strong&gt;&lt;br /&gt;
四元数由4个分量组成：&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>5.Quaternion为什么要使用四元数</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/</id>
    <published>2025-03-02T02:10:07.000Z</published>
    <updated>2025-03-02T03:01:30.593Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101040200.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101049212.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101107012.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101235714.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302102110758.png" alt="" /></p><p>在unity中将Rotation的x设置为90°，调整y和z都绕同一个轴旋转</p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302102438979.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>4.Vector3向量</title>
    <link href="http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/"/>
    <id>http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/</id>
    <published>2025-03-01T10:14:34.000Z</published>
    <updated>2025-03-02T03:01:40.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="unity中的向量"><a class="markdownIt-Anchor" href="#unity中的向量"></a> Unity中的向量</h1><h2 id="向量常用的成员和方法"><a class="markdownIt-Anchor" href="#向量常用的成员和方法"></a> 向量常用的成员和方法</h2><p>向量在数学和编程中有许多常用的成员和方法，常见的包括：</p><ol><li><strong>成员</strong>：<ul><li><code>x</code>、<code>y</code>、<code>z</code>：向量的分量，表示向量在 x、y、z 方向上的值。</li><li><code>magnitude</code> 或 <code>length</code>：向量的<strong>长度或模长</strong>，表示从原点到向量的终点的距离。</li><li><code>normalized</code>：返回与当前向量方向相同但长度为1的<strong>单位向量</strong>。也可以 向量 /magnitude</li><li><code>sqrMagnitude</code>：向量<strong>长度的平方</strong>，用于比较向量长度时避免开方计算。</li><li><code>zero</code>：零向量，所有分量均为0的向量。</li></ul></li><li><strong>方法</strong>：<ul><li><code>Vector3.Dot(Vector3 a, Vector3 b)</code>：计算两个向量的<strong>点乘</strong>结果。返回弧度</li><li><code>Vector3.Cross(Vector3 a, Vector3 b)</code>：计算两个向量的<strong>叉乘</strong>结果。</li><li><code>Vector3.Distance(Vector3 a, Vector3 b)</code>：计算两个向量之间的<strong>距离</strong>。</li><li><code>Vector3.Lerp(Vector3 a, Vector3 b, float t)</code>：在两个向量之间进行<strong>线性插值</strong>。</li><li><code>Vector3.Slerp(Vector3 a, Vector3 b, float t)</code>：在两个向量之间进行<strong>球形插值</strong></li><li><code>Vector3.Normalize(Vector3 value)</code>：将向量转化为单位向量。</li><li><code>Vector3.Project(Vector3 vector, Vector3 onNormal)</code>：将一个向量<strong>投影</strong>到另一个向量上。</li><li><code>Vector3.RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)</code>：将一个向量从当前方向<strong>旋转</strong>到目标方向。</li><li><code>Vector3.Angle(Vector3 from, Vector3 to)</code>：返回值float, 计算两个向量之间的<strong>角度值</strong></li></ul></li></ol><p>例子eg:</p><ul><li>利用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">A \cdot B = |A| * |B| cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 或者 Vector.Angle()(角度) 来计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A\cdot B &gt;= 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 前方 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A \times B &lt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>  则A右B左</li><li>线性插值 (匀速)</li></ul><h2 id="向量的点积"><a class="markdownIt-Anchor" href="#向量的点积"></a> 向量的点积</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Debug类中的DrawLine静态方法 画线段</span></span><br><span class="line"><span class="comment">// 参数：前两个参数分别是起点和终点，最后一个参数是划线颜色。</span></span><br><span class="line">Debug.DrawLine(<span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward, Color.red);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Debug类中的DrawRay静态方法 画射线</span></span><br><span class="line"><span class="comment">// 参数：前两个参数分别是起点和方向，最后一个参数是划线颜色。</span></span><br><span class="line">Debug.DrawRay(<span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.up, Color.blue);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两个向量 a=(x1​,y1​) 和 b=(x2​,y2​) 的点积定义为 <code>a⋅b=x1x2​+y1​y2</code>​​，其结果是一个标量，且 <code>a⋅b=∣a∣×∣b∣×cosθ</code>，其中 θ 是 a 和 b 之间的夹角。<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mi>A</mi><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mtext>单位向量</mtext><mi>a</mi><mo>⋅</mo><mtext>单位向量</mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta = Acos(单位向量a \cdot 单位向量b )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">量</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">量</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span><br /><strong>点积可用于判断两个向量的前后关系</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector3 forward = transform.forward;</span><br><span class="line">Vector3 toEnemy = enemy.position - transform.position;</span><br><span class="line"><span class="built_in">float</span> dotResult = Vector3.Dot(forward, toEnemy.normalized);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值&gt;0表示敌人在前方，&lt;0表示在后方</span></span><br><span class="line"><span class="keyword">if</span>(dotResult &gt; <span class="number">0.5f</span>) &#123;</span><br><span class="line">    <span class="comment">// 敌人位于前方60度范围内</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量的叉积"><a class="markdownIt-Anchor" href="#向量的叉积"></a> 向量的叉积</h2><p>获取垂直向量（右手定则， 常用于计算旋转轴）<br /><strong>可以用叉乘来判断两个向量的左右关系</strong><br /><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/file-20250301192541472.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vector3 C = Vector3.Cross(A.position, B.position);</span><br><span class="line"><span class="keyword">if</span> (C.y &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;A在B的右侧&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;B在A的右侧&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向量插值运算"><a class="markdownIt-Anchor" href="#向量插值运算"></a> 向量插值运算</h2><p>插值公式和<a href="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/#%E6%8F%92%E5%80%BC%E8%BF%90%E7%AE%97" title="2.Mathf数学计算结构体常用方法">Mathf的插值运算</a>差不多</p><h3 id="线性插值"><a class="markdownIt-Anchor" href="#线性插值"></a> 线性插值</h3><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/file-20250301201243989.png" alt="" /><br />先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以理解为t不变 每次往方向向量加的值(end - start)一直会变小</span></span><br><span class="line"></span><br><span class="line">A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime);</span><br></pre></td></tr></table></figure><p>匀速 每帧改变时间 当t&gt;=1时 得到结果</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 可以理解为t每一帧累加相同值 start和(end - start)不变 所以是匀速运动</span></span><br><span class="line"><span class="comment">// 这种匀速移动 当time&gt;=1时  我改变了 目标位置后  它会直接瞬移到我们的目标位置 因为t&gt;=1时直接的得到结果</span></span><br><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"><span class="keyword">private</span> Vector3 startPos;</span><br><span class="line"><span class="keyword">private</span> Vector3 tmpTarget;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 每次终点移动变化, 重置时间, 起点</span></span><br><span class="line"><span class="keyword">if</span> (tmpTarget != target.position)</span><br><span class="line">&#123;</span><br><span class="line">tmpTarget = target.position;</span><br><span class="line">time = <span class="number">0</span>;</span><br><span class="line">startPos = transform.position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time += Time.deltaTime;</span><br><span class="line">transform.position = Vector3.Lerp(startPos, target.position, time);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="球形插值"><a class="markdownIt-Anchor" href="#球形插值"></a> 球形插值</h3><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/file-20250301202346155.png" alt="" /><br />从（10， 0， 0） 到 （0， 0， 10）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time += Time.deltaTime;</span><br><span class="line">A.position = Vector3.Slerp(Vector3.right * <span class="number">10</span>, Vector3.forward * <span class="number">10</span>, time);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/file-20250301203227418.png" alt="" /></p><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="用向量相关知识实现摄像机跟随"><a class="markdownIt-Anchor" href="#用向量相关知识实现摄像机跟随"></a> 用向量相关知识，实现摄像机跟随</h2><p>摄像机代码写在<code>LateUpdate</code>中<br />如果在<code>Update</code>中更新摄像机的位置，可能会出现<strong>摄像机位置更新早于目标对象位置更新</strong>的情况，导致摄像机出现<strong>抖动或延迟跟随</strong>的问题。<br />而在<code>LateUpdate</code>中更新摄像机位置，可以确保在目标对象位置更新完成后再进行摄像机的移动，从而实现平滑的跟随效果。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> zOffect = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> yOffect = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 摄像机的位置等于目标的位置进行向量偏移</span></span><br><span class="line">    <span class="comment">// 先朝目标对象的面朝向的反方向平移4米再朝目标的头顶位置平移7米</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置摄像机位置</span></span><br><span class="line">    <span class="keyword">this</span>.transform.position = target.position - target.forward * zOffect + target.up * yOffect;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看向目标</span></span><br><span class="line">    <span class="keyword">this</span>.transform.LookAt(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="发现入侵者"><a class="markdownIt-Anchor" href="#发现入侵者"></a> 发现入侵者</h2><p>当一个物体B在物体A前方45度角范围内，并且离A只有5米距离时，在控制台打印“发现入侵者”<br /><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/4.Vector3%E5%90%91%E9%87%8F/file-20250301191637062.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动算</span></span><br><span class="line"><span class="keyword">if</span> (Vector3.Distance(<span class="keyword">this</span>.transform.position, B.transform.position) &lt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一步：算出点乘结果（方向向量）</span></span><br><span class="line">    <span class="built_in">float</span> dotResult = Vector3.Dot(<span class="keyword">this</span>.transform.forward, (B.transform.position - <span class="keyword">this</span>.transform.position).normalized);</span><br><span class="line">    <span class="comment">// 第二步：通过反余弦函数算出夹角</span></span><br><span class="line">    <span class="keyword">if</span> (Mathf.Acos(dotResult) * Mathf.Rad2Deg &lt;= <span class="number">22.5f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;手动算角度 发现入侵者&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Angle直接算角度</span></span><br><span class="line"><span class="keyword">if</span> (Vector3.Distance(<span class="keyword">this</span>.transform.position, B.transform.position) &lt;= <span class="number">5</span> &amp;&amp;</span><br><span class="line">    Vector3.Angle(<span class="keyword">this</span>.transform.forward, B.transform.position - <span class="keyword">this</span>.transform.position) &lt;= <span class="number">22.5f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;Angle直接算角度 发现入侵者&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="左上左下-右上右下哪个方位"><a class="markdownIt-Anchor" href="#左上左下-右上右下哪个方位"></a> 左上，左下 ，右上，右下哪个方位?</h2><p>判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VectorPositionDetector</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform objectA;</span><br><span class="line">    <span class="keyword">public</span> Transform objectB;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;阈值&quot;</span>)</span>] </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> angleThreshold = <span class="number">45f</span>; <span class="comment">// 方向识别角度范围</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取A到B的水平方向向量</span></span><br><span class="line">        Vector3 aToB = objectB.position - objectA.position;</span><br><span class="line">        aToB.y = <span class="number">0</span>; <span class="comment">// 忽略垂直分量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取A的基准方向向量（已水平化）</span></span><br><span class="line">        Vector3 aForward = objectA.forward;</span><br><span class="line">        aForward.y = <span class="number">0</span>;</span><br><span class="line">        Vector3 aRight = objectA.right;</span><br><span class="line">        aRight.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算方向点积（自动处理向量长度）</span></span><br><span class="line">        <span class="built_in">float</span> forwardDot = Vector3.Dot(aToB.normalized, aForward.normalized);</span><br><span class="line">        <span class="built_in">float</span> rightDot = Vector3.Dot(aToB.normalized, aRight.normalized);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 精确角度计算版本</span></span><br><span class="line">        <span class="built_in">float</span> angle = Vector3.Angle(aForward, aToB);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基本方位判断</span></span><br><span class="line">        <span class="built_in">bool</span> isFront = forwardDot &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> isBack = forwardDot &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> isRight = rightDot &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> isLeft = rightDot &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 精确方位判断（45度扇形区）</span></span><br><span class="line">        <span class="built_in">bool</span> inFrontSector = angle &lt;= angleThreshold;</span><br><span class="line">        <span class="built_in">bool</span> inRightSector = Vector3.Angle(aRight, aToB) &lt;= angleThreshold;</span><br><span class="line">        </span><br><span class="line">        Debug.Log(<span class="string">$&quot;前方: <span class="subst">&#123;isFront&#125;</span> | 后方: <span class="subst">&#123;isBack&#125;</span>\n&quot;</span> +</span><br><span class="line">                  <span class="string">$&quot;右侧: <span class="subst">&#123;isRight&#125;</span> | 左侧: <span class="subst">&#123;isLeft&#125;</span>\n&quot;</span> +</span><br><span class="line">                  <span class="string">$&quot;前扇形区: <span class="subst">&#123;inFrontSector&#125;</span> | 右扇形区: <span class="subst">&#123;inRightSector&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算八个方向识别</span></span><br><span class="line">        <span class="built_in">bool</span> isFrontRight = forwardDot &gt; <span class="number">0</span> &amp;&amp; rightDot &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> isFrontLeft = forwardDot &gt; <span class="number">0</span> &amp;&amp; rightDot &lt; <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 距离综合判断</span></span><br><span class="line">        <span class="built_in">float</span> distance = aToB.magnitude;</span><br><span class="line">        <span class="built_in">bool</span> inRange = distance &lt; <span class="number">5f</span>; <span class="comment">// 5米范围内</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运动方向预测（需记录上一帧位置）</span></span><br><span class="line">        Vector3 velocity = (objectB.position - lastPosition) / Time.deltaTime;</span><br><span class="line">        lastPosition = objectB.position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lesson08_</span>练习题 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拖拽得到AB位置变量</span></span><br><span class="line">    <span class="keyword">public</span> Transform A;</span><br><span class="line">    <span class="keyword">public</span> Transform B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点乘接过和叉乘结果变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> dotResult;</span><br><span class="line">    <span class="keyword">private</span> Vector3 crossResult;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 练习题一</span></span><br><span class="line">        <span class="comment">//判断一个物体B位置再另一个物体A的位置的左上，左下 ，右上，右下哪个方位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算 A位置向量和AB方向差向量 点乘和叉乘结果</span></span><br><span class="line">        dotResult = Vector3.Dot(A.forward, B.position - A.position);</span><br><span class="line">        crossResult = Vector3.Cross(A.forward, B.position - A.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据点乘和叉乘的值判断前后左右</span></span><br><span class="line">        <span class="keyword">if</span> (dotResult &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//右侧</span></span><br><span class="line">            <span class="keyword">if</span> (crossResult.y &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;右前&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左侧</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;左前&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//右侧</span></span><br><span class="line">            <span class="keyword">if</span> (crossResult.y &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;右后&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左侧</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;左后&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 练习题二</span></span><br><span class="line">        <span class="comment">//当一个物体B在物体A左前方20度角或右前方30度范围内，并且离A只有5米距离时，在控制台打印“发现入侵者”</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算叉乘 用于判断左边还是右边</span></span><br><span class="line">        crossResult = Vector3.Cross(A.forward, B.position - A.position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断距离</span></span><br><span class="line">        <span class="keyword">if</span> (Vector3.Distance(A.position, B.position) &lt;= <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//A左前方20度角或右前方30度范围内</span></span><br><span class="line">            <span class="keyword">if</span> (crossResult.y &gt;= <span class="number">0</span> &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= <span class="number">30</span> ||</span><br><span class="line">                crossResult.y &lt; <span class="number">0</span> &amp;&amp; Vector3.Angle(A.forward, B.position - A.position) &lt;= <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;发现入侵者&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插值实现摄像机跟随"><a class="markdownIt-Anchor" href="#插值实现摄像机跟随"></a> 插值实现摄像机跟随</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前摄像机的目标位置不是目标对象的后方4米，向上偏7米 就设置目标位置 记录摄像机当前开始位置 重置时间</span></span><br><span class="line"><span class="keyword">if</span> (cameraTargetPos != target.position + -target.forward * zOffect + target.up * yOffect)</span><br><span class="line">&#123;</span><br><span class="line">    cameraTargetPos = target.position + -target.forward * zOffect + target.up * yOffect;</span><br><span class="line">    startPos = <span class="keyword">this</span>.transform.position;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">time += Time.deltaTime;</span><br><span class="line"><span class="keyword">this</span>.transform.position = Vector3.Lerp(startPos, cameraTargetPos, time * moveSpeed);</span><br></pre></td></tr></table></figure><h2 id="球形插值模拟太阳轨迹"><a class="markdownIt-Anchor" href="#球形插值模拟太阳轨迹"></a> 球形插值模拟太阳轨迹</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    time2 += Time.deltaTime;</span><br><span class="line">    <span class="comment">// sun.position = Vector3.Slerp(Vector3.right * 10, Vector3.left * 10, time2 * 0.1f);//假如直接写最终值会不知道从哪里转 可能会平这转</span></span><br><span class="line">    sun.position = Vector3.Slerp(Vector3.right * <span class="number">10</span>, Vector3.left * <span class="number">10</span> + Vector3.up * <span class="number">0.1f</span>, time2 * <span class="number">0.1f</span>);<span class="comment">//要给最终值加一点向上的向量 才会往上转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;unity中的向量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#unity中的向量&quot;&gt;&lt;/a&gt; Unity中的向量&lt;/h1&gt;
&lt;h2 id=&quot;向量常用的成员和方法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3.坐标系</title>
    <link href="http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    <id>http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/</id>
    <published>2025-03-01T07:57:07.000Z</published>
    <updated>2025-03-02T03:01:44.817Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-20250301160938092.png" alt="" /></p><h1 id="世界坐标系"><a class="markdownIt-Anchor" href="#世界坐标系"></a> 世界坐标系</h1><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-20250301155758132.png" alt="" /></p><ul><li><code>this.transform.position</code>-返回物体在世界坐标系中的位置</li><li><code>this.transform.rotation</code>-返回物体在世界坐标系中的旋转四元数</li><li><code>this.transform.eulerAngles</code>-返回物体在世界坐标系中的欧拉角</li><li><code>this.transform.lossyScale</code>-返回物体在世界坐标系中的缩放</li><li>修改它们将导致相对于世界坐标系的变化</li></ul><h1 id="物体坐标系"><a class="markdownIt-Anchor" href="#物体坐标系"></a> 物体坐标系</h1><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-20250301155814045.png" alt="" /></p><ul><li><code>this.transform.localPosition</code>-返回物体在其父对象坐标系中的位置</li><li><code>this.transform.localEulerAngles</code>-返回物体在其父对象坐标系中的旋转四元数</li><li><code>this.transform.localRotation</code>-返回物体在其父对象坐标系中的欧拉角</li><li><code>this.transform.localScale</code>-返回物体在其父对象坐标系中的缩放</li><li>修改它们将导致相对于父对象物体坐标系的变化</li></ul><h1 id="屏幕坐标系"><a class="markdownIt-Anchor" href="#屏幕坐标系"></a> 屏幕坐标系</h1><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-20250301155843741.png" alt="" /></p><ul><li><code>Input.mousePosition</code>-返回鼠标在屏幕坐标系中的位置</li><li><code>Screen.width</code>-返回屏幕坐标系的宽度</li><li><code>Screen.height</code>-返回屏幕坐标系的高度</li><li><code>currentResolution</code>当前屏幕的分辨率为</li></ul><h1 id="视口坐标系"><a class="markdownIt-Anchor" href="#视口坐标系"></a> 视口坐标系</h1><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-20250301155903740.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-20250301161722119.png" alt="" /></p><h1 id="坐标转换"><a class="markdownIt-Anchor" href="#坐标转换"></a> 坐标转换</h1><a href="/2025/02/19/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/18.%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/" title="18.坐标转换">点与向量在本地与世界之间的来回转换</a><h2 id="世界转本地"><a class="markdownIt-Anchor" href="#世界转本地"></a> 世界转本地</h2><p><code>this.transform.InverseTransformDirection</code> 将世界空间中的方向向量转换为本地空间中的方向向量。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 worldDirection = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 localDirection = <span class="keyword">this</span>.transform.InverseTransformDirection(worldDirection);    <span class="comment">// (不受缩放影响</span></span><br></pre></td></tr></table></figure><p><code>this.transform.InverseTransformPoint</code> 将世界空间中的点转换为本地空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 worldPoint = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Vector3 localPoint = <span class="keyword">this</span>.transform.InverseTransformPoint(worldPoint);</span><br></pre></td></tr></table></figure><p><code>this.transform.InverseTransformVector</code> 将世界空间中的向量转换为本地空间中的向量。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 worldVector = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 localVector = <span class="keyword">this</span>.transform.InverseTransformVector(worldVector);     <span class="comment">// (受缩放影响</span></span><br></pre></td></tr></table></figure><h2 id="本地转世界"><a class="markdownIt-Anchor" href="#本地转世界"></a> 本地转世界</h2><p><code>this.transform.TransformDirection</code> 将本地空间中的方向向量转换为世界空间中的方向向量。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 localDirection = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 worldDirection = <span class="keyword">this</span>.transform.TransformDirection(localDirection);<span class="comment">// (不受缩放影响</span></span><br></pre></td></tr></table></figure><p><code>this.transform.TransformPoint</code> 将本地空间中的点转换为世界空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 localPoint = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">Vector3 worldPoint = <span class="keyword">this</span>.transform.TransformPoint(localPoint);</span><br></pre></td></tr></table></figure><p><code>this.transform.TransformVector</code> 将本地空间中的向量转换为世界空间中的向量。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 localVector = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 worldVector = <span class="keyword">this</span>.transform.TransformVector(localVector);    <span class="comment">// (受缩放影响</span></span><br></pre></td></tr></table></figure><h2 id="世界转屏幕"><a class="markdownIt-Anchor" href="#世界转屏幕"></a> 世界转屏幕</h2><p><code>Camera.main.WorldToScreenPoint</code> 将世界空间中的点转换为屏幕空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 worldPoint = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Vector3 screenPoint = Camera.main.WorldToScreenPoint(worldPoint);</span><br></pre></td></tr></table></figure><h2 id="屏幕转世界"><a class="markdownIt-Anchor" href="#屏幕转世界"></a> 屏幕转世界</h2><p><code>Camera.main.ScreenToWorldPoint</code> 将屏幕空间中的点转换为世界空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 screenPoint = <span class="keyword">new</span> Vector3(<span class="number">100</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 worldPoint = Camera.main.ScreenToWorldPoint(screenPoint);</span><br></pre></td></tr></table></figure><h2 id="世界转视口"><a class="markdownIt-Anchor" href="#世界转视口"></a> 世界转视口</h2><p><code>Camera.main.WorldToViewportPoint</code> 将世界空间中的点转换为视口空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 worldPoint = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Vector3 viewportPoint = Camera.main.WorldToViewportPoint(worldPoint);</span><br></pre></td></tr></table></figure><h2 id="视口转世界"><a class="markdownIt-Anchor" href="#视口转世界"></a> 视口转世界</h2><p><code>Camera.main.ViewportToWorldPoint</code> 将视口空间中的点转换为世界空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 viewportPoint = <span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 worldPoint = Camera.main.ViewportToWorldPoint(viewportPoint);</span><br></pre></td></tr></table></figure><h2 id="视口转屏幕"><a class="markdownIt-Anchor" href="#视口转屏幕"></a> 视口转屏幕</h2><p><code>Camera.main.ViewportToScreenPoint</code> 将视口空间中的点转换为屏幕空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 viewportPoint = <span class="keyword">new</span> Vector3(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 screenPoint = Camera.main.ViewportToScreenPoint(viewportPoint);</span><br></pre></td></tr></table></figure><h2 id="屏幕转视口"><a class="markdownIt-Anchor" href="#屏幕转视口"></a> 屏幕转视口</h2><p><code>Camera.main.ScreenToViewportPoint</code> 将屏幕空间中的点转换为视口空间中的点。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector3 screenPoint = <span class="keyword">new</span> Vector3(<span class="number">100</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">Vector3 viewportPoint = Camera.main.ScreenToViewportPoint(screenPoint);</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/3.%E5%9D%90%E6%A0%87%E7%B3%BB/file-2025030116093</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2.Mathf数学计算结构体常用方法</title>
    <link href="http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-01T06:51:42.000Z</published>
    <updated>2025-03-02T03:01:47.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mathf和math"><a class="markdownIt-Anchor" href="#mathf和math"></a> Mathf和Math</h1><ul><li>Math是C#中封装好的用于数学计算的<strong>工具类</strong>，位于System命名空间中。</li><li>Mathf是Unity中封装好的用于数学计算的<strong>工具结构体</strong>，位于UnityEngine命名空间中。</li><li>他们都是提供来用于进行数学相关计算的。</li></ul><h1 id="mathf和math的区别"><a class="markdownIt-Anchor" href="#mathf和math的区别"></a> Mathf和Math的区别</h1><ul><li>Mathf 和 Math中的相关方法几乎一样。</li><li>Math - C#自带数学库，提供基本的数学计算方法。</li><li>Mathf - Unity专门针对游戏开发增强的数学库，包含了Math中的方法，并添加了一些适用于游戏开发的方法。</li></ul><h1 id="mathf中的常用方法"><a class="markdownIt-Anchor" href="#mathf中的常用方法"></a> Mathf中的常用方法</h1><h2 id="pi常量-获取圆周率π"><a class="markdownIt-Anchor" href="#pi常量-获取圆周率π"></a> PI常量 获取圆周率π</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 众所周知的“3.14159265358979...”值（只读）。</span></span><br><span class="line">print(Mathf.PI);<span class="comment">//3.141593</span></span><br></pre></td></tr></table></figure><h2 id="abs静态方法-取绝对值"><a class="markdownIt-Anchor" href="#abs静态方法-取绝对值"></a> Abs静态方法 取绝对值</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 f 的绝对值。</span></span><br><span class="line">print(Mathf.Abs(<span class="number">-10</span>));<span class="comment">//10</span></span><br><span class="line">print(Mathf.Abs(<span class="number">-20</span>));<span class="comment">//20</span></span><br><span class="line">print(Mathf.Abs(<span class="number">1</span>));<span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="ceiltoint静态方法-向上取整"><a class="markdownIt-Anchor" href="#ceiltoint静态方法-向上取整"></a> CeilToInt静态方法 向上取整</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回大于或等于 f 的最小整数。</span></span><br><span class="line"><span class="built_in">float</span> f = <span class="number">1.3f</span>;</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)f;</span><br><span class="line">print(i);<span class="comment">//1</span></span><br><span class="line">print(Mathf.CeilToInt(f));<span class="comment">//2</span></span><br><span class="line">print(Mathf.CeilToInt(<span class="number">1.00001f</span>));<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="floortoint静态方法-向下取整"><a class="markdownIt-Anchor" href="#floortoint静态方法-向下取整"></a> FloorToInt静态方法 向下取整</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小于或等于 f 的最大整数。</span></span><br><span class="line">print(Mathf.FloorToInt(<span class="number">9.6f</span>));<span class="comment">//9</span></span><br></pre></td></tr></table></figure><h2 id="clamp静态方法-钳制函数"><a class="markdownIt-Anchor" href="#clamp静态方法-钳制函数"></a> Clamp静态方法 钳制函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在给定的最小浮点值和最大浮点值之间钳制给定值。如果在最小和最大范围内，则返回给定值。</span></span><br><span class="line"><span class="comment">// 比最小还小，就取最小，比最大还大，就取最大，两者之间，就取本身</span></span><br><span class="line">print(Mathf.Clamp(<span class="number">10</span>, <span class="number">11</span>, <span class="number">20</span>));<span class="comment">//11</span></span><br><span class="line">print(Mathf.Clamp(<span class="number">21</span>, <span class="number">11</span>, <span class="number">20</span>));<span class="comment">//20</span></span><br><span class="line">print(Mathf.Clamp(<span class="number">15</span>, <span class="number">11</span>, <span class="number">20</span>));<span class="comment">//15</span></span><br></pre></td></tr></table></figure><h2 id="max静态方法-获取最大值"><a class="markdownIt-Anchor" href="#max静态方法-获取最大值"></a> Max静态方法 获取最大值</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个或更多值中的最大值。</span></span><br><span class="line"><span class="comment">// 内部有一个可变长的参数</span></span><br><span class="line">print(Mathf.Max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));<span class="comment">//8</span></span><br><span class="line">print(Mathf.Max(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="min静态方法-获取最小值"><a class="markdownIt-Anchor" href="#min静态方法-获取最小值"></a> Min静态方法 获取最小值</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个或更多值中的最小值。</span></span><br><span class="line"><span class="comment">// 内部有一个可变长的参数</span></span><br><span class="line">print(Mathf.Min(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">545</span>, <span class="number">6</span>, <span class="number">1123</span>, <span class="number">123</span>));<span class="comment">//1</span></span><br><span class="line">print(Mathf.Min(<span class="number">1.1f</span>, <span class="number">0.4f</span>));<span class="comment">//0.4</span></span><br></pre></td></tr></table></figure><h2 id="pow静态方法-一个数的n次幂"><a class="markdownIt-Anchor" href="#pow静态方法-一个数的n次幂"></a> Pow静态方法 一个数的n次幂</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 f 的 p 次幂。</span></span><br><span class="line">print(<span class="string">&quot;一个数的n次方&quot;</span> + Mathf.Pow(<span class="number">4</span>, <span class="number">2</span>));<span class="comment">//16</span></span><br><span class="line">print(<span class="string">&quot;一个数的n次方&quot;</span> + Mathf.Pow(<span class="number">2</span>, <span class="number">3</span>));<span class="comment">//8</span></span><br></pre></td></tr></table></figure><h2 id="roundtoint静态方法-四舍五入"><a class="markdownIt-Anchor" href="#roundtoint静态方法-四舍五入"></a> RoundToInt静态方法 四舍五入</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回舍入为最近整数的 / f /。</span></span><br><span class="line">print(<span class="string">&quot;四舍五入&quot;</span> + Mathf.RoundToInt(<span class="number">1.3f</span>));<span class="comment">//1</span></span><br><span class="line">print(<span class="string">&quot;四舍五入&quot;</span> + Mathf.RoundToInt(<span class="number">1.5f</span>));<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="sqrt静态方法-返回一个数的平方根"><a class="markdownIt-Anchor" href="#sqrt静态方法-返回一个数的平方根"></a> Sqrt静态方法 返回一个数的平方根</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 f 的平方根。</span></span><br><span class="line">print(<span class="string">&quot;返回一个数的平方根&quot;</span> + Mathf.Sqrt(<span class="number">4</span>));<span class="comment">//2</span></span><br><span class="line">print(<span class="string">&quot;返回一个数的平方根&quot;</span> + Mathf.Sqrt(<span class="number">16</span>));<span class="comment">//4</span></span><br><span class="line">print(<span class="string">&quot;返回一个数的平方根&quot;</span> + Mathf.Sqrt(<span class="number">64</span>));<span class="comment">//8</span></span><br></pre></td></tr></table></figure><h2 id="ispoweroftwo静态方法-判断一个数是否是2的n次方"><a class="markdownIt-Anchor" href="#ispoweroftwo静态方法-判断一个数是否是2的n次方"></a> IsPowerOfTwo静态方法 判断一个数是否是2的n次方</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果值是 2 的幂，则返回 true。</span></span><br><span class="line">print(<span class="string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line">print(<span class="string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="number">8</span>));<span class="comment">//true</span></span><br><span class="line">print(<span class="string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="number">3</span>));<span class="comment">//false</span></span><br><span class="line">print(<span class="string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="number">1</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="sign静态方法-判断正负数"><a class="markdownIt-Anchor" href="#sign静态方法-判断正负数"></a> Sign静态方法 判断正负数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 f 的符号。</span></span><br><span class="line"><span class="comment">// 正数和0就返回1，负数就返回-1</span></span><br><span class="line">print(<span class="string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="number">0</span>));<span class="comment">//1</span></span><br><span class="line">print(<span class="string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="number">10</span>));<span class="comment">//1</span></span><br><span class="line">print(<span class="string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="number">-10</span>));<span class="comment">//-1</span></span><br><span class="line">print(<span class="string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="number">3</span>));<span class="comment">//1</span></span><br><span class="line">print(<span class="string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="number">-2</span>));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><h2 id="插值运算"><a class="markdownIt-Anchor" href="#插值运算"></a> 插值运算</h2><p>Lerp :   result = Mathf.Lerp(start, end, t);<br />t为插值系数   取值范围<code>[0, 1]</code><br /><code>result = start + (end - start) * t</code>;</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t不变，起点不断变化</span></span><br><span class="line"><span class="comment">// 用法1  先快后慢, 无限趋近10</span></span><br><span class="line"><span class="built_in">float</span> start = <span class="number">1</span>;</span><br><span class="line">start = Mathf.Lerp(start, <span class="number">10</span>, Time.deltaTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 起点不变，时间t匀速变化</span></span><br><span class="line"><span class="comment">// 用法2  匀速变化</span></span><br><span class="line"><span class="built_in">float</span> start = <span class="number">1</span>; <span class="built_in">float</span> time = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">time += Time.deltaTime;</span><br><span class="line">result = Mathf.Lerp(start, <span class="number">10</span>, time);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250301153953564.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/2.Mathf%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%84%E4%BD%93%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250301154007473.png" alt="" /></p><p>Rad2Deg常量 弧度转角度的常量</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弧度到度换算常量（只读）。</span></span><br><span class="line"><span class="built_in">float</span> rad = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">float</span> anger = rad * Mathf.Rad2Deg;</span><br><span class="line">print(anger);<span class="comment">//57.29578f;</span></span><br></pre></td></tr></table></figure><p>Deg2Rad常量 角度转弧度的常量</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 度到弧度换算常量（只读）。</span></span><br><span class="line">anger = <span class="number">1</span>;</span><br><span class="line">rad = anger * Mathf.Deg2Rad;</span><br><span class="line">print(rad);<span class="comment">//0.01745329</span></span><br></pre></td></tr></table></figure><h1 id="unity中的三角函数"><a class="markdownIt-Anchor" href="#unity中的三角函数"></a> Unity中的三角函数</h1><p>注意：Mathf中的三角函数相关函数，<strong>传入的参数需要时弧度值</strong></p><h2 id="sin静态方法-计算正弦函数"><a class="markdownIt-Anchor" href="#sin静态方法-计算正弦函数"></a> Sin静态方法 计算正弦函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回角度 f 的正弦。</span></span><br><span class="line">print(Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad));<span class="comment">//0.5</span></span><br></pre></td></tr></table></figure><h2 id="cos静态方法-计算余弦函数"><a class="markdownIt-Anchor" href="#cos静态方法-计算余弦函数"></a> Cos静态方法 计算余弦函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回角度 f 的余弦。</span></span><br><span class="line">print(Mathf.Cos(<span class="number">60</span> * Mathf.Deg2Rad));<span class="comment">//0.5</span></span><br></pre></td></tr></table></figure><p>注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度</p><h2 id="asin静态方法-反正弦函数"><a class="markdownIt-Anchor" href="#asin静态方法-反正弦函数"></a> Asin静态方法 反正弦函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 f 的反正弦 - 其正弦为 f 的角度（以弧度为单位）。</span></span><br><span class="line">rad = Mathf.Asin(<span class="number">0.5f</span>);</span><br><span class="line">print(rad * Mathf.Rad2Deg);<span class="comment">//30</span></span><br></pre></td></tr></table></figure><h2 id="acos静态方法-反余弦函数"><a class="markdownIt-Anchor" href="#acos静态方法-反余弦函数"></a> Acos静态方法 反余弦函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 f 的反余弦 - 其余弦为 f 的角度（以弧度为单位）。</span></span><br><span class="line">rad = Mathf.Acos(<span class="number">0.5f</span>);</span><br><span class="line">print(rad * Mathf.Rad2Deg);<span class="comment">//60</span></span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="使用插值实现一个方块跟随另一个方块移动"><a class="markdownIt-Anchor" href="#使用插值实现一个方块跟随另一个方块移动"></a> 使用插值实现一个方块跟随另一个方块移动</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个脚本将要挂载到方块A上 实现方块A跟随着方块B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lesson02_</span>练习题 : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//要跟随的对象B</span></span><br><span class="line">    <span class="keyword">public</span> Transform B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位置中介</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B当前的位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 bNowPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始位置</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 startPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匀速运动累加的时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> mode = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第一种 就是 先快后慢的形式</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录当前这一帧A的位置</span></span><br><span class="line">            pos = <span class="keyword">this</span>.transform.position;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//传入这一帧A的位置算出下一帧A的位置</span></span><br><span class="line">            pos.x = Mathf.Lerp(pos.x, B.position.x, Time.deltaTime * moveSpeed);</span><br><span class="line">            pos.y = Mathf.Lerp(pos.y, B.position.y, Time.deltaTime * moveSpeed);</span><br><span class="line">            pos.z = Mathf.Lerp(pos.z, B.position.z, Time.deltaTime * moveSpeed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//算出下一帧A的位置赋值给A</span></span><br><span class="line">            <span class="keyword">this</span>.transform.position = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mode == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第二种 就是 匀速运动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//发现存储的B的位置不等于当前B的位置</span></span><br><span class="line">            <span class="keyword">if</span> (bNowPos != B.transform.position)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//清空时间 重写设置B的位置 开始位置是A当前的位置</span></span><br><span class="line">                time = <span class="number">0</span>;</span><br><span class="line">                bNowPos = B.transform.position;</span><br><span class="line">                startPos = <span class="keyword">this</span>.transform.position;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//时间每一帧运算累加</span></span><br><span class="line">            time += Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//startPos和bNowPos其实定死了 只有time在变化 传入算出下一帧A的位置</span></span><br><span class="line">            pos.x = Mathf.Lerp(startPos.x, bNowPos.x, time * moveSpeed);</span><br><span class="line">            pos.y = Mathf.Lerp(startPos.y, bNowPos.y, time * moveSpeed);</span><br><span class="line">            pos.z = Mathf.Lerp(startPos.z, bNowPos.z, time * moveSpeed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//算出下一帧A的位置赋值给A</span></span><br><span class="line">            <span class="keyword">this</span>.transform.position = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>), <span class="string">&quot;切换模式&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mode = <span class="number">3</span> - mode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现一个物体按照曲线移动正弦或余弦"><a class="markdownIt-Anchor" href="#实现一个物体按照曲线移动正弦或余弦"></a> 实现一个物体按照曲线移动（正弦或余弦）</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathfTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向前移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 振幅</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> changeSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 频率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> changeSpeed = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line">        time += Time.deltaTime;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.right * Mathf.Sin(time * changeSpeed) * changeSize * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mathf和math&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mathf和math&quot;&gt;&lt;/a&gt; Mathf和Math&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Math是C#中封装好的用于数学计算的&lt;strong&gt;工具类&lt;/strong&gt;，位于</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>1.unity基础概述</title>
    <link href="http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</id>
    <published>2025-03-01T06:43:09.000Z</published>
    <updated>2025-03-01T06:47:12.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/file-20250301144349330.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/file-20250301144710806.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/1.unity%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/file</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>4.模型自资源的导入</title>
    <link href="http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/"/>
    <id>http://example.com/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/</id>
    <published>2025-03-01T06:37:18.000Z</published>
    <updated>2025-03-01T06:40:34.472Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/file-20250301144027904.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/file-20250301143740401.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/file-20250301143825667.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/file-20250301143846271.png" alt="" /></p><p><img src="/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/4.%E6%A8%A1%E5%9E%8B%E8%87%AA%E8%B5%84%E6%BA%90%E7%9A%84%E5%AF%BC%E5%85%A5/file-20250301143929796.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/01/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门实践项目" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门实践项目" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>泛型委托和泛型接口の协变和逆变</title>
    <link href="http://example.com/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"/>
    <id>http://example.com/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/</id>
    <published>2025-03-01T02:26:27.000Z</published>
    <updated>2025-03-01T06:36:44.841Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/lemontea/archive/2013/02/17/2915065.html">逆变与协变详解 - zhangweiwen - 博客园 (cnblogs.com)</a></p><p>协变和逆变是用来修饰泛型类型参数T的<br />协变：out   表明修饰的T只能作为<strong>返回值</strong>来使用<br />逆变：in      表明修饰的T只能作为<strong>参数</strong>来使j用<br />只有<strong>泛型接口</strong>和<strong>泛型委托</strong>能使用</p><h1 id="协变foo父类-foo子类"><a class="markdownIt-Anchor" href="#协变foo父类-foo子类"></a> 协变（Foo&lt;父类&gt; = Foo&lt;子类&gt; ）</h1><p>典型场景：<strong>生产者（输出数据），如返回值、只读集合。</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型委托：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> T <span class="title">MyFuncA</span>&lt;<span class="title">T</span>&gt;()</span>;<span class="comment">//不支持逆变与协变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> T <span class="title">MyFuncB</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;<span class="comment">//支持协变</span></span><br><span class="line"> </span><br><span class="line">MyFuncA&lt;<span class="built_in">object</span>&gt; funcAObject = <span class="literal">null</span>;</span><br><span class="line">MyFuncA&lt;<span class="built_in">string</span>&gt; funcAString = <span class="literal">null</span>;</span><br><span class="line">MyFuncB&lt;<span class="built_in">object</span>&gt; funcBObject = <span class="literal">null</span>;</span><br><span class="line">MyFuncB&lt;<span class="built_in">string</span>&gt; funcBString = <span class="literal">null</span>;</span><br><span class="line">MyFuncB&lt;<span class="built_in">int</span>&gt; funcBInt = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">funcAObject = funcAString;<span class="comment">//编译失败，MyFuncA不支持逆变与协变</span></span><br><span class="line">funcBObject = funcBString;<span class="comment">//变了，协变</span></span><br><span class="line">funcBObject = funcBInt;<span class="comment">//编译失败，值类型不参与协变或逆变</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyA</span>&lt;<span class="title">T</span>&gt; &#123; &#125;<span class="comment">//不支持逆变与协变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFlyB</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; &#123; &#125;<span class="comment">//支持协变</span></span><br><span class="line"> </span><br><span class="line">IFlyA&lt;<span class="built_in">object</span>&gt; flyAObject = <span class="literal">null</span>;</span><br><span class="line">IFlyA&lt;<span class="built_in">string</span>&gt; flyAString = <span class="literal">null</span>;</span><br><span class="line">IFlyB&lt;<span class="built_in">object</span>&gt; flyBObject = <span class="literal">null</span>;</span><br><span class="line">IFlyB&lt;<span class="built_in">string</span>&gt; flyBString = <span class="literal">null</span>;</span><br><span class="line">IFlyB&lt;<span class="built_in">int</span>&gt; flyBInt = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">flyAObject = flyAString;<span class="comment">//编译失败，IFlyA不支持逆变与协变</span></span><br><span class="line">flyBObject = flyBString;<span class="comment">//变了，协变</span></span><br><span class="line">flyBObject = flyBInt;<span class="comment">//编译失败，值类型不参与协变或逆变</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//数组：</span></span><br><span class="line"><span class="built_in">string</span>[] strings = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;string&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">object</span>[] objects = strings;</span><br></pre></td></tr></table></figure><h1 id="逆变foo子类-foo父类"><a class="markdownIt-Anchor" href="#逆变foo子类-foo父类"></a> 逆变（Foo&lt;子类&gt; = Foo&lt;父类&gt;）</h1><p>典型场景：<strong>消费者（输入数据），如函数参数、写入操作。</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyActionA</span>&lt;<span class="title">T</span>&gt;(<span class="params">T param</span>)</span>;<span class="comment">//不支持逆变与协变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyActionB</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T param</span>)</span>;<span class="comment">//支持逆变</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPlayA</span>&lt;<span class="title">T</span>&gt; &#123; &#125;<span class="comment">//不支持逆变与协变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPlayB</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt; &#123; &#125;<span class="comment">//支持逆变</span></span><br><span class="line"> </span><br><span class="line">MyActionA&lt;<span class="built_in">object</span>&gt; actionAObject = <span class="literal">null</span>;</span><br><span class="line">MyActionA&lt;<span class="built_in">string</span>&gt; actionAString = <span class="literal">null</span>;</span><br><span class="line">MyActionB&lt;<span class="built_in">object</span>&gt; actionBObject = <span class="literal">null</span>;</span><br><span class="line">MyActionB&lt;<span class="built_in">string</span>&gt; actionBString = <span class="literal">null</span>;</span><br><span class="line">actionAString = actionAObject;<span class="comment">//MyActionA不支持逆变与协变,编译失败</span></span><br><span class="line">actionBString = actionBObject;<span class="comment">//变了，逆变</span></span><br><span class="line"> </span><br><span class="line">IPlayA&lt;<span class="built_in">object</span>&gt; playAObject = <span class="literal">null</span>;</span><br><span class="line">IPlayA&lt;<span class="built_in">string</span>&gt; playAString = <span class="literal">null</span>;</span><br><span class="line">IPlayB&lt;<span class="built_in">object</span>&gt; playBObject = <span class="literal">null</span>;</span><br><span class="line">IPlayB&lt;<span class="built_in">string</span>&gt; playBString = <span class="literal">null</span>;</span><br><span class="line">playAString = playAObject;<span class="comment">//IPlayA不支持逆变与协变,编译失败</span></span><br><span class="line">playBString = playBObject;<span class="comment">//变了，逆变</span></span><br></pre></td></tr></table></figure><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> <strong>注意:</strong></h1><ul><li>当前仅支持接口和委托的逆变与协变 ，不支持类和方法。但数组也有协变性。</li><li>值类型不参与逆变与协变。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">Test</span>(<span class="params">T param</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sub</span>&lt;<span class="title">T</span>&gt; : <span class="title">Base</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Test</span>(<span class="params">T param</span>)</span> &#123; <span class="keyword">return</span> <span class="literal">default</span>(T); &#125;</span><br><span class="line">&#125;</span><br><span class="line">Base&lt;<span class="built_in">string</span>&gt; b = <span class="keyword">new</span> Sub&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">b.Test(<span class="string">&quot;你好&quot;</span>);</span><br></pre></td></tr></table></figure><p>在上面的例子中，b里面的实例是<code>Sub&lt;string&gt;</code> <code>b.Test(&quot;你好&quot;)</code>会把参数 “你好” 传入到Sub里面执行方法<br /><img src="/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/file-20250301104738051.png" alt="" /></p><p><strong>即调用父类的方法，其实实际是调用子类的方法。</strong><br />可以看到，这个方法能够安全的调用，需要两个条件：</p><ol><li>变式（父）的方法参数能安全转为原式（子）的参数；</li><li>原式（子）的返回值能安全的转为变式的返回值。</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base&lt;<span class="built_in">object</span>&gt; BaseObject = <span class="literal">null</span>;</span><br><span class="line">Base&lt;<span class="built_in">string</span>&gt; BaseString = <span class="literal">null</span>;</span><br><span class="line">BaseObject = BaseString;<span class="comment">//编译失败</span></span><br><span class="line">BaseObject.Test(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里的“实际流程”如下，可以看到，参数那里是object是不能安全转换为string，所以编译失败：<br /><img src="/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/file-20250301105137915.png" alt="" /></p><p>看到这里如果都明白的话，我们不难得到逆变与协变的”实际流程图”（记住，它们是有in/out限制的）:<br /><img src="/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/file-20250301105254234.png" alt="" /></p><h1 id="稍微难一点的问题"><a class="markdownIt-Anchor" href="#稍微难一点的问题"></a> 稍微难一点的问题</h1><p>下面哪个正确？</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBar</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt; &#123; &#125;</span><br><span class="line"><span class="comment">//应该是in</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFoo</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params">IBar&lt;T&gt; bar</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//还是out</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IFoo</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params">IBar&lt;T&gt; bar</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是，如果是in的话，会编译失败，out才正确（当然不要泛型修饰符也能通过编译，但IFoo就没有协变能力了）。<br />这里的意思就是说，一个有协变（逆变）能力的泛型（IBar），作为另一个泛型（IFoo）的参数时，影响到了它（IFoo）的泛型的定义。乍一看以为是in的其中一个陷阱是T是在Test方法的参数里的，所以以为是in。但<strong>这里Test的参数根本不是T，而是<code>IBar&lt;T&gt;</code></strong>。</p><p><img src="/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/file-20250301105647504.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lemontea/archive/2013/02/17/2915065.html&quot;&gt;逆变与协变详解 - zhangweiwen - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;协变和逆变是用来修</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>csharp事件</title>
    <link href="http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E4%BA%8B%E4%BB%B6/"/>
    <id>http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E4%BA%8B%E4%BB%B6/</id>
    <published>2025-02-28T11:31:10.000Z</published>
    <updated>2025-03-01T03:26:04.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是事件"><a class="markdownIt-Anchor" href="#什么是事件"></a> <strong>什么是事件？</strong></h1><p>事件的核心是：<strong>当某件事发生时，自动通知所有关心它的人</strong>。<br />在 C# 中，事件是一种机制，允许一个对象（发布者）在特定动作发生时，通知其他对象（订阅者）执行某些代码。</p><h1 id="事件的核心三要素"><a class="markdownIt-Anchor" href="#事件的核心三要素"></a> <strong>事件的核心三要素</strong></h1><ol><li><strong>发布者（Publisher）</strong>：定义事件并触发它</li><li><strong>订阅者（Subscriber）</strong>：注册事件处理方法</li><li><strong>事件处理方法（Handler）</strong>：当事件发生时执行的代码</li></ol><h1 id="游戏开发高频场景"><a class="markdownIt-Anchor" href="#游戏开发高频场景"></a> <strong>游戏开发高频场景</strong></h1><table><thead><tr><th><strong>场景</strong></th><th><strong>事件用法</strong></th><th><strong>代码灵魂示例</strong></th></tr></thead><tbody><tr><td><strong>角色受伤</strong></td><td>触发UI血条更新、音效、伤害数字</td><td><code>player.OnHurt += UpdateHealthBar;</code></td></tr><tr><td><strong>敌人死亡</strong></td><td>触发掉落物品、任务进度更新、成就解锁</td><td><code>enemy.OnDeath += DropLoot;</code></td></tr><tr><td><strong>技能释放</strong></td><td>触发特效、冷却计时、连击计数</td><td><code>skill.OnCast += PlayVFX;</code></td></tr><tr><td><strong>游戏状态切换</strong></td><td>暂停/继续、关卡加载完成、游戏结束</td><td><code>GameManager.OnPause += FreezeEnemies;</code></td></tr><tr><td><strong>UI交互</strong></td><td>按钮点击、菜单打开/关闭、道具拖动</td><td><code>button.OnClick += OpenInventory;</code></td></tr></tbody></table><h1 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h1><p><strong>角色受伤</strong>触发UI血条更新、音效、伤害数字</p><h2 id="第一步定义事件参数类传递伤害值"><a class="markdownIt-Anchor" href="#第一步定义事件参数类传递伤害值"></a> 第一步：定义事件参数类（传递伤害值）</h2><p><strong>为什么事件参数要继承 <code>EventArgs</code>？</strong></p><ul><li>这是一个约定，保持代码统一性。</li><li>如果需要传递数据，推荐使用自定义的 <code>EventArgs</code> 子类。</li><li><strong>EventArgs 作用</strong>：<br />通过自定义参数类，把伤害值传递给所有监听者，避免每个系统单独查询角色状态</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DamageEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Damage &#123; <span class="keyword">get</span>; &#125; <span class="comment">// 需要传递的伤害值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DamageEventArgs</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二步创建角色类事件发布者"><a class="markdownIt-Anchor" href="#第二步创建角色类事件发布者"></a> 第二步：创建角色类（事件发布者）</h2><p><strong><code>EventHandler&lt;T&gt;</code> 委托</strong></p><ul><li>是 .NET 内置的泛型委托，无需自己定义。</li><li>签名：<code>void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e)</code>。</li><li><code>sender</code>：触发事件的对象（通常是发布者自己）。</li><li><code>e</code>：事件参数（传递额外数据）。</li><li>事件名称以 <code>On</code> 开头（如 <code>OnClick</code>）。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明事件（使用自定义的EventArgs）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;DamageEventArgs&gt; Damaged;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件的通用写法</span></span><br><span class="line">        OnDamaged(<span class="keyword">new</span> DamageEventArgs(damage));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDamaged</span>(<span class="params">DamageEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Damaged?.Invoke(<span class="keyword">this</span>, e);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步创建各种事件订阅者"><a class="markdownIt-Anchor" href="#第三步创建各种事件订阅者"></a> 第三步：创建各种事件订阅者</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UI血条控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIHealthBar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 别人sender发来通知，并携带了e的参数，你要做的事如下： 更新血条</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCharacterDamaged</span>(<span class="params"><span class="built_in">object</span> sender, DamageEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UpdateHealthBar(e.Damage);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;血条更新：减少<span class="subst">&#123;e.Damage&#125;</span>HP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateHealthBar</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span> &#123; <span class="comment">/* 实际血条逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音效系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SoundSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 别人sender发来通知，并携带了e的参数，你要做的事如下： 播放受伤音效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayHurtSound</span>(<span class="params"><span class="built_in">object</span> sender, DamageEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Audio.Play(<span class="string">&quot;受伤音效&quot;</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;播放受伤音效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伤害数字系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DamageNumbers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 别人sender发来通知，并携带了e的参数，你要做的事如下： 显示上海数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowDamagePopup</span>(<span class="params"><span class="built_in">object</span> sender, DamageEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreateFloatingText(e.Damage);</span><br><span class="line">        Debug.Log(<span class="string">$&quot;显示伤害数字：<span class="subst">&#123;e.Damage&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateFloatingText</span>(<span class="params"><span class="built_in">int</span> damage</span>)</span> &#123; <span class="comment">/* 数字弹窗逻辑 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第四步连接事件订阅"><a class="markdownIt-Anchor" href="#第四步连接事件订阅"></a> 第四步：连接事件订阅</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化所有对象</span></span><br><span class="line">Character player = <span class="keyword">new</span> Character();</span><br><span class="line">UIHealthBar ui = <span class="keyword">new</span> UIHealthBar();</span><br><span class="line">SoundSystem sound = <span class="keyword">new</span> SoundSystem();</span><br><span class="line">DamageNumbers numbers = <span class="keyword">new</span> DamageNumbers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件（+= 添加监听）</span></span><br><span class="line">player.Damaged += ui.OnCharacterDamaged;</span><br><span class="line">player.Damaged += sound.PlayHurtSound;</span><br><span class="line">player.Damaged += numbers.ShowDamagePopup;</span><br></pre></td></tr></table></figure><h2 id="第五步触发事件"><a class="markdownIt-Anchor" href="#第五步触发事件"></a> 第五步：触发事件</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当玩家受到伤害时</span></span><br><span class="line">player.TakeDamage(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 血条更新：减少50HP</span></span><br><span class="line"><span class="comment">// 播放受伤音效</span></span><br><span class="line"><span class="comment">// 显示伤害数字：50</span></span><br></pre></td></tr></table></figure><h1 id="事件与委托的区别"><a class="markdownIt-Anchor" href="#事件与委托的区别"></a> 事件与委托的区别</h1><table><thead><tr><th><strong>特性</strong></th><th><strong>委托（Delegate）</strong></th><th><strong>事件（Event）</strong></th></tr></thead><tbody><tr><td><strong>访问权限</strong></td><td>可直接调用或赋值（<code>=</code>）</td><td>只能在类内部触发（<code>Invoke</code>）</td></tr><tr><td><strong>多播（Multicast）</strong></td><td>支持（<code>+=</code>/<code>-=</code>）</td><td>支持（本质是委托的封装）</td></tr><tr><td><strong>封装性</strong></td><td>低（外部可任意修改委托链）</td><td>高（外部只能订阅/取消订阅）</td></tr><tr><td><strong>典型用途</strong></td><td>通用回调机制</td><td>发布-订阅模式的通知机制</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是事件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是事件&quot;&gt;&lt;/a&gt; &lt;strong&gt;什么是事件？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;事件的核心是：&lt;strong&gt;当某件事发生时，自动通知所有关心它的人&lt;/strong&gt;。&lt;</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>csharp表达式体</title>
    <link href="http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93/"/>
    <id>http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93/</id>
    <published>2025-02-28T10:17:19.000Z</published>
    <updated>2025-02-28T10:32:37.134Z</updated>
    
    <content type="html"><![CDATA[<p>表达式体（Expression-bodied members）是 C# 6.0 及更高版本引入的特性，它允许用简洁的 <code>=&gt;</code> 语法替代传统代码块，适用于方法、属性、构造函数等成员。</p><p><strong>注意</strong>：<br /><strong><a href="/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="csharp的Lambda表达式">csharp的Lambda表达式</a>（核心是创建匿名函数）</strong><br /><strong>表达式体成员（核心是简写方法体）</strong></p><h1 id="综合示例"><a class="markdownIt-Anchor" href="#综合示例"></a> <strong>综合示例</strong></h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span><br><span class="line">    <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Model =&gt; <span class="string">&quot;Scientific-Calculator-3000&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">Square</span>(<span class="params"><span class="built_in">double</span> x</span>)</span> =&gt; x * x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span>[] _history = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] =&gt; _history[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span>(<span class="params"><span class="built_in">string</span> model</span>)</span> =&gt; Model = model;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运算符重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Calculator <span class="keyword">operator</span> +(Calculator a, Calculator b) =&gt; </span><br><span class="line">        <span class="keyword">new</span> Calculator(<span class="string">$&quot;<span class="subst">&#123;a.Model&#125;</span>+<span class="subst">&#123;b.Model&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法methods"><a class="markdownIt-Anchor" href="#方法methods"></a> <strong>方法（Methods）</strong></h1><p>用 <code>=&gt;</code> 替代 <code>&#123;&#125;</code>，适用于单行返回值的方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式体写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> =&gt; a + b;</span><br></pre></td></tr></table></figure><h1 id="只读属性read-only-properties"><a class="markdownIt-Anchor" href="#只读属性read-only-properties"></a> <strong>只读属性（Read-Only Properties）</strong></h1><p>直接返回计算结果的属性（仅有 <code>get</code> 访问器）。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> FullName &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="string">$&quot;<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式体写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> FullName =&gt; <span class="string">$&quot;<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="构造函数析构函数c-70"><a class="markdownIt-Anchor" href="#构造函数析构函数c-70"></a> <strong>构造函数/析构函数（C# 7.0+）</strong></h1><p>单行初始化或清理逻辑。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> =&gt; Name = name; <span class="comment">// 初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Resource</span> &#123;</span><br><span class="line">    ~Resource() =&gt; Console.WriteLine(<span class="string">&quot;资源已释放&quot;</span>); <span class="comment">// 清理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="索引器indexers"><a class="markdownIt-Anchor" href="#索引器indexers"></a> <strong>索引器（Indexers）</strong></h1><p>简化索引器的 <code>get</code> 访问器。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>[] _data = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> _data[index]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式体写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] =&gt; _data[index];</span><br></pre></td></tr></table></figure><h1 id="属性访问器c-70"><a class="markdownIt-Anchor" href="#属性访问器c-70"></a> <strong>属性访问器（C# 7.0+）</strong></h1><p>对 <code>get</code> 和 <code>set</code> 访问器分别使用表达式体。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式体写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; _name;</span><br><span class="line">    <span class="keyword">set</span> =&gt; _name = <span class="keyword">value</span> ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="事件访问器c-70"><a class="markdownIt-Anchor" href="#事件访问器c-70"></a> <strong>事件访问器（C# 7.0+）</strong></h1><p>简化事件的 <code>add</code> 和 <code>remove</code> 逻辑。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EventHandler _myEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent &#123;</span><br><span class="line">    <span class="keyword">add</span> &#123; _myEvent += <span class="keyword">value</span>; &#125;</span><br><span class="line">    <span class="keyword">remove</span> &#123; _myEvent -= <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式体写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent &#123;</span><br><span class="line">    <span class="keyword">add</span> =&gt; _myEvent += <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">remove</span> =&gt; _myEvent -= <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载operator-overloading"><a class="markdownIt-Anchor" href="#运算符重载operator-overloading"></a> <strong>运算符重载（Operator Overloading）</strong></h1><p>简化运算符的实现。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> =&gt; (X, Y) = (x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传统运算符重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="keyword">operator</span> +(Vector a, Vector b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector(a.X + b.X, a.Y + b.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式体写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector <span class="keyword">operator</span> +(Vector a, Vector b) =&gt; <span class="keyword">new</span>(a.X + b.X, a.Y + b.Y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="throw-表达式c-70"><a class="markdownIt-Anchor" href="#throw-表达式c-70"></a> <strong><code>throw</code> 表达式（C# 7.0+）</strong></h1><p>直接在表达式中抛出异常。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数校验</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>(<span class="params"><span class="built_in">string</span> input</span>)</span> =&gt; </span><br><span class="line">    input ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(input));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替代传统写法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>(<span class="params"><span class="built_in">string</span> input</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(input));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;表达式体（Expression-bodied members）是 C# 6.0 及更高版本引入的特性，它允许用简洁的 &lt;code&gt;=&amp;gt;&lt;/code&gt; 语法替代传统代码块，适用于方法、属性、构造函数等成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;br </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>csharp的Lambda表达式</title>
    <link href="http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2025-02-28T02:38:33.000Z</published>
    <updated>2025-02-28T10:33:14.120Z</updated>
    
    <content type="html"><![CDATA[<p>在C#中，<strong>Lambda表达式</strong>是一种简洁的<a href="/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95" title="csharp委托">匿名函数</a>，用于创建委托或表达式树类型。</p><h1 id="lambda表达式的基本形式"><a class="markdownIt-Anchor" href="#lambda表达式的基本形式"></a> <strong>Lambda表达式的基本形式</strong></h1><p>Lambda表达式分为两种形式：</p><p><strong>表达式Lambda</strong><br />仅包含单个表达式，无需大括号，自动返回结果。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt; 表达式</span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square = x =&gt; x * x;</span><br><span class="line">Console.WriteLine(square(<span class="number">5</span>)); <span class="comment">// 输出 25</span></span><br></pre></td></tr></table></figure><p><strong>语句块Lambda</strong><br />包含多行语句，需用大括号包裹，显式使用<code>return</code>（若有返回值）。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) =&gt; &#123; </span><br><span class="line">    语句块;</span><br><span class="line">    <span class="keyword">return</span> 结果; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; greet = name =&gt; &#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">$&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出 &quot;Hello, Alice!&quot;</span></span><br></pre></td></tr></table></figure><h1 id="lambda表达式的简写"><a class="markdownIt-Anchor" href="#lambda表达式的简写"></a> Lambda表达式的简写</h1><p>注意和<a href="/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93/" title="csharp表达式体">csharp表达式体</a>的区别</p><h2 id="简化1自动类型推断"><a class="markdownIt-Anchor" href="#简化1自动类型推断"></a> <strong>简化1：自动类型推断</strong></h2><p>当委托类型明确时，参数类型可省略：  <code>(int x) =&gt; ...</code> → <code>x =&gt; ...</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; doubler = (x) =&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简化2单参数可省略括号"><a class="markdownIt-Anchor" href="#简化2单参数可省略括号"></a> <strong>简化2：单参数可省略括号</strong></h2><p>若只有一个参数，<code>()</code>可省略：  <code>(x) =&gt; ...</code> → <code>x =&gt; ...</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; doubler = x =&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简化3单行表达式自动返回"><a class="markdownIt-Anchor" href="#简化3单行表达式自动返回"></a> <strong>简化3：单行表达式自动返回</strong></h2><p>若主体是单行表达式，可省略<code>&#123;&#125;</code>和<code>return</code>：  <code>x =&gt; &#123; return x*2; &#125;</code> → <code>x =&gt; x*2</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; doubler = x =&gt; x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> <strong>注意事项</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多参数必须保留括号：</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt; a + b; <span class="comment">// 正确</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = a, b =&gt; a + b;   <span class="comment">// 错误！</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 无参数时需空括号:</span></span><br><span class="line">Action printHello = () =&gt; Console.WriteLine(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂逻辑仍需代码块：</span></span><br><span class="line">Action log = () =&gt; &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">    <span class="comment">// 多行逻辑</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="lambda的常见用途"><a class="markdownIt-Anchor" href="#lambda的常见用途"></a> <strong>Lambda的常见用途</strong></h1><p>委托实例化  和 事件处理</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; sum = (a, b) =&gt; a + b;</span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; log = msg =&gt; Console.WriteLine(msg);</span><br><span class="line">button.Click += (sender, e) =&gt; MessageBox.Show(<span class="string">&quot;Clicked!&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>LINQ查询</strong><br />与LINQ方法结合，实现数据筛选、转换等操作：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 筛选偶数</span></span><br><span class="line"><span class="keyword">var</span> squares = numbers.Select(x =&gt; x * x);         <span class="comment">// 计算平方</span></span><br></pre></td></tr></table></figure><p><strong>表达式树（Expression Trees）</strong><br />将Lambda编译为表达式树，供其他框架（如EF Core）解析：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; expr = x =&gt; x &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="闭包与变量捕获"><a class="markdownIt-Anchor" href="#闭包与变量捕获"></a> <strong>闭包与变量捕获</strong></h1><p><strong>当匿名函数捕获了外部变量时，C# 编译器会自动生成一个隐藏的类（称为“闭包类”），将捕获的变量“打包”到这个类的实例中。这个实例的生命周期会延长，使得闭包可以在后续继续访问这些变量。</strong></p><p><strong>示例 1：基本闭包</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Func&lt;<span class="built_in">int</span>&gt; <span class="title">CreateCounter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> () =&gt; ++count; <span class="comment">// 闭包捕获了外部变量 count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = CreateCounter();</span><br><span class="line">Console.WriteLine(counter()); <span class="comment">// 输出 1</span></span><br><span class="line">Console.WriteLine(counter()); <span class="comment">// 输出 2（说明闭包修改并保留了 count 的状态）</span></span><br></pre></td></tr></table></figure><ul><li><strong>现象</strong>：<code>count</code> 本应在 <code>CreateCounter</code> 方法执行完毕后被销毁，但闭包保留了它的状态。</li><li><strong>原理</strong>：编译器生成一个类，将 <code>count</code> 作为该类的字段存储，闭包通过这个类的实例访问 <code>count</code>。</li></ul><p><strong>示例 2：循环中的闭包陷阱</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> actions = <span class="keyword">new</span> List&lt;Action&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    actions.Add(() =&gt; Console.WriteLine(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> action <span class="keyword">in</span> actions)</span><br><span class="line">&#123;</span><br><span class="line">    action(); <span class="comment">// 输出 3, 3, 3（而非预期的 0, 1, 2）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>问题原因</strong>：所有闭包共享同一个变量 <code>i</code>（在循环结束后，<code>i</code> 的值为 3）。</li><li><strong>解决方案</strong>：在循环内部创建临时变量，让闭包捕获独立的值：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> current = i; <span class="comment">// 每次循环新建一个临时变量</span></span><br><span class="line">    actions.Add(() =&gt; Console.WriteLine(current)); <span class="comment">// 输出 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C#中，&lt;strong&gt;Lambda表达式&lt;/strong&gt;是一种简洁的&lt;a href=&quot;/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/#%E5%8C%BF</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>csharp委托</title>
    <link href="http://example.com/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/"/>
    <id>http://example.com/2025/02/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A7%94%E6%89%98/</id>
    <published>2025-02-27T14:37:01.000Z</published>
    <updated>2025-03-01T03:21:55.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="委托基本概念"><a class="markdownIt-Anchor" href="#委托基本概念"></a> 委托基本概念</h1><ul><li><strong>定义</strong>：委托是<strong>类型安全的函数指针</strong>，通过 <code>delegate</code> 关键字声明。（ 委托就是一个用来装函数的类的类型）</li><li><strong>作用</strong>：允许将方法作为参数传递、动态调用多个方法。</li><li><strong>核心特点</strong>：<ul><li>类型安全（编译时检查参数和返回值）。</li><li>支持多播（组合多个方法）。</li><li>可用于异步编程。</li></ul></li></ul><h1 id="委托的声明与使用"><a class="markdownIt-Anchor" href="#委托的声明与使用"></a> <strong>委托的声明与使用</strong></h1><p>写在哪里？<br />可以申明在namespace和class语句块中<br />更多的写在<strong>namespace</strong>中</p><p>委托常用在：</p><ol><li>作为类的成员</li><li>作为函数的参数</li></ol><p><strong>声明委托类型</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义委托类型，指定方法签名</span></span><br><span class="line"><span class="comment">// MathOperation是一个委托类型，只能引用接受两个 int 参数并返回 string 的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">MathOperation</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>实例化委托</strong>：<br />eg1：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定到具体方法</span></span><br><span class="line">MathOperation <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br><span class="line">MathOperation multiply = (a, b) =&gt; a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用委托</span></span><br><span class="line"><span class="built_in">int</span> result = <span class="keyword">add</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 输出 8</span></span><br></pre></td></tr></table></figure><p>eg2：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Fun</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MyFun1</span>(<span class="params"><span class="built_in">int</span> a</span>) ...</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">MyFun2</span>(<span class="params"><span class="built_in">int</span> a</span>) ...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Fun f</span> = MyFun1;</span><br><span class="line"><span class="built_in">int</span> tmp = f.Invoke(<span class="number">666</span>);</span><br><span class="line"><span class="built_in">int</span> tmp = f(<span class="number">666</span>);</span><br></pre></td></tr></table></figure><h1 id="多播委托multicast-delegate"><a class="markdownIt-Anchor" href="#多播委托multicast-delegate"></a> <strong>多播委托（Multicast Delegate）</strong></h1><ul><li><strong>功能</strong>：一个委托实例可绑定多个方法，按顺序执行。</li><li><strong>操作符</strong>：<ul><li><code>+=</code> 添加方法。</li><li><code>-=</code> 移除方法。</li></ul></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MathOperation <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br><span class="line">MathOperation multiply = (a, b) =&gt; a * b;</span><br><span class="line">MathOperation operations = <span class="keyword">add</span>;</span><br><span class="line">operations += multiply;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时会依次执行 add 和 multiply</span></span><br><span class="line"><span class="built_in">int</span> finalResult = operations(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 返回 multiply 的结果 15（最后一个方法的返回值）</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：返回值通常只保留最后一个方法的返回值，中间结果可能被覆盖。<br />以下是一个示例，演示了如何获取多播委托每一个函数的返回值：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>()</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegate myDelegate = Method1;</span><br><span class="line">        myDelegate += Method2;</span><br><span class="line">        myDelegate += Method3;</span><br><span class="line">        <span class="comment">// 获取每一个函数的返回值</span></span><br><span class="line">        Delegate[] delegates = myDelegate.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> del <span class="keyword">in</span> delegates)</span><br><span class="line">        &#123;</span><br><span class="line">            MyDelegate singleDelegate = (MyDelegate)del;</span><br><span class="line">            <span class="built_in">int</span> result = singleDelegate();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Method returned: <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Method1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Method2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Method3</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内置泛型委托"><a class="markdownIt-Anchor" href="#内置泛型委托"></a> <strong>内置泛型委托</strong></h1><p><strong><code>Action</code></strong>：无返回值的方法，最多支持 16 个参数。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; log = message =&gt; Console.WriteLine(message);</span><br><span class="line">log(<span class="string">&quot;Hello, Action!&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong><code>Func</code></strong>：有返回值的方法，最后一个类型参数为返回类型。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">string</span>&gt; formatSum = (a, b) =&gt; <span class="string">$&quot;<span class="subst">&#123;a + b&#125;</span>&quot;</span>;</span><br><span class="line">Console.WriteLine(formatSum(<span class="number">3</span>, <span class="number">5</span>)); <span class="comment">// 输出 &quot;8&quot;</span></span><br></pre></td></tr></table></figure><h1 id="匿名方法"><a class="markdownIt-Anchor" href="#匿名方法"></a> <strong>匿名方法</strong></h1><p><strong>匿名函数的使用主要是配合委托和事件进行使用</strong><br />何时使用？</p><ol><li>函数中传递委托参数时</li><li>委托或事件赋值时</li></ol><p>缺点?</p><ol><li>不能删的具体只能无脑null</li></ol><p>eg：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>(<span class="params">Action action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;需要委托作为参数的函数,使用函数更加方便&quot;</span>);</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">GetFun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delegate</span> ()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;匿名函数常用作返回值&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 匿名函数给委托赋值</span></span><br><span class="line">        Action a = <span class="built_in">delegate</span> ()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;匿名函数逻辑&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.Fun1(a); </span><br><span class="line">        t.GetFun()();</span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; b = <span class="built_in">delegate</span> (<span class="built_in">int</span> a)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;匿名函数的返回值直接返回就行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="-swig8-"><a class="markdownIt-Anchor" href="#-swig8-"></a> <a href="/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E4%BA%8B%E4%BB%B6/" title="csharp事件">csharp事件</a></h1><h1 id="-swig9-"><a class="markdownIt-Anchor" href="#-swig9-"></a> <a href="/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="csharp的Lambda表达式">csharp的Lambda表达式</a></h1><h1 id="-swig10-"><a class="markdownIt-Anchor" href="#-swig10-"></a> <a href="/2025/03/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%81%AE%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/" title="泛型委托和泛型接口の协变和逆变">泛型委托和泛型接口の协变和逆变</a></h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;委托基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#委托基本概念&quot;&gt;&lt;/a&gt; 委托基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：委托是&lt;strong&gt;类型安全的函数指针&lt;/strong&gt;，通过 &lt;</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
</feed>
