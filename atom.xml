<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>akiraの博客思密达</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-02-21T14:22:39.717Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>akira23369</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>反射</title>
    <link href="http://example.com/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E5%8F%8D%E5%B0%84/</id>
    <published>2025-02-21T12:55:53.000Z</published>
    <updated>2025-02-21T14:22:39.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csharp源代码到运行时主要阶段"><a class="markdownIt-Anchor" href="#csharp源代码到运行时主要阶段"></a> Csharp源代码到运行时主要阶段</h1><p><img src="/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E5%8F%8D%E5%B0%84/file-20250221205846017.png" alt="" /><br />在 C# 中，从源代码到运行时的整个过程可以分为以下主要阶段：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码(.cs) → 编译 → IL/程序集(.exe/.dll) → CLR加载 → JIT编译 → 本机代码 → 执行</span><br></pre></td></tr></table></figure><h2 id="源代码阶段"><a class="markdownIt-Anchor" href="#源代码阶段"></a> 源代码阶段：</h2><ol><li><strong>编写源代码：</strong> 开发者编写 C# 源代码文件（<code>.cs</code>）。</li></ol><h2 id="编译阶段"><a class="markdownIt-Anchor" href="#编译阶段"></a> 编译阶段：</h2><ol><li><strong>编译：</strong> 使用 C# 编译器（<code>csc.exe</code>）将源代码编译为中间语言（IL，Intermediate Language）代码。生成的文件通常是一个扩展名为 <code>.exe</code>（可执行文件）或 <code>.dll</code>（动态链接库）的程序集。</li><li><strong>生成[[元数据]]：</strong> 编译过程中，生成包含程序集信息的[[元数据]]，包括类型、成员、版本等信息。</li></ol><h2 id="jit-编译阶段"><a class="markdownIt-Anchor" href="#jit-编译阶段"></a> JIT 编译阶段：</h2><ol><li><strong>JIT 编译：</strong> 在运行时，Common Language Runtime（CLR）的 JIT 编译器负责将 IL 代码编译为本地机器代码。这一步是在程序加载到内存时进行的，即时（Just-In-Time）编译。</li></ol><h2 id="执行阶段"><a class="markdownIt-Anchor" href="#执行阶段"></a> 执行阶段：</h2><ol><li><strong>加载程序集：</strong> CLR 加载编译好的程序集，包括 IL 代码和[[元数据]]。</li><li><strong>执行程序：</strong> 程序在 CLR 中执行，JIT 编译器将 IL 代码转换为本地机器代码。执行过程中，CLR 负责内存管理、类型检查、垃圾回收等任务。</li></ol><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><ol><li><strong>开发者阶段：</strong> 编写源代码。</li><li><strong>编译阶段：</strong> 编译源代码生成 IL 代码和[[元数据]]。</li><li><strong>JIT 编译阶段：</strong> 在运行时将 IL 代码编译为本地机器代码。</li><li><strong>执行阶段：</strong> 加载程序集，执行程序，CLR 负责管理运行时环境。</li></ol><p><img src="/2025/02/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/%E5%8F%8D%E5%B0%84/file-20250221210648838.png" alt="" /></p><h2 id="编译-vs-运行"><a class="markdownIt-Anchor" href="#编译-vs-运行"></a> 编译 vs 运行</h2><table><thead><tr><th></th><th>编译期</th><th>运行时</th></tr></thead><tbody><tr><td><strong>发生时间</strong></td><td>发生在构建过程中，源代码被翻译为目标代码或中间代码。</td><td>发生在程序实际运行时，加载到内存并执行。</td></tr><tr><td><strong>可能出现的错误</strong></td><td>静态检查错误，如语法错误、类型错误等。</td><td>动态运行时错误，如空指针引用、除零错误等。</td></tr><tr><td><strong>排查难度</strong></td><td>错误信息清晰，易于定位和修复。</td><td>错误可能更难以排查，需要使用调试工具进行追踪。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th>无运行时</th><th>有运行时</th></tr></thead><tbody><tr><td style="text-align:center"><strong>内存管理</strong></td><td>程序员需要手动管理内存分配和释放。</td><td>运行时环境负责内存管理，可能包括自动内存分配和垃圾回收。</td></tr><tr><td style="text-align:center"><strong>线程模型</strong></td><td>通常依赖操作系统提供的线程机制。</td><td>可能提供自己的线程管理机制，与操作系统的线程模型有一定差异。</td></tr><tr><td style="text-align:center"><strong>系统调用</strong></td><td>直接使用操作系统提供的系统调用接口。</td><td>通过运行时环境提供的接口进行系统调用，可能会屏蔽一些底层细节。</td></tr><tr><td style="text-align:center"><strong>运行效率</strong></td><td>对于底层硬件和操作系统有更直接的控制。</td><td>需要运行时环境的支持，可能引入一些开销。</td></tr></tbody></table><h2 id="动态库-vs-静态库-编译和链接阶段"><a class="markdownIt-Anchor" href="#动态库-vs-静态库-编译和链接阶段"></a> 动态库 vs. 静态库 - 编译和链接阶段：</h2><table><thead><tr><th>阶段</th><th>静态库</th><th>动态库</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>静态库是在编译时被链接到程序的库，代码在程序编译阶段就被静态地合并。</td><td>态库是在运行时加载到内存的库，它的代码在程序执行时被动态地链接。</td></tr><tr><td><strong>文件格式</strong></td><td><code>.lib</code>（Windows）或 <code>.a</code>（Unix/Linux）</td><td><code>.dll</code>（Windows）或 <code>.so</code>（Unix/Linux）</td></tr><tr><td><strong>编译和链接阶段</strong></td><td>静态库的代码在编译时被整合到程序中</td><td>编译时不包含库的代码，只在链接时引用库的符号</td></tr><tr><td><strong>作用</strong></td><td>提供独立的代码副本，每个程序有自己的库的实例，适用于没有外部库的环境</td><td>节省内存，允许在运行时替换库的版本，减小程序的可执行文件大小</td></tr></tbody></table><h2 id="动态库-vs-静态库-区别和使用场景"><a class="markdownIt-Anchor" href="#动态库-vs-静态库-区别和使用场景"></a> 动态库 vs. 静态库 - 区别和使用场景：</h2><table><thead><tr><th>特点</th><th>静态库</th><th>动态库</th></tr></thead><tbody><tr><td><strong>链接方式</strong></td><td>链接在编译时</td><td>链接在运行时</td></tr><tr><td><strong>内存占用</strong></td><td>每个程序有自己的库的实例，可能占用更多内存</td><td>共享内存，多个程序可以共享同一个动态库的实例</td></tr><tr><td><strong>更新和维护</strong></td><td>需要重新编译整个程序，更新较为繁琐</td><td>可在运行时替换库的版本，更容易更新</td></tr><tr><td><strong>可执行文件大小</strong></td><td>可执行文件较大，因为库的代码在编译时合并到可执行文件中</td><td>可执行文件较小，因为库的代码在运行时加载</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h1 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h1><p>程序正在运行时，可以查看其它[[程序集]]或者自身的[[元数据]]。<br />一个<strong>运行的程序查看本身或者其它程序的[[元数据]]的行为</strong>就叫做反射</p><p>在程序运行时，通过反射可以得到其它[[程序集]]或者自己[[程序集]]代码的各种信息<br />类，函数，变量，对象等等，实例化它们，执行它们，操作它们</p><p>exe/dll(主要区别是exe有入口)<br /><strong>metadata</strong>: 描述dll/exe文件的一个 <strong>数据清单</strong><br /><strong>反射</strong>: 用来操作获取[[元数据]]         就是一个操作metadata的一个类库, 用来操作[[元数据]]中的**类, 方法, 属性, [[特性]], **</p><p>为什么通过反射去间接操作?</p><ol><li><strong>我们需要动态</strong>  (这些 “动态” 操作都是在运行时期根据运行时的信息来进行的，而不是在编译时期就确定好的。这使得程序更加灵活，能够处理一些在编译时难以确定的情况。)</li><li><strong>读取私有的对象</strong></li></ol><h2 id="type类的信息类"><a class="markdownIt-Anchor" href="#type类的信息类"></a> Type（类的信息类）</h2><p>它是反射功能的基础！<br />它是访问[[元数据]]的主要方式。<br />使用 Type 的成员获取有关类型声明的信息<br />有关类型的成员（如构造函数、方法、字段、属性和类的[[事件]]）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">32</span>;</span><br><span class="line">Type t1 = a.GetType();</span><br><span class="line">Type t2 = <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line"><span class="comment">// 必须要包含命名空间.类名</span></span><br><span class="line">Type t3 = Type.GetType(<span class="string">&quot;System.Int32&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个类只有一份元数据, 所以上面的t1, t2, t3 指向的是同一个堆空间</span></span><br></pre></td></tr></table></figure><h2 id="获取所有公共成员-getmembers"><a class="markdownIt-Anchor" href="#获取所有公共成员-getmembers"></a> 获取所有公共成员 （GetMembers</h2><p>成员包括：成员变量，成员函数等等</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">string</span> s</span>) : <span class="title">this</span>(<span class="params">i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">MemberInfo[] memberInfos = t.GetMembers();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; memberInfos.Length; i++) Console.WriteLine(memberInfos[i]);</span><br></pre></td></tr></table></figure><h2 id="获取类所有的公共构造函数并调用-getconstructors"><a class="markdownIt-Anchor" href="#获取类所有的公共构造函数并调用-getconstructors"></a> 获取类所有的公共构造函数并调用 （GetConstructors</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有公共构造函数</span></span><br><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得构造函数传入 Type数组 数组中内容按顺序是参数类型</span></span><br><span class="line"><span class="comment">// 执行构造函数传入  object数组 表示按顺序传入的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造获取</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">ConstructorInfo constructorInfo = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line">Test test = constructorInfo.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参构造获取    获取一个参数为int的构造函数</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">ConstructorInfo constructorInfo = t.GetConstructor(<span class="keyword">new</span> Type[<span class="number">1</span>] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line">Test test = constructorInfo.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">1</span>] &#123; <span class="number">666</span> &#125;) <span class="keyword">as</span> Test;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取类所有公共成员变量-getfields"><a class="markdownIt-Anchor" href="#获取类所有公共成员变量-getfields"></a> 获取类所有公共成员变量 （GetFields</h2><p><code>FieldInfo</code> 类是 .NET 反射中的一个类，用于表示和操作类或结构体的字段信息。字段是类或结构体中的成员变量，通常用于存储对象的状态。<code>FieldInfo</code> 类提供了访问字段的[[元数据]]和运行时值的方法。</p><p>以下是一些 <code>FieldInfo</code> 类的常用属性和方法：</p><ol><li><strong>属性：</strong><ul><li><strong>Name:</strong> 获取字段的名称。</li><li><strong>FieldType:</strong> 获取字段的类型。</li><li><strong>IsPublic, IsPrivate, IsStatic, IsInitOnly:</strong> 判断字段的访问修饰符和其他属性。</li><li><strong>DeclaringType:</strong> 获取定义该字段的类的 <code>Type</code> 对象。</li></ul></li><li><strong>方法：</strong><ul><li><strong>GetValue(object obj):</strong> 获取指定对象上的字段值。需要传递目标对象的实例作为参数。</li><li><strong>SetValue(object obj, object value):</strong> 设置指定对象上的字段值。需要传递目标对象的实例和要设置的值作为参数。</li></ul></li></ol><p>以下是一个简单的示例，演示如何使用 <code>FieldInfo</code> 获取和操作字段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到所有公共成员变量</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">FieldInfo[] fieldInfos = t.GetFields();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到指定名称的公共成员</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">FieldInfo fieldInfo = t.GetField(<span class="string">&quot;str&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射 获取其它程序集的对象的某个成员变量的值</span></span><br><span class="line"><span class="comment">// 假设下面的Test是其他程序集new出来的, Test.str = &quot;wocao&quot;</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test(<span class="number">999</span>, <span class="string">&quot;wocao&quot;</span>);</span><br><span class="line">Console.WriteLine(fieldInfo.GetValue(test));    <span class="comment">// 获取到test.str </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射 设置其它程序集的对象的某个成员变量的值   第一个参数是想要通过反射操作的对象!</span></span><br><span class="line">fieldInfo.SetValue(test, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">Console.WriteLine(fieldInfo.GetValue(test));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> PublicField;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> PrivateField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PublicField = <span class="keyword">value</span>;</span><br><span class="line">        PrivateField = <span class="string">&quot;PrivateFieldValue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type myClassType = <span class="keyword">typeof</span>(MyClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字段信息</span></span><br><span class="line">        FieldInfo publicFieldInfo = myClassType.GetField(<span class="string">&quot;PublicField&quot;</span>);</span><br><span class="line">        FieldInfo privateFieldInfo = myClassType.GetField(<span class="string">&quot;PrivateField&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 MyClass 实例</span></span><br><span class="line">        MyClass myObject = <span class="keyword">new</span> MyClass(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取和修改字段的值</span></span><br><span class="line">        <span class="built_in">int</span> publicFieldValue = (<span class="built_in">int</span>)publicFieldInfo.GetValue(myObject);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;PublicField value: <span class="subst">&#123;publicFieldValue&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        privateFieldInfo.SetValue(myObject, <span class="string">&quot;NewPrivateFieldValue&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> privateFieldValue = (<span class="built_in">string</span>)privateFieldInfo.GetValue(myObject);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;PrivateField value: <span class="subst">&#123;privateFieldValue&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取了所有公共成员函数-getmethods"><a class="markdownIt-Anchor" href="#获取了所有公共成员函数-getmethods"></a> 获取了所有公共成员函数 （GetMethods</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有公共成员函数并执行</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(<span class="built_in">string</span>);</span><br><span class="line">MethodInfo[] methodInfos = t.GetMethods();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methodInfos.Length; i++) Console.WriteLine(methodInfos[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取特定名称的公共成员函数</span></span><br><span class="line">MethodInfo methodInfo = t.GetMethod(<span class="string">&quot;Substring&quot;</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行该方法</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是想要通过反射操作的对象 相当于 对象.XX    如果是静态就传 null    </span></span><br><span class="line">str = methodInfo.Invoke(str, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">0</span>, <span class="number">5</span> &#125;) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type myClassType = <span class="keyword">typeof</span>(MyClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有公共方法</span></span><br><span class="line">MethodInfo[] publicMethods = myClassType.GetMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出方法信息</span></span><br><span class="line"><span class="keyword">foreach</span> (MethodInfo methodInfo <span class="keyword">in</span> publicMethods)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Method Name: <span class="subst">&#123;methodInfo.Name&#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Return Type: <span class="subst">&#123;methodInfo.ReturnType&#125;</span>&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取方法的参数信息</span></span><br><span class="line">    ParameterInfo[] parameters = methodInfo.GetParameters();</span><br><span class="line">    Console.Write(<span class="string">&quot;Parameters: &quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (ParameterInfo parameter <span class="keyword">in</span> parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123;parameter.ParameterType&#125;</span> <span class="subst">&#123;parameter.Name&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其它-typegetxxx"><a class="markdownIt-Anchor" href="#其它-typegetxxx"></a> 其它    type.GetXXX</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得枚举</span></span><br><span class="line">GetEnumName</span><br><span class="line">GetEnumNames</span><br><span class="line"></span><br><span class="line"><span class="comment">//得事件</span></span><br><span class="line">GetEvent</span><br><span class="line">GetEvents</span><br><span class="line"></span><br><span class="line"><span class="comment">//得接口</span></span><br><span class="line">GetInterface</span><br><span class="line">GetInterfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">//得属性</span></span><br><span class="line">GetProperty</span><br><span class="line">GetPropertys</span><br><span class="line"><span class="comment">//等等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速通过反射实例化对象-activator"><a class="markdownIt-Anchor" href="#快速通过反射实例化对象-activator"></a> 快速通过反射实例化对象 Activator</h2><p>使用 <code>Activator</code> 类的主要优势在于在运行时创建对象，尤其是当不知道具体类型的情况下。然而，需要注意的是，使用 <code>Activator</code> 可能会导致性能损失，因为它依赖于反射机制。在已知类型的情况下，直接使用 <code>new</code> 操作符通常是更好的选择。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速将Type实例化为对象    无参构造</span></span><br><span class="line">Type t = <span class="keyword">typeof</span>(Test);</span><br><span class="line">Test test = Activator.CreateInstance(t) <span class="keyword">as</span> Test;</span><br><span class="line"><span class="comment">// 有参构造     后面参数如果不对会报错</span></span><br><span class="line">test = Activator.CreateInstance(t, <span class="number">666</span>, <span class="string">&quot;wocao&quot;</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure><h2 id="assembly"><a class="markdownIt-Anchor" href="#assembly"></a> Assembly</h2><p>[[程序集]]类Assembly: 主要用来加载其它[[程序集]]，加载后 才能用Type来使用其它[[程序集]]中的信息<br />如果想要使用不是自己[[程序集]]中的内容 需要先加载[[程序集]] 比如 dll文件(库文件)<br />简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类</p><p>三种加载[[程序集]]的函数:<br />一般用来加载在同一文件下的其它[[程序集]]<br />Assembly asembly2 = Assembly.Load(“[[程序集]]名称”);</p><p>一般用来加载不在同一文件下的其它[[程序集]]<br />Assembly asembly = Assembly.LoadFrom(“包含[[程序集]]清单的文件的名称或路径”);<br />Assembly asembly3 = Assembly.LoadFile(“要加载的文件的完全限定路径”);</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Assembly assembly = Assembly.LoadFrom(<span class="string">@&quot;D:\\Myproject VS\\静态\\bin\\Debug\\net8.0\\test.dll&quot;</span>);</span><br><span class="line">Type[] types = assembly.GetTypes();</span><br><span class="line">Type t = assembly.GetType(<span class="string">&quot;test.Icon&quot;</span>);</span><br><span class="line"></span><br><span class="line">t.XXX</span><br></pre></td></tr></table></figure><h2 id="判断一个类型是否可以让其它类型给自己分配空间-父类装子类-isassignablefrom"><a class="markdownIt-Anchor" href="#判断一个类型是否可以让其它类型给自己分配空间-父类装子类-isassignablefrom"></a> 判断一个类型是否可以让其它类型给自己分配空间  (父类装子类) IsAssignableFrom</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Father</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">Type fatherType = <span class="keyword">typeof</span>(Father);</span><br><span class="line">Type sonType = <span class="keyword">typeof</span>(Son);</span><br><span class="line"><span class="keyword">if</span> (fatherType.IsAssignableFrom(sonType))</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;可以用sonType来给fatherType分配内存&quot;</span>);</span><br><span class="line">Father f = Activator.CreateInstance&lt;Son&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过反射获取泛型类型的-泛型参数参数1-getgenericarguments"><a class="markdownIt-Anchor" href="#通过反射获取泛型类型的-泛型参数参数1-getgenericarguments"></a> 通过反射获取泛型类型的 泛型参数(&lt;参数1, …&gt;) GetGenericArguments</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">string</span>&gt;&gt; dic = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, List&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line">Type dicType = dic.GetType();</span><br><span class="line">Type[] types = dicType.GetGenericArguments();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; types.Length; i++)</span><br><span class="line">Console.WriteLine(types[i]);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;csharp源代码到运行时主要阶段&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#csharp源代码到运行时主要阶段&quot;&gt;&lt;/a&gt; Csharp源代码到运行时主要阶段&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/21/%E7%B</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>4.PlayerPrefs总结</title>
    <link href="http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/</id>
    <published>2025-02-21T12:27:02.000Z</published>
    <updated>2025-02-21T12:27:41.462Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/file-20250221202721966.png" alt="" /></p><p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/file-20250221202731186.png" alt="" /></p><p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.PlayerPrefs%E6%80%BB%E7%BB%93/file-20250221202739818.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5</summary>
      
    
    
    
    <category term="数据" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/tags/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>3.PlayerPrefs不同平台的存储位置</title>
    <link href="http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.PlayerPrefs%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <id>http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.PlayerPrefs%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</id>
    <published>2025-02-21T12:09:14.000Z</published>
    <updated>2025-02-21T12:18:05.485Z</updated>
    
    <content type="html"><![CDATA[<p><strong>PlayerPrefs存储的数据存在哪里？</strong><br />在不同平台上，PlayerPrefs存储的位置会有所不同：</p><h2 id="playerprefs的存储位置"><a class="markdownIt-Anchor" href="#playerprefs的存储位置"></a> PlayerPrefs的存储位置</h2><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows：</h3><p><code>PlayerPrefs</code> 存储在注册表（regedit）中。具体位置为：</p><ul><li>32位系统：<code>HKEY_CURRENT_USER\Software\[公司名]\[产品名]</code></li><li>64位系统：<code>HKEY_CURRENT_USER\Software\WOW6432Node\[公司名]\[产品名]</code></li></ul><h3 id="android"><a class="markdownIt-Anchor" href="#android"></a> Android：</h3><p>在Android上，<code>PlayerPrefs</code> 存储在应用的持久数据目录中。具体路径为：<code>/data/data/[包名]/shared_prefs/unity.[公司名].[产品名]_prefs.xml</code>。</p><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux：</h3><p>在Linux上，<code>PlayerPrefs</code> 存储在用户主目录的 <code>.config/unity3d/[公司名]/[产品名]/prefs</code> 目录中。</p><h3 id="ios"><a class="markdownIt-Anchor" href="#ios"></a> iOS：</h3><p>在iOS上，<code>PlayerPrefs</code> 存储在应用的 <code>Library/Preferences</code> 目录中，文件名是 <code>unity.[公司名].[产品名].plist</code>。</p><h3 id="macos"><a class="markdownIt-Anchor" href="#macos"></a> macOS：</h3><p>在macOS上，<code>PlayerPrefs</code> 存储在用户主目录的 <code>Library/Preferences</code> 目录中，文件名是 <code>unity.[公司名].[产品名].plist</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;PlayerPrefs存储的数据存在哪里？&lt;/strong&gt;&lt;br /&gt;
在不同平台上，PlayerPrefs存储的位置会有所不同：&lt;/p&gt;
&lt;h2 id=&quot;playerprefs的存储位置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    <category term="数据" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/tags/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2.PlayerPrefs基本方法</title>
    <link href="http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.PlayerPrefs%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.PlayerPrefs%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</id>
    <published>2025-02-21T11:49:40.000Z</published>
    <updated>2025-02-21T12:08:14.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="playerprefs是什么"><a class="markdownIt-Anchor" href="#playerprefs是什么"></a> PlayerPrefs是什么</h1><p><code>PlayerPrefs</code>是Unity提供的可以用于存储读取玩家数据的公共类。<br /><code>PlayerPrefs</code>，你可以轻松地存储和获取一些简单的数据，例如玩家的分数、游戏设置、解锁的关卡等。这些数据将在应用程序关闭后仍然保留，可以在下次启动应用程序时继续使用。</p><h1 id="playerprefs的数据存储"><a class="markdownIt-Anchor" href="#playerprefs的数据存储"></a> PlayerPrefs的数据存储</h1><ul><li>PlayerPrefs的数据存储类似于键值对存储，一个键对应一个值。</li><li>提供了存储3种数据的方法 int float string。</li><li>键: string类型。</li><li>值：int float string 对应3种API。</li></ul><h2 id="setint方法-setfloat方法-setstring方法-存储数据"><a class="markdownIt-Anchor" href="#setint方法-setfloat方法-setstring方法-存储数据"></a> SetInt方法 SetFloat方法 SetString方法 存储数据</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置由 key 标识的偏好的值。</span></span><br><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;第几帅&quot;</span>, <span class="number">1</span>);</span><br><span class="line">PlayerPrefs.SetFloat(<span class="string">&quot;存个浮点数&quot;</span>, <span class="number">1.1f</span>);</span><br><span class="line">PlayerPrefs.SetString(<span class="string">&quot;黄&quot;</span>, <span class="string">&quot;先生&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="save方法-马上存储数据到硬盘中"><a class="markdownIt-Anchor" href="#save方法-马上存储数据到硬盘中"></a> Save方法 马上存储数据到硬盘中</h2><p>直接调用Set相关方法只会把数据存到内存里。<br />当游戏结束时 Unity会自动把数据存到硬盘中。<br />如果游戏不是正常结束的而是崩溃 数据是不会存到硬盘中的。<br />调用该方法马上存到硬盘(各个平台默认位置)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.Save();</span><br></pre></td></tr></table></figure><h2 id="playerprefs局限性"><a class="markdownIt-Anchor" href="#playerprefs局限性"></a> PlayerPrefs局限性</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PlayerPrefs是有局限性的 它只能存3种类型的数据。</span></span><br><span class="line"><span class="comment">//如果你想要存储别的类型的数据 只能降低精度 或者上升精度来进行存储。</span></span><br><span class="line"><span class="built_in">bool</span> sex = <span class="literal">true</span>;</span><br><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;sex&quot;</span>, sex ? <span class="number">1</span> : <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="如果不同类型用同一键名进行存储-会进行覆盖"><a class="markdownIt-Anchor" href="#如果不同类型用同一键名进行存储-会进行覆盖"></a> 如果不同类型用同一键名进行存储 会进行覆盖</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;myAge&quot;</span>, <span class="number">18</span>);</span><br><span class="line">PlayerPrefs.SetFloat(<span class="string">&quot;myAge&quot;</span>, <span class="number">20.2f</span>);<span class="comment">//覆盖上一行存储的myAge数据</span></span><br></pre></td></tr></table></figure><h2 id="读取相关"><a class="markdownIt-Anchor" href="#读取相关"></a> 读取相关</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果填了第二个参数代表没找到就返回后的默认值, 可用来进行基础数据的初始化</span></span><br><span class="line"><span class="built_in">string</span> test = PlayerPrefs.GetString(<span class="string">&quot;黄&quot;</span>);     </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>运行时只要你Set了对应键值对 即使你没有马上存储Save在本地 也能够读取出信息</li><li>如果存的是<code>SetInt(&quot;myAge&quot;， 18);</code> 读取的是<code>GetFloat(&quot;myAge&quot;);</code>则会使用Float默认值0</li></ol><h2 id="键的存在与删除"><a class="markdownIt-Anchor" href="#键的存在与删除"></a> 键的存在与删除</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PlayerPrefs.HasKey(<span class="string">&quot;测试&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">// 根据键来删除</span></span><br><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line"><span class="comment">// 删除所有键值对</span></span><br><span class="line">PlayerPrefs.DeleteAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;playerprefs是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#playerprefs是什么&quot;&gt;&lt;/a&gt; PlayerPrefs是什么&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;PlayerPrefs&lt;/code&gt;是Unity提供的可以用</summary>
      
    
    
    
    <category term="数据" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/tags/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>1.PlayerPrefs概述</title>
    <link href="http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/</id>
    <published>2025-02-21T11:42:51.000Z</published>
    <updated>2025-02-21T11:47:56.848Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/file-20250221194522944.png" alt="" /></p><p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/file-20250221194600773.png" alt="" /></p><p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/file-20250221194636919.png" alt="" /></p><p><img src="/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.PlayerPrefs%E6%A6%82%E8%BF%B0/file-20250221194754823.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/02/21/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5</summary>
      
    
    
    
    <category term="数据" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/PlayerPrefs/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
    <category term="数据持久化" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="PlayerPrefs" scheme="http://example.com/tags/PlayerPrefs/"/>
    
    <category term="PlayerPrefs基础知识" scheme="http://example.com/tags/PlayerPrefs%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>34.unity入门基础知识总结</title>
    <link href="http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2025-02-21T08:54:06.000Z</published>
    <updated>2025-02-21T08:56:05.646Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/34.unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/file-20250221165603601.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>33.Microphone麦克风</title>
    <link href="http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.Microphone%E9%BA%A6%E5%85%8B%E9%A3%8E/"/>
    <id>http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/33.Microphone%E9%BA%A6%E5%85%8B%E9%A3%8E/</id>
    <published>2025-02-21T08:21:52.000Z</published>
    <updated>2025-02-21T08:44:22.060Z</updated>
    
    <content type="html"><![CDATA[<p>Unity提供了<code>Microphone</code>类</p><h1 id="获取设备信息"><a class="markdownIt-Anchor" href="#获取设备信息"></a> 获取设备信息</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取设备Microphone信息</span></span><br><span class="line"><span class="built_in">string</span>[] strs = Microphone.devices;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; strs.Length; i++)</span><br><span class="line">    print(strs[i]);</span><br></pre></td></tr></table></figure><h1 id="开始-结束录制并存储"><a class="markdownIt-Anchor" href="#开始-结束录制并存储"></a> 开始, 结束录制并存储</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始录制     (1. 设备名 传null使用默认设备, 2. 超过录制长度是否重新录制</span></span><br><span class="line"><span class="comment">//             (3. 录制时长,    4. 采样率</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">&#123;</span><br><span class="line">    _audioClip = Microphone.Start(<span class="literal">null</span>, <span class="literal">false</span>, <span class="number">10</span>, <span class="number">44100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束录制</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyUp(KeyCode.Space))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 为null表示默认设备</span></span><br><span class="line">    Microphone.End(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 播放录制音频</span></span><br><span class="line">    AudioSource audio = GetComponent&lt;AudioSource&gt;() ?? gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    audio.clip = _audioClip;</span><br><span class="line">    audio.Play();</span><br><span class="line"></span><br><span class="line"><span class="comment">//AudioClip类的channels变量和samples变量</span></span><br><span class="line"><span class="comment">//channels变量 音频剪辑中的声道数。（只读）</span></span><br><span class="line"><span class="comment">//samples变量 样本中音频剪辑的长度。（只读）</span></span><br><span class="line"><span class="comment">//规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度</span></span><br><span class="line">    <span class="built_in">float</span>[] f = <span class="keyword">new</span> <span class="built_in">float</span>[_audioClip.channels * _audioClip.samples];</span><br><span class="line">    <span class="comment">// 把数据存储到浮点数数组里     第二个参数是偏离的位置, 默认填0</span></span><br><span class="line">    _audioClip.GetData(f, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity提供了&lt;code&gt;Microphone&lt;/code&gt;类&lt;/p&gt;
&lt;h1 id=&quot;获取设备信息&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#获取设备信息&quot;&gt;&lt;/a&gt; 获取设备信息&lt;/h1&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>32.AudioSource音频源代码控制</title>
    <link href="http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/32.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/</id>
    <published>2025-02-21T07:58:00.000Z</published>
    <updated>2025-02-21T08:13:34.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码控制播放停止"><a class="markdownIt-Anchor" href="#代码控制播放停止"></a> 代码控制播放停止</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_audioSource = GetComponent&lt;AudioSource&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下p键播放</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.P))</span><br><span class="line">&#123;</span><br><span class="line">    _audioSource.Play();</span><br><span class="line">    <span class="comment">//_audioSource.PlayDelayed(4);    // 4秒后播放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 音频停止</span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.S))</span><br><span class="line">&#123;</span><br><span class="line">    _audioSource.Stop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 音频暂停 </span></span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">&#123;</span><br><span class="line">    _audioSource.Pause();</span><br><span class="line">    <span class="comment">//_audioSource.UnPause();再次播放可恢复 (或者使用停止暂停</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 音量大小</span></span><br><span class="line">audioSource.volume = floatValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否静音</span></span><br><span class="line">audioSource.mute = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="检测播放是否完毕"><a class="markdownIt-Anchor" href="#检测播放是否完毕"></a> 检测播放是否完毕</h1><p>AudioSource没有提供相关</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测音频是否播放完    </span></span><br><span class="line"><span class="keyword">if</span> (!_audioSource.isPlaying)</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">$&quot;在Update中不断检测该属性可以判断是否播放完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制音频播放几种方式"><a class="markdownIt-Anchor" href="#控制音频播放几种方式"></a> 控制音频播放几种方式</h1><ol><li>直接在要播放音频的对象上挂载脚本来控制</li><li>自己创建一个挂载了音频脚本的GameObject(放在prefab预设体里)       用得少<br />在其他脚本中实例化(如果playOnAwake实例化时播放) 这个对象</li><li>用一个AudioSource来控制不同的音效 _audioSource.clip = XXX（AudioClip)</li></ol><p>ps: 注意: 一个GameObject可以挂载多个音频源脚本AudioSource, 但一定要自己管理好, 不然谁是谁都不知道</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码控制播放停止&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#代码控制播放停止&quot;&gt;&lt;/a&gt; 代码控制播放停止&lt;/h1&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="音效系统" scheme="http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>31.AudioSource音频源组件和AudioListener音频监听组件</title>
    <link href="http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/</id>
    <published>2025-02-21T07:31:03.000Z</published>
    <updated>2025-02-21T07:57:18.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加audiosource-音频源脚本"><a class="markdownIt-Anchor" href="#添加audiosource-音频源脚本"></a> 添加AudioSource 音频源脚本</h1><p><img src="/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/file-20250221153408611.png" alt="" /></p><p><img src="/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/file-20250221153449553.png" alt="" /></p><p><img src="/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/file-20250221153553505.png" alt="" /></p><p><img src="/2025/02/21/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/31.AudioSource%E9%9F%B3%E9%A2%91%E6%BA%90%E7%BB%84%E4%BB%B6%E5%92%8CAudioListener%E9%9F%B3%E9%A2%91%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6/file-20250221155703937.png" alt="" /></p><h1 id="audioclip-声音剪辑文件音频文件"><a class="markdownIt-Anchor" href="#audioclip-声音剪辑文件音频文件"></a> AudioClip 声音剪辑文件（音频文件）</h1><ul><li>可以拖拽音频文件到这个变量上</li></ul><h1 id="output-输出"><a class="markdownIt-Anchor" href="#output-输出"></a> Output 输出*</h1><ul><li>默认不设置的话将直接输出到场景中的音频监听器</li><li>可以更改为输出到混音器</li><li>混音器是高级功能，以后再讲解</li></ul><h1 id="mute-静音开关"><a class="markdownIt-Anchor" href="#mute-静音开关"></a> Mute 静音开关</h1><h1 id="bypass-effect-开关滤波器效果"><a class="markdownIt-Anchor" href="#bypass-effect-开关滤波器效果"></a> Bypass Effect 开关滤波器效果*</h1><h1 id="bypass-listener-effects-快速开关所有监听器"><a class="markdownIt-Anchor" href="#bypass-listener-effects-快速开关所有监听器"></a> Bypass Listener Effects 快速开关所有监听器*</h1><h1 id="bypass-reverb-zones-快速开关所有混响区"><a class="markdownIt-Anchor" href="#bypass-reverb-zones-快速开关所有混响区"></a> Bypass Reverb Zones 快速开关所有混响区*</h1><h1 id="play-on-awake-唤醒时播放"><a class="markdownIt-Anchor" href="#play-on-awake-唤醒时播放"></a> Play On Awake 唤醒时播放</h1><ul><li>对象创建时就播放音乐</li><li>开启的话启动游戏默认就播放</li><li>关闭的话启动游戏默认就不播放</li></ul><h1 id="loop-循环"><a class="markdownIt-Anchor" href="#loop-循环"></a> Loop 循环</h1><ul><li>循环播放音乐，一般背景音乐才用</li></ul><h1 id="priority-优先级"><a class="markdownIt-Anchor" href="#priority-优先级"></a> Priority 优先级</h1><ul><li>优先级越高，越不容易被别的音效覆盖</li></ul><h1 id="volume-音量大小"><a class="markdownIt-Anchor" href="#volume-音量大小"></a> Volume 音量大小</h1><h1 id="pitch-音调"><a class="markdownIt-Anchor" href="#pitch-音调"></a> Pitch 音调</h1><ul><li>可以理解为音乐快放满房</li></ul><h1 id="stereo-pan-立体声效"><a class="markdownIt-Anchor" href="#stereo-pan-立体声效"></a> Stereo Pan 立体声效</h1><ul><li>2D声音立体声位置</li><li>相当于左右声道</li></ul><h1 id="spatial-blend-空间混合"><a class="markdownIt-Anchor" href="#spatial-blend-空间混合"></a> Spatial Blend 空间混合</h1><ul><li>音频受3D空间的影响程度，默认是2D音效，拖满为1变成3D音效</li></ul><h1 id="reverb-zone-mix-混响区混音"><a class="markdownIt-Anchor" href="#reverb-zone-mix-混响区混音"></a> Reverb Zone Mix 混响区混音*</h1><ul><li>到混响区的输出信号量</li></ul><h1 id="3d-sound-settings-3d声音设置"><a class="markdownIt-Anchor" href="#3d-sound-settings-3d声音设置"></a> 3D Sound Settings 3D声音设置</h1><ul><li>和Spatial Blend参数成正比应用</li><li>Doppler Level 多普勒效果等级</li><li>Spread 扩张<ul><li>扩散角度设置为3D立体声还是多声道</li></ul></li><li>Volume Rolloff 音量衰减<ul><li>声音衰减速度，蓝线横轴可以理解为离耳朵的远近，红线纵轴可以理解为声音大小，耳朵可以理解为AudioListener音频监听脚本</li><li>Logarithmic Rolloff 对数衰减<ul><li>靠近音频源时，声音很大，但离开对象时，声音降低得非常快。</li></ul></li><li>Linear Rolloff 线性衰减<ul><li>与音频源的距离越远，听到的声音越小。</li></ul></li><li>Custom Rolloff 自定义衰减<ul><li>音频源的音频效果是根据曲线图的设置变化的。</li></ul></li></ul></li><li>Min/Max Distance 最大最小距离<ul><li>最小距离内，声音保持最大响度</li><li>最大距离外，声音开始减弱</li></ul></li></ul><h1 id="audiolistener-音频监听脚本"><a class="markdownIt-Anchor" href="#audiolistener-音频监听脚本"></a> AudioListener 音频监听脚本</h1><ul><li>默认挂载到场景的主摄像机上，可以理解为是我们的耳朵</li><li>有且只有一个，两个把另外一个要移除</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;添加audiosource-音频源脚本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#添加audiosource-音频源脚本&quot;&gt;&lt;/a&gt; 添加AudioSource 音频源脚本&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/21</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="音效系统" scheme="http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>30.音频文件导入</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/</id>
    <published>2025-02-20T15:03:03.000Z</published>
    <updated>2025-02-20T15:14:04.577Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/30.%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5/file-20250220230421751.png" alt="" /></p><h1 id="音频文件常用格式"><a class="markdownIt-Anchor" href="#音频文件常用格式"></a> 音频文件常用格式</h1><ul><li>wav</li><li>mp3</li><li>ogg</li><li>aiff    （不常用）</li></ul><h1 id="导入音频文件"><a class="markdownIt-Anchor" href="#导入音频文件"></a> 导入音频文件</h1><p>导入音频文件直接从外部拖拽音频文件到Project窗口即可</p><h1 id="force-to-mono-强制变为单声道"><a class="markdownIt-Anchor" href="#force-to-mono-强制变为单声道"></a> Force To Mono 强制变为单声道</h1><ul><li>多声道转单声道</li><li>Normalize 归一化<ul><li>强制为单声道时，混合过程中被标准化</li></ul></li></ul><h1 id="load-in-background-后台加载"><a class="markdownIt-Anchor" href="#load-in-background-后台加载"></a> Load In Background 后台加载</h1><p>在后台加载，不阻塞主线程</p><h1 id="ambisonic-全景声音"><a class="markdownIt-Anchor" href="#ambisonic-全景声音"></a> Ambisonic 全景声音*</h1><ul><li>立体混响声</li><li>非常适合 360 度视频和 XR 应用程序</li><li>如果音频文件包含立体混响声编码的音频，请启用此选项</li></ul><h1 id="loadtype-加载类型"><a class="markdownIt-Anchor" href="#loadtype-加载类型"></a> LoadType 加载类型</h1><ul><li>Decompress On Load 加载时压缩<ul><li>不压缩形式存在内存，加载块，但是内存占用高</li><li>适用于小音效</li></ul></li><li>Compress in memory 压缩内存<ul><li>压缩形式存在内存，加载慢，内存小</li><li>仅适用于较大音效文件</li></ul></li><li>Streaming 流式处理<ul><li>以流形式存在，使用时解码。内存占用最小，cpu消耗高</li><li>性能换内存</li></ul></li></ul><h1 id="preload-audio-data-预加载音频数据"><a class="markdownIt-Anchor" href="#preload-audio-data-预加载音频数据"></a> Preload Audio Data 预加载音频数据</h1><ul><li>预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载</li></ul><h1 id="compression-format-压缩格式"><a class="markdownIt-Anchor" href="#compression-format-压缩格式"></a> Compression Format 压缩格式</h1><ul><li>PCM 音频以最高质量存储</li><li>Vorbis 相对PCM压缩的更小，根据质量决定</li><li>ADPCM 包含噪音，会被多次播放的声音，如碰撞声</li></ul><h1 id="quality-音频质量"><a class="markdownIt-Anchor" href="#quality-音频质量"></a> Quality 音频质量*</h1><ul><li>确定要应用于压缩剪辑的压缩量。</li><li>不适用于 PCM/ADPCM/HEVAG 格式</li></ul><h1 id="sample-rate-setting-采样率设置"><a class="markdownIt-Anchor" href="#sample-rate-setting-采样率设置"></a> Sample Rate Setting 采样率设置*</h1><ul><li>PCM 和 ADPCM 压缩格式允许自动优化或手动降低采样率</li><li>Preserve Sample Rate 保持采样率<ul><li>此设置可保持采样率不变（默认值）</li></ul></li><li>Optimize Sample Rate 优化采样率<ul><li>此设置根据分析的最高频率内容自动优化采样率</li></ul></li><li>Override Sample Rate 覆盖采样率<ul><li>此设置允许手动覆盖采样率 因此可有效地将其用于丢弃频率内容。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="音效系统" scheme="http://example.com/tags/%E9%9F%B3%E6%95%88%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>29.刚体加力</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/</id>
    <published>2025-02-20T12:09:49.000Z</published>
    <updated>2025-02-20T15:00:43.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刚体加力"><a class="markdownIt-Anchor" href="#刚体加力"></a> 刚体加力</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取刚体组件对象</span></span><br><span class="line">rigidbody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加力</span></span><br><span class="line"><span class="comment">// (相对世界坐标系</span></span><br><span class="line">rigidbody.AddForce(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"><span class="comment">//   (相对本地坐标系</span></span><br><span class="line">rigidbody.AddRelativeForce(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加扭矩力</span></span><br><span class="line"><span class="comment">// (世界坐标系      // 没有扭矩阻力会一直动</span></span><br><span class="line">rigidbody.AddTorque(Vector3.up * <span class="number">10</span>);</span><br><span class="line"><span class="comment">// (本地坐标系</span></span><br><span class="line">rigidbody.AddRelativeTorque(Vector3.forward * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变刚体速度       用的少, 位移一般用translate或者给力</span></span><br><span class="line"><span class="comment">// 世界坐标系</span></span><br><span class="line">rigidbody.velocity = Vector3.forward;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟爆炸         在中心产生半径 20m 40的力</span></span><br><span class="line"><span class="comment">// 如果想要所有刚体都产生同样的爆炸效果就必须所有的刚体组件都要调用AddExplosionForce方法</span></span><br><span class="line">rigidbody.AddExplosionForce(<span class="number">40</span>, Vector3.zero, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h1 id="addforce方法第二个参数力的模式"><a class="markdownIt-Anchor" href="#addforce方法第二个参数力的模式"></a> AddForce方法第二个参数力的模式</h1><h2 id="1-forcemodeforce默认模式"><a class="markdownIt-Anchor" href="#1-forcemodeforce默认模式"></a> <strong>1. ForceMode.Force（默认模式）</strong></h2><ul><li><strong>公式</strong>：F * t = m * v</li><li><strong>说明</strong>：<ul><li>力会持续作用，受物体质量（<code>mass</code>）影响，质量越大加速度越小。</li><li>需要乘以 <code>Time.fixedDeltaTime</code> 才能与物理时间步长匹配（Unity 已自动处理）。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推动质量为2kg的物体，每帧施加10N的力</span></span><br><span class="line">rb.AddForce(Vector3.forward * <span class="number">10</span>, ForceMode.Force);</span><br><span class="line"><span class="comment">// 最终加速度 = 10N / 2kg = 5m/s²</span></span><br></pre></td></tr></table></figure><h3 id="2-forcemodeacceleration"><a class="markdownIt-Anchor" href="#2-forcemodeacceleration"></a> <strong>2. ForceMode.Acceleration</strong></h3><ul><li><strong>公式</strong>：F * t = v （m 为 1）</li><li><strong>说明</strong>：<ul><li><strong>直接施加加速度</strong>，忽略物体质量。</li><li>适合需要固定加速度的场景（如模拟重力）。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论质量如何，物体以5m/s²的加速度运动</span></span><br><span class="line">rb.AddForce(Vector3.forward * <span class="number">5</span>, ForceMode.Acceleration);</span><br></pre></td></tr></table></figure><h3 id="3-forcemodeimpulse"><a class="markdownIt-Anchor" href="#3-forcemodeimpulse"></a> <strong>3. ForceMode.Impulse</strong></h3><ul><li><strong>公式</strong>：F = m * v  （t 为 1）</li><li><strong>说明</strong>：<ul><li>瞬间施加一个冲量，效果类似“一次性爆发力”。</li><li>受质量影响，质量越大效果越弱。</li></ul></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 施加一个冲量为100N·s的力（相当于100N的力作用1秒）</span></span><br><span class="line">rb.AddForce(Vector3.up * <span class="number">100</span>, ForceMode.Impulse);</span><br><span class="line"><span class="comment">// 质量为2kg时，速度增量 = 100 / 2 = 50m/s</span></span><br></pre></td></tr></table></figure><h3 id="4-forcemodevelocitychange"><a class="markdownIt-Anchor" href="#4-forcemodevelocitychange"></a> <strong>4. ForceMode.VelocityChange</strong></h3><ul><li><strong>公式</strong>：F = v   （m 为 1， t 为 1）</li><li><strong>说明</strong>：<ul><li><strong>直接修改速度</strong>，忽略质量和时间步长。</li><li>效果类似“瞬间设置速度”。</li></ul></li><li><strong>示例</strong>：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接将物体的Y轴速度增加10m/s（无视质量）</span></span><br><span class="line">rb.AddForce(Vector3.up * <span class="number">10</span>, ForceMode.VelocityChange);</span><br></pre></td></tr></table></figure><h1 id="恒力场组件"><a class="markdownIt-Anchor" href="#恒力场组件"></a> 恒力场组件</h1><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/29.%E5%88%9A%E4%BD%93%E5%8A%A0%E5%8A%9B/file-20250220225644597.png" alt="" /></p><h1 id="刚体的休眠"><a class="markdownIt-Anchor" href="#刚体的休眠"></a> 刚体的休眠</h1><p>Unity为了节约性能，可能会让刚体休眠。<br />比如让一个有刚体的Cube，受重力影响掉落一个平面上。<br />当他们静止时，斜向下旋转刚体，这个时候Cube可能不会往下落，因为Cube休眠了。<br />假如这个时候移动一下平面的位置，Cube可能又会往下落，因为移动平面唤醒了刚体。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsSleeping方法 获取刚体是否处于休眠状态</span></span><br><span class="line"><span class="keyword">if</span> (rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒休眠</span></span><br><span class="line"><span class="keyword">if</span> (rigidBody.IsSleeping())</span><br><span class="line">&#123;</span><br><span class="line">    rigidBody.WakeUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;刚体加力&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#刚体加力&quot;&gt;&lt;/a&gt; 刚体加力&lt;/h1&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>28.碰撞检测之碰撞检测函数</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/</id>
    <published>2025-02-20T11:22:55.000Z</published>
    <updated>2025-02-20T11:50:51.481Z</updated>
    
    <content type="html"><![CDATA[<p>注意:碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用<br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/28.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E5%9B%BE.bmp" alt="" /><br />ps：<br />只要挂载的对象能和其它物体产生碰撞检测才会响应下面的函数<br />如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的，必须挂载到这个刚体父对象上才行。</p><h1 id="物理碰撞检测响应函数"><a class="markdownIt-Anchor" href="#物理碰撞检测响应函数"></a> 物理碰撞检测响应函数</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Collision类   (碰撞信息类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 碰撞到的对象碰撞器的信息</span></span><br><span class="line">Collider collider1 = collision.collider;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 碰撞到的对象的所依附的对象    (GameObject)</span></span><br><span class="line">GameObject gameObject1 = collision.gameObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 碰撞到的对象的transform组件信息</span></span><br><span class="line">Transform transform1 = collision.transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触碰点数相关   接触点具体坐标</span></span><br><span class="line">ContactPoint[] contacts = collision.contacts;</span><br><span class="line"></span><br><span class="line">print(<span class="string">$&quot;我被<span class="subst">&#123;collision.gameObject.name&#125;</span>碰撞到了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 碰撞结束分离时, 自动执行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionExit</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;我和<span class="subst">&#123;collision.gameObject.name&#125;</span>碰撞分离了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个物体相互摩擦时会不停调用该函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionStay</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;我和<span class="subst">&#123;collision.gameObject.name&#125;</span>一直在产生摩擦&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="触发器检测响应函数"><a class="markdownIt-Anchor" href="#触发器检测响应函数"></a> 触发器检测响应函数</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发开始时会自动调用该函数    (传入的是Collider脚本对象)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;我被<span class="subst">&#123;other.gameObject.name&#125;</span>触发了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Stay结束时调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;我被<span class="subst">&#123;other.gameObject.name&#125;</span>结束触发了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两触发器相交会不停调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;我被<span class="subst">&#123;other.gameObject.name&#125;</span>水乳相融&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>碰撞和触发器函数都可以写成虚函数，在子类去重写逻辑</strong></p><ul><li>一般会把想要重写的碰撞和触发检测函数写成protected保护类型的，加上virtual变成虚函数。</li><li>没有必要写成public，因为不会自己手动调用碰撞和触发检测函数，都是Unity通过反射帮助我们自动调用的。</li></ul><h1 id="小练习"><a class="markdownIt-Anchor" href="#小练习"></a> 小练习</h1><p>在之前Input和Screen中的练习题基础上，加入一个点击鼠标左键可以发射一颗子弹飞出的功能</p><p><strong>给坦克添加一个炮口空物体当做子弹飞出来的位置</strong><br /><strong>添加点击飞出子弹代码，创建子弹预设体，拖拽赋值炮口空物体和子弹预设体</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Update内 </span></span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//实例化一个子弹对象 </span></span><br><span class="line">    GameObject obj = Instantiate(bulletObj); </span><br><span class="line">    <span class="comment">//设置对象的位置 </span></span><br><span class="line">    obj.transform.position = bulletPos.position; </span><br><span class="line">    <span class="comment">//设置对象的角度 </span></span><br><span class="line">    obj.transform.eulerAngles = bulletPos.eulerAngles; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子弹一直飞</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Update内 //子弹一直往前飞 </span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);</span><br></pre></td></tr></table></figure><p>加入子弹触碰到地面会自动消失的功能</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//问题一：如果发射子弹时  和坦克自身的碰撞和重合了 可能一开始 就会被移除</span></span><br><span class="line">    <span class="comment">//解决方案：判断自己碰撞到的对象 是什么 一定是特定对象 才移除自己</span></span><br><span class="line">    <span class="keyword">if</span> (other.gameObject.CompareTag(<span class="string">&quot;Ground&quot;</span>) ||</span><br><span class="line">        other.gameObject.CompareTag(<span class="string">&quot;Monster&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//碰撞到别的东西 就让子弹小时</span></span><br><span class="line">        <span class="comment">//一定是移除自己依附的GameObject对象 而不是脚本自己</span></span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题二：坦克本身就带有碰撞盒  当子弹和坦克自身的碰撞盒碰撞可能会产生力的作用 出现一些意想不到的效果</span></span><br><span class="line">    <span class="comment">//解决方案：把子弹做成触发器 这样就没有了力的作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> HP = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子弹碰到我时  就减血 血量为0了 就移除</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//由于场景上 只有子弹时触发器 所以我们可以不用进行任何判断 就可以完成这个功能</span></span><br><span class="line">    <span class="comment">//减血</span></span><br><span class="line">    HP -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//为0就移除自己</span></span><br><span class="line">    <span class="keyword">if</span> (HP &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注意:碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用&lt;br /&gt;
&lt;img src=&quot;/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>27.碰撞检测之物理材质</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/</id>
    <published>2025-02-20T11:15:21.000Z</published>
    <updated>2025-02-20T11:22:12.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建物理材质"><a class="markdownIt-Anchor" href="#创建物理材质"></a> 创建物理材质</h1><ul><li>在Project窗口加号创建或者右键创建</li><li>把物理材质拖拽到两个碰撞器上才能相互作用<br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/27.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8/file-20250220191639388.png" alt="" /></li></ul><h1 id="物理材质参数"><a class="markdownIt-Anchor" href="#物理材质参数"></a> 物理材质参数</h1><h2 id="dynamic-friction-动摩擦力"><a class="markdownIt-Anchor" href="#dynamic-friction-动摩擦力"></a> Dynamic Friction 动摩擦力</h2><ul><li>已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。</li></ul><h2 id="static-friction-静摩擦力"><a class="markdownIt-Anchor" href="#static-friction-静摩擦力"></a> Static Friction 静摩擦力</h2><ul><li>当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。</li></ul><h2 id="bounciness-弹性"><a class="markdownIt-Anchor" href="#bounciness-弹性"></a> Bounciness 弹性</h2><ul><li>表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。</li></ul><h2 id="friction-combine-摩擦力组合"><a class="markdownIt-Anchor" href="#friction-combine-摩擦力组合"></a> Friction Combine 摩擦力组合</h2><ul><li>两个碰撞对象的摩擦力的组合方式。<ol><li>Average 对两个摩擦值求平均值。</li><li>Minimum 使用两个值中的最小值。</li><li>Maximum 使用两个值中的最大值。</li><li>Multiply 两个摩擦值相乘。</li></ol></li></ul><h2 id="bounce-combine-反弹组合"><a class="markdownIt-Anchor" href="#bounce-combine-反弹组合"></a> Bounce Combine 反弹组合</h2><ul><li>两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同。<ol><li>Average 对两个摩擦值求平均值。</li><li>Minimum 使用两个值中的最小值。</li><li>Maximum 使用两个值中的最大值。</li><li>Multiply 两个摩擦值相乘。</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建物理材质&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#创建物理材质&quot;&gt;&lt;/a&gt; 创建物理材质&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在Project窗口加号创建或者右键创建&lt;/li&gt;
&lt;li&gt;把物理材质拖拽到两个碰撞器上才能相互作用&lt;br </summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>26.碰撞检测之碰撞器</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/</id>
    <published>2025-02-20T10:39:05.000Z</published>
    <updated>2025-02-20T11:11:29.063Z</updated>
    
    <content type="html"><![CDATA[<p><strong>知识回顾</strong><br />两个物体都有碰撞器，至少一个物体有刚体<br />碰撞器表示物体的体积（形状）<br />刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用</p><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/file-20250220184701670.png" alt="" /></p><h1 id="3d碰撞器种类"><a class="markdownIt-Anchor" href="#3d碰撞器种类"></a> 3D碰撞器种类</h1><p>1.盒状 2.球状 3.胶囊 4.网格 5.轮胎 6.地形</p><h1 id="共同参数"><a class="markdownIt-Anchor" href="#共同参数"></a> 共同参数</h1><h2 id="edit-collider-编辑碰撞器"><a class="markdownIt-Anchor" href="#edit-collider-编辑碰撞器"></a> Edit Collider 编辑碰撞器</h2><p>改变碰撞体大小</p><h2 id="is-trigger-是否是触发器"><a class="markdownIt-Anchor" href="#is-trigger-是否是触发器"></a> Is Trigger 是否是触发器</h2><ul><li>如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略</li><li>主要用于进行没有物理效果的碰撞检测</li></ul><h2 id="material-物理材质"><a class="markdownIt-Anchor" href="#material-物理材质"></a> Material 物理材质*</h2><ul><li>可以确定碰撞体和其它对象碰撞时的交互（表现）方式。</li></ul><h2 id="center-碰撞器中心"><a class="markdownIt-Anchor" href="#center-碰撞器中心"></a> Center 碰撞器中心</h2><ul><li>碰撞体在对象局部空间中的中心点位置</li></ul><h1 id="常用碰撞器"><a class="markdownIt-Anchor" href="#常用碰撞器"></a> 常用碰撞器</h1><h2 id="boxcollider-盒状碰撞器"><a class="markdownIt-Anchor" href="#boxcollider-盒状碰撞器"></a> BoxCollider 盒状碰撞器</h2><ul><li>Size 大小：碰撞体在X、Y、Z方向上的大小</li></ul><h2 id="sphere-collider-球状碰撞器"><a class="markdownIt-Anchor" href="#sphere-collider-球状碰撞器"></a> Sphere Collider 球状碰撞器</h2><ul><li>Radius 半径：球形碰撞体的半径大小</li></ul><h2 id="capsule-collider-胶囊碰撞器"><a class="markdownIt-Anchor" href="#capsule-collider-胶囊碰撞器"></a> Capsule Collider 胶囊碰撞器</h2><ul><li>Radius 半径：胶囊体的半径</li><li>Height 高度：胶囊体的高度</li><li>Direction 轴向：胶囊体在对象局部空间中的轴向</li></ul><h1 id="异形物体使用多种碰撞器组合"><a class="markdownIt-Anchor" href="#异形物体使用多种碰撞器组合"></a> 异形物体使用多种碰撞器组合</h1><ul><li>刚体对象的子对象碰撞器信息参与碰撞检测</li><li>比如金字塔预设体，只在金字塔最高层级对象添加刚体，子对象的所有Cube都会参与碰撞检测</li><li>再比如一个Cube添加刚体，再给他添加两个空物体，两个空物体分别添加斜着的盒型碰撞器当做支架，这样这个Cube下落时就会被支架撑起来，即便两个空物体连模型都没有只有碰撞器</li></ul><h1 id="不常用碰撞器"><a class="markdownIt-Anchor" href="#不常用碰撞器"></a> 不常用碰撞器*</h1><h2 id="mesh-collider-网格碰撞器"><a class="markdownIt-Anchor" href="#mesh-collider-网格碰撞器"></a> Mesh Collider 网格碰撞器*</h2><ul><li>不常用的原因是性能消耗较高</li><li>默认不会显示绿色的碰撞器边框，开启Convex 才会显示绿色的碰撞器边框</li><li>Convex Mesh Collider 最多 255 个三角形。</li></ul><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/file-20250220190918454.png" alt="" /></p><h2 id="wheel-collider-轮胎碰撞器"><a class="markdownIt-Anchor" href="#wheel-collider-轮胎碰撞器"></a> Wheel Collider 轮胎碰撞器*</h2><ul><li>可以通过给车的父对象加刚体（注意刚体质量一定要大），子对象加车轮碰撞器模拟汽车</li></ul><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/26.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E7%A2%B0%E6%92%9E%E5%99%A8/file-20250220190955289.png" alt="" /></p><h2 id="terrain-collider-地形碰撞器"><a class="markdownIt-Anchor" href="#terrain-collider-地形碰撞器"></a> Terrain Collider 地形碰撞器*</h2><ul><li>不常用的原因是性能消耗很高</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;知识回顾&lt;/strong&gt;&lt;br /&gt;
两个物体都有碰撞器，至少一个物体有刚体&lt;br /&gt;
碰撞器表示物体的体积（形状）&lt;br /&gt;
刚体会利用体积进行碰撞计算，模拟真实的碰撞效果，产生力的作用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/20/%E</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>25.碰撞检测之刚体</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/</id>
    <published>2025-02-20T09:28:06.000Z</published>
    <updated>2025-02-20T10:21:59.657Z</updated>
    
    <content type="html"><![CDATA[<p><strong>碰撞产生的必要条件</strong>：两个物体都有碰撞器，至少一个物体有刚体</p><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/file-20250220175255335.png" alt="" /></p><p>RigidBody组件信息如下<br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/file-20250220180007874.png" alt="" /></p><h1 id="mass-质量"><a class="markdownIt-Anchor" href="#mass-质量"></a> <strong>Mass 质量</strong></h1><ul><li>默认为千克</li><li>质量越大惯性越大</li></ul><h1 id="drag-空气阻力"><a class="markdownIt-Anchor" href="#drag-空气阻力"></a> <strong>Drag 空气阻力</strong></h1><ul><li>根据力移动对象时影响对象的空气阻力大小，0 表示没有空气阻力</li></ul><h1 id="angular-drag-角阻力扭矩阻力"><a class="markdownIt-Anchor" href="#angular-drag-角阻力扭矩阻力"></a> <strong>Angular Drag 角阻力（扭矩阻力）</strong></h1><ul><li>通俗理解就是阻碍对象旋转的阻力，角阻力越大越不容易旋转</li><li>0 表示没有空气阻力。</li></ul><h1 id="use-gravity-重力开关"><a class="markdownIt-Anchor" href="#use-gravity-重力开关"></a> <strong>Use Gravity 重力开关</strong></h1><ul><li>是否受重力影响</li></ul><h1 id="is-kinematic"><a class="markdownIt-Anchor" href="#is-kinematic"></a> <strong>Is Kinematic</strong></h1><ul><li>控制物理是否影响刚体。</li><li>可以理解为开启后不受力的影响，只能通过Transform移动</li><li>如果启用此选项，则对象将不会被物理引擎驱动，只能通过 (Transform) 对其进行操作。对于移动平台，或者如果要动画化附加了 HingeJoint 的刚体，此属性将非常有用。</li></ul><h1 id="interpolate-插值运算"><a class="markdownIt-Anchor" href="#interpolate-插值运算"></a> <strong>Interpolate 插值运算</strong></h1><ul><li>让刚体物体移动更平滑</li><li>可以更改FixTime，改成一秒，这样对象会很突兀的一秒移动一次，这时开启插值运算就可以让刚体对象平滑移动</li></ul><ol><li>None 无插值运算模式<ul><li>不应用插值运算</li></ul></li><li>Interpolate 插值模式<ul><li>插值将始终滞后一点，但比外推更流畅。</li><li>根据前一帧的变换来平滑变换。</li></ul></li><li>Extrapolate 外推模式<ul><li>外推将根据当前速度预测刚体的位置。</li><li>根据下一帧的估计变换来平滑变换。</li></ul></li></ol><h1 id="collision-detection-碰撞检测模式"><a class="markdownIt-Anchor" href="#collision-detection-碰撞检测模式"></a> <strong>Collision Detection 碰撞检测模式</strong></h1><blockquote><p>Continuous Dynamic 连续动态检测 <strong>&gt;</strong> Continuous Speculative 连续推测检测 <strong>&gt;</strong> Continuous 连续检测 <strong>&gt;</strong> Discrete 离散检测</p></blockquote><ul><li>用于防止快速移动的对象穿过其它对象而不检测碰撞</li></ul><ol><li>Discrete 离散检测<ul><li>默认的碰撞检测模式。</li><li>在每一帧中进行一次碰撞检测，适用于大多数普通物体。</li><li>最省性能，但可能会错过高速物体的碰撞。</li><li>适合一般速度移动的物体，不适合高速移动的小物体。</li><li>对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值）</li></ul></li><li>Continuous 连续检测<ul><li>提高了碰撞检测的精度，特别适合高速移动的物体。</li><li>在每一帧中进行多次碰撞检测，避免高速物体穿过其他物体。</li><li>比 <code>Discrete</code> 消耗更多的性能，但减少了穿透问题。</li><li>适用于高速移动的物体，如子弹或快速飞行的物体。</li><li>对动态碰撞体（具有刚体）使用离散碰撞检测，并对静态碰撞体（没有刚体）使用连续碰撞检测。</li><li>设置为连续动态 (Continuous Dynamic) 的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为 Discrete 设置）</li><li>其他刚体将使用离散碰撞检测。</li></ul></li><li>Continuous Dynamic 连续动态检测<ul><li>针对快速移动的物体和其他静止或缓慢移动的物体之间的碰撞检测。</li><li>结合 <code>Continuous</code> 和 <code>Discrete</code> 的优点，对高速物体进行多次检测，对慢速或静止物体进行一次检测。</li><li>在保证精度的同时比 <code>Continuous</code> 更省性能。</li><li>适用于快速移动的物体与静止或缓慢移动的物体之间的碰撞检测，如快速移动的角色或车辆。</li><li>性能消耗高</li><li>对设置为连续 (Continuous)和连续动态 (Continuous Dynamic)碰撞的游戏对象使用连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。</li><li>对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。</li></ul></li><li>Continuous Speculative 连续推测检测<ul><li>使用预测的方式进行碰撞检测。</li><li>预测物体的未来位置，并在物体穿过其他物体前进行检测和处理。</li><li>性能较高，精度也不错，但有时可能会出现误判。</li><li>适合大多数需要高精度且有较高速度的物体。</li><li>对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。<br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/25.%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%B9%8B%E5%88%9A%E4%BD%93/file-20250220181902841.png" alt="" /></li></ul></li></ol><h1 id="constraints-刚体约束"><a class="markdownIt-Anchor" href="#constraints-刚体约束"></a> Constraints 刚体约束</h1><ul><li>对刚体运动的限制</li></ul><ol><li>Freeze Position 冻结位置<ul><li>有选择地停止刚体沿世界 X、Y 和 Z 轴的移动。</li></ul></li><li>Freeze Rotation 冻结旋转<ul><li>有选择地停止刚体围绕局部 X、Y 和 Z 轴旋转。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;碰撞产生的必要条件&lt;/strong&gt;：两个物体都有碰撞器，至少一个物体有刚体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>24.光面板</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/</id>
    <published>2025-02-20T09:07:17.000Z</published>
    <updated>2025-02-20T09:35:08.172Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/file-20250220170800403.png" alt="" /><br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/24.%E5%85%89%E9%9D%A2%E6%9D%BF/file-20250220171204536.png" alt="" /></p><h1 id="skybox-material-天空盒材质"><a class="markdownIt-Anchor" href="#skybox-material-天空盒材质"></a> <strong>Skybox Material 天空盒材质</strong></h1><p>可以改变天空盒<br />可以在project窗口右键创建材质，材质选择成天空盒着色器</p><h1 id="sun-source-太阳来源"><a class="markdownIt-Anchor" href="#sun-source-太阳来源"></a> Sun Source 太阳来源*</h1><p>不设置会默认使用场景中最亮的方向光代表太阳</p><h1 id="environment-lighting-环境光设置"><a class="markdownIt-Anchor" href="#environment-lighting-环境光设置"></a> Environment Lighting 环境光设置*</h1><h2 id="source-环境光光源颜色"><a class="markdownIt-Anchor" href="#source-环境光光源颜色"></a> Source 环境光光源颜色*</h2><ol><li>Skybox 天空盒：天空和材质作为环境光颜色</li><li>Gradient 渐变：可以为天空、地平线、地面单独选择颜色和他们之间混合</li><li>Color颜色</li></ol><h2 id="intensity-multiplier-环境光亮度"><a class="markdownIt-Anchor" href="#intensity-multiplier-环境光亮度"></a> Intensity Multiplier 环境光亮度*</h2><h2 id="ambient-mode-环境模式"><a class="markdownIt-Anchor" href="#ambient-mode-环境模式"></a> Ambient Mode 环境模式*</h2><ol><li>全局光照模式，只有启用了实时全局和全局烘焙时才有用</li><li>Realtime 实时（已弃用）</li><li>Baked 烘焙</li></ol><h1 id="othersettings-其它设置"><a class="markdownIt-Anchor" href="#othersettings-其它设置"></a> OtherSettings 其它设置*</h1><h2 id="fog-雾开关"><a class="markdownIt-Anchor" href="#fog-雾开关"></a> Fog 雾开关*</h2><ol><li>Color 雾颜色</li><li>Mode 雾计算模式<ul><li>Linear 线性模式<ul><li>随距离线性增加</li><li>Start 开始距离 离摄像机多远开始有雾</li><li>End 结束距离 离摄像机多远完全遮挡</li></ul></li><li>Exponential 指数模式<ul><li>随距离指数增加</li><li>Density 密度 雾强度</li></ul></li><li>Exponential Qquare 指数平方模式<ul><li>随距离比指数更快的增加</li><li>Density 密度 雾强度</li></ul></li></ul></li></ol><h2 id="halo-texture-光晕材质"><a class="markdownIt-Anchor" href="#halo-texture-光晕材质"></a> Halo Texture 光晕材质*</h2><p>光源周围挥着光环的纹理</p><h2 id="halo-strength-光晕强度"><a class="markdownIt-Anchor" href="#halo-strength-光晕强度"></a> Halo Strength 光晕强度*</h2><p>光环可见性</p><h2 id="flare-fade-speed-炫光交叉淡化速度"><a class="markdownIt-Anchor" href="#flare-fade-speed-炫光交叉淡化速度"></a> Flare Fade Speed 炫光交叉淡化速度*</h2><p>耀斑淡出时间，最初出现之后淡出的时间</p><h2 id="flare-strength-炫光强度"><a class="markdownIt-Anchor" href="#flare-strength-炫光强度"></a> Flare Strength 炫光强度*</h2><p>耀斑可见性</p><h2 id="spot-cookie-聚光灯剪影"><a class="markdownIt-Anchor" href="#spot-cookie-聚光灯剪影"></a> Spot Cookie 聚光灯剪影*</h2><p>聚光灯剪影纹理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="光源系统" scheme="http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>23.Light光源组件</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/</id>
    <published>2025-02-20T08:10:23.000Z</published>
    <updated>2025-02-20T09:35:01.927Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/file-20250220161146691.png" alt="" /><br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/file-20250220161201502.png" alt="" /></p><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/23.Light%E5%85%89%E6%BA%90%E7%BB%84%E4%BB%B6/file-20250220165850186.png" alt="" /></p><h1 id="type光源类型"><a class="markdownIt-Anchor" href="#type光源类型"></a> <strong>Type光源类型</strong></h1><ul><li>Spot聚光灯<ul><li>Spot Angle光锥角度</li><li>Range发光范围距离</li></ul></li><li>Directional方向光(环境光)</li><li>Point点光源</li><li>Area面光源</li></ul><h1 id="mode-光源模式"><a class="markdownIt-Anchor" href="#mode-光源模式"></a> <strong>Mode 光源模式</strong></h1><ol><li>Realtime 实时光源：每帧实时计算，效果好，性能消耗大</li><li>Baked 烘焙光源：事先计算好，无法动态变化</li><li>Mixed 混合光源：预先计算+实时运算</li></ol><h1 id="intensity-光源强度"><a class="markdownIt-Anchor" href="#intensity-光源强度"></a> <strong>Intensity 光源强度</strong></h1><h2 id="indirect-multiplier-间接系数"><a class="markdownIt-Anchor" href="#indirect-multiplier-间接系数"></a> Indirect Multiplier 间接系数 *</h2><p>改变间接光的强度<br />低于1，每次反弹会使光更暗<br />大于1，每次反弹会使光更亮</p><h1 id="shadow-type-阴影类型"><a class="markdownIt-Anchor" href="#shadow-type-阴影类型"></a> <strong>Shadow Type 阴影类型</strong></h1><ol><li>NoShadows 关闭阴影</li><li>HardShadows 生硬阴影</li><li>SoftShadows 柔和阴影</li></ol><h1 id="realtime-shadows-实时阴影"><a class="markdownIt-Anchor" href="#realtime-shadows-实时阴影"></a> Realtime Shadows 实时阴影*</h1><ol><li>Strength 强度: 阴影暗度 0~1之间，越大越黑</li><li>Resolution 分辨率: 阴影贴图渲染分辨率，越高越逼真，消耗越高     （Project Setting中的Quallty的设置）</li><li>Bias 偏离: 阴影推离光源的距离</li><li>Normal Bias 法线偏离: 阴影投射面沿法线收缩距离</li><li>Near Panel 近平面: 渲染阴影的近裁剪面</li></ol><h1 id="cookie-剪影"><a class="markdownIt-Anchor" href="#cookie-剪影"></a> <strong>Cookie 剪影</strong></h1><p>投影遮罩: 一般用于聚光灯，显示图案</p><h1 id="draw-halo-绘制光晕"><a class="markdownIt-Anchor" href="#draw-halo-绘制光晕"></a> <strong>Draw Halo 绘制光晕</strong></h1><p>球形光环开关<br />可以用于蜡烛等效果</p><h1 id="flare-眩光"><a class="markdownIt-Anchor" href="#flare-眩光"></a> Flare 眩光</h1><p>耀斑<br />有点类似于太阳耀斑效果<br />想要在Game窗口看到耀斑要在摄像机Camera上加FlareLayer脚本</p><h1 id="render-mode-渲染模式"><a class="markdownIt-Anchor" href="#render-mode-渲染模式"></a> Render Mode 渲染模式*</h1><ol><li>Auto 自动: 运行时确定</li><li>Important 重要: 以像素质量为单位进行渲染，效果逼真，消耗大</li><li>Not Important 非重要: 以快速模式进行渲染</li></ol><h1 id="culling-mask-剔除遮罩"><a class="markdownIt-Anchor" href="#culling-mask-剔除遮罩"></a> <strong>Culling Mask 剔除遮罩</strong></h1><ul><li>剔除遮罩层，决定哪些层的对象受到该光源影响</li></ul><p>ps：所有参数都可都可以在代码中设置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="光源系统" scheme="http://example.com/tags/%E5%85%89%E6%BA%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>22.Camera代码控制</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/</id>
    <published>2025-02-20T06:40:08.000Z</published>
    <updated>2025-02-20T09:34:11.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重要静态成员"><a class="markdownIt-Anchor" href="#重要静态成员"></a> 重要静态成员</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取主摄像机       只能是有MainCamera tag的</span></span><br><span class="line">print(Camera.main?.name);         **************</span><br><span class="line"><span class="comment">// 所有摄像机数量</span></span><br><span class="line">print(Camera.allCamerasCount);</span><br><span class="line"><span class="comment">// 所有摄像机</span></span><br><span class="line">Camera[] allCameras = Camera.allCameras;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染相关委托</span></span><br><span class="line"><span class="comment">// 摄像机剔除前处理的委托函 数</span></span><br><span class="line">Camera.onPreCull += (c) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 摄像机渲染前处理的委托</span></span><br><span class="line">Camera.onPreRender += (c) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 摄像机渲染后处理的委托</span></span><br><span class="line">Camera.onPostRender += (c) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="重要成员"><a class="markdownIt-Anchor" href="#重要成员"></a> 重要成员</h1><p>Inspector窗口的所有值都能用代码得到并修改<br />比如：<code>Camera.main.depth = 10;</code></p><p><strong>下面非常常用</strong><br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/22.Camera%E4%BB%A3%E7%A0%81%E6%8E%A7%E5%88%B6/file-20250220145501137.png" alt="" /></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 世界坐标 转 屏幕坐标</span></span><br><span class="line"><span class="comment">// 转换后的x, y就是屏幕坐标, z则为  Camera.main 离 这个物体position有多远 (纵深</span></span><br><span class="line"><span class="comment">//  用这个来做 头顶血条          ****************</span></span><br><span class="line">Vector3 vector3 = Camera.main.WorldToScreenPoint(<span class="keyword">this</span>.transform.position);</span><br><span class="line">print(vector3);</span><br></pre></td></tr></table></figure><p>设置z之后，屏幕坐标就会转换到世界坐标的距离摄像机的z距离的平面上</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 屏幕坐标 转 世界坐标</span></span><br><span class="line"><span class="comment">// 转换要自己设定z轴的距离, 否则为0, 一直在视口点上坐标不变</span></span><br><span class="line">Vector3 v = Input.mousePosition;        ***********</span><br><span class="line">v.z = <span class="number">10</span>;</span><br><span class="line">Vector3 vector31 = Camera.main.ScreenToWorldPoint(v);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重要静态成员&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#重要静态成员&quot;&gt;&lt;/a&gt; 重要静态成员&lt;/h1&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Unity重要组件和API" scheme="http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"/>
    
  </entry>
  
  <entry>
    <title>21.Camera</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/</id>
    <published>2025-02-20T05:43:21.000Z</published>
    <updated>2025-02-20T09:34:08.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="camera可编辑参数"><a class="markdownIt-Anchor" href="#camera可编辑参数"></a> Camera可编辑参数</h1><p><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/file-20250220134605164.png" alt="" /><br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/file-20250220134621006.png" alt="" /></p><h2 id="clear-flags清楚标志"><a class="markdownIt-Anchor" href="#clear-flags清楚标志"></a> <strong>Clear Flags清楚标志</strong></h2><p>skybox天空盒    （做3d游戏）<br />Solid Color颜色填充     （做2d游戏）<br />Depth only 只画该层，背景透明   （一般多个摄像机叠加渲染的时候使用，一般与下面的<strong>Depth</strong>配合使用）<br />Don’t Clear 不移除，覆盖渲染    （<strong>不常用</strong>，会保留每一帧的渲染内容，就像黄金体验镇魂曲）</p><h2 id="culling-mask剔除遮罩"><a class="markdownIt-Anchor" href="#culling-mask剔除遮罩"></a> <strong>Culling Mask剔除遮罩</strong></h2><p>选择渲染部分层级（Layer）</p><h2 id="projection"><a class="markdownIt-Anchor" href="#projection"></a> <strong>Projection</strong></h2><p>FOV Axis Fov轴：视野轴，决定了光学仪器的视野范围。</p><p>Perspective 透视模式<br />Field of view 视野：摄像机视角（以沿着 FOV Axis__ 下拉选单中指定轴的度数为单位）。0-180度之间，一般保持默认60就行。</p><p>orthographic 正交摄像机（一般用于2D游戏制作）<br />Size：摄制范围</p><h2 id="clipping-planes裁剪平面"><a class="markdownIt-Anchor" href="#clipping-planes裁剪平面"></a> <strong>Clipping Planes裁剪平面</strong></h2><p>Near：近平面<br />Far：远平面</p><h2 id="depth深度"><a class="markdownIt-Anchor" href="#depth深度"></a> <strong>Depth深度</strong></h2><p>渲染顺序上的深度 （数字越小，越先渲染）<br />数字小的照片会先放， 数字大的照片会叠在上面，天空盒有背景是不透明，depth only透明<br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/file-20250220141807107.png" alt="" /></p><h2 id="target-texture目标纹理"><a class="markdownIt-Anchor" href="#target-texture目标纹理"></a> <strong>Target Texture目标纹理</strong></h2><p>可以把摄像机画面渲染到一张图上， 主要用于制作小地图<br />在Project右键创建 Render Texture，将创建的Render Texture拖到摄像机，就会把摄像机看到的画面渲染到一张图上</p><h2 id="occlusion-culling剔除遮挡"><a class="markdownIt-Anchor" href="#occlusion-culling剔除遮挡"></a> <strong>Occlusion Culling剔除遮挡</strong></h2><p>勾选时一些游戏物体被大一点的物体挡住可以不用渲染</p><h1 id="不常用的参数"><a class="markdownIt-Anchor" href="#不常用的参数"></a> 不常用的参数</h1><p>Viewport Rect视口范围 屏幕上将绘制该摄像机视图的位置，主要用于双摄像机游戏，0~1 相当于宽高百分比</p><p>Redering path渲染路径<br /><img src="/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/21.Camera/file-20250220143333576.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;camera可编辑参数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#camera可编辑参数&quot;&gt;&lt;/a&gt; Camera可编辑参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2025/02/20/%E6%B8%B8%E6%88%8F%E5%B</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Unity重要组件和API" scheme="http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"/>
    
  </entry>
  
  <entry>
    <title>20.Screen屏幕相关</title>
    <link href="http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.Screen%E5%B1%8F%E5%B9%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2025/02/20/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20.Screen%E5%B1%8F%E5%B9%95%E7%9B%B8%E5%85%B3/</id>
    <published>2025-02-20T02:50:13.000Z</published>
    <updated>2025-02-20T09:33:59.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用"><a class="markdownIt-Anchor" href="#常用"></a> 常用</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前屏幕分辨率  (设备的分辨率</span></span><br><span class="line">Resolution currentResolution = Screen.currentResolution;</span><br><span class="line">print(<span class="string">$&quot;当前分辨率宽:<span class="subst">&#123;currentResolution.width&#125;</span>, 高:<span class="subst">&#123;currentResolution.height&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前游戏窗口分辨率 </span></span><br><span class="line">print(<span class="string">$&quot;当前窗口分辨率为:<span class="subst">&#123;Screen.width&#125;</span> * <span class="subst">&#123;Screen.height&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 屏幕休眠模式   </span></span><br><span class="line">Screen.sleepTimeout = SleepTimeout.NeverSleep;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="不常用"><a class="markdownIt-Anchor" href="#不常用"></a> 不常用</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 运行时是否全屏</span></span><br><span class="line">Screen.fullScreen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口模式     (以后在发布的时候在设置, 一般不用代码去设置)</span></span><br><span class="line"><span class="comment">// 独占全屏 FullScreenMode.ExclusiveFullScreen</span></span><br><span class="line"><span class="comment">// 全屏窗口 FullScreenMode.FullScreenWindow;</span></span><br><span class="line"><span class="comment">// 最大化窗口 FullScreenMode.MaximizedWindow</span></span><br><span class="line"><span class="comment">// 窗口模式 FullScreenMode.Windowed;</span></span><br><span class="line">Screen.fullScreenMode = FullScreenMode.FullScreenWindow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动设备转向相关...</span></span><br><span class="line">Screen.autorotateToLandscapeLeft = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定屏幕显示方向</span></span><br><span class="line">Screen.orientation = ScreenOrientation.LandscapeLeft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置分辨率 第三个参数是否为全屏    (移动设备不用, </span></span><br><span class="line">Screen.SetResolution(<span class="number">1920</span>, <span class="number">1080</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常用&quot;&gt;&lt;/a&gt; 常用&lt;/h1&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity入门" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8/"/>
    
    <category term="unity入门基础知识" scheme="http://example.com/tags/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="Unity重要组件和API" scheme="http://example.com/tags/Unity%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E5%92%8CAPI/"/>
    
  </entry>
  
</feed>
