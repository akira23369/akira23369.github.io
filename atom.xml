<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>akiraの博客思密达</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-05T09:12:37.703Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>akira23369</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.NGUI基础知识概述</title>
    <link href="http://example.com/2025/03/05/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2025/03/05/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/</id>
    <published>2025-03-05T09:12:05.000Z</published>
    <updated>2025-03-05T09:12:37.703Z</updated>
    
    <content type="html"><![CDATA[<p>只是测试</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;只是测试&lt;/p&gt;
&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;https://unpkg.com/kity@2.0.4/dist/kity.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text&amp;#x2F;javascr</summary>
      
    
    
    
    <category term="UI系统" scheme="http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="NGUI" scheme="http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/"/>
    
    <category term="NGUI基础知识" scheme="http://example.com/categories/UI%E7%B3%BB%E7%BB%9F/NGUI/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="UI系统" scheme="http://example.com/tags/UI%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="NGUI" scheme="http://example.com/tags/NGUI/"/>
    
    <category term="NGUI基础知识" scheme="http://example.com/tags/NGUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>19.unity基础总结</title>
    <link href="http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</id>
    <published>2025-03-05T08:55:39.000Z</published>
    <updated>2025-03-05T09:09:05.873Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/file-20250305165545976.png" alt="" /></p><p><img src="/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/file-20250305165815723.png" alt="" /></p><p><img src="/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/file-20250305165849997.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/19.unity%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/fil</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>18.射线检测</title>
    <link href="http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/18.%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/"/>
    <id>http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/18.%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</id>
    <published>2025-03-05T07:40:00.000Z</published>
    <updated>2025-03-05T08:56:35.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是射线检测"><a class="markdownIt-Anchor" href="#什么是射线检测"></a> 什么是射线检测</h1><ul><li>物理系统中</li><li>目前我们学习的物体相交判断</li><li><strong>碰撞检测</strong> - 必备条件 - 1刚体 2碰撞器</li><li><strong>范围检测</strong> - 必备条件 - 碰撞器</li></ul><p>如果想要做这样的碰撞检测呢？</p><ul><li>鼠标选择场景上一物体</li><li>FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）</li><li>等等 需要判断一条线和物体的碰撞情况</li></ul><p>射线检测 就是来解决这些问题的</p><ul><li>它可以在指定点发射一个指定方向的射线</li><li>判断该射线与哪些碰撞器相交，得到对应对象</li><li>结合物理系统进行射线碰撞判断</li></ul><p>注意：</p><ul><li>距离、层级两个参数都是int类型</li><li>当我们传入参数时，一定要明确传入的参数代表的是距离还是层级</li></ul><h1 id="ray射线类"><a class="markdownIt-Anchor" href="#ray射线类"></a> Ray射线类</h1><p>一条起点为坐标(1,0,0) 方向为世界坐标Z轴正方向的射线<br /><strong>参数</strong>：</p><ul><li>origin 起点</li><li>direction 方向</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray2 = <span class="keyword">new</span> Ray(Vector3.right, Vector3.forward);</span><br></pre></td></tr></table></figure><h1 id="camerascreenpointtoray方法-摄像机发射出的射线"><a class="markdownIt-Anchor" href="#camerascreenpointtoray方法-摄像机发射出的射线"></a> Camera.ScreenPointToRay方法 摄像机发射出的射线</h1><ul><li>返回从摄像机通过屏幕点的光线</li><li>得到一条从屏幕位置作为起点，摄像机视口方向为方向的射线</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ray ray3 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure><h1 id="physicsraycast方法"><a class="markdownIt-Anchor" href="#physicsraycast方法"></a> Physics.Raycast方法</h1><h2 id="是否碰撞到对象"><a class="markdownIt-Anchor" href="#是否碰撞到对象"></a> 是否碰撞到对象</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：bool 是否碰撞到对象</span></span><br><span class="line"><span class="comment">//参数一：射线 </span></span><br><span class="line"><span class="comment">//参数二: 检测的最大距离 超出这个距离不检测 </span></span><br><span class="line"><span class="comment">//参数三：检测指定层级（不填检测所有层） </span></span><br><span class="line"><span class="comment">//参数四：是否忽略触发器</span></span><br><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal)) &#123; print(<span class="string">&quot;碰撞到了对象&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="获取相交单个物体信息-raycasthit结构体"><a class="markdownIt-Anchor" href="#获取相交单个物体信息-raycasthit结构体"></a> 获取相交单个物体信息 RaycastHit结构体</h2><p><strong>常用属性</strong>：<br /><code>collider</code></p><ul><li><strong>类型</strong>：<code>Collider</code></li><li><strong>说明</strong>：该属性返回与射线相交的碰撞体对象。通过这个属性，你可以访问碰撞体所在的游戏对象及其相关组件。</li></ul><p><code>point</code></p><ul><li><strong>类型</strong>：<code>Vector3</code></li><li><strong>说明</strong>：该属性表示射线与碰撞体相交的点的世界坐标。在很多场景中，比如在碰撞点生成特效，被子弹打中飙血，墙壁被打贴图</li></ul><p><code>distance</code></p><ul><li><strong>类型</strong>：<code>float</code></li><li><strong>说明</strong>：该属性表示从射线的起点到碰撞点的距离。可以用于判断射线与物体相交的远近。</li></ul><p><code>normal</code></p><ul><li><strong>类型</strong>：<code>Vector3</code></li><li><strong>说明</strong>：该属性表示碰撞点处碰撞体表面的法线向量。法线向量在很多场景中都有重要作用，比如反射效果、物体表面的朝向，射击游戏特效计算相关等。</li></ul><p><code>transform</code></p><ul><li><strong>类型</strong>：<code>Transform</code></li><li><strong>说明</strong>：该属性返回与射线相交的碰撞体所附着的游戏对象的 <code>Transform</code> 组件。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit raycastHitInfo;</span><br><span class="line"><span class="comment">//返回值：bool 是否碰撞到对象</span></span><br><span class="line"><span class="comment">//参数一：射线</span></span><br><span class="line"><span class="comment">//参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中</span></span><br><span class="line"><span class="comment">//参数三：距离</span></span><br><span class="line"><span class="comment">//参数四：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 </span></span><br><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray4, <span class="keyword">out</span> raycastHitInfo, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰撞到了物体 得到了信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;碰撞到物体的名字&quot;</span> + raycastHitInfo.collider.gameObject.name);</span><br><span class="line"></span><br><span class="line">    print(raycastHitInfo.point);</span><br><span class="line"></span><br><span class="line">    print(raycastHitInfo.normal);</span><br><span class="line"></span><br><span class="line">    print(raycastHitInfo.transform.position);</span><br><span class="line"></span><br><span class="line">    print(raycastHitInfo.distance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取相交多个物体信息-raycasthit"><a class="markdownIt-Anchor" href="#获取相交多个物体信息-raycasthit"></a> 获取相交多个物体信息 <code>RaycastHit[]</code></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值：RaycastHit[] 碰撞到对象</span></span><br><span class="line"><span class="comment">//参数一：射线</span></span><br><span class="line"><span class="comment">//参数二：距离</span></span><br><span class="line"><span class="comment">//参数三：检测指定层级（不填检测所有层）</span></span><br><span class="line"><span class="comment">//参数四：是否忽略触发器</span></span><br><span class="line"><span class="comment">//Physics.RaycastAll方法传入RaycastHit数组对象可以得到多个碰到的对象</span></span><br><span class="line">RaycastHit[] raycastHitInfos = Physics.RaycastAll(ray4, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>), QueryTriggerInteraction.UseGlobal);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; raycastHitInfos.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;碰到的所有物体 名字分别是&quot;</span> + raycastHitInfos[i].collider.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="子弹打墙"><a class="markdownIt-Anchor" href="#子弹打墙"></a> 子弹打墙</h2><p>实现鼠标点击场景上一面墙，在点击的位置创建子弹特效和弹孔</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将鼠标在屏幕上的位置通过主相机转换为世界坐标系中的一条视线射线并赋值给 ray1。</span></span><br><span class="line">    Ray ray1 = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 Debug.DrawRay 方法可将检测到的射线绘制出来以便调试查看（仅在编辑模式下生效）。</span></span><br><span class="line">    Debug.DrawRay(ray1.origin, ray1.direction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), <span class="keyword">out</span> info, <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            GameObject obj = Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Effect/HitEff&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设定打击特效在发生碰撞的物体前方偏移 0.2 米处</span></span><br><span class="line">            obj.transform.position = info.point + info.normal * <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据表面法线调整特效的朝向角度，以适应目标物体产生视觉效果。</span></span><br><span class="line">            obj.transform.rotation = Quaternion.LookRotation(info.normal);</span><br><span class="line"></span><br><span class="line">            Destroy(obj, <span class="number">0.8f</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 特效 DDD </span></span><br><span class="line">            obj = Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Effect/DDD&quot;</span>));</span><br><span class="line"></span><br><span class="line">            obj.transform.position = info.point + info.normal * <span class="number">0.2f</span>;</span><br><span class="line"></span><br><span class="line">            obj.transform.rotation = Quaternion.LookRotation(info.normal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="鼠标长按物体移动"><a class="markdownIt-Anchor" href="#鼠标长按物体移动"></a> 鼠标长按物体移动</h2><p>场景上有一个平面，有一个立方体，当鼠标点击选中立方体时，长按鼠标左键 可以拖动立方体 在平面上移动，点击鼠标右键取消选中</p><p>注意：</p><ul><li>想要让物体只在平面就和平面做射线检测</li><li>物体的中心点 和 平面的中心点 和 物体脚下</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit hit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录当前选中的对象的 Transform 组件。 </span></span><br><span class="line"><span class="keyword">private</span> Transform nowSel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个公共浮点型变量 offsetY，用于设定物体拖曳时的高度偏移量。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> offsetY;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 射线检测获取要选中的物体, 然后让物体跟随鼠标移动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), <span class="keyword">out</span> hit, </span><br><span class="line">        <span class="number">100</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>)))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 得到想要操作对象的transform</span></span><br><span class="line">        nowSel = hit.transform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前有选中的对象 并且是长按</span></span><br><span class="line"><span class="keyword">if</span> (nowSel != <span class="literal">null</span> &amp;&amp; Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), <span class="keyword">out</span> hit, </span><br><span class="line">        <span class="number">1000</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Floor&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        nowSel.position = hit.point + Vector3.up *offsetY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    nowSel = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是射线检测&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是射线检测&quot;&gt;&lt;/a&gt; 什么是射线检测&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;物理系统中&lt;/li&gt;
&lt;li&gt;目前我们学习的物体相交判断&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;碰撞检测&lt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>17.范围检测</title>
    <link href="http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/17.%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B/"/>
    <id>http://example.com/2025/03/05/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/17.%E8%8C%83%E5%9B%B4%E6%A3%80%E6%B5%8B/</id>
    <published>2025-03-05T06:24:21.000Z</published>
    <updated>2025-03-05T08:56:24.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾物理系统之碰撞检测"><a class="markdownIt-Anchor" href="#回顾物理系统之碰撞检测"></a> 回顾物理系统之碰撞检测</h1><p><strong>碰撞产生的必要条件</strong></p><ul><li>至少一个物体有刚体</li><li>两个物体都必须有碰撞器<br /><strong>碰撞和触发</strong></li><li>碰撞会产生实际的物理效果</li><li>触发看起来不会产生碰撞，但是可以通过函数监听触发</li><li>碰撞检测主要用于实体物体之间产生物理效果时使用</li></ul><h1 id="什么是范围检测"><a class="markdownIt-Anchor" href="#什么是范围检测"></a> 什么是范围检测</h1><p>游戏中瞬时的攻击范围判断一般会使用范围检测<br />举例：<br />玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害<br />玩家攻击，在前方1米圆形范围内对象都受到伤害<br />类似这种并没有实体物体，只想要检测在指定某一范围是否让敌方受到伤害时，便可以使用范围判断<br />在指定位置进行范围判断，我们可以得到处于指定范围内的对象<br />目的是对对象进行处理，比如受伤、减血等等</p><h1 id="layermask层级相关知识补充"><a class="markdownIt-Anchor" href="#layermask层级相关知识补充"></a> LayerMask层级相关知识补充</h1><ol><li>Unity 顶部菜单 → <code>Edit</code> → <code>Project Settings</code> → <code>Tags and Layers</code></li><li>在 <code>Layers</code> 列表中添加/修改层级名称（如 “Enemy”, “Player”）</li></ol><p><code>LayerMask.NameToLayer()</code>方法 传入层级名字返回层级索引</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>多层级组合检测</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时检测 Enemy 和 NPC 层</span></span><br><span class="line">LayerMask combinedMask = LayerMask.GetMask(<span class="string">&quot;Enemy&quot;</span>, <span class="string">&quot;NPC&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效位运算写法</span></span><br><span class="line">LayerMask combinedMask = (<span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Enemy&quot;</span>)) | (<span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;NPC&quot;</span>)); </span><br></pre></td></tr></table></figure><p><strong>排除特定层级</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测除了 Player 之外的所有层级</span></span><br><span class="line">LayerMask mask = ~LayerMask.GetMask(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 射线检测排除自身层</span></span><br><span class="line">RaycastHit hit;</span><br><span class="line"><span class="built_in">int</span> selfLayer = gameObject.layer;</span><br><span class="line">LayerMask raycastMask = ~(<span class="number">1</span> &lt;&lt; selfLayer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Physics.Raycast(transform.position, transform.forward, <span class="keyword">out</span> hit, <span class="number">100f</span>, raycastMask)) &#123;</span><br><span class="line">    <span class="comment">// 检测到非自身层的物体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="如何进行范围检测"><a class="markdownIt-Anchor" href="#如何进行范围检测"></a> 如何进行范围检测</h1><p><strong>范围检测必备条件</strong>：想要被范围检测到的对象必须具备碰撞器<br /><strong>范围检测注意点：</strong></p><ul><li>范围检测相关API只有当执行该句代码时进行一次范围检测，它是瞬时的</li><li>范围检测相关API并不会真正产生一个碰撞器，只是碰撞判断计算而已</li></ul><h1 id="范围检测api"><a class="markdownIt-Anchor" href="#范围检测api"></a> 范围检测API</h1><h2 id="physicsoverlapbox方法-盒状范围检测"><a class="markdownIt-Anchor" href="#physicsoverlapbox方法-盒状范围检测"></a> Physics.OverlapBox方法 盒状范围检测</h2><p>查找与给定盒体接触或位于盒体内部的所有碰撞体。<br /><strong>返回值：</strong> 返回该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息）<br /><strong>参数：</strong></p><ul><li>立方体中心点</li><li>立方体三边大小，构成立方体的<strong>长宽高的一半</strong>（传入(1,1,1)，立方体的长宽高(2,2,2)）</li><li>立方体角度，传入四元数</li><li>检测指定层级（不填检测所有层）</li><li>是否忽略触发器，<strong>UseGlobal</strong>-使用全局设置， <strong>Collide</strong>-检测触发器， <strong>Ignore</strong>-忽略触发器，不填默认使用UseGlobal  （全局设置在ProjectSetting中的Physics里的 Queries Hit Triggers 可以查看并设置）</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] colliders = Physics.OverlapBox(Vector3.zero, Vector3.one, Quaternion.AngleAxis(<span class="number">45</span>, Vector3.up),</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>) |</span><br><span class="line">                    <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>), QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><p>另一个盒壮范围检测，返回值是检测到的Collider的个数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != <span class="number">0</span>) &#123; <span class="comment">// 处理碰撞器 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="physicsoverlapsphere方法-球形范围检测"><a class="markdownIt-Anchor" href="#physicsoverlapsphere方法-球形范围检测"></a> Physics.OverlapSphere方法 球形范围检测</h2><p><strong>返回值：</strong> 返回该范围内的碰撞器数组（得到了对象触发器就可以得到对象的所有信息）<br /><strong>参数：</strong></p><ul><li>球中心点</li><li>半径</li><li>检测指定层级（不填检测所有层）</li><li>是否忽略触发器，<strong>UseGlobal</strong>-使用全局设置， <strong>Collide</strong>-检测触发器， <strong>Ignore</strong>-忽略触发器</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colliders = Physics.OverlapSphere(Vector3.zero, <span class="number">5</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Default&quot;</span>));</span><br></pre></td></tr></table></figure><p>另一个球形范围检测，返回值是检测到的Collider的个数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.OverlapSphereNonAlloc(Vector3.zero, <span class="number">5</span>, colliders) != <span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="physicsoverlapcapsule方法-胶囊范围检测"><a class="markdownIt-Anchor" href="#physicsoverlapcapsule方法-胶囊范围检测"></a> Physics.OverlapCapsule方法 胶囊范围检测</h2><p><strong>返回值：</strong> 返回该范围内的碰撞器数组<br /><strong>参数：</strong></p><ul><li>半圆1中心点</li><li>半圆2中心点 （前两个参数决定胶囊中间的圆柱体情况）</li><li>上下两个半球体半径</li><li>检测指定层级（不填检测所有层）</li><li>是否忽略触发器，<strong>UseGlobal</strong>-使用全局设置， <strong>Collide</strong>-检测触发器， <strong>Ignore</strong>-忽略触发器</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colliders = Physics.OverlapCapsule(Vector3.zero, Vector3.up, <span class="number">1</span>, <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;UI&quot;</span>), QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure><p>返回值是检测到的Collider的个数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, <span class="number">1</span>, colliders) != <span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><p><strong>世界坐标原点有一个立方体，键盘WASD键可以控制其前后移动和旋转,请结合所学知识实现,按J键在立方体面朝向前方1米处进行立方体范围检测,按K键在立方体前面5米范围内进行胶囊范围检测,按L键以立方体脚下为原点，半径10米内进行球形范围检测</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 位移</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Translate(Vector3.forward * Time.deltaTime * moveSpeed * Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    <span class="keyword">this</span>.transform.Rotate(Vector3.up, Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>) * roundSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下J键</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.J))</span><br><span class="line">    &#123;</span><br><span class="line">        Collider[] colliders = Physics.OverlapBox(</span><br><span class="line">            <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward, </span><br><span class="line">            Vector3.one * <span class="number">0.5f</span>, </span><br><span class="line">            <span class="keyword">this</span>.transform.rotation, <span class="comment">//创建出来的立方体要保持和当前立方体相同的旋转，否则不是刚好在前面</span></span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;盒子 物体受伤&quot;</span> + colliders[i].gameObject.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下K</span></span><br><span class="line">    <span class="comment">//可以理解为往前面吐火 或者刺出来长枪</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.K))</span><br><span class="line">    &#123;</span><br><span class="line">        Collider[] colliders = Physics.OverlapCapsule(</span><br><span class="line">            <span class="keyword">this</span>.transform.position, </span><br><span class="line">            <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.forward * <span class="number">5</span>, </span><br><span class="line">            <span class="number">0.5f</span>, </span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;胶囊 物体受伤&quot;</span> + colliders[i].gameObject.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下L键</span></span><br><span class="line">    <span class="comment">//比如有些时候范围内加buff或者震开敌人</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.L))</span><br><span class="line">    &#123;</span><br><span class="line">        Collider[] colliders = Physics.OverlapSphere(</span><br><span class="line">            <span class="keyword">this</span>.transform.position, </span><br><span class="line">            <span class="number">10</span>, </span><br><span class="line">            <span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Monster&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; colliders.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;球 物体受伤&quot;</span> + colliders[i].gameObject.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回顾物理系统之碰撞检测&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#回顾物理系统之碰撞检测&quot;&gt;&lt;/a&gt; 回顾物理系统之碰撞检测&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;碰撞产生的必要条件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少一个物</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="物理系统" scheme="http://example.com/tags/%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="核心系统" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>16.LineRenderer画线组件</title>
    <link href="http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/</id>
    <published>2025-03-04T12:06:43.000Z</published>
    <updated>2025-03-04T13:16:11.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linerenderer画线渲染器组件是什么"><a class="markdownIt-Anchor" href="#linerenderer画线渲染器组件是什么"></a> LineRenderer画线渲染器组件是什么？</h1><p><strong>LineRenderer</strong> 是Unity提供的一个用于画线的组件。<br />使用它我们可以在场景中绘制线段，一般可以用于：绘制攻击范围，武器红外线，辅助功能，其它画线功能</p><p><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304201037387.png" alt="" /></p><p><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304201215321.png" alt="" /></p><h1 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h1><h2 id="场景点编辑模式"><a class="markdownIt-Anchor" href="#场景点编辑模式"></a> 场景点编辑模式</h2><p><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304204135493.png" alt="" /></p><h2 id="loop-循环"><a class="markdownIt-Anchor" href="#loop-循环"></a> Loop 循环</h2><ul><li>是否终点起始自动相连。</li></ul><h2 id="positions-位置"><a class="markdownIt-Anchor" href="#positions-位置"></a> Positions 位置</h2><ul><li>默认以世界坐标系为基准，设置线段的点并连接。</li><li>可以在 <strong>Use World Space</strong> 是否使用世界坐标系修改是否以世界坐标系为基准。</li><li>设置开不开启 <strong>Loop 循环</strong> 就能选择是否收尾线段点相连。<br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304201941419.png" alt="" /><br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304202000864.png" alt="" /><br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304202012733.png" alt="" /><br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304202020354.png" alt="" /></li></ul><h2 id="width-宽度"><a class="markdownIt-Anchor" href="#width-宽度"></a> Width 宽度</h2><ul><li>线段宽度曲线调整。</li></ul><p><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304202120351.png" alt="" /><br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304202130522.png" alt="" /></p><p>可以在宽度表里右键添加key，添加秘钥，修改划线宽度曲线。</p><h2 id="color-颜色"><a class="markdownIt-Anchor" href="#color-颜色"></a> Color 颜色</h2><p>修改颜色变化，颜色也可以是渐变的，假如没有材质修改颜色不起作用。</p><h2 id="corner-vertices-角顶点"><a class="markdownIt-Anchor" href="#corner-vertices-角顶点"></a> Corner Vertices 角顶点</h2><p>角顶点可以理解为把划线的角变成圆角。<br />此属性指示在一条线中绘制角时使用了多少额外的顶点。<br />增加此值，使线角看起来更圆。</p><h2 id="end-cap-vertices-末端顶点"><a class="markdownIt-Anchor" href="#end-cap-vertices-末端顶点"></a> End Cap Vertices 末端顶点</h2><p>终端顶点也变成圆角。</p><h2 id="alignment-对其方式"><a class="markdownIt-Anchor" href="#alignment-对其方式"></a> Alignment 对其方式*</h2><p>View：视点线段对着摄像机。<br />Transform Z：线段面向其Z轴。</p><h2 id="texture-mode-纹理模式"><a class="markdownIt-Anchor" href="#texture-mode-纹理模式"></a> Texture Mode 纹理模式*</h2><p>Stretch：拉伸，沿整条线映射纹理一次。<br />Tile：瓷砖平铺，不停的重复纹理。<br />Distribute Per Segment：分配执行。<br />Repeat Per Segment：重复显示。</p><h2 id="shadow-bias-阴影偏移"><a class="markdownIt-Anchor" href="#shadow-bias-阴影偏移"></a> Shadow Bias 阴影偏移*</h2><h2 id="generate-lighting-data-生成光源数据"><a class="markdownIt-Anchor" href="#generate-lighting-data-生成光源数据"></a> Generate Lighting Data 生成光源数据*</h2><h2 id="use-world-space-是否使用世界坐标系"><a class="markdownIt-Anchor" href="#use-world-space-是否使用世界坐标系"></a> Use World Space 是否使用世界坐标系</h2><ul><li>勾选了，不管怎么改都是相对于世界坐标的线段点。</li><li>不勾选，就会是当前依附的游戏对象的相对坐标点，移动游戏对象也会移动划线。</li></ul><h2 id="materials-划线使用的材质球"><a class="markdownIt-Anchor" href="#materials-划线使用的材质球"></a> Materials 划线使用的材质球</h2><p>我们可以新建一个材质，使用默认shader，关联一张图片，拖拽到划线组件的材质球上。<br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304203048233.png" alt="" /><br />注意：假如一些材质需要光源，要开Generate Lighting Data 生成光源数据，不然可能变黑显示不出来。</p><h2 id="lighting-光照影响"><a class="markdownIt-Anchor" href="#lighting-光照影响"></a> Lighting 光照影响*</h2><p>Cast Shadows：投射阴影，是否开启阴影。<br />Receive Shadows：接收阴影。</p><h2 id="probes-光照探针"><a class="markdownIt-Anchor" href="#probes-光照探针"></a> Probes 光照探针*</h2><p>Light Probes：光探测器模式<br />不使用光探针<br />使用内插光探针<br />使用三维网格内插光探针<br />自定义从材质决定</p><h2 id="reflection-probes反射探测器模式"><a class="markdownIt-Anchor" href="#reflection-probes反射探测器模式"></a> Reflection Probes：反射探测器模式*</h2><p>不使用反射探针<br />启用混合反射探针<br />启用混合反射探针并且和天空和混合<br />启用普通探针，重叠式不混合</p><h2 id="additional-settings-附加设置"><a class="markdownIt-Anchor" href="#additional-settings-附加设置"></a> Additional Settings 附加设置*</h2><p>Motion Vectors：运动矢量</p><ul><li>使用相机运动来跟踪运动</li><li>特定对象来跟踪运动</li><li>不跟踪<br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/16.LineRenderer%E7%94%BB%E7%BA%BF%E7%BB%84%E4%BB%B6/file-20250304203455005.png" alt="" /></li></ul><p>Dynamic Occludee：动态遮挡剔除<br />Sorting Layer：排序图层<br />Order in Layer：此线段在排序图层中的顺序</p><h1 id="代码相关"><a class="markdownIt-Anchor" href="#代码相关"></a> 代码相关</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GameObject line = <span class="keyword">new</span> GameObject();</span><br><span class="line">line.name = <span class="string">&quot;myLine&quot;</span>;</span><br><span class="line">LineRenderer myLine = line.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否首尾相连</span></span><br><span class="line">myLine.loop = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 开始结束宽</span></span><br><span class="line">myLine.startWidth = <span class="number">0.02f</span>;</span><br><span class="line">myLine.endWidth = <span class="number">0.02f</span>;</span><br><span class="line"><span class="comment">// 开始结束颜色</span></span><br><span class="line">myLine.startColor = Color.black;</span><br><span class="line">myLine.endColor = Color.white;</span><br><span class="line"><span class="comment">// 设置材质</span></span><br><span class="line">myLine.material = Resources.Load&lt;Material&gt;(<span class="string">&quot;Material地址&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置点</span></span><br><span class="line"><span class="comment">// 先设置数量, 在设置每个点的位置</span></span><br><span class="line">myLine.positionCount = <span class="number">4</span>;</span><br><span class="line">myLine.SetPositions(<span class="keyword">new</span> Vector3[]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    <span class="comment">//new Vector3(0, 0, 5)          // 没有设置最后一个点，默认0,0,0</span></span><br><span class="line">&#125;);</span><br><span class="line">myLine.SetPosition(<span class="number">3</span>, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否使用世界坐标</span></span><br><span class="line">myLine.useWorldSpace = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否接受光照进行着色计算</span></span><br><span class="line">myLine.generateLightingData = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><p><strong>请写一个方法，传入一个中心点，传入一个半径，用 LineRenderer 画一个圆出来</strong><br />添加画圆函数，需要传入圆心位置(centerPos)，半径®，点的数量(pointNum)</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆心位置(centerPos)，半径，点的数量(pointNum)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DrawLineRenderer</span>(<span class="params">Vector3 centerPos, <span class="built_in">float</span> r, <span class="built_in">int</span> pointNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">    obj.name = <span class="string">&quot;R&quot;</span>;</span><br><span class="line"></span><br><span class="line">    LineRenderer line = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">    line.loop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    line.positionCount = pointNum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> angle = <span class="number">360f</span> / pointNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pointNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 点加向量相当于平移点</span></span><br><span class="line">        <span class="comment">// 2. 四元数 * 向量相当于在旋转向量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过四元数进行旋转后，再进行位移操作</span></span><br><span class="line">        Vector3 pos = Quaternion.AngleAxis(angle * i, Vector3.up) * Vector3.forward * r + centerPos;</span><br><span class="line"></span><br><span class="line">        line.SetPosition(i, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>请实现，在 Game 窗口长按鼠标用 LineRenderer 画出鼠标移动的轨迹</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 练习题二用来装 LineRenderer 的临时变量</span></span><br><span class="line"><span class="keyword">private</span> LineRenderer line2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 练习题二</span></span><br><span class="line">    <span class="comment">// 在 Game 窗口长按鼠标用 LineRenderer 画出鼠标移动的轨迹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/假如没有添加鼠标左键被按下时的逻辑，那么每次只能接着上次画，会和上次画的末尾连接起来</span></span><br><span class="line">    <span class="comment">//line2 = this.gameObject.AddComponent&lt;LineRenderer&gt;();</span></span><br><span class="line">    <span class="comment">//line2.loop = false;</span></span><br><span class="line">    <span class="comment">//line2.startWidth = 0.5f;</span></span><br><span class="line">    <span class="comment">//line2.endWidth = 0.5f;</span></span><br><span class="line">    <span class="comment">//line2.positionCount = 0;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类成员变量 nowPos，记录当前鼠标指针所在的位置</span></span><br><span class="line"><span class="keyword">private</span> Vector3 nowPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Update 函数中，检测鼠标点击事件，实现从当前鼠标指针处开始划线的功能。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 鼠标左键被按下时</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 鼠标左键被按下时，创建新的游戏对象，并且新增为其 LineRenderer 组件</span></span><br><span class="line">        GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line">        line2 = obj.AddComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线段状态为非闭合状态，设置开始和结束的宽度为 0.5</span></span><br><span class="line">        line2.loop = <span class="literal">false</span>;</span><br><span class="line">        line2.startWidth = <span class="number">0.5f</span>;</span><br><span class="line">        line2.endWidth = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置顶点数目为 0 表示该线段暂时为空</span></span><br><span class="line">        line2.positionCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标左键持续按压时</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 鼠标左键持续按压时，不断新增线段中增加顶点，记录每个顶点的世界坐标，直到松开鼠标键停止绘制。</span></span><br><span class="line">        line2.positionCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何得到鼠标转世界坐标的对应点 </span></span><br><span class="line">        <span class="comment">// 知识点</span></span><br><span class="line">        <span class="comment">// 1. 如何得到鼠标位置</span></span><br><span class="line">        <span class="comment">// Input.mousePosition</span></span><br><span class="line">        <span class="comment">// 2. 怎么把鼠标转世界坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Camera.main.ScreenToWorldPoint() 方法来将当前鼠标所在的屏幕像素坐标转换到和场景中对象相对应的世界坐标上。</span></span><br><span class="line">        nowPos = Input.mousePosition;</span><br><span class="line">        <span class="comment">// 这个 z 是设置和摄像机的距离的，这样画出来的线一直和摄像机的距离是 10</span></span><br><span class="line">        nowPos.z = <span class="number">10</span>;  <span class="comment">// 将 Z 轴坐标设置为一个固定值，使得线段可以显示在屏幕上方</span></span><br><span class="line">        line2.SetPosition(line2.positionCount - <span class="number">1</span>, Camera.main.ScreenToWorldPoint(nowPos));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linerenderer画线渲染器组件是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linerenderer画线渲染器组件是什么&quot;&gt;&lt;/a&gt; LineRenderer画线渲染器组件是什么？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Lin</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>15.场景异步加载</title>
    <link href="http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/15.%E5%9C%BA%E6%99%AF%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/15.%E5%9C%BA%E6%99%AF%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</id>
    <published>2025-03-04T11:11:28.000Z</published>
    <updated>2025-03-04T12:05:29.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="-swig4-"><a class="markdownIt-Anchor" href="#-swig4-"></a> <a href="/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE/1.%E5%9C%BA%E6%99%AF%E5%88%87%E6%8D%A2%E5%92%8C%E6%B8%B8%E6%88%8F%E9%80%80%E5%87%BA/" title="1.场景切换和游戏退出">回顾场景同步切换</a></h1><p><strong>场景同步切换的缺点</strong></p><ul><li>在切换场景时，Unity会删除当前场景上所有对象，并且去加载下一个场景的相关信息。</li><li>如果当前场景对象过多或者下一个场景对象过多，这个过程会非常耗时，会让玩家感受到卡顿。</li><li>所以异步切换就是来解决该问题的。</li></ul><p>回顾一下<code>&#123;% post_link 13.Resources异步加载#ResourceRequest的父类AsyncOperation AsyncOperation%&#125;</code></p><h1 id="通过事件回调函数-异步加载"><a class="markdownIt-Anchor" href="#通过事件回调函数-异步加载"></a> 通过事件回调函数 异步加载</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在后台异步加载场景。</span></span><br><span class="line">    AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(<span class="string">&quot;场景异步加载&quot;</span>);</span><br><span class="line"></span><br><span class="line">    asyncOperation.completed += (a) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    asyncOperation.completed += AsynLoadOver;</span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// 直接用法这种方法异步加载场景的话，就算过场景脚本或脚本依附的对象被销毁，异步加载的回调也能执行</span></span><br><span class="line">    <span class="comment">// 因为异步加载的回调被存到事件中了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载场景回调</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AsynLoadOver</span>(<span class="params">AsyncOperation ao</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;AsynLoadOver&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="通过协程-异步加载"><a class="markdownIt-Anchor" href="#通过协程-异步加载"></a> 通过协程 异步加载</h1><p>协程异步加载可以在过场景的时候做其他逻辑~~</p><p>需要注意的是，加载场景会把当前场景上没有特别处理的对象都删除了, <a href="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/#%E5%8D%8F%E7%A8%8B%E5%8F%97%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%84%E4%BB%B6%E5%A4%B1%E6%B4%BB%E9%94%80%E6%AF%81%E7%9A%84%E5%BD%B1%E5%93%8D" title="10.协同程序">10.协同程序</a>，事件回调函数则不会有这个问题，因为函数被存着，垃圾回收不了<br />所以，协程中的部分逻辑可能是执行不了的<br />因为过场景会把脚本或者脚本依附的对象都销毁了<br />解决思路：让处理场景加载的脚本依附的对象过场景时不被移除<code>DontDestroyOnLoad(this.gameObject)</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 让该脚本依附的对象过场景时不会被移除，这样脚本就不被移除，否则协程后面的逻辑会失效</span></span><br><span class="line">    DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    <span class="comment">// 协程后面的逻辑会失效是因为Unity的协程管理器的机制，只要依附的对象被删除或失活或者脚本被删除，协程就会失效，我们改不了这个机制</span></span><br><span class="line"></span><br><span class="line">    StartCoroutine(CoroutineAsynLoadScene(<span class="string">&quot;Lesson21_场景异步加载Test&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载场景协程函数</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">CoroutineAsynLoadScene</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异步加载场景</span></span><br><span class="line">    AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程的好处是，在异步加载场景时，我可以在加载的同时做一些别的逻辑</span></span><br><span class="line">    print(<span class="string">&quot;异步加载过程中打印的信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如，我们可以在异步加载过程中去更新进度条，一般有两种做法</span></span><br><span class="line">    <span class="comment">// 更新进度条第一种做法就是利用场景异步加载的进度去更新，但是不是特别准确，一般也不会直接用</span></span><br><span class="line">    <span class="keyword">while</span> (!asyncOperation.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        print(asyncOperation.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开循环后就会认为场景加载结束</span></span><br><span class="line">    <span class="comment">// 可以把进度条顶满，然后隐藏进度条</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unity内部的协程协调器发现是异步加载类型的返回对象，那么就会等待</span></span><br><span class="line">    <span class="comment">// 等待异步加载结束后才会继续执行迭代器函数中后面的步骤</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> asyncOperation;</span><br><span class="line">    print(<span class="string">&quot;异步加载结束后打印的信息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进度条第二种做法就是根据你游戏的规则自己定义进度条变化的条件</span></span><br><span class="line">    <span class="comment">// 比如：当场景加载结束更新20%进度</span></span><br><span class="line">    <span class="comment">// 接着去加载场景中的其他信息，比如动态加载怪物</span></span><br><span class="line">    <span class="comment">// 这时进度条再更新20%</span></span><br><span class="line">    <span class="comment">// 动态加载场景模型，这时就认为加载结束了，进度条顶满，隐藏进度条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>场景异步加载</strong> 和 <strong>资源异步加载</strong> 一样，有两种方式<ul><li>通过事件回调函数</li><li>协程异步加载</li></ul></li><li>他们的优缺点表现和资源异步加载也是一样的<ul><li>事件回调函数<ul><li>优点：写法简单，逻辑清晰</li><li>缺点：只能加载完场景做一些事情，不能再加载过程中处理逻辑</li></ul></li><li>协程异步加载<ul><li>优点：可以在加载过程中处理逻辑，比如进度条更新等</li><li>缺点：写法较为麻烦，要通过协程</li></ul></li></ul></li></ul><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><p><strong>请写一个简单的场景管理器，提供统一的方法给外部用于场景异步切换，外部可以传入委托用于当异步切换结束时执行某些逻辑</strong><br />和这道题类似 <a href="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/13.Resources%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/#%E7%BB%83%E4%B9%A0" title="13.Resources异步加载">Resources异步加载练习题</a></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景管理类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneMgr</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SceneMgr instance = <span class="keyword">new</span> SceneMgr();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SceneMgr Instance =&gt; instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SceneMgr</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载场景的方法，需要传入目标场景的名称和一个UnityAction类型的委托参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> name, UnityAction action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(name);</span><br><span class="line">        </span><br><span class="line">        asyncOperation.completed += (aO) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            action();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SceneMgr.Instance.LoadScene(<span class="string">&quot;场景异步加载&quot;</span>, () =&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;加载结束&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没封装写法</span></span><br><span class="line">AsyncOperation ao = SceneManager.LoadSceneAsync(name);</span><br><span class="line">ao.completed += (ao) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 场景加载结束逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;-swig4-&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#-swig4-&quot;&gt;&lt;/a&gt; &lt;a href=&quot;/2025/02/27/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>14.Resources资源卸载</title>
    <link href="http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/14.Resources%E8%B5%84%E6%BA%90%E5%8D%B8%E8%BD%BD/"/>
    <id>http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/14.Resources%E8%B5%84%E6%BA%90%E5%8D%B8%E8%BD%BD/</id>
    <published>2025-03-04T10:46:52.000Z</published>
    <updated>2025-03-04T11:09:16.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="resources重复加载资源会浪费内存吗"><a class="markdownIt-Anchor" href="#resources重复加载资源会浪费内存吗"></a> Resources重复加载资源会浪费内存吗？</h1><p>其实Resources加载一次资源过后<br />该资源就一直存放在内存中作为缓存<br />第二次加载时发现缓存中存在该资源，会直接取出来进行使用<br />所以，多<strong>次重复加载不会浪费内存</strong><br />但是会<strong>浪费性能</strong>（每次加载都会去查找取出，始终伴随一些性能消耗）</p><h1 id="手动释放掉缓存中的资源"><a class="markdownIt-Anchor" href="#手动释放掉缓存中的资源"></a> 手动释放掉缓存中的资源</h1><p><code>Resources.UnloadAsset</code>方法 卸载指定资源<br />可以在 window的 分析器查看内存是否卸载<br /><img src="/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/14.Resources%E8%B5%84%E6%BA%90%E5%8D%B8%E8%BD%BD/file-20250304190913967.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内存中卸载 / assetToUnload /</span></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//该方法 不能释放 GameObject对象 因为它会用于实例化对象</span></span><br><span class="line"><span class="comment">//它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等</span></span><br><span class="line"><span class="comment">//一般情况下 我们很少单独使用它</span></span><br><span class="line"><span class="comment">//GameObject obj = Resources.CoroutineAsynLoad&lt;GameObject&gt;(&quot;Cube&quot;)</span></span><br><span class="line"><span class="comment">//即使是没有实例化的 GameObject对象也不能进行卸载</span></span><br><span class="line"><span class="comment">//Resources.UnloadAsset(obj);//报错 不能卸载GameObject</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="resources中的unloadunusedassets方法-卸载未使用的资源"><a class="markdownIt-Anchor" href="#resources中的unloadunusedassets方法-卸载未使用的资源"></a> Resources中的UnloadUnusedAssets方法 卸载未使用的资源</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卸载未使用的资源。</span></span><br><span class="line"><span class="comment">//注意：一般在过场景时和GC一起使用</span></span><br><span class="line">Resources.UnloadUnusedAssets();</span><br><span class="line">GC.Collect();    <span class="comment">// 手动触发垃圾回收</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;resources重复加载资源会浪费内存吗&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#resources重复加载资源会浪费内存吗&quot;&gt;&lt;/a&gt; Resources重复加载资源会浪费内存吗？&lt;/h1&gt;
&lt;p&gt;其实Resources加载一</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>13.Resources异步加载</title>
    <link href="http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/13.Resources%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/13.Resources%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</id>
    <published>2025-03-04T08:25:58.000Z</published>
    <updated>2025-03-04T10:05:03.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="resources-异步加载是什么"><a class="markdownIt-Anchor" href="#resources-异步加载是什么"></a> <strong>Resources 异步加载是什么？</strong></h1><p><strong>问题背景</strong>：<br />同步加载（<code>Resources.Load</code>）大资源时，硬盘读取到内存的资源的越大，耗时操作会<strong>阻塞主线程</strong>，导致游戏卡顿、掉帧。</p><p><strong>异步加载原理</strong>：Unity 内部会将资源加载任务分配到其他线程处理，主线程继续执行游戏逻辑，加载完成后通知主线程使用资源。<br /><strong>注意</strong>：虽然逻辑上是“多线程”，但 Unity 主线程仍需每帧检查加载状态，因此<strong>要等待加载完毕(至少要等1帧)</strong> 才能获取资源。</p><p><strong>两种实现方式</strong>：<br /><strong>事件监听</strong>：简单直接，适合单一资源加载。<br /><strong>协程</strong>：灵活控制，适合复杂加载逻辑。</p><h1 id="通过事件监听完成回调"><a class="markdownIt-Anchor" href="#通过事件监听完成回调"></a> <strong>通过事件监听完成回调</strong></h1><p>使用 <code>ResourceRequest</code> 的 <code>completed</code> 事件监听加载完成。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncLoadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始异步加载</span></span><br><span class="line">        ResourceRequest request = Resources.LoadAsync&lt;GameObject&gt;(<span class="string">&quot;Prefabs/Dragon&quot;</span>);</span><br><span class="line">        <span class="comment">// 注册完成事件</span></span><br><span class="line">        request.completed += OnLoadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载完成后的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadCompleted</span>(<span class="params">AsyncOperation operation</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ResourceRequest request = operation <span class="keyword">as</span> ResourceRequest;</span><br><span class="line">        GameObject dragonPrefab = request.asset <span class="keyword">as</span> GameObject;</span><br><span class="line">        Instantiate(dragonPrefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过-swig9-等待加载完成"><a class="markdownIt-Anchor" href="#通过-swig9-等待加载完成"></a> <strong>通过<a href="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/" title="10.协同程序">协程</a>等待加载完成</strong></h1><p>利用协程的 <code>yield return</code> 逐帧检查加载进度。</p><h2 id="resourcerequest的父类asyncoperation"><a class="markdownIt-Anchor" href="#resourcerequest的父类asyncoperation"></a> <code>ResourceRequest</code>的父类<code>AsyncOperation</code>：</h2><p>它代表一个异步操作。当你在 Unity 中执行一些可能会阻塞主线程的任务时，比如加载场景、加载资源等，Unity 会返回一个 <code>AsyncOperation</code> 对象，通过这个对象你可以监控异步操作的进度，以及在操作完成时执行特定的代码。</p><p><strong>常用属性</strong>：<br /><strong><code>isDone</code></strong>：这是一个布尔类型的属性，用于表示异步操作是否已经完成。<br /><strong><code>progress</code></strong>：这是一个浮点类型的属性，范围从 0 到 1，表示异步操作的进度。0 表示操作还未开始，1 表示操作已经完成。<br /><strong><code>allowSceneActivation</code></strong>：在使用 <code>SceneManager.LoadSceneAsync</code> 加载场景时，这个属性非常有用。当 <code>allowSceneActivation</code> 为 <code>false</code> 时，场景加载到 90% 就会暂停，直到将其设置为 <code>true</code> 才会继续加载并激活场景。</p><p><strong><code>completed</code></strong>：这是一个<code>Action&lt;AsyncOperation&gt;</code>事件，当异步操作完成时会触发该事件。你可以为这个事件添加一个委托，以便在操作完成时执行特定的代码。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourceRequest</span> : <span class="title">AsyncOperation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Object asset &#123; <span class="keyword">get</span>; &#125;   <span class="comment">// 加载完成的资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> progress &#123; <span class="keyword">get</span>; &#125; <span class="comment">// 加载进度(0.0~1.0)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDone &#123; <span class="keyword">get</span>; &#125;    <span class="comment">// 是否完成加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单加载案例"><a class="markdownIt-Anchor" href="#简单加载案例"></a> <strong>简单加载案例</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadCharacter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceRequest request = Resources.LoadAsync&lt;GameObject&gt;(<span class="string">&quot;Characters/Player&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request; <span class="comment">// 等待加载完成</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (request.asset != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Instantiate(request.asset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;加载资源失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带进度条的加载"><a class="markdownIt-Anchor" href="#带进度条的加载"></a> <strong>带进度条的加载</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadWithProgress</span>(<span class="params">Image progressBar</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ResourceRequest request = Resources.LoadAsync&lt;Texture2D&gt;(<span class="string">&quot;Textures/Background&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!request.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        progressBar.fillAmount = request.progress;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧更新进度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (request.asset != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GetComponent&lt;Renderer&gt;().material.mainTexture = request.asset <span class="keyword">as</span> Texture2D;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量异步加载"><a class="markdownIt-Anchor" href="#批量异步加载"></a> <strong>批量异步加载</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadMultipleResources</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] paths = &#123; <span class="string">&quot;Audio/Music&quot;</span>, <span class="string">&quot;Prefabs/Enemies&quot;</span>, <span class="string">&quot;Materials/Weapons&quot;</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> path <span class="keyword">in</span> paths)</span><br><span class="line">    &#123;</span><br><span class="line">        ResourceRequest request = Resources.LoadAsync(path);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 资源处理逻辑</span></span><br><span class="line">        HandleLoadedAsset(request.asset);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每加载完一个资源清理一次内存</span></span><br><span class="line">        Resources.UnloadUnusedAssets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带优先级的加载队列"><a class="markdownIt-Anchor" href="#带优先级的加载队列"></a> <strong>带优先级的加载队列</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">PriorityLoading</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一步：先加载核心资源</span></span><br><span class="line">    <span class="comment">// StartCoroutine 用于启动一个协程，这里启动了 LoadEssentialResources 协程</span></span><br><span class="line">    <span class="comment">// yield return 会暂停当前协程的执行，直到 LoadEssentialResources 协程执行完毕</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroutine</span>(<span class="params">LoadEssentialResources(</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：同时加载多个次要资源</span></span><br><span class="line"></span><br><span class="line">    Coroutine[] backgroundLoads = &#123;</span><br><span class="line">        <span class="comment">// UI 协程</span></span><br><span class="line">        StartCoroutine(LoadUIElements()),</span><br><span class="line">        <span class="comment">// 环境纹理 协程</span></span><br><span class="line">        StartCoroutine(LoadEnvironmentTextures())</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：等待所有次要资源加载完成</span></span><br><span class="line">    <span class="comment">// WaitUntil 是一个协程等待指令，它会暂停当前协程的执行，直到传入的委托返回 true</span></span><br><span class="line">    <span class="comment">// 这里使用 LINQ 的 All 方法来检查 backgroundLoads 数组中的所有协程是否都已经停止运行</span></span><br><span class="line">    <span class="comment">// IsCoroutineRunning 是一个自定义方法，用于判断一个协程是否正在运行</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params">(</span>)</span> =&gt; </span><br><span class="line">        backgroundLoads.All(c =&gt; !IsCoroutineRunning(c)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个自定义方法，用于检查一个协程是否正在运行</span></span><br><span class="line"><span class="comment">// 注意：Unity 本身没有直接提供检查协程是否运行的方法，这里只是一个示例实现</span></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">IsCoroutineRunning</span>(<span class="params">Coroutine coroutine</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实际实现需要根据具体情况来判断，这里简单返回 false 作为示例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载核心资源</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadEssentialResources</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里可以添加具体的核心资源加载逻辑</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 UI 元素</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadUIElements</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里可以添加具体的 UI 元素加载逻辑</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载环境纹理</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadEnvironmentTextures</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里可以添加具体的环境纹理加载逻辑</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><p><strong>请写一个简单的资源管理器，提供统一的方法给外部用于资源异步加载，外部可以传入委托用于当资源加载结束时使用资源</strong><br />注意到：<strong>每次加载资源都在重复做两件事</strong>：“这些重复代码能不能抽出来？”</p><ol><li>调用 <code>Resources.LoadAsync</code></li><li>处理 <code>completed</code> 事件并转换类型</li></ol><ul><li>识别重复代码中的「稳定部分」和「变化部分」</li><li>例：<code>LoadAsync</code>和回调处理是稳定部分，资源类型和路径是变化部分</li></ul><p><strong>封装触发点：</strong><br />当你第三次写出几乎相同的代码时，脑海中应该浮现：</p><blockquote><p>“这些加载操作的结构完全一样，只是<strong>资源类型</strong>、<strong>路径</strong>和<strong>回调内容</strong>不同。如果能写个方法把相同的部分抽出来，只要传递这三个变量就好了！”<br />这正是 <code>LoadRes&lt;T&gt;</code> 方法的诞生过程！</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourcesMgr</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourcesMgr _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResourcesMgr Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _instance = <span class="keyword">new</span> ResourcesMgr();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResourcesMgr</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己封装的资源异步加载</span></span><br><span class="line">    <span class="comment">// T是要加载的资源类型 可以加载任意类型的Unity资源（如GameObject、Texture、AudioClip等）</span></span><br><span class="line">    <span class="comment">// 注意LoadAsync的T有一个约束,必须是Object的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadRes</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> path, System.Action&lt;T&gt; callback</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        ResourceRequest rq = Resources.LoadAsync&lt;T&gt;(path);</span><br><span class="line">        <span class="comment">// 加载完成后的回调, a是 AsyncOperation 类型，需要转换为 ResourceRequest </span></span><br><span class="line">        rq.completed += (a) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 执行外面传进来的回调逻辑，callback的函数参数是</span></span><br><span class="line">            callback((a <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> T);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载预制件</span></span><br><span class="line">ResourcesMgr.Instance.LoadRes&lt;GameObject&gt;(<span class="string">&quot;Prefabs/Player&quot;</span>, (prefab) =&gt; &#123;</span><br><span class="line">    Instantiate(prefab); <span class="comment">// 实例化玩家</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载贴图</span></span><br><span class="line">ResourcesMgr.Instance.LoadRes&lt;Texture2D&gt;(<span class="string">&quot;Textures/Icon&quot;</span>, (texture) =&gt; &#123;</span><br><span class="line">    GetComponent&lt;Renderer&gt;().material.mainTexture = texture;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>对比着没有封装的写法</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有使用管理器的情况</span></span><br><span class="line">ResourceRequest rq = Resources.LoadAsync&lt;GameObject&gt;(<span class="string">&quot;Prefabs/Player&quot;</span>);</span><br><span class="line">rq.completed += (a) =&gt; &#123;</span><br><span class="line">    GameObject prefab = (a <span class="keyword">as</span> ResourceRequest).asset <span class="keyword">as</span> GameObject;</span><br><span class="line">    Instantiate(prefab);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;resources-异步加载是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#resources-异步加载是什么&quot;&gt;&lt;/a&gt; &lt;strong&gt;Resources 异步加载是什么？&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;问</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>12.Resources同步加载</title>
    <link href="http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/12.Resources%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/12.Resources%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD/</id>
    <published>2025-03-04T07:28:05.000Z</published>
    <updated>2025-03-04T08:11:30.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="resources-资源动态加载的作用"><a class="markdownIt-Anchor" href="#resources-资源动态加载的作用"></a> <strong>Resources 资源动态加载的作用</strong></h1><ul><li><strong>核心功能</strong>：允许在运行时按需加载资源，避免将所有资源预先加载到内存中。</li><li>避免繁琐的拖曳操作</li><li><strong>适用场景</strong>：<ul><li>按需加载不常用的资源（如关卡特定素材）。</li><li>动态替换资源（如角色换装）。</li></ul></li><li><strong>优点</strong>：减少内存占用，提升启动速度。</li><li><strong>缺点</strong>：频繁加载可能引发卡顿，滥用会导致应用体积膨胀。</li></ul><h1 id="常用资源类型"><a class="markdownIt-Anchor" href="#常用资源类型"></a> <strong>常用资源类型</strong></h1><p>Resources 支持加载 Unity 支持的几乎所有资源类型，常见的有：</p><ol><li><strong>预制体（Prefab）</strong>：<code>.prefab</code></li><li><strong>纹理（Texture）</strong>：<code>.png</code>, <code>.jpg</code></li><li><strong>音频（AudioClip）</strong>：<code>.mp3</code>, <code>.wav</code></li><li><strong>文本（TextAsset）</strong>：<code>.txt</code>, <code>.json</code>,<code>.xml</code>,<code>.bytes</code>,<code>.html</code>,<code>.csv</code></li><li><strong>材质（Material）</strong>：<code>.mat</code></li></ol><p>预设体对象加载需要实例化，音效要关联，图片要使用，文本要打印<br />其它资源加载一般直接用。</p><h1 id="资源同步加载-普通方法"><a class="markdownIt-Anchor" href="#资源同步加载-普通方法"></a> <strong>资源同步加载 - 普通方法</strong></h1><p>使用 <code>Resources.Load(string path)</code>，返回 <code>Object</code> 类型，需手动转换类型。<br />在一个工程当中， Resources可以有多个并放在任意的文件夹下， 通过API加载时候会自己去同名的Resources自己找</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载预制体，// 这里只是把预制体这个配置文件加载到内存, 还没实例化</span></span><br><span class="line">GameObject prefab = Resources.Load(<span class="string">&quot;Prefabs/Enemy&quot;</span>) <span class="keyword">as</span> GameObject;</span><br><span class="line">Instantiate(prefab);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载纹理</span></span><br><span class="line">Texture2D texture = Resources.Load(<span class="string">&quot;Textures/Icon&quot;</span>) <span class="keyword">as</span> Texture2D;</span><br><span class="line">GetComponent&lt;Renderer&gt;().material.mainTexture = texture;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载文本</span></span><br><span class="line">TextAsset textAsset = Resources.Load(<span class="string">&quot;Configs/Data&quot;</span>) <span class="keyword">as</span> TextAsset;</span><br><span class="line">Debug.Log(textAsset.text + <span class="string">&quot; &quot;</span> + textAsset.bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载音效</span></span><br><span class="line"><span class="keyword">public</span> AudioSource audioSource;</span><br><span class="line">Object obj3 = Resources.Load(<span class="string">&quot;Music/BKMusic&quot;</span>);</span><br><span class="line"><span class="comment">//我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可</span></span><br><span class="line">audioSource.clip = obj3 <span class="keyword">as</span> AudioClip;</span><br><span class="line">audioSource.Play();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line">tex = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>) <span class="keyword">as</span> Texture;</span><br></pre></td></tr></table></figure><p><strong>问题：资源同名怎么办</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Resources.Load加载同名资源时 无法准确加载出你想要的内容</span></span><br><span class="line"><span class="comment">//可以使用Load方法的重载，第二个参数传入加载的指定类型的资源</span></span><br><span class="line"><span class="comment">//加载指定类型的资源</span></span><br><span class="line">tex = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>, <span class="keyword">typeof</span>(Texture)) <span class="keyword">as</span> Texture;</span><br><span class="line">ta = Resources.Load(<span class="string">&quot;Tex/TestJPG&quot;</span>, <span class="keyword">typeof</span>(TextAsset)) <span class="keyword">as</span> TextAsset;</span><br><span class="line">print(ta.text);</span><br></pre></td></tr></table></figure><h1 id="资源同步加载-泛型方法"><a class="markdownIt-Anchor" href="#资源同步加载-泛型方法"></a> <strong>资源同步加载 - 泛型方法</strong></h1><p>使用 <code>Resources.Load&lt;T&gt;(string path)</code>，直接返回指定类型，无需强制转换。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载预制体（直接指定类型）</span></span><br><span class="line">GameObject prefab = Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Prefabs/Enemy&quot;</span>);</span><br><span class="line">Instantiate(prefab);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载音频</span></span><br><span class="line">AudioClip clip = Resources.Load&lt;AudioClip&gt;(<span class="string">&quot;Audio/Explosion&quot;</span>);</span><br><span class="line">GetComponent&lt;AudioSource&gt;().PlayOneShot(clip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载材质</span></span><br><span class="line">Material mat = Resources.Load&lt;Material&gt;(<span class="string">&quot;Materials/Glow&quot;</span>);</span><br><span class="line">GetComponent&lt;Renderer&gt;().material = mat;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><p><strong>请把之前<a href="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/#%E7%BB%83%E4%B9%A0" title="8.Quaternion四元数计算">四元数练习题</a>四元数练习题中，发射散弹等相关逻辑改为动态加载资源并创建</strong></p><p>把子弹丢到Resources文件夹后，有两种改法<br />第一种是不在Inspector窗口拖拽Prefab，直接在Start()里Load，实例化的时候直接使用即可</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接在Start()里Load</span></span><br><span class="line"><span class="keyword">private</span> GameObject bullet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    bullet = Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是在实例化的时候每次都Resources.Load(“Bullet”)<br />注意：这样不会造成内存上的浪费，因为Unity加载好的资源放在缓存区，判断Load过了就不重新Load了，内存不会开销但是会造成<strong>性能开销</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明发射类型枚举  </span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> E_FireType  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//单发  </span></span><br><span class="line">    One,  </span><br><span class="line">    <span class="comment">//双发  </span></span><br><span class="line">    Two,  </span><br><span class="line">    <span class="comment">//扇形  </span></span><br><span class="line">    Three,  </span><br><span class="line">    <span class="comment">//环形  </span></span><br><span class="line">    Round  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Airplane</span> : <span class="title">MonoBehaviour</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//声明发射类型变量   </span></span><br><span class="line">    <span class="keyword">private</span> E_FireType nowType = E_FireType.One;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//子弹  </span></span><br><span class="line">    <span class="keyword">public</span> GameObject bullet;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> roundNum = <span class="number">4</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//Update内添加按按键切换发射类型逻辑  </span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))  </span><br><span class="line">        &#123;  </span><br><span class="line">            nowType = E_FireType.One;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))  </span><br><span class="line">        &#123;  </span><br><span class="line">            nowType = E_FireType.Two;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))  </span><br><span class="line">        &#123;  </span><br><span class="line">            nowType = E_FireType.Three;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha4))  </span><br><span class="line">        &#123;  </span><br><span class="line">            nowType = E_FireType.Round;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//Update内添加按按键发射子弹逻辑  </span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))  </span><br><span class="line">        &#123;  </span><br><span class="line">            Fire();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开火方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">switch</span> (nowType)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">case</span> E_FireType.One:  </span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> E_FireType.Two:  </span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);  </span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> E_FireType.Three:  </span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);  </span><br><span class="line">                <span class="comment">//左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加  </span></span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">-20</span>, Vector3.up));  </span><br><span class="line">                <span class="comment">//右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加  </span></span><br><span class="line">                Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="keyword">case</span> E_FireType.Round:  </span><br><span class="line">                <span class="built_in">float</span> angle = <span class="number">360</span> / roundNum;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; roundNum; i++)  </span><br><span class="line">                    <span class="comment">//角度是当前偏移度数乘飞机自己的旋转  </span></span><br><span class="line">                    Instantiate(Resources.Load&lt;GameObject&gt;(<span class="string">&quot;Bullet&quot;</span>), <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up));  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;resources-资源动态加载的作用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#resources-资源动态加载的作用&quot;&gt;&lt;/a&gt; &lt;strong&gt;Resources 资源动态加载的作用&lt;/strong&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>11.特殊文件夹</title>
    <link href="http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/11.%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://example.com/2025/03/04/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/11.%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E5%A4%B9/</id>
    <published>2025-03-04T06:33:29.000Z</published>
    <updated>2025-03-04T07:26:14.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对比总结"><a class="markdownIt-Anchor" href="#对比总结"></a> <strong>对比总结</strong></h1><table><thead><tr><th>文件夹</th><th>用途</th><th>是否打包</th><th>可读写性</th></tr></thead><tbody><tr><td><strong>Resources</strong></td><td>动态加载资源</td><td>是</td><td>只读</td></tr><tr><td><strong>StreamingAssets</strong></td><td>存放原始文件（视频、数据库）</td><td>是</td><td>只读（移动端）</td></tr><tr><td><strong>persistentDataPath</strong></td><td>用户数据持久化</td><td>否</td><td>可读写</td></tr><tr><td><strong>Plugins</strong></td><td>原生插件</td><td>是</td><td>只读</td></tr><tr><td><strong>Editor</strong></td><td>编辑器扩展脚本</td><td>否</td><td>可读写</td></tr></tbody></table><h1 id="工程路径获取"><a class="markdownIt-Anchor" href="#工程路径获取"></a> <strong>工程路径获取</strong></h1><ul><li><strong>作用</strong>：获取项目根目录或特定子文件夹的路径。</li><li><strong>常用 API</strong>：<code>Application.dataPath</code>：项目根目录的绝对路径（不包含 Assets 文件夹）（该方式 获取到的路径 一般情况下 只在 编辑模式下使用，我们不会在实际发布游戏后 还使用该路径）例如：</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(Application.dataPath); <span class="comment">// 输出：D:/MyProject/Assets</span></span><br></pre></td></tr></table></figure><ul><li><code>Application.streamingAssetsPath</code>：<code>StreamingAssets</code> 文件夹的路径（后文详解）。</li><li><code>Application.persistentDataPath</code>：持久化数据目录的路径（后文详解）。</li></ul><h1 id="resources-资源文件夹"><a class="markdownIt-Anchor" href="#resources-资源文件夹"></a> <strong>Resources 资源文件夹</strong></h1><p>如果你希望在代码中动态加载资源，可以将这些资源放在 Resources 文件夹中，然后使用 Resources.Load 方法来加载。</p><ul><li><strong>路径</strong>：<code>Assets/Resources</code></li><li><strong>特点</strong>：<ul><li><strong>打包后只读 只能通过Resources相关API加载</strong>，通过 <code>Resources.Load(&quot;资源名&quot;)</code> 动态加载资源（无需路径）。</li><li>打包时Unity会对其压缩加密 所以一般不会用Application.dataPath + “/Resources” 得到路径</li><li><strong>打包时会压缩</strong>：<strong>所有资源会被打包到应用中。</strong></li><li><strong>慎用</strong>：过度使用会导致应用体积膨胀，且加载效率较低。（不要把所有游戏资源都丢进去 一般放在美术资源文件夹就行了 需要动态加载或者打包的再丢进去）</li><li><strong>需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错</strong></li></ul></li></ul><h1 id="streamingassets-流动资源文件夹"><a class="markdownIt-Anchor" href="#streamingassets-流动资源文件夹"></a> <strong>StreamingAssets 流动资源文件夹</strong></h1><p>用于存放项目运行时需要访问的静态数据文件，如音频、视频、配置文件等。这些文件在构建项目时会被打包到应用程序的可执行文件中，可以通过路径访问。</p><ul><li><strong>路径</strong>：<code>Assets/StreamingAssets</code></li><li><strong>特点</strong>：<ul><li>可以放入一些需要<strong>自定义动态加载的初始资源</strong></li><li><strong>不压缩</strong>：资源保持原始格式，适用于视频、数据库等文件，打包出去不会被压缩加密，可以任由我们摆布。</li><li><strong>只读</strong>：在移动平台（如 Android、iOS）上不可写入，PC平台可读可写。</li><li><strong>访问方式</strong>：通过 <code>Application.streamingAssetsPath</code> 获取路径。</li><li><strong>需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错</strong></li></ul></li><li><strong>平台路径差异</strong>：<ul><li>PC：直接文件路径（如 D:/MyProject/Assets/StreamingAssets/data.txt）。</li><li>Android：路径在 APK 内部，需用 <code>UnityWebRequest</code> 读取。</li></ul></li></ul><h1 id="persistentdatapath-持久数据文件夹"><a class="markdownIt-Anchor" href="#persistentdatapath-持久数据文件夹"></a> <strong>persistentDataPath 持久数据文件夹</strong></h1><p>固定数据文件夹,  通常用于存储应用程序的配置文件、用户数据、游戏进度等重要数据，确保数据在应用程序关闭后仍然能够被保留和访问<br />还可以用于放置动态下载或者动态创建的文件, 游戏中创建或者获取的文件都放在其中</p><ul><li><strong>路径</strong>：不同平台路径不同：<code>Application.persistentDataPath</code><ul><li><strong>Windows</strong>：C:/Users/用户名/AppData/LocalLow/公司名/应用名</li><li><strong>Android</strong>：/data/data/包名/files</li><li><strong>iOS</strong>：Application.persistentDataPath</li></ul></li><li><strong>特点</strong>：<ul><li><strong>可读写</strong>：用于保存用户生成的数据（如存档、配置文件）。</li><li><strong>持久化</strong>：应用更新或重启后数据不会丢失。</li><li>所有平台<strong>可读可写</strong></li><li><strong>不需创建StreamingAssets文件夹</strong></li></ul></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> savePath = Path.Combine(Application.persistentDataPath, <span class="string">&quot;save.dat&quot;</span>);</span><br><span class="line">File.WriteAllText(savePath, <span class="string">&quot;游戏存档数据&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="plugins-插件文件夹"><a class="markdownIt-Anchor" href="#plugins-插件文件夹"></a> <strong>Plugins 插件文件夹</strong></h1><p>存放原生插件（如 .dll、.so、.a 文件）或平台特定代码。<br />不同平台的插件相关文件放在其中<br />比如IOS和Android平台 可能需要对应平台提供的代码包才能在Unity使用<br />以后搞SDK相关的时候可能才用得到</p><ul><li><strong>路径</strong>：<code>Assets/Plugins</code></li><li><strong>特点</strong>：<ul><li><strong>需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错</strong></li></ul></li><li><strong>平台子文件夹</strong>：<ul><li><code>Android</code>：存放安卓平台的 <code>.so</code> 文件。</li><li><code>iOS</code>：存放 iOS 的 <code>.a</code> 文件。</li></ul></li><li><strong>注意事项</strong>：插件需按平台分类存放，Unity 会自动识别。</li></ul><h1 id="editor-编辑器文件夹"><a class="markdownIt-Anchor" href="#editor-编辑器文件夹"></a> <strong>Editor 编辑器文件夹</strong></h1><p>存放编辑器扩展脚本（如自定义 Inspector、工具）。</p><ul><li><strong>路径</strong>：<code>Assets/Editor</code></li><li><strong>特点</strong>：<ul><li><strong>需自己手动在Asset文件下创建StreamingAssets文件夹 名字一定不要错</strong></li><li>脚本只在 Unity 编辑器中运行，不会被打包到应用中。</li><li>可继承 <code>Editor</code> 类实现自定义功能。</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对比总结&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#对比总结&quot;&gt;&lt;/a&gt; &lt;strong&gt;对比总结&lt;/strong&gt;&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件夹&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;是否</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>csharp迭代器</title>
    <link href="http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2025-03-03T12:31:58.000Z</published>
    <updated>2025-03-04T06:16:05.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器是什么"><a class="markdownIt-Anchor" href="#迭代器是什么"></a> 迭代器是什么</h1><p>在 C# 中，<strong>迭代器（Iterator）</strong> 是一种用于遍历集合（如数组、列表等）元素的机制，它允许你按顺序访问集合中的每个元素而不必暴露集合的内部结构。迭代器的核心是通过 <code>IEnumerable</code> 和 <code>IEnumerator</code> 接口实现的，但 C# 提供了更简洁的语法（<code>yield</code> 关键字）来简化迭代器的创建。</p><p>在表现效果上看，迭代器是可以在容器对象（例如链表或数组）上遍历访问的接口。设计人员无需关心容器对象的内存分配的实现细节，可以用foreach遍历的类，都是实现了迭代器的。</p><h1 id="迭代器的基本概念"><a class="markdownIt-Anchor" href="#迭代器的基本概念"></a> <strong>迭代器的基本概念</strong></h1><ul><li><strong><code>IEnumerable</code> 接口</strong>：表示一个集合可以被迭代，包含一个 <code>GetEnumerator</code> 方法。</li><li><strong><code>IEnumerator</code> 接口</strong>：提供了遍历集合的能力，包含 <code>MoveNext()</code>、<code>Reset()</code> 和 <code>Current</code> 属性。</li></ul><p><strong>标准迭代器实现（手动版）</strong><br /><strong>接口定义</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>()</span>;</span><br><span class="line">    <span class="built_in">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>()</span>; <span class="comment">// 实际开发中通常不实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完整实现示例</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCollection</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span> =&gt; <span class="keyword">new</span> MyEnumerator(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义枚举器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">MyEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span>[] data;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyEnumerator</span>(<span class="params"><span class="built_in">int</span>[] data</span>)</span> =&gt; <span class="keyword">this</span>.data = data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> index &lt; data.Length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">object</span> Current =&gt; data[index];</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span> =&gt; index = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="built_in">int</span> num <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">MyCollection</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num); <span class="comment">// 输出 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="foreach本质"><a class="markdownIt-Anchor" href="#foreach本质"></a> foreach本质</h1><p><strong>foreach本质</strong>:</p><ol><li>先获取in后面这个对象的 <code>IEnumerator</code> 会调用对象其中的<code>GetEnumerator</code>方法</li><li>执行得到这个<code>IEnumerator</code>对象中的 <code>MoveNext</code>方法</li><li>只要<code>MoveNext()</code>方法的返回值时true 就会去得到<code>Current</code>然后复制给 item</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> collection) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">IEnumerator enumerator = collection.GetEnumerator();</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (enumerator.MoveNext()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> item = enumerator.Current;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> </span><br><span class="line">&#123;</span><br><span class="line">    IDisposable disposable = enumerator <span class="keyword">as</span> IDisposable;</span><br><span class="line">    disposable?.Dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="yield-return-语法糖"><a class="markdownIt-Anchor" href="#yield-return-语法糖"></a> <code>yield return</code> 语法糖</h1><p>C# 的 <code>yield return</code> 关键字可以快速定义迭代器，无需手动实现 <code>IEnumerator</code></p><h2 id="基本作用简化迭代器"><a class="markdownIt-Anchor" href="#基本作用简化迭代器"></a> <strong>基本作用：简化迭代器</strong></h2><p><code>yield return</code> 的作用是告诉编译器：“帮我自动生成一个迭代器，按我写的顺序逐个返回这些值”。例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>GetNumbers()</code> 时，它不会一次性返回所有值，而是返回一个“待执行的迭代器”。只有当你用 <code>foreach</code> 遍历时，才会按顺序取出每个值。</p><h2 id="关键特性延迟执行lazy"><a class="markdownIt-Anchor" href="#关键特性延迟执行lazy"></a> <strong>关键特性：延迟执行（Lazy）</strong></h2><p><code>yield return</code> 的代码不会一次性全部执行，而是按需执行。看这个例子：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">string</span>&gt; <span class="title">GetMessages</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;开始迭代&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;第一步&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;执行到中间&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;第二步&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;结束迭代&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码：</span></span><br><span class="line"><span class="keyword">var</span> messages = GetMessages();  <span class="comment">// 这里不会输出任何内容！</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;准备遍历&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> messages)  <span class="comment">// 此时才开始真正执行</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li>调用 <code>GetMessages()</code> 时，代码不会运行，只是返回一个“迭代器对象”。</li><li>当 <code>foreach</code> 开始遍历时，代码才从头执行，每次遇到 <code>yield return</code> 时：<ul><li>返回一个值，</li><li><strong>暂停当前方法</strong>，记录当前位置（状态）。</li><li>下次循环时，从暂停的位置继续执行。</li></ul></li></ul><h2 id="底层原理状态机"><a class="markdownIt-Anchor" href="#底层原理状态机"></a> <strong>底层原理：状态机</strong></h2><p>编译器会将 <code>yield return</code> 代码转换为一个隐藏的“状态机”类。例如，上述 <code>GetMessages()</code> 会被编译成一个类似如下的类：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">GeneratedStateMachine</span> : <span class="title">IEnumerator</span>&lt;<span class="title">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Current &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">MoveNext</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (_state)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;开始迭代&quot;</span>);</span><br><span class="line">                Current = <span class="string">&quot;第一步&quot;</span>;</span><br><span class="line">                _state = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;执行到中间&quot;</span>);</span><br><span class="line">                Current = <span class="string">&quot;第二步&quot;</span>;</span><br><span class="line">                _state = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;结束迭代&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 结束</span></span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他接口方法（略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="yield-break"><a class="markdownIt-Anchor" href="#yield-break"></a> yield break</h2><p><strong><code>yield break</code> 的基本作用</strong></p><ul><li><strong>功能</strong>：在迭代器方法中，<code>yield break</code> 会立即终止迭代，不再生成后续的值。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>; <span class="comment">// 这里终止，后续的 yield return 不会执行</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// 永远不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> num <span class="keyword">in</span> <span class="title">GetNumbers</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：1, 2</span></span><br></pre></td></tr></table></figure><h2 id="实际应用案例"><a class="markdownIt-Anchor" href="#实际应用案例"></a> <strong>实际应用案例</strong></h2><p><strong>分页加载数据</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">LoadBigData</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> pageSize = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> page = <span class="number">0</span>; ; page++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> data = QueryDatabase(page, pageSize);</span><br><span class="line">        <span class="keyword">if</span> (data.Count == <span class="number">0</span>) <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>游戏技能连招系统</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">ComboAttack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">PlayAnimation</span>(<span class="params"><span class="string">&quot;Attack1&quot;</span></span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetButton(<span class="string">&quot;Attack&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">PlayAnimation</span>(<span class="params"><span class="string">&quot;Attack2&quot;</span></span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButton(<span class="string">&quot;Attack&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">PlayAnimation</span>(<span class="params"><span class="string">&quot;FinalBlow&quot;</span></span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树形结构遍历</strong>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable&lt;Node&gt; <span class="title">Traverse</span>(<span class="params">Node root</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> root.Children)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> node <span class="keyword">in</span> <span class="title">Traverse</span>(<span class="params">child</span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迭代器是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#迭代器是什么&quot;&gt;&lt;/a&gt; 迭代器是什么&lt;/h1&gt;
&lt;p&gt;在 C# 中，&lt;strong&gt;迭代器（Iterator）&lt;/strong&gt; 是一种用于遍历集合（如数组、列表等）元素的机</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>csharp多线程</title>
    <link href="http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2025-03-03T12:20:16.000Z</published>
    <updated>2025-03-03T12:20:30.543Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wyt007/p/9486752.html">c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园</a></p><h1 id="线程基础"><a class="markdownIt-Anchor" href="#线程基础"></a> 线程基础</h1><h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2><p><code>Thread t = new Thread(PrintNumbers)</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(PrintNumbers);</span><br><span class="line">    t.Start();<span class="comment">//线程开始执行</span></span><br><span class="line">    PrintNumbers();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暂停线程"><a class="markdownIt-Anchor" href="#暂停线程"></a> 暂停线程</h2><p><code>Thread.Sleep</code><br />工作原理：<br />当线程处于休眠状态时，它会占用尽可能少的 CPU 时间。结果我们会发现通常后运行的 PrintNumbers 方法中的代码会比独立线程中的 PrintNumbersWithDelay暂停2S 方法中的代码先执行。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        PrintNumbers();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithDelay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));<span class="comment">//暂停2S</span></span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程等待"><a class="markdownIt-Anchor" href="#线程等待"></a> 线程等待</h2><p><code>t.Join()</code><br />工作原理：<br />但我们在主程序中调用了 t.Join 方法，该方法允许我们等待直到线程 t 完成。当线程 t 完成时，主程序会继续运行。<br />借助该技术可以实现在两个线程间同步执行步骤。第一个线程会等待另一个线程完成后再继续执行。第一个线程等待时是处于阻塞状态 (正如暂停线程中调用 Thread.Sleep 方法一样)。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting program...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        t.Join();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Thread completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithDelay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="终止线程"><a class="markdownIt-Anchor" href="#终止线程"></a> 终止线程</h2><p><code> t.Abort()</code> 弃用了<br />工作原理：<br />当主程序和单独的数字打印线程运行时，我们等待 6 秒后对线程调用了 t.Abort 方法。<br />这给线程注入了 ThreadAbortException 方法，导致线程被终结。这非常危险，因为该异常可以在任何时刻发生并可能彻底摧毁应用程序。<br />另外，使用该技术也不一定总能终止线程。目标线程可以通过处理该异常并调用 Thread.ResetAbort 方法来拒绝被终止。因此<strong>并不推荐使用 Abort 方法来关闭线程。</strong> 可优先使用一些其他方法，比如提供一个 CancellationToken 方法来取消线程的执行。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting program...&quot;</span>);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithDelay);</span><br><span class="line">        t.Start();</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">6</span>));</span><br><span class="line">        t.Abort();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A thread has been aborted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithDelay</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监测线程状态"><a class="markdownIt-Anchor" href="#监测线程状态"></a> 监测线程状态</h2><p><code>Thread 对象的 ThreadState</code>:</p><ul><li>Unstarted：线程已被创建，但尚未调用 <code>Start</code> 方法启动。</li><li>Running ：线程正在执行。当调用 <code>Start</code> 方法后，线程进入此状态并开始执行其关联的方法。</li><li>WaitSleepJoin：线程正在等待、休眠或被阻塞。当线程调用 <code>Sleep</code>、<code>Wait</code> 或 <code>Join</code> 方法时，会进入此状态。</li><li>Suspended（不推荐使用）：线程已被挂起。可以使用 <code>Suspend</code> 方法将线程挂起，但该方法已被弃用，因为它可能会导致死锁等问题。</li><li>Stopped：线程已完成执行或被终止，处于停止状态。</li><li>Aborted：线程已被调用 <code>Abort</code> 方法终止，但尚未完全停止执行。</li><li>。。。。。。。。。<br />工作原理：<br />当主程序启动时定义了两个不同的线程。一个将被终止，另一个则会成功完成运行。<br /><strong>线程状态位于 Thread 对象的 ThreadState 属性中。ThreadState 属性是一个 C# 枚举对象。</strong><br />刚开始线程状态为 ThreadState.Unstarted, 然后我们启动线程，并估计在一个周期为 30 次迭代的区间中，线程状态会从 ThreadState.Running 变为 ThreadState.WaitSleepJoin。<br />请注意始终可以通过 <code>Thread.CurrentThread</code> 静态属性获得当前 Thread 对象。<br />如果实际情况与以上不符，请增加迭代次数。终止第一个线程后，会看到现在该线程状态为 ThreadState.Aborted, 程序也有可能会打印出 ThreadState.AbortRequested 状态。这充分说明了同步两个线程的复杂性。请记住不要在程序中使用线程终止。我在这里使用它只是为了展示相应的线程状态。<br />最后可以看到第二个线程 t2 成功完成并且状态为 ThreadState.Stopped。另外还有一些其他的线程状态，但是要么已经被弃用，要么没有我们实验过的几种状态有用。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting program...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(PrintNumbersWithStatus);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(DoNothing);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 t 的初始状态</span></span><br><span class="line">        Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        t2.Start();</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 29 次，输出线程 t 的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠 6 秒</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 终止线程 t</span></span><br><span class="line">        t.Abort();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;A thread has been aborted&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 t 终止后的状态</span></span><br><span class="line">        Console.WriteLine(t.ThreadState.ToString());</span><br><span class="line">        <span class="comment">// 线程 t2 的状态</span></span><br><span class="line">        Console.WriteLine(t2.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoNothing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumbersWithStatus</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting...&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出当前线程的状态</span></span><br><span class="line">        Console.WriteLine(Thread.CurrentThread.ThreadState.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 9 次，每次打印一个数字，每次循环间隔 2 秒</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h2><p><code>Thread.CurrentThread.Priority</code></p><p>工作原理：<br />当主程序启动时定义了两个不同的线程。<br />第一个线程优先级为 ThreadPriority.Highest, 即具有最高优先级。<br />第二个线程优先级为 ThreadPriority.Lowest, 即具有最低优先级。<br />我们先打印出主线程的优先级值，然后在所有可用的 CPU 核心上启动这两个线程。如果拥有一个 1 以上的计算核心，将在两秒钟内得到初步结果。最高优先级的线程通常会计算更多的迭代，但是两个值应该很接近。然而，如果有其他程序占用了所有的 CPU 核心运行负载，结果则会截然不同。<br />为了模拟该情形，我们设置了 <code>ProcessorAffinity</code> 选项，让操作系统将所有的线程运行在单个 CPU 核心 (第一个核心) 上。现在结果完全不同，并且计算耗时将超过 2 秒钟。这是因为 CPU 核心大部分时间在运行高优先级的线程，只留给剩下的线程很少的时间来运行。<br />请注意这是操作系统使用线程优先级的一个演示。通常你无需使用这种行为编写程序。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出当前线程的优先级</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Current thread priority: &#123;0&#125;&quot;</span>, Thread.CurrentThread.Priority);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Running on all cores available&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 RunThreads 方法启动线程, 程序将在所有可用核心上运行</span></span><br><span class="line">        RunThreads();</span><br><span class="line">        <span class="comment">// 主线程休眠 2 秒</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Running on a single core&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置当前进程仅使用一个核心</span></span><br><span class="line">        Process.GetCurrentProcess().ProcessorAffinity = <span class="keyword">new</span> IntPtr(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        RunThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动两个线程并设置不同优先级的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunThreads</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sample = <span class="keyword">new</span> ThreadSample();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> threadOne = <span class="keyword">new</span> Thread(sample.CountNumbers);</span><br><span class="line">        threadOne.Name = <span class="string">&quot;ThreadOne&quot;</span>;  <span class="comment">// 线程命名</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> threadTwo = <span class="keyword">new</span> Thread(sample.CountNumbers);</span><br><span class="line">        threadTwo.Name = <span class="string">&quot;ThreadTwo&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置第一个线程的优先级为最高</span></span><br><span class="line">        threadOne.Priority = ThreadPriority.Highest;</span><br><span class="line">        <span class="comment">// 设置第二个线程的优先级为最低</span></span><br><span class="line">        threadTwo.Priority = ThreadPriority.Lowest;</span><br><span class="line"></span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadTwo.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠 2 秒</span></span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 调用 Stop 方法停止线程计数</span></span><br><span class="line">        sample.Stop();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadSample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用于控制线程计数循环的标志</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">bool</span> _isStopped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止线程计数的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Stop</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            _isStopped = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程执行的计数方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 初始化计数器</span></span><br><span class="line">            <span class="built_in">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要未停止，就持续计数</span></span><br><span class="line">            <span class="keyword">while</span> (!_isStopped)</span><br><span class="line">            &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出线程名称、优先级和计数结果</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; with &#123;1,11&#125; priority &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;has a count = &#123;2,13&#125;&quot;</span>, Thread.CurrentThread.Name,</span><br><span class="line">                        Thread.CurrentThread.Priority,</span><br><span class="line">                        counter.ToString(<span class="string">&quot;N0&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前台线程和后台线程"><a class="markdownIt-Anchor" href="#前台线程和后台线程"></a> 前台线程和后台线程</h2><p><code>thread.IsBackground = true</code><br />工作原理：<br />当主程序启动时定义了两个不同的线程。默认情况下，显式创建的线程是前台线程。通过手动的设置 threadTwo 对象的 IsBackground 属性为 ture 来创建一个后台线程(可以在主线程设置其它线程执行完毕的条件)。通过配置来实现第一个线程会比第二个线程先完成。然后运行程序。<br />第一个线程完成后，程序结束并且后台线程被终结。这是前台线程与后台线程的主要区别：<strong>进程会等待所有的前台线程完成后再结束工作，但是如果只剩下后台线程，则会直接结束工作。</strong><br />一个重要注意事项是：如果程序定义了一个不会完成的前台线程，主程序并不会正常结束。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> sampleForeground = <span class="keyword">new</span> ThreadSample(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">var</span> sampleBackground = <span class="keyword">new</span> ThreadSample(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> threadOne = <span class="keyword">new</span> Thread(sampleForeground.CountNumbers);</span><br><span class="line">        threadOne.Name = <span class="string">&quot;ForegroundThread&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> threadTwo = <span class="keyword">new</span> Thread(sampleBackground.CountNumbers);</span><br><span class="line">        threadTwo.Name = <span class="string">&quot;BackgroundThread&quot;</span>;</span><br><span class="line">        threadTwo.IsBackground = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        threadOne.Start();</span><br><span class="line">        threadTwo.Start();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadSample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _iterations;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadSample</span>(<span class="params"><span class="built_in">int</span> iterations</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _iterations = iterations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(<span class="number">0.5</span>));</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; prints &#123;1&#125;&quot;</span>, Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向线程传递参数"><a class="markdownIt-Anchor" href="#向线程传递参数"></a> 向线程传递参数</h2><p><strong>通过实例字段间接传递参数</strong></p><p><strong>Thread.Start 方法传入object类型参数</strong><br />另一种传递数据的方式是使用 Thread.Start 方法。该方法会接收一个对象，并将该对象传递给线程。为了应用该方法，在线程中启动的方法必须接受 object 类型的单个参数。在创建 threadTwo 线程时演示了该方式。我们将 8 作为一个对象传递给了 Count 方法，然后 Count 方法被转换为整型。</p><p><strong>使用 Lambda 表达式捕获变量</strong><br />接下来的方式是使用 lambda 表达式。lambda 表达式定义了一个不属于任何类的方法。我们创建了一个方法，该方法使用需要的参数调用了另一个方法，并在另一个线程中运行该方法。当启动 threadThree 线程时，打印出了 12 个数字，这正是我们通过 lambda 表达式传递的数字。</p><p>使用 lambda 表达式引用另一个 C# 对象的方式被称为<a href="/2025/02/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/#%E9%97%AD%E5%8C%85%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7" title="csharp的Lambda表达式">csharp的Lambda表达式</a>。当在 lambda 表达式中使用任何局部变量时，C# 会生成一个类，并将该变量作为该类的一个属性。所以实际上该方式与 threadOne 线程中使用的一样，但是我们无须定义该类，C# 编译器会自动帮我们实现。<br />这可能会导致几个问题。例如，如果在多个 lambda 表达式中使用相同的变量，它们会共享该变量值。在前一个例子中演示了这种情况。当启动 threadFour 和 threadFive 线程时，它们都会打印 20, 因为在这两个线程启动之前变量被修改为 20。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指定迭代次数为 10</span></span><br><span class="line">        <span class="keyword">var</span> sample = <span class="keyword">new</span> ThreadSample(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第一个线程，执行 sample 实例的 CountNumbers 方法</span></span><br><span class="line">        <span class="keyword">var</span> threadOne = <span class="keyword">new</span> Thread(sample.CountNumbers);</span><br><span class="line">        threadOne.Name = <span class="string">&quot;ThreadOne&quot;</span>;</span><br><span class="line">        threadOne.Start();</span><br><span class="line">        <span class="comment">// 主线程等待 threadOne 执行完毕</span></span><br><span class="line">        threadOne.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第二个线程，执行静态方法 Count</span></span><br><span class="line">        <span class="keyword">var</span> threadTwo = <span class="keyword">new</span> Thread(Count);</span><br><span class="line">        threadTwo.Name = <span class="string">&quot;ThreadTwo&quot;</span>;</span><br><span class="line">        <span class="comment">// 启动线程并传递参数 8</span></span><br><span class="line">        threadTwo.Start(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 主线程等待 threadTwo 执行完毕</span></span><br><span class="line">        threadTwo.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第三个线程，使用 Lambda 表达式调用静态方法 CountNumbers</span></span><br><span class="line">        <span class="keyword">var</span> threadThree = <span class="keyword">new</span> Thread(() =&gt; CountNumbers(<span class="number">12</span>));</span><br><span class="line">        threadThree.Name = <span class="string">&quot;ThreadThree&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        threadThree.Start();</span><br><span class="line">        <span class="comment">// 主线程等待 threadThree 执行完毕</span></span><br><span class="line">        threadThree.Join();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个整数变量 i 并初始化为 10</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 创建第四个线程，使用 Lambda 表达式调用静态方法 PrintNumber</span></span><br><span class="line">        <span class="keyword">var</span> threadFour = <span class="keyword">new</span> Thread(() =&gt; PrintNumber(i));</span><br><span class="line">        <span class="comment">// 修改变量 i 的值为 20</span></span><br><span class="line">        i = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 创建第五个线程，使用 Lambda 表达式调用静态方法 PrintNumber</span></span><br><span class="line">        <span class="keyword">var</span> threadFive = <span class="keyword">new</span> Thread(() =&gt; PrintNumber(i));</span><br><span class="line">        threadFour.Start(); </span><br><span class="line">        threadFive.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Count</span>(<span class="params"><span class="built_in">object</span> iterations</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CountNumbers((<span class="built_in">int</span>)iterations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法，用于循环打印线程名称和迭代次数，每次循环间隔 0.5 秒</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>(<span class="params"><span class="built_in">int</span> iterations</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= iterations; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">0.5</span>));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; prints &#123;1&#125;&quot;</span>, Thread.CurrentThread.Name, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintNumber</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadSample</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 迭代次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> _iterations;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadSample</span>(<span class="params"><span class="built_in">int</span> iterations</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _iterations = iterations;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环打印线程名称和迭代次数，每次循环间隔 0.5 秒</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CountNumbers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= _iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(<span class="number">0.5</span>));</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; prints &#123;1&#125;&quot;</span>, Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-c-中的-lock-关键字"><a class="markdownIt-Anchor" href="#使用-c-中的-lock-关键字"></a> 使用 C# 中的 lock 关键字</h2><p><strong>lock 的作用</strong></p><ul><li><strong>线程同步</strong>：确保在多线程环境下，同一时间只有一个线程可以访问临界区（被锁保护的代码块）。</li><li><strong>解决竞态条件</strong>：防止多个线程同时修改共享资源导致数据不一致。</li></ul><p><strong>基本语法</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _lockObj = <span class="keyword">new</span> <span class="built_in">object</span>(); <span class="comment">// 锁对象必须是引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadSafeMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_lockObj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 临界区代码（同一时间仅一个线程可执行）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层原理</strong><br /><strong>基于 Monitor 类</strong>：<code>lock</code> 是语法糖，编译后等价于：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Enter(_lockObj, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockTaken)</span><br><span class="line">        Monitor.Exit(_lockObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不安全的计数器（Counter 类）</strong> 与 <strong>安全的计数器（CounterWithLock 类）</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不正确的计数器</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Incorrect counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> t1 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c));</span><br><span class="line">        <span class="keyword">var</span> t2 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c));</span><br><span class="line">        <span class="keyword">var</span> t3 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c));</span><br><span class="line">        t1.Start();</span><br><span class="line">        t2.Start();</span><br><span class="line">        t3.Start();</span><br><span class="line">        t1.Join();</span><br><span class="line">        t2.Join();</span><br><span class="line">        t3.Join();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Total count: &#123;0&#125;&quot;</span>,c.Count);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确的计数器</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Correct counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> c1 = <span class="keyword">new</span> CounterWithLock();</span><br><span class="line"></span><br><span class="line">        t1 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c1));</span><br><span class="line">        t2 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c1));</span><br><span class="line">        t3 = <span class="keyword">new</span> Thread(() =&gt; TestCounter(c1));</span><br><span class="line">        t1.Start();</span><br><span class="line">        t2.Start();</span><br><span class="line">        t3.Start();</span><br><span class="line">        t1.Join();</span><br><span class="line">        t2.Join();</span><br><span class="line">        t3.Join();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Total count: &#123;0&#125;&quot;</span>, c1.Count);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestCounter</span>(<span class="params">CounterBase c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c.Increment();</span><br><span class="line">            c.Decrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没加锁的计数器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Counter</span> : <span class="title">CounterBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加了锁的计数器</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">CounterWithLock</span> : <span class="title">CounterBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _syncRoot = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_syncRoot)</span><br><span class="line">            &#123;</span><br><span class="line">                Count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_syncRoot)</span><br><span class="line">            &#123;</span><br><span class="line">                Count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CounterBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lock相关注意：</strong><br /><strong>(1) 锁对象的选择</strong></p><ul><li><strong>锁对象必须是引用类型</strong>：值类型会被装箱，每次装箱生成新对象，导致锁失效。</li><li><strong>私有且只读</strong>：防止锁对象被修改。推荐模式：<code>private readonly object _lockObj = new object(); // 专用锁对象</code><br /><strong>(2) 临界区最小化</strong></li><li><strong>锁的粒度要细</strong>：仅保护真正需要同步的资源，减少锁持有时间</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：锁范围过大</span></span><br><span class="line"><span class="keyword">lock</span> (_lockObj)</span><br><span class="line">&#123;</span><br><span class="line">    ReadData();</span><br><span class="line">    ProcessData(); <span class="comment">// 长时间计算</span></span><br><span class="line">    WriteData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：仅锁共享数据操作</span></span><br><span class="line"><span class="keyword">var</span> data = ReadData();</span><br><span class="line"><span class="keyword">var</span> result = ProcessData(data); <span class="comment">// 无锁计算</span></span><br><span class="line"><span class="keyword">lock</span> (_lockObj)</span><br><span class="line">&#123;</span><br><span class="line">    WriteData(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(3) 避免嵌套锁</strong></p><ul><li><strong>死锁风险</strong>：若多个锁以不同顺序嵌套获取，可能引发死锁。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="keyword">lock</span> (A)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (B) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="keyword">lock</span> (B) <span class="comment">// 若线程1已持A等B，线程2持B等A → 死锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (A) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用monitor类锁定资源"><a class="markdownIt-Anchor" href="#使用monitor类锁定资源"></a> 使用Monitor类锁定资源*</h2><p><strong>代码行为分析</strong></p><p><strong>第一部分（使用 TryEnter 避免死锁）</strong></p><ol><li><strong>线程1</strong>执行 <code>LockTooMuch</code>：获取 <code>lock1</code> → 休眠 1 秒 → 尝试获取 <code>lock2</code>。</li><li><strong>主线程</strong>：获取 <code>lock2</code> → 休眠 1 秒 → 尝试通过 <code>TryEnter</code> 获取 <code>lock1</code>（超时 5 秒）。</li></ol><p><strong>可能的执行结果</strong>：</p><ul><li><strong>线程1</strong>持有 <code>lock1</code>，等待 <code>lock2</code>；<strong>主线程</strong>持有 <code>lock2</code>，等待 <code>lock1</code> → <strong>死锁条件成立</strong>。</li><li>但由于主线程使用 <code>TryEnter</code>，5 秒后会超时并释放 <code>lock2</code>，随后线程1最终能获取 <code>lock2</code>，继续执行。</li><li>输出：<code>Timeout acquiring a resource!</code>。</li></ul><p><strong>第二部分（直接死锁）</strong></p><ol><li><strong>线程2</strong>再次执行 <code>LockTooMuch</code>（同上）。</li><li><strong>主线程</strong>再次尝试以 <code>lock2 → lock1</code> 顺序获取锁。<br /><strong>结果</strong>：主线程持有 <code>lock2</code>，等待 <code>lock1</code>；线程2持有 <code>lock1</code>，等待 <code>lock2</code> → <strong>死锁</strong>，程序永久阻塞。</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建两个锁对象</span></span><br><span class="line">        <span class="built_in">object</span> lock1 = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">        <span class="built_in">object</span> lock2 = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动第一个线程：尝试以 lock1 → lock2 顺序获取锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程尝试以 lock2 → lock1 顺序获取锁</span></span><br><span class="line">        <span class="keyword">lock</span> (lock2) <span class="comment">// 主线程获取 lock2</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 等待 1 秒（让第一个线程先获取 lock1）</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Monitor.TryEnter 允许不阻塞，在超时后返回 false&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试在 5 秒内获取 lock1（非阻塞式）</span></span><br><span class="line">            <span class="keyword">if</span> (Monitor.TryEnter(lock1, TimeSpan.FromSeconds(<span class="number">5</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;成功获取受保护资源！&quot;</span>);</span><br><span class="line">                Monitor.Exit(lock1); <span class="comment">// 释放锁（实际代码中应使用 finally 确保释放）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;获取资源超时！&quot;</span>); </span><br><span class="line">                <span class="comment">// 此处未获取到 lock1，但 lock2 会在当前代码块结束后自动释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次启动线程：再次尝试 lock1 → lock2 顺序</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt; LockTooMuch(lock1, lock2)).Start();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主线程再次尝试以 lock2 → lock1 顺序获取锁（此次无超时机制）</span></span><br><span class="line">        <span class="keyword">lock</span> (lock2) <span class="comment">// 获取 lock2</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这将引发死锁！&quot;</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试获取 lock1（此时第一个线程可能持有 lock1 并等待 lock2）</span></span><br><span class="line">            <span class="keyword">lock</span> (lock1) <span class="comment">// 阻塞在此处，无法继续执行</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;成功获取受保护资源！&quot;</span>); <span class="comment">// 永远不会执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockTooMuch</span>(<span class="params"><span class="built_in">object</span> lock1, <span class="built_in">object</span> lock2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (lock1) <span class="comment">// 先获取 lock1</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>); <span class="comment">// 等待 1 秒（让主线程有机会获取 lock2）</span></span><br><span class="line">            <span class="keyword">lock</span> (lock2) <span class="comment">// 再尝试获取 lock2（可能导致死锁）</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 临界区代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多线程异常处理"><a class="markdownIt-Anchor" href="#多线程异常处理"></a> <strong>多线程异常处理</strong></h2><p><strong>异常作用域规则</strong></p><ul><li><strong>线程是独立执行路径</strong>：每个线程拥有自己的异常处理上下文。</li><li><strong>主线程无法直接捕获子线程的异常</strong>：<code>try-catch</code> 在父线程中无法捕获子线程未处理的异常。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一个线程：内部捕获异常</span></span><br><span class="line">        <span class="keyword">var</span> t = <span class="keyword">new</span> Thread(FaultyThread);</span><br><span class="line">        t.Start();    <span class="comment">// 启动线程</span></span><br><span class="line">        t.Join();     <span class="comment">// 等待线程结束（此时异常已被内部处理，不会传播到主线程）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个线程：未处理异常</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(BadFaultyThread);</span><br><span class="line">            t.Start(); <span class="comment">// 启动线程（但未调用 Join）</span></span><br><span class="line">            <span class="comment">// 主线程不会等待此线程结束，try-catch 无法捕获子线程异常！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 此处永远不会执行，因为子线程的异常不会传递到主线程</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;We won&#x27;t get here!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：内部捕获异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FaultyThread</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Starting a faulty thread...&quot;</span>);</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Boom!&quot;</span>); <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 异常在此处被捕获并处理</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Exception handled: &#123;0&#125;&quot;</span>, ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：未处理异常</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BadFaultyThread</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Starting a faulty thread...&quot;</span>);</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Boom!&quot;</span>); <span class="comment">// 抛出未捕获的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确捕获子线程异常的方法</strong><br /><strong>(1) 在线程方法内部处理异常</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SafeThreadMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">/* 代码 */</span> &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123; <span class="comment">/* 记录或处理异常 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 使用 <code>Task</code> 替代 <code>Thread</code></strong></p><ul><li><strong>优势</strong>：通过 <code>Task.Exception</code> 属性聚合所有异常（<code>AggregateException</code>）。</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可能抛异常的代码</span></span><br><span class="line">&#125;).ContinueWith(t =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.Exception != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;捕获异常: &quot;</span> + t.Exception.InnerException.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, TaskContinuationOptions.OnlyOnFaulted);</span><br></pre></td></tr></table></figure><p><strong>(3) 全局异常捕获（不推荐）</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppDomain.CurrentDomain.UnhandledException += (sender, e) =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;全局捕获: &quot;</span> + e.ExceptionObject.ToString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wyt007/p/9486752.html&quot;&gt;c#多线程总结（纯干货） - 一个大西瓜咚咚咚 - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;线程基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>10.协同程序</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/10.%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F/</id>
    <published>2025-03-02T11:15:55.000Z</published>
    <updated>2025-03-04T06:29:05.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单回顾csharp中的多线程"><a class="markdownIt-Anchor" href="#简单回顾csharp中的多线程"></a> 简单回顾csharp中的多线程</h1><a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="csharp多线程">csharp多线程</a><h1 id="unity是否支持多线程"><a class="markdownIt-Anchor" href="#unity是否支持多线程"></a> Unity是否支持多线程？</h1><ol><li>Unity是支持多线程的，只是新开线程无法访问Unity相关场景上对象的内容。例如this.transform（必须在主线程调用）。</li><li>注意：<strong>Unity中的多线程 要记住关闭 不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容 可以在OnDestroy执行关闭线程逻辑</strong></li><li>在Unity中，不会开启多线程访问Unity相关。<strong>当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿。这时就可以开启多线程用于A星寻路算法，网络收发相关。</strong> 当算好了结果或者收到了消息过后，放在公共的内存区域。主线程判断判断公共的内存区域有没有想要的对象，拿来使用。</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新线程</span></span><br><span class="line">Thread newThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设寻路算法会算出来一个点 申明一个变量作为一个公共内存容器 主线程要用就判断是否有内容往里面拿东西</span></span><br><span class="line">Queue&lt;Vector3&gt; queue = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//副线程可能也要拿主线程的数据用来判断做逻辑</span></span><br><span class="line">Queue&lt;Vector3&gt; queue2 = <span class="keyword">new</span> Queue&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//首先要明确一点</span></span><br><span class="line">    <span class="comment">//Unity是支持多线程的</span></span><br><span class="line">    <span class="comment">//只是新开线程无法访问Unity相关对象的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用System.Threading命名空间</span></span><br><span class="line">    newThread = <span class="keyword">new</span> Thread(newThreadLogic);</span><br><span class="line">    newThread.Start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意：</span></span><br><span class="line">    <span class="comment">//Unity中的多线程 要记住关闭</span></span><br><span class="line">    <span class="comment">//不然的话会和Unity这个编辑器共生 就算停止运行也会继续执行新线程内容</span></span><br><span class="line">    <span class="comment">//可以在OnDestroy执行关闭线程逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在主线程判断 副线程有没有往队列里放东西，有的话就拿出来用</span></span><br><span class="line">    <span class="keyword">if</span> (queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = queue.Dequeue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新线程逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThreadLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        print(<span class="string">&quot;新线程逻辑 每隔一秒的打印&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//我们在Unity中，不会开启多线程访问Unity相关</span></span><br><span class="line">        <span class="comment">//当射涉及复杂逻辑的计算的时候，假如都放到主线程里，可能会造成主线程的卡顿</span></span><br><span class="line">        <span class="comment">//这时就可以开启多线程用于A星寻路算法，网络收发相关</span></span><br><span class="line">        <span class="comment">//当算好了结果或者收到了消息过后，放在公共的内存区域</span></span><br><span class="line">        <span class="comment">//主线程判断判断公共的内存区域有没有想要的对象，拿来使用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这句代码会报错 不能在副线程控制Unity相关</span></span><br><span class="line">        <span class="comment">//UnityException: get_transform can only be called from the main thread.</span></span><br><span class="line">        <span class="comment">//this.transform.Translate(Vector3.forward * Time.deltaTime);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中</span></span><br><span class="line">        <span class="comment">//用Unity的随机数都不能用 用C#里的随机数</span></span><br><span class="line">        System.Random r = <span class="keyword">new</span> System.Random();</span><br><span class="line">        queue.Enqueue(<span class="keyword">new</span> Vector3(r.Next(<span class="number">-10</span>, <span class="number">10</span>), r.Next(<span class="number">-10</span>, <span class="number">10</span>), r.Next(<span class="number">-10</span>, <span class="number">10</span>)));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//关闭线程</span></span><br><span class="line">    newThread.Abort();</span><br><span class="line">    <span class="comment">//关闭线程后置空</span></span><br><span class="line">    newThread = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="什么是协程"><a class="markdownIt-Anchor" href="#什么是协程"></a> <strong>什么是协程？</strong></h1><p>协程（Coroutine）是Unity中一种特殊的函数，可以<strong>分步执行代码</strong>并<strong>跨越多帧运行</strong>。它通过<code>yield</code>关键字暂停执行，并在特定条件（如等待时间结束、帧结束等）满足后继续执行。</p><ul><li><p>它是“假”的多线程，它不是多线程</p></li><li><p><strong>它的本质是<a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="csharp迭代器">迭代器</a></strong></p></li><li><p>C#的<a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="csharp迭代器">迭代器</a>**函数”分步执行”的特点</p></li><li><p>加上 Unity自己定义的一些协程调度逻辑</p></li><li><p>实现的一套分时执行函数的规则</p></li></ul><h1 id="协程的主要作用"><a class="markdownIt-Anchor" href="#协程的主要作用"></a> <strong>协程的主要作用</strong></h1><p>将代码分时执行，不卡主线程<br />简单理解，是把可能会让主线程卡顿的耗时的逻辑<strong>分时分步</strong>执行</p><ul><li><strong>处理延时操作</strong>：例如等待1秒后执行代码。</li><li><strong>分步执行任务</strong>：将复杂任务拆分成多个步骤，避免卡顿。</li><li><strong>按帧控制逻辑</strong>：逐帧处理动画、AI行为等。</li><li><strong>异步加载资源</strong>：分批加载资源防止主线程阻塞。</li><li><strong>异步下载文件</strong></li><li><strong>场景异步加载</strong></li><li><strong>批量创建时防止卡顿</strong></li></ul><h1 id="主要使用场景"><a class="markdownIt-Anchor" href="#主要使用场景"></a> <strong>主要使用场景</strong></h1><ul><li>角色技能冷却倒计时。</li><li>分批次加载大型场景或资源。</li><li>实现平滑的动画过渡（如物体渐隐）。</li><li>等待网络请求返回后更新UI。</li></ul><h1 id="协同程序和线程的区别"><a class="markdownIt-Anchor" href="#协同程序和线程的区别"></a> 协同程序和线程的区别</h1><ul><li>新开一个线程是独立的一个管道，与主线程并行执行。</li><li>新开一个协程是在原线程之上开启，进行<strong>逻辑分时分步执行</strong>。</li></ul><h1 id="-swig14-"><a class="markdownIt-Anchor" href="#-swig14-"></a> <a href="/2025/03/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E8%BF%AD%E4%BB%A3%E5%99%A8/#yield-return-%E8%AF%AD%E6%B3%95%E7%B3%96" title="csharp迭代器">回顾yield return相关知识点</a></h1><h1 id="协程的使用方法"><a class="markdownIt-Anchor" href="#协程的使用方法"></a> <strong>协程的使用方法</strong></h1><p><strong>基本规则</strong>：</p><ol><li>协程方法的返回类型必须是 <code>IEnumerator</code>。</li><li>使用 <code>yield return</code> 指定暂停条件（如 <code>new WaitForSeconds(2)</code>）。</li><li>通过 <code>StartCoroutine()</code> 启动协程。</li></ol><h2 id="启动协程"><a class="markdownIt-Anchor" href="#启动协程"></a> <strong>启动协程</strong>：</h2><p><strong>基本语法：</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CoroutineExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动协程</span></span><br><span class="line">        StartCoroutine(SimpleCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCoroutine</span>(<span class="params"><span class="built_in">string</span> hello</span>)</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">$&quot;协程开始，say hello\n<span class="subst">&#123;hello&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 暂停1秒</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;1秒后执行&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2</span></span>)</span>; <span class="comment">// 再暂停2秒</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;又过了2秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unity 提供了多种内置的等待指令，可以直接在协程中使用：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>说明</strong></th><th>指令满足之后在哪里执行</th></tr></thead><tbody><tr><td><code>null 或者 数字</code></td><td>等待到下一帧（等同 <code>yield return null</code>）</td><td><code>Update</code>和<code>LateUpdate</code>之间执行</td></tr><tr><td><code>WaitForSeconds</code></td><td>等待指定秒数（受<code>Time.timeScale</code>时间缩放影响）</td><td><code>Update</code>和<code>LateUpdate</code>之间执行</td></tr><tr><td><code>WaitForSecondsRealtime</code></td><td>等待指定秒数（不受<code>Time.timeScale</code>时间缩放影响）</td><td><code>Update</code>之后</td></tr><tr><td><code>WaitForFixedUpdate</code></td><td>等待到下一个 FixedUpdate</td><td>在<code>FixedUpdate</code>和碰撞检测相关函数之后执行</td></tr><tr><td><code>WaitForEndOfFrame</code></td><td>等待到帧结束（截图功能）</td><td>等待摄像机和GUI渲染完成后执行，在LateUpdate之后的渲染相关处理完毕后之后</td></tr><tr><td><code>WWW</code> 或 <code>UnityWebRequest</code></td><td>等待网络请求完成</td><td><code>Update</code>之后</td></tr></tbody></table><h2 id="停止协程"><a class="markdownIt-Anchor" href="#停止协程"></a> 停止协程</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止单个协程</span></span><br><span class="line">Coroutine coroutine = StartCoroutine(MyCoroutine());</span><br><span class="line">StopCoroutine(coroutine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止所有协程</span></span><br><span class="line">StopAllCoroutines();</span><br></pre></td></tr></table></figure><h1 id="协程的典型使用场景"><a class="markdownIt-Anchor" href="#协程的典型使用场景"></a> <strong>协程的典型使用场景</strong></h1><h2 id="场景-1延迟执行"><a class="markdownIt-Anchor" href="#场景-1延迟执行"></a> <strong>场景 1：延迟执行</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DelayedAction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;</span><br><span class="line">    Debug.Log(<span class="string">&quot;3秒后执行爆炸效果&quot;</span>);</span><br><span class="line">    <span class="comment">// 触发爆炸动画、音效等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景-2分帧处理大数据"><a class="markdownIt-Anchor" href="#场景-2分帧处理大数据"></a> <strong>场景 2：分帧处理大数据</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">ProcessLargeData</span>(<span class="params">List&lt;Item&gt; data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> data)</span><br><span class="line">    &#123;</span><br><span class="line">        ProcessItem(item); <span class="comment">// 处理单个数据</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧处理一个，避免卡顿</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景-3按顺序执行多段逻辑"><a class="markdownIt-Anchor" href="#场景-3按顺序执行多段逻辑"></a> <strong>场景 3：按顺序执行多段逻辑</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DialogueSequence</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ShowText(<span class="string">&quot;你好，旅行者！&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params">(</span>)</span> =&gt; Input.GetKeyDown(KeyCode.Space)); <span class="comment">// 等待玩家按空格</span></span><br><span class="line">    ShowText(<span class="string">&quot;前方有危险...&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2</span></span>)</span>;</span><br><span class="line">    ShowText(<span class="string">&quot;准备好了吗？&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程受对象和组件失活销毁的影响"><a class="markdownIt-Anchor" href="#协程受对象和组件失活销毁的影响"></a> 协程受对象和组件失活销毁的影响</h1><ul><li>协程开启后：<ul><li>组件或物体销毁，物体失活，则协程不再执行。</li><li>组件失活时，协程仍然执行。</li></ul></li></ul><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="协程实现的计秒器"><a class="markdownIt-Anchor" href="#协程实现的计秒器"></a> <strong>协程实现的计秒器</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Timer</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Text timerText; <span class="comment">// 关联UI文本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> elapsedTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isRunning;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(CountSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">CountSeconds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isRunning = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isRunning)</span><br><span class="line">        &#123;</span><br><span class="line">            elapsedTime += Time.deltaTime;</span><br><span class="line">            <span class="comment">// 显示格式化为整数秒（或保留1位小数）</span></span><br><span class="line">            timerText.text = <span class="string">&quot;Time: &quot;</span> + elapsedTime.ToString(<span class="string">&quot;F1&quot;</span>); </span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止计时（可选）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopTimer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isRunning = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分帧创建10万立方体无卡顿"><a class="markdownIt-Anchor" href="#分帧创建10万立方体无卡顿"></a> <strong>分帧创建10万立方体（无卡顿）</strong></h2><p>原本 1帧 创建 10万个<br />现在 1帧 创建 cubesPerFrame 个</p><p>比较蠢的做法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">    obj.transform.position = <span class="keyword">new</span> Vector3(Random.Range(<span class="number">-100</span>, <span class="number">100</span>), Random.Range(<span class="number">-100</span>, <span class="number">100</span>), Random.Range(<span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeSpawner</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject cubePrefab; <span class="comment">// 立方体预制体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> totalCubes = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> cubesPerFrame = <span class="number">500</span>; <span class="comment">// 每帧生成的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(SpawnCubes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">SpawnCubes</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> created = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (created &lt; totalCubes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cubesPerFrame; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (created &gt;= totalCubes) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 随机生成位置（范围可调）</span></span><br><span class="line">                Vector3 pos = <span class="keyword">new</span> Vector3(</span><br><span class="line">                    Random.Range(<span class="number">-50f</span>, <span class="number">50f</span>),</span><br><span class="line">                    Random.Range(<span class="number">-50f</span>, <span class="number">50f</span>),</span><br><span class="line">                    Random.Range(<span class="number">-50f</span>, <span class="number">50f</span>)</span><br><span class="line">                );</span><br><span class="line">                Instantiate(cubePrefab, pos, Quaternion.identity);</span><br><span class="line">                created++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 每帧分批生成</span></span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(<span class="string">&quot;生成完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手动实现协程调度器不使用unity自带功能"><a class="markdownIt-Anchor" href="#手动实现协程调度器不使用unity自带功能"></a> 手动实现协程调度器（不使用Unity自带功能）</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomYieldReturn</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 下次执行的时间点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Timer;</span><br><span class="line">    <span class="comment">// 每次MoveNext后的返回值</span></span><br><span class="line">    <span class="keyword">public</span> IEnumerator Coroutine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCoroutineMgr</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyCoroutineMgr</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyCoroutineMgr _instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyCoroutineMgr Instance =&gt; _instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器函数对象的 容器 用于 一会继续执行（在Update中不断调用MoveNext）</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CustomYieldReturn&gt; customYieldReturns = <span class="keyword">new</span> List&lt;CustomYieldReturn&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启协程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCoroutine</span>(<span class="params">IEnumerator coroutine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (coroutine.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            CustomYieldReturn tmp = <span class="keyword">new</span> CustomYieldReturn();</span><br><span class="line">            <span class="comment">// 记录下次执行的时间点, 用于Update中判断是否执行</span></span><br><span class="line">            tmp.Timer = Time.time + (<span class="built_in">float</span>)coroutine.Current;</span><br><span class="line">            <span class="comment">// 记录当前的协程位置</span></span><br><span class="line">            tmp.Coroutine = coroutine;</span><br><span class="line">            customYieldReturns.Add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每一帧倒着遍历所有的协程，因为有可能会删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = customYieldReturns.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            CustomYieldReturn tmp = customYieldReturns[i];</span><br><span class="line">            <span class="comment">// 判断是否到了下次执行</span></span><br><span class="line">            <span class="keyword">if</span> (Time.time &gt; tmp.Timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp.Coroutine.MoveNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 更新下一个yield return的条件</span></span><br><span class="line">                    tmp.Timer = Time.time + (<span class="built_in">float</span>)tmp.Coroutine.Current;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    customYieldReturns.RemoveAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// **使用自己的协程管理器**    Test.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 协程</span></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyTestFunc</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">        Debug.Log(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2.0f</span>;</span><br><span class="line">        Debug.Log(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">3.0f</span>;</span><br><span class="line">        Debug.Log(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用自己的协程管理器</span></span><br><span class="line">        MyCoroutineMgr.Instance.StartCoroutine(MyTestFunc());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>D老师写的版本</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器状态机控制</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// yield return 类型        | 对应处理方式</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// null                    | 下一帧继续</span></span><br><span class="line"><span class="comment">// WaitForSeconds(秒数)    | 计时等待</span></span><br><span class="line"><span class="comment">// WaitForEndOfFrame       | 帧结束时继续</span></span><br><span class="line"><span class="comment">// 其他对象                | 特殊处理（本例暂不实现）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomCoroutineRunner</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自定义协程数据类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">CoroutineTask</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> IEnumerator Routine; <span class="comment">// 迭代器函数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">object</span> CurrentYield; <span class="comment">// 当前等待条件</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Timer;         <span class="comment">// 计时器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;CoroutineTask&gt; activeCoroutines = <span class="keyword">new</span> List&lt;CoroutineTask&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动协程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartCustomCoroutine</span>(<span class="params">IEnumerator routine</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = <span class="keyword">new</span> CoroutineTask</span><br><span class="line">        &#123;</span><br><span class="line">            Routine = routine,</span><br><span class="line">            CurrentYield = <span class="literal">null</span>,</span><br><span class="line">            Timer = <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">        activeCoroutines.Add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历允许安全移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = activeCoroutines.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> task = activeCoroutines[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理等待条件</span></span><br><span class="line">            <span class="built_in">bool</span> canContinue = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (task.CurrentYield == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                canContinue = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (task.CurrentYield <span class="keyword">is</span> WaitForSeconds waitForSeconds)</span><br><span class="line">            &#123;</span><br><span class="line">                task.Timer += Time.deltaTime;</span><br><span class="line">                <span class="keyword">if</span> (task.Timer &gt;= waitForSeconds.m_Seconds)</span><br><span class="line">                &#123;</span><br><span class="line">                    canContinue = <span class="literal">true</span>;</span><br><span class="line">                    task.Timer = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行迭代器下一步</span></span><br><span class="line">            <span class="keyword">if</span> (canContinue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.Routine.MoveNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 更新下一个yield return的条件</span></span><br><span class="line">                    task.CurrentYield = task.Routine.Current;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    activeCoroutines.RemoveAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例 TestScript.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> runner = gameObject.AddComponent&lt;CustomCoroutineRunner&gt;();</span><br><span class="line">        runner.StartCustomCoroutine(MyCustomCoroutine());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MyCustomCoroutine</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;步骤1：&quot;</span> + Time.time);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 等待1秒</span></span><br><span class="line">        </span><br><span class="line">        Debug.Log(<span class="string">&quot;步骤2：&quot;</span> + Time.time);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>; <span class="comment">// 再等1秒</span></span><br><span class="line">        </span><br><span class="line">        Debug.Log(<span class="string">&quot;最终步骤：&quot;</span> + Time.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单回顾csharp中的多线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简单回顾csharp中的多线程&quot;&gt;&lt;/a&gt; 简单回顾csharp中的多线程&lt;/h1&gt;
&lt;a href=&quot;/2025/03/03/%E7%BC%96%E7%A8</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>9.延迟函数</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/9.%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/9.%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0/</id>
    <published>2025-03-02T09:08:38.000Z</published>
    <updated>2025-03-02T09:32:59.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是延迟函数"><a class="markdownIt-Anchor" href="#什么是延迟函数"></a> 什么是延迟函数</h1><p>延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。<br />它是<code>MonoBehaviour</code>基类中实现好的方法。</p><h1 id="延迟函数的使用"><a class="markdownIt-Anchor" href="#延迟函数的使用"></a> 延迟函数的使用</h1><h2 id="invoke方法-开启延迟函数"><a class="markdownIt-Anchor" href="#invoke方法-开启延迟函数"></a> Invoke方法 开启延迟函数</h2><p>注意:</p><ul><li>没法调用有参数的函数</li><li>必须是该脚本上申明的函数</li><li>可以用<code>DelayedFunction</code>间接调用到其它对象, 或者有参数的函数</li><li><strong>只有挂载的脚本对象失活可以继续执行, 其它情况都会无法继续执行</strong></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在time秒后调用methodName方法。 </span></span><br><span class="line"><span class="comment">// 参数一：函数名字符串 </span></span><br><span class="line"><span class="comment">// 参数二：延迟时间，秒为单位 </span></span><br><span class="line">Invoke(<span class="string">&quot;DelayDoSomething&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="invokerepeating方法-开启延迟重复执行函数"><a class="markdownIt-Anchor" href="#invokerepeating方法-开启延迟重复执行函数"></a> InvokeRepeating方法 开启延迟重复执行函数</h2><p>与<code>Invoke</code>类似，但可以设置重复调用的间隔时间。<br />参数2：第一次延迟的时间<br />参数3：以后每次延迟的时间</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InvokeRepeating(<span class="string">&quot;RepeatedFunction&quot;</span>, <span class="number">2.0f</span>, <span class="number">1.0f</span>); <span class="comment">// 延时2秒后每隔1秒调用一次RepeatedFunction方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RepeatedFunction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在这里写重复延时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cancelinvoke-取消延时调用"><a class="markdownIt-Anchor" href="#cancelinvoke-取消延时调用"></a> CancelInvoke 取消延时调用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CancelInvoke(<span class="string">&quot;Fun&quot;</span>);        <span class="comment">// 只取消Fun，所有延迟执行Fun的都会没</span></span><br><span class="line">CancelInvoke();             <span class="comment">// 无参数取消所有延时函数</span></span><br></pre></td></tr></table></figure><h2 id="isinvoking方法-判断是否有延迟函数"><a class="markdownIt-Anchor" href="#isinvoking方法-判断是否有延迟函数"></a> IsInvoking方法 判断是否有延迟函数</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否有任何待处理的methodName调用？</span></span><br><span class="line"><span class="comment">// 不传入参数，判断该脚本上是否存在任何延迟函数</span></span><br><span class="line"><span class="keyword">if</span> (IsInvoking())</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;存在延迟函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入参数，判断该脚本上是否存在指定延迟函数</span></span><br><span class="line"><span class="keyword">if</span> (IsInvoking(<span class="string">&quot;DelayDoSomething&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;存在延迟函数DelayDoSomething&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="延迟函数受对象失活销毁影响"><a class="markdownIt-Anchor" href="#延迟函数受对象失活销毁影响"></a> 延迟函数受对象失活销毁影响</h1><p>延迟函数在依附对象或者脚本失活时不受影响，但在对象销毁或者移除脚本时无法继续执行。<br />如果想在失活 或者 激活 的时候来执行延迟函数， 可以在<a href="/2025/02/18/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%85%A5%E9%97%A8/unity%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/" title="9.生命周期函数">生命周期函数</a><code>OnEnable</code>和<code>OnDisable</code>中做逻辑</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对象激活的生命周期函数中，开启延迟（重复执行的延迟）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对象失活的生命周期函数中，停止延迟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="利用延时函数实现一个计秒器"><a class="markdownIt-Anchor" href="#利用延时函数实现一个计秒器"></a> 利用延时函数实现一个计秒器</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用延迟重复函数，一进来直接调用，然后每隔一秒调用，实现计时器</span></span><br><span class="line">InvokeRepeating(<span class="string">&quot;DelayTimer&quot;</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接执行函数 函数里面在写一个普通延迟函数每秒调用自己</span></span><br><span class="line">DelayTimer2();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayTimer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    ++time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayTimer2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">    ++time;</span><br><span class="line">    Invoke(<span class="string">&quot;DelayTimer2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="请用两种方式延时销毁一个指定对象"><a class="markdownIt-Anchor" href="#请用两种方式延时销毁一个指定对象"></a> 请用两种方式延时销毁一个指定对象</h2><p>一个只能销毁，一个销毁还可以写逻辑</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Destroy来进行延迟销毁</span></span><br><span class="line">Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟函数销毁，内部使用销毁逻辑，</span></span><br><span class="line"><span class="comment">// 包裹一层，相比于Destroy直接销毁，假如想有其他逻辑也可以写在延迟销毁函数中</span></span><br><span class="line">Invoke(<span class="string">&quot;DelayDestroy&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DelayDestroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是延迟函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是延迟函数&quot;&gt;&lt;/a&gt; 什么是延迟函数&lt;/h1&gt;
&lt;p&gt;延迟函数顾名思义，就是会延时执行的函数。我们可以自己设定延时要执行的函数和具体延时的时间。&lt;br /&gt;
它是&lt;co</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>8.Quaternion四元数计算</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/</id>
    <published>2025-03-02T07:55:47.000Z</published>
    <updated>2025-03-04T08:07:05.852Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302160521675.png" alt="" /></p><h1 id="四元数相乘"><a class="markdownIt-Anchor" href="#四元数相乘"></a> 四元数相乘</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302155620368.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过轴角对API传入要转的轴和角度</span></span><br><span class="line"><span class="comment">//绕着y轴转20度</span></span><br><span class="line">Quaternion q = Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up);</span><br><span class="line"><span class="comment">//乘上这个脚本挂载的立方体当前旋转四元数 让这个脚本挂载的立方体绕着y轴转20度</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= q;</span><br><span class="line"><span class="comment">//注意1：用四元数旋转完可能和Inspector窗口上的旋转对不上 不用管它</span></span><br><span class="line"><span class="comment">//注意2：旋转相对的坐标系 是物体自身坐标系 </span></span><br></pre></td></tr></table></figure><h1 id="四元数乘以向量"><a class="markdownIt-Anchor" href="#四元数乘以向量"></a> 四元数乘以向量</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302160009145.png" alt="" /><br />注意一定是 <code>向量 = 四元数 * 向量</code> 不是 <s><code>向量 = 向量 * 四元数</code></s></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个向量</span></span><br><span class="line">    Vector3 vector = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个四元数表示45度绕Y轴的旋转</span></span><br><span class="line">    Quaternion rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">45</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用四元数旋转向量</span></span><br><span class="line">    Vector3 rotatedVector = rotation * vector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;Original Vector: &quot;</span> + vector);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Rotated Vector: &quot;</span> + rotatedVector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="模拟飞机发射不同类型子弹的方法单发双发扇形环形"><a class="markdownIt-Anchor" href="#模拟飞机发射不同类型子弹的方法单发双发扇形环形"></a> 模拟飞机发射不同类型子弹的方法：单发，双发，扇形，环形</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明发射类型枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> E_FireType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//单发</span></span><br><span class="line">    One,</span><br><span class="line">    <span class="comment">//双发</span></span><br><span class="line">    Two,</span><br><span class="line">    <span class="comment">//扇形</span></span><br><span class="line">    Three,</span><br><span class="line">    <span class="comment">//环形</span></span><br><span class="line">    Round</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Airplane</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明发射类型变量 </span></span><br><span class="line">    <span class="keyword">private</span> E_FireType nowType = E_FireType.One;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子弹</span></span><br><span class="line">    <span class="keyword">public</span> GameObject bullet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> roundNum = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Update内添加按按键切换发射类型逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha1))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.One;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha2))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Two;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha3))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Three;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Alpha4))</span><br><span class="line">        &#123;</span><br><span class="line">            nowType = E_FireType.Round;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Update内添加按按键发射子弹逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            Fire();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开火方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Fire</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (nowType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.One:</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Two:</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position - <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position + <span class="keyword">this</span>.transform.right * <span class="number">0.5f</span>, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Three:</span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation);</span><br><span class="line">                <span class="comment">//左边的子弹朝飞机自己左侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">-20</span>, Vector3.up));</span><br><span class="line">                <span class="comment">//右边的子弹朝飞机自己右侧旋转20度再发射——知识点 四元数*四元数=一个新的四元数 相当于是旋转量的叠加</span></span><br><span class="line">                Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(<span class="number">20</span>, Vector3.up));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> E_FireType.Round:</span><br><span class="line">                <span class="built_in">float</span> angle = <span class="number">360</span> / roundNum;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; roundNum; i++)</span><br><span class="line">                    <span class="comment">//角度是当前偏移度数乘飞机自己的旋转</span></span><br><span class="line">                    Instantiate(bullet, <span class="keyword">this</span>.transform.position, <span class="keyword">this</span>.transform.rotation * Quaternion.AngleAxis(i * angle, Vector3.up));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将此脚本制作成预制体，并拖到飞机的bullet</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子弹一直往前飞，五秒后销毁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bullet</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="摄像机跟随"><a class="markdownIt-Anchor" href="#摄像机跟随"></a> 摄像机跟随</h2><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302165252272.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1%E7%AE%97/file-20250302170255830.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个脚本要挂载到摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraMove</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//目标对象</span></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相对头顶的偏移位置 看向头顶多高的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> headOffsetH = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机倾斜的角度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> offsetAngle = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机离观测点的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> cameraDis = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//摄像机离观测点的距离必须是3和10之间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> minDis = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxDis = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标中间滚动控制的移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> roundSpeed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看向对象时 四元数 旋转的速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lookAtSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟随对象移动的 速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前摄像机应该在的位置</span></span><br><span class="line">    Vector3 nowPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头顶一个在的位置</span></span><br><span class="line">    Vector3 headPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头顶位置指向摄像机的方向向量</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 nowDir;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实现了鼠标中键 滚动 来改变摄像机远近</span></span><br><span class="line">        cameraDis += Input.GetAxis(<span class="string">&quot;Mouse ScrollWheel&quot;</span>) * roundSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取最大值和最小值之间的数</span></span><br><span class="line">        cameraDis = Mathf.Clamp(cameraDis, minDis, maxDis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向头顶偏移位置</span></span><br><span class="line">        headPos = target.position + target.up * headOffsetH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用要倾斜的角度和轴算出要旋转的四元数 乘上当前向后的向量 就能得到摄像机偏移角度后往后方偏移位置</span></span><br><span class="line">        <span class="comment">//通俗理解 nowDir就是头顶位置指向摄像机的方向向量</span></span><br><span class="line">        nowDir = Quaternion.AngleAxis(offsetAngle, target.right) * -target.forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用头顶位置加上要偏移的角度乘摄像机离观测点的距离 就是当前摄像机应该在的位置</span></span><br><span class="line">        nowPos = headPos + nowDir * cameraDis;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接把算出来的位置 进行赋值</span></span><br><span class="line">        <span class="comment">//this.transform.position = nowPos;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过插值运算缓慢移动相机位置</span></span><br><span class="line">        <span class="keyword">this</span>.transform.position = Vector3.Lerp(<span class="keyword">this</span>.transform.position, nowPos, Time.deltaTime * moveSpeed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是通过插值运算来缓动看向物体</span></span><br><span class="line">        <span class="comment">//摄像机要看的是nowDir的反向向量 所以通过LookRotation算出旋转成的四元数 传入当做插值函数的终点</span></span><br><span class="line">        <span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(<span class="keyword">this</span>.transform.rotation, Quaternion.LookRotation(-nowDir), Time.deltaTime * lookAtSpeed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//画出头顶和摄像机的连线</span></span><br><span class="line">        Debug.DrawLine(<span class="keyword">this</span>.transform.position, headPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/8.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E8%AE%A1</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>3.hexo插件</title>
    <link href="http://example.com/2025/03/02/hexo/3.hexo%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2025/03/02/hexo/3.hexo%E6%8F%92%E4%BB%B6/</id>
    <published>2025-03-02T07:07:49.000Z</published>
    <updated>2025-03-02T07:36:58.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思维导图"><a class="markdownIt-Anchor" href="#思维导图"></a> 思维导图</h1><p><strong>安装</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-simple-mindmap</span><br></pre></td></tr></table></figure><p><strong>使用</strong><br />使用 Hexo 的 pullquote 将思维导图的内容包裹起来，<code>mindmap</code> 是思维导图渲染的标志<br />尺寸有三种规格：<code>mindmap-sm</code>、<code>mindmap-md</code> 和 <code>mindmap-lg</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote mindmap mindmap-sm %&#125;</span><br><span class="line">- [在 Hexo 中使用思维导图](https://hunterx.xyz/use-mindmap-in-hexo.html)</span><br><span class="line">  - 前言</span><br><span class="line">  - 操作指南</span><br><span class="line">    - 准备需要的文件</span><br><span class="line">    - 为主题添加 CSS/JS 文件</span><br><span class="line">  - 使用方法</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure><blockquote class="pullquote mindmap mindmap-sm"><ul><li><a href="https://hunterx.xyz/use-mindmap-in-hexo.html">在 Hexo 中使用思维导图</a><ul><li>前言</li><li>操作指南<ul><li>准备需要的文件</li><li>为主题添加 CSS/JS 文件</li></ul></li><li>使用方法</li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;思维导图&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#思维导图&quot;&gt;&lt;/a&gt; 思维导图&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>csharp拓展方法</title>
    <link href="http://example.com/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-02T06:56:36.000Z</published>
    <updated>2025-03-02T07:42:37.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓展方法基本概念"><a class="markdownIt-Anchor" href="#拓展方法基本概念"></a> 拓展方法基本概念</h1><p>C# 中的扩展方法是 C# 3.0 引入的一项特性，它允许开发者在不修改原始类或对象的情况下，向现有类添加新方法</p><p><strong>作用</strong></p><ol><li>提升程序拓展性</li><li>不需要再对象中重新写方法</li><li>不需要继承来添加方法</li><li>为别人封装的类型写额外的方法</li></ol><p><strong>特点</strong></p><ol><li>一定是写在静态类中</li><li>一定是个静态函数</li><li>第一个参数为拓展目标</li><li>第一个参数用this修饰</li></ol><h1 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h1><p><code>访问修饰符 static 返回值 函数名(this 拓展类名 参数名, 参数类型 参数名,参数类型 参数名....)</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法 </span></span><br><span class="line">    <span class="comment">//成员方法 是需要 实例化对象后 才 能使用的</span></span><br><span class="line">    <span class="comment">//value 代表 使用该方法的 实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拓展的方法 的逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为int拓展的方法&quot;</span> + <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakStringInfo</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">string</span> str2, <span class="built_in">string</span> str3</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为string拓展的方法&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用方法的对象&quot;</span> + str);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;传的参数&quot;</span> + str2 + str3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun3</span>(<span class="params"><span class="keyword">this</span> Test t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;为test拓展的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为自定义的类型拓展方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fun2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;拓展方法&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">10</span>;</span><br><span class="line">        i.SpeakValue();</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">        str.SpeakStringInfo(<span class="string">&quot;卧槽&quot;</span>, <span class="string">&quot;nm&quot;</span>);</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.Fun2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：</span></span><br><span class="line"><span class="comment">//概念：为现有的非静态 变量类型 添加 方法</span></span><br><span class="line"><span class="comment">//作用：</span></span><br><span class="line"><span class="comment">// 提升程序拓展性</span></span><br><span class="line"><span class="comment">// 不需要再在对象中重新写方法</span></span><br><span class="line"><span class="comment">// 不需要继承来添加方法</span></span><br><span class="line"><span class="comment">// 为别人封装的类型写额外的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特点：</span></span><br><span class="line"><span class="comment">//静态类中的静态方法</span></span><br><span class="line"><span class="comment">//第一个参数 代表拓展的目标</span></span><br><span class="line"><span class="comment">//第一个参数前面一定要加 this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//可以有返回值 和 n个参数</span></span><br><span class="line"><span class="comment">//根据需求而定</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拓展方法基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#拓展方法基本概念&quot;&gt;&lt;/a&gt; 拓展方法基本概念&lt;/h1&gt;
&lt;p&gt;C# 中的扩展方法是 C# 3.0 引入的一项特性，它允许开发者在不修改原始类或对象的情况下，向现有类添加新</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/"/>
    
    
    <category term="编程语言" scheme="http://example.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Csharp" scheme="http://example.com/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>7.Quaternion四元数常用方法</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2025-03-02T03:00:47.000Z</published>
    <updated>2025-03-02T09:06:50.413Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302110057184.png" alt="" /></p><h1 id="单位四元数"><a class="markdownIt-Anchor" href="#单位四元数"></a> 单位四元数</h1><p>满足条件：<code>x² + y² + z² + w² = 1</code><br /><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302110228942.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单位四元数 [1, (0, 0, 0)]</span></span><br><span class="line"> Quaternion i = Quaternion.identity;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//Object的Instantiate方法有重载 第三个参数可以传入四元数角度 </span></span><br><span class="line"> Instantiate(testCube, Vector3.zero, Quaternion.identity);</span><br></pre></td></tr></table></figure><h1 id="插值运算"><a class="markdownIt-Anchor" href="#插值运算"></a> 插值运算</h1><p><img src="../../../../../public/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302110554680.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限接近，先快后慢</span></span><br><span class="line">A.transform.rotation = Quaternion.Slerp(A.transform.rotation, target.rotation, Time.deltaTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匀速</span></span><br><span class="line">time += Time.deltaTime; </span><br><span class="line">B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);</span><br></pre></td></tr></table></figure><h1 id="向量指向转四元数lookrotation"><a class="markdownIt-Anchor" href="#向量指向转四元数lookrotation"></a> 向量指向转四元数LookRotation</h1><p><img src="../../../../../public/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/file-20250302111627899.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform target;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> rotateSpeed = <span class="number">2f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    Vector3 dir = target.position - transform.position;</span><br><span class="line">    Quaternion targetRot = Quaternion.LookRotation(dir);</span><br><span class="line">    transform.rotation = Quaternion.Slerp(transform.rotation, targetRot, rotateSpeed * Time.deltaTime);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h1><h2 id="为transform拓展方法实现lookat"><a class="markdownIt-Anchor" href="#为transform拓展方法实现lookat"></a> 为transform拓展方法实现LookAt</h2><p><strong>使用<a href="/2025/03/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Csharp/csharp%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95/" title="csharp拓展方法">拓展方法</a> ，利用四元数的LookRotation方法，使transform实现LookAt的效果</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自己写的看向目标的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyLookAt</span>(<span class="params"><span class="keyword">this</span> Transform obj, Transform target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//算出目标和自己的向量</span></span><br><span class="line">        Vector3 vec = target.position - obj.position;</span><br><span class="line">        <span class="comment">//用LookRotation得到转向的四元数赋值给自己</span></span><br><span class="line">        obj.transform.rotation = Quaternion.LookRotation(vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123; </span><br><span class="line">    <span class="comment">//调用自己写的拓展方法看向B </span></span><br><span class="line">    lookA.MyLookAt(lookB); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="摄像机使用slerp来缓慢看向玩家"><a class="markdownIt-Anchor" href="#摄像机使用slerp来缓慢看向玩家"></a> 摄像机使用Slerp来缓慢看向玩家</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发现目标对象位置改变时</span></span><br><span class="line"><span class="keyword">if</span> (targetQ != Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重新用目标的位置减去摄像机的位置计算出新的面朝向向量四元数</span></span><br><span class="line">    targetQ = Quaternion.LookRotation(target.position - <span class="keyword">this</span>.transform.position);</span><br><span class="line">    <span class="comment">// 清空累加时间 不然时间一直大于1 会一直盯着目标看 不能达到匀速旋转看向目标的效果</span></span><br><span class="line">    roundTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重置摄像机开始旋转位置</span></span><br><span class="line">    startQ = <span class="keyword">this</span>.transform.rotation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加时间</span></span><br><span class="line">roundTime += Time.deltaTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入发现目标对象位置改变后定死的摄像机开始旋转位置，目标旋转位置，和累加的时间</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation = Quaternion.Slerp(startQ, targetQ, roundTime * roundSpeed);</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/7.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E5%B8%B8</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>6.Quaternion四元数概念</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/</id>
    <published>2025-03-02T02:26:57.000Z</published>
    <updated>2025-03-02T09:05:07.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四元数概念"><a class="markdownIt-Anchor" href="#四元数概念"></a> 四元数概念</h1><p><strong>数学定义</strong><br />四元数由4个分量组成：<code>x</code>, <code>y</code>, <code>z</code>, <code>w</code>，数学表示为 <code>q = xi + yj + zk + w</code><br /><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302102720902.png" alt="" /></p><h1 id="四元数构成"><a class="markdownIt-Anchor" href="#四元数构成"></a> 四元数构成</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302102808972.png" alt="" /></p><h1 id="轴-角对"><a class="markdownIt-Anchor" href="#轴-角对"></a> 轴-角对</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302102917944.png" alt="" /></p><p>这里的n是3d向量<br /><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302103043266.png" alt="" /></p><h1 id="unity中的四元数-quaternion"><a class="markdownIt-Anchor" href="#unity中的四元数-quaternion"></a> Unity中的四元数 Quaternion</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302103241431.png" alt="" /></p><h1 id="unity中的四元数初始化方法"><a class="markdownIt-Anchor" href="#unity中的四元数初始化方法"></a> Unity中的四元数初始化方法</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302103358189.png" alt="" /></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用四元数的计算原理 绕着(x,y,z)向量旋转β度(弧度)</span></span><br><span class="line"><span class="built_in">float</span> timeAngle = Mathf.Sin(β / <span class="number">2</span> * Mathf.Deg2Rad);</span><br><span class="line">Quaternion q = <span class="keyword">new</span> Quaternion(timeAngle * x, timeAngle * y, timeAngle * z, Mathf.Cos(β / <span class="number">2</span> * Mathf.Deg2Rad));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//绕着(1,0,0)向量旋转60度 要传入弧度制 角度转弧度</span></span><br><span class="line">Quaternion q1 = <span class="keyword">new</span> Quaternion(Mathf.Sin(<span class="number">30</span> * Mathf.Deg2Rad), <span class="number">0</span>, <span class="number">0</span>, Mathf.Cos(<span class="number">30</span> * Mathf.Deg2Rad));</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个围绕 axis 旋转 offsetAngle 度的旋转。</span></span><br><span class="line"><span class="comment">//提供的轴角对 初始化 四元数的方法 分别传入度数和向量轴</span></span><br><span class="line">Quaternion q2 = Quaternion.AngleAxis(<span class="number">60</span>, Vector3.right);</span><br></pre></td></tr></table></figure><h1 id="四元数和欧拉角相互转换"><a class="markdownIt-Anchor" href="#四元数和欧拉角相互转换"></a> 四元数和欧拉角相互转换</h1><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欧拉角 转 四元数</span></span><br><span class="line">Quaternion q = Quaternion.Euler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四元数 转 欧拉角</span></span><br><span class="line">print(q.eulerAngles);<span class="comment">//(60.0, 0.0, 0.0)</span></span><br></pre></td></tr></table></figure><h1 id="弥补的欧拉角缺点"><a class="markdownIt-Anchor" href="#弥补的欧拉角缺点"></a> 弥补的欧拉角缺点</h1><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302104937133.png" alt="" /></p><p>注意：四元数转换为欧拉角的范围始终是<code>[-180°, 180°]</code>之间</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每一帧绕着y轴旋转1度 </span></span><br><span class="line"><span class="comment">//四元数绕 y轴转  *****物体坐标系****** 旋转</span></span><br><span class="line"><span class="keyword">this</span>.transform.rotation *= Quaternion.AngleAxis(<span class="number">1</span>, Vector3.up);</span><br></pre></td></tr></table></figure><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/6.Quaternion%E5%9B%9B%E5%85%83%E6%95%B0%E6%A6%82%E5%BF%B5/file-20250302105740026.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四元数概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#四元数概念&quot;&gt;&lt;/a&gt; 四元数概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;数学定义&lt;/strong&gt;&lt;br /&gt;
四元数由4个分量组成：&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>5.Quaternion为什么要使用四元数</title>
    <link href="http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    <id>http://example.com/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/</id>
    <published>2025-03-02T02:10:07.000Z</published>
    <updated>2025-03-02T03:01:30.593Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101040200.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101049212.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101107012.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302101235714.png" alt="" /></p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302102110758.png" alt="" /></p><p>在unity中将Rotation的x设置为90°，调整y和z都绕同一个轴旋转</p><p><img src="/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9B%9B%E5%85%83%E6%95%B0/file-20250302102438979.png" alt="" /></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2025/03/02/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/5.Quaternion%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81</summary>
      
    
    
    
    <category term="游戏引擎" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/unity/unity%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="游戏引擎" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="unity" scheme="http://example.com/tags/unity/"/>
    
    <category term="unity基础" scheme="http://example.com/tags/unity%E5%9F%BA%E7%A1%80/"/>
    
    <category term="3D数学" scheme="http://example.com/tags/3D%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
